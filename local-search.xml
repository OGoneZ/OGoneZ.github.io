<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL学习指北</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-STL-概述"><a href="#1-STL-概述" class="headerlink" title="1 STL 概述"></a>1 STL 概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><strong>STL</strong>是Standard Template Library的简称，中文名<strong>标准模板库</strong>，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，<strong>STL</strong>是一些“<strong>容器</strong>”的集合，这些“<strong>容器</strong>”有<code>list</code>,<code>vector</code>,<code>set</code>,<code>map</code>等，<strong>STL</strong>也是<strong>算法</strong>和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。<strong>STL</strong>的目的是<strong>标准化组件</strong>，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。<br>在C++标准中，<strong>STL</strong>被组织为下面的13个<strong>头文件</strong>：<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator &gt;</code> 、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;memory.h&gt;</code>、<code>&lt;numeric&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt; stack&gt;</code>和</p><hr><p>STL 容器包括<strong>顺序式容器</strong>和<strong>关联式容器</strong>。</p><ul><li>关联容器中的元素按关键字保存和访问；顺序容器中的元素按它们在容器中的位置和顺序保存和访问</li><li>关联容器不支持顺序容器位置相关的操作，因为关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义；关联容器也不支持构造函数或插入操作这些接收一个元素值和一个数量值的操作。</li><li>关联容器支持高效的关键字查找和访问，两个主要的关联容器类型是 <code>map</code> 和 <code>set</code>：<ul><li><code>map</code> 中的元素是键值对（key–value）：关键字起到索引的作用，值则表示与索引相关联的数据。</li><li><code>set</code> 中的元素只包含关键字：<code>set</code> 支持高效的关键字查询操作，检查给定关键字是否在 <code>set</code> 中。</li></ul></li></ul><h2 id="1-2-顺序式容器"><a href="#1-2-顺序式容器" class="headerlink" title="1.2 顺序式容器"></a>1.2 顺序式容器</h2><p><code>vector</code>：动态数组，从末尾能快速插入与删除，直接访问任何元素。<br><code>list</code>：双链表，从任何地方快速插入与删除。<br><code>queue</code>：队列，先进先出。<br><code>deque</code>：双向队列，从前面或后面快速插入与删除，直接访问任何元素。<br><code>priority_queue</code>：优先队列，最高优先级元素总是第一个出列。<br><code>stack</code>：栈，先进后出。</p><p>它们之所以被称为<strong>顺序容器</strong>，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p><h2 id="1-3-关联式容器"><a href="#1-3-关联式容器" class="headerlink" title="1.3 关联式容器"></a>1.3 关联式容器</h2><p>元素位置取决于特定的排序准则，和插入顺序无关。<br><code>set</code>：集合，快速查找，不允许重复值。<br><code>multiset</code>：允许有两个次序相同的元素的集合。<br><code>map</code>：由键值对组成。<br><code>multimap</code>：允许键对有相等次序的映射。</p><h2 id="1-4-容器特点"><a href="#1-4-容器特点" class="headerlink" title="1.4 容器特点"></a>1.4 容器特点</h2><blockquote><p>任何两个容器对象，只要它们的类型相同，就可以用 <strong>&gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</strong> 进行比较运算。 </p></blockquote><p>假设a、b是两个类型相同的容器对象，其规则如下：<br><strong>a &#x3D;&#x3D; b</strong>：若 a 和 b 中的元素个数相同，且对应元素均相等，则a &#x3D;&#x3D; b的值为 true，否则值为 false。元素是否相等是用<code>==</code>运算符进行判断的。<br><strong>a &lt; b**：依次比较，若a中元素少于b则判断成立，或者a中每个元素都大于b中对应的元素成立，为true，否则为false。<br>**a !&#x3D; b**：等价于 !(a &#x3D;&#x3D; b)。<br>**a &gt; b</strong>：等价于 b &lt; a。<br><strong>a &lt;&#x3D; b**：等价于 !(b &lt; a)。<br>**a &gt;&#x3D; b</strong>：等价于 !(a &lt; b)。</p><p><strong>所有容器</strong>都有以下两个成员函数：<br><code>size()</code>：返回容器对象中元素的个数。<br><code>empty()</code>：判断容器对象是否为空。</p><p><strong>顺序容器</strong>和<strong>关联容器</strong>都有以下成员函数：<br><code>begin()</code>：返回指向容器中第一个元素的迭代器。<br><code>end()</code>：返回指向容器中最后一个元素后面的位置的迭代器。<br><code>rbegin()</code>：返回指向容器中最后一个元素的反向迭代器（reverse_iterator）。<br><code>rend()</code>：返回指向容器中第一个元素前面的位置的反向迭代器。<br><code>erase()</code>：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。<br><code>clear()</code>：从容器中删除所有元素。<br>如果一个容器是空的，则 <code>begin()</code> 和 <code>end()</code> 的返回值相等，<code>rbegin()</code> 和 <code>rend()</code> 的返回值也相等。</p><p><strong>顺序容器</strong>还有以下常用成员函数：<br><code>front()</code>：返回容器中第一个元素的引用。<br><code>back()</code>：返回容器中最后一个元素的引用。<br><code>push_back()</code>：在容器末尾增加新元素。<br><code>pop_back()</code>：删除容器末尾的元素。<br><code>insert()</code>：插入一个或多个元素。 </p><p>对于所有容器基本都有的<code>size()</code>、<code>empty()</code>、<code>clear()</code>，下面不再赘述</p><h1 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h1><h2 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h2><p>在 <code>#include &lt;vector&gt;</code> 中使用</p><blockquote><p><code>vector</code>是STL的<strong>动态数组</strong>，在运行时能根据情况改变数组的大小。由于它是以<strong>数组</strong>形式存储，也就是说它的<strong>内存空间是连续的</strong>，所以索引可以在常数时间内完成，但是在中间进行<strong>插入</strong>和<strong>删除</strong>会造成内存块的复制。另外，如果数组后面的内存空间不够，需要申请一块足够大的内存，会影响<code>vector</code>的效率,同时使迭代器失效。</p></blockquote><p><img src="/../../../cpp_assets/c_vector.png"></p><p><strong>vector扩容</strong>示意图:<br><img src="/../../../cpp_assets/c_vector_expand.gif"></p><p><strong>函数</strong>基本功能目录如下!<br><img src="/../../../cpp_assets/c_vector_fun.png"></p><hr><h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><table><thead><tr><th>功能</th><th align="left">例子</th><th>说明</th></tr></thead><tbody><tr><td>定义<strong>int</strong>型数组</td><td align="left">vecotr&lt;int&gt; a;</td><td>默认初始化,a为空</td></tr><tr><td></td><td align="left">vector&lt;int&gt; b(a);</td><td>用a定义b</td></tr><tr><td></td><td align="left">vector&lt;int&gt; a(100);</td><td>a有100个值为0的元素</td></tr><tr><td></td><td align="left">vector&lt;int&gt; a(100, 6);</td><td>100个值为6的元素</td></tr><tr><td>定义<strong>string</strong>型数组</td><td align="left">vetor&lt;string&gt; a(10, “null”);</td><td>10个值为null的元素</td></tr><tr><td></td><td align="left">vector&lt;string&gt; vec(10, “hello”);</td><td>10个值为hello的元素</td></tr><tr><td></td><td align="left">vector&lt;string&gt; b(a.begin(), a.end());</td><td>b是a的复制</td></tr><tr><td>定义<strong>结构体</strong>型数组</td><td align="left">struct point { int x, y;}; vector&lt;point&gt; a;</td><td>a用来存坐标</td></tr></tbody></table><ul><li>定义<strong>int</strong>型</li><li>定义<strong>string</strong>型</li><li>定义<strong>结构体</strong>型</li><li>定义<strong>多维数组</strong>,例如定义一个二维数组: <code>vector&lt;int&gt; a[233];</code><br>第一维是固定的长度为233,第二维是动态的</li></ul><p>要注意，它和数组类似但不同一旦声明出来后，<code>vector</code> 容器还是空的没有下标，因此无法直接 <code>cin</code>，需要借助<code>push_back()</code>，访问数据和普通数组一样通过下标访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空的vector 不能输入输出 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 三个元素均为 0 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 三个元素均为1 </span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec3</span><span class="hljs-params">(vec2)</span></span>;<span class="hljs-comment">// 将vec2的元素初始化给vec3</span><br><span class="hljs-comment">// 参数类型要相同 </span><br><br><span class="hljs-comment">// 用迭代器初始化 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite = vec<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 指向vec2的头 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = vec<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 指向vec2的尾 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec4</span><span class="hljs-params">(ite, ite1)</span></span>;<br></code></pre></td></tr></table></figure><p>虽然 <code>vector</code> 可以动态扩展，但需要确保在使用下标访问时， <code>vector</code> 已经<strong>分配足够的空间</strong>，否则会出现段错误，如果 <code>vector</code> 还没有分配空间，可以使用 <code>push_back()</code> 插入元素。</p><h2 id="2-3-迭代器"><a href="#2-3-迭代器" class="headerlink" title="2.3 迭代器"></a>2.3 迭代器</h2><p>迭代器就像<strong>STL</strong>容器的“指针”，可以用星号”<code>*</code>“操作符解除引用。<br>一个保存<strong>int</strong>的<strong>vector</strong>的迭代器声明方法为：<code>vector&lt;int&gt;::iterator it;</code><br><strong>vector</strong>的迭代器是“随机访问迭代器”，可以把<strong>vector</strong>的迭代器与一个整数相加减，其行为和<strong>指针</strong>的移动类似。可以把<strong>vector</strong>的两个迭代器相减，其结果也和<strong>指针</strong>相减类似，得到两个迭代器对应下标之间的距离。</p><h2 id="2-4-遍历"><a href="#2-4-遍历" class="headerlink" title="2.4 遍历"></a>2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(vecor&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); it++) <br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">// auto 代替 vecor&lt;int&gt;::iterator</span><br><br><span class="hljs-comment">// 逆序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); it++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>; it != vec.begin - <span class="hljs-number">1</span>; it--)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : vec) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-5-常用函数"><a href="#2-5-常用函数" class="headerlink" title="2.5 常用函数"></a>2.5 常用函数</h2><h3 id="push-back-在尾部添加一个元素"><a href="#push-back-在尾部添加一个元素" class="headerlink" title="push_back()  在尾部添加一个元素"></a><code>push_back()</code>  <strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>vec.push_back(value);</strong><br><strong>添加</strong>值为value的元素到当前vector的末尾。</p></blockquote><hr><h3 id="pop-back-删除最后一个元素"><a href="#pop-back-删除最后一个元素" class="headerlink" title="pop_back()  删除最后一个元素"></a><code>pop_back()</code>  <strong>删除最后一个元素</strong></h3><blockquote><p><strong>vec.pop_back();</strong><br><strong>删除</strong>当前vector最后一个元素。</p></blockquote><hr><h3 id="begin-返回起始位置的迭代器"><a href="#begin-返回起始位置的迭代器" class="headerlink" title="begin()  返回起始位置的迭代器"></a><code>begin()</code>  <strong>返回起始位置的迭代器</strong></h3><blockquote><p><strong>vec.begin();</strong><br>返回指向当前vector<strong>起始元素的迭代器</strong>。</p></blockquote><hr><h3 id="end-返回末尾元素下一位置的迭代器"><a href="#end-返回末尾元素下一位置的迭代器" class="headerlink" title="end()  返回末尾元素下一位置的迭代器"></a><code>end()</code>  <strong>返回末尾元素下一位置的迭代器</strong></h3><blockquote><p><strong>vec.end();</strong><br>返回指向当前vector<strong>末尾元素的下一位置的迭代器</strong>。</p></blockquote><hr><h3 id="front-返回起始元素"><a href="#front-返回起始元素" class="headerlink" title="front()  返回起始元素"></a><code>front()</code>  <strong>返回起始元素</strong></h3><blockquote><p><strong>vec.front();</strong><br>返回当前vector<strong>起始元素</strong>。<br>等同于 <code>vec[0]</code> 和 <code>*vec.begin()</code></p></blockquote><hr><h3 id="back-返回末尾元素"><a href="#back-返回末尾元素" class="headerlink" title="back()  返回末尾元素"></a><code>back()</code>  <strong>返回末尾元素</strong></h3><blockquote><p><strong>vec.back();</strong><br>返回当前vector<strong>末尾元素</strong>。<br>等同于 <code>vec[vec.size() - 1]</code> 和 <code>*(vec.end() - 1)</code></p></blockquote><h2 id="2-6-二维vector"><a href="#2-6-二维vector" class="headerlink" title="2.6 二维vector"></a>2.6 二维vector</h2><p><code>vector</code> 可以替代一维数组，并且还可以灵活的自动扩充，当然也可以替代二维数组！，如下声明中的 v 准确来说是变量的声明格式，只不过这个容器神通广大类似于数组，因此叫“一维数组”，但本质是变量。这个变量里面可以塞很多东西，模样像个数组。<br>既然是一个变量，我们可以把它变成一维数组，但很像“二维”，不过每一行都不一定一样长。添加数据的时候要注意，必须找到某一行，然后它是一个变量v[？],通过方法 <code>push_back</code> 将数据保存到这一行的末尾就可以了。访问数据和二维数组一样通过行下标和列下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">// vector 的“二维”</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec[<span class="hljs-number">100</span>];<br><span class="hljs-comment">//添加元素到第0行</span><br>vec[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_vector_array.png"></p><h1 id="3-stack"><a href="#3-stack" class="headerlink" title="3 stack"></a>3 stack</h1><h2 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1 基础概念"></a>3.1 基础概念</h2><p>在 <code>#include &lt;stack&gt;</code> 中使用</p><blockquote><p>栈(<code>stack</code>)是一种<strong>先进后出</strong>的数据结构,栈中只能通过<code>top()</code>来访问<strong>栈顶元素</strong>, 元素的<strong>插入</strong>和<strong>删除</strong>都只能<strong>栈顶</strong>进行。</p></blockquote><p><img src="/../../../cpp_assets/c_stack.png"></p><h2 id="3-2-声明"><a href="#3-2-声明" class="headerlink" title="3.2 声明"></a>3.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>stack&lt;<span class="hljs-type">double</span>&gt; st2;<br>stack&lt;<span class="hljs-type">char</span>&gt; st3;<br></code></pre></td></tr></table></figure><h2 id="3-3-遍历"><a href="#3-3-遍历" class="headerlink" title="3.3 遍历"></a>3.3 遍历</h2><p><strong>堆栈中的数据是不允许随机访问的，也就是说不能通过下标访问，且堆栈内的元素是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将stack中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就需要弹出这个元素，因此该方法只能读取一遍stack中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; st.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    st.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-常用函数"><a href="#3-4-常用函数" class="headerlink" title="3.4 常用函数"></a>3.4 常用函数</h2><h3 id="push-栈顶插入元素"><a href="#push-栈顶插入元素" class="headerlink" title="push()  栈顶插入元素"></a><code>push()</code>  <strong>栈顶插入元素</strong></h3><blockquote><p><strong>st.push(value);</strong><br>在<strong>栈顶</strong>插入一个元素value。</p></blockquote><hr><h3 id="pop-删除栈顶元素"><a href="#pop-删除栈顶元素" class="headerlink" title="pop()  删除栈顶元素"></a><code>pop()</code>  <strong>删除栈顶元素</strong></h3><blockquote><p><strong>st.pop();</strong><br>在<strong>栈顶</strong>删除一个元素。</p></blockquote><hr><h3 id="top-返回栈顶元素"><a href="#top-返回栈顶元素" class="headerlink" title="top()  返回栈顶元素"></a><code>top()</code>  <strong>返回栈顶元素</strong></h3><blockquote><p><strong>st.top()</strong><br>访问<strong>栈顶</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="4-queue"><a href="#4-queue" class="headerlink" title="4 queue"></a>4 queue</h1><h2 id="4-1-基础概念"><a href="#4-1-基础概念" class="headerlink" title="4.1 基础概念"></a>4.1 基础概念</h2><p>在 <code>#include &lt;queue&gt;</code> 中使用</p><blockquote><p>队列(<code>queue</code>)是一种<strong>先进先出</strong>的限制性数据结构，对数据的<strong>存</strong>和<strong>取</strong>有严格要求。它只能通过<code>front()</code>进行访问<strong>队首</strong>元素，通过<code>back()</code>访问<strong>队尾</strong>元素。队列中只有<strong>队头</strong>和<strong>队尾</strong>才可以被外界使用，因此队列<strong>不允许</strong>有<strong>遍历</strong>行为。<br>与<strong>栈</strong>结构不同的是，<strong>队列</strong>的<strong>两端</strong>都”开口”，要求数据只能从<strong>一端进</strong>，从<strong>另一端出</strong>，通常，称进数据的一端为<strong>队尾</strong>，出数据的一端为<strong>队头</strong>，数据元素进队列的过程称为<strong>入队</strong>，出队列的过程称为<strong>出队</strong>。</p></blockquote><p><img src="/../../../cpp_assets/c_queue.png"></p><h2 id="4-2-声明"><a href="#4-2-声明" class="headerlink" title="4.2 声明"></a>4.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>queue&lt;<span class="hljs-type">double</span>&gt; q2;<br>queue&lt;<span class="hljs-type">char</span>&gt; q3;<br></code></pre></td></tr></table></figure><h2 id="4-3-遍历"><a href="#4-3-遍历" class="headerlink" title="4.3 遍历"></a>4.3 遍历</h2><p><strong>和<code>stack</code>类似，不能通过下标访问，是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将queue中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就要让该元素出队，因此该方法只能读取一遍queue中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出队首</span><br>    q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 队首出队</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-常用函数"><a href="#4-4-常用函数" class="headerlink" title="4.4 常用函数"></a>4.4 常用函数</h2><h3 id="push-队尾插入元素"><a href="#push-队尾插入元素" class="headerlink" title="push()  队尾插入元素"></a><code>push()</code>  <strong>队尾插入元素</strong></h3><blockquote><p><strong>q.push(value)</strong><br>在<strong>队尾</strong>插入一个元素value。</p></blockquote><hr><h3 id="pop-删除队头元素"><a href="#pop-删除队头元素" class="headerlink" title="pop()  删除队头元素"></a><code>pop()</code>  <strong>删除队头元素</strong></h3><blockquote><p><strong>q.pop()</strong><br>在<strong>队头</strong>删除一个元素。</p></blockquote><hr><h3 id="front-返回队头元素"><a href="#front-返回队头元素" class="headerlink" title="front()  返回队头元素"></a><code>front()</code>  <strong>返回队头元素</strong></h3><blockquote><p><strong>q.front()</strong><br>返回<strong>队头</strong>元素。</p></blockquote><hr><h3 id="back-返回队尾元素"><a href="#back-返回队尾元素" class="headerlink" title="back()  返回队尾元素"></a><code>back()</code>  <strong>返回队尾元素</strong></h3><blockquote><p><strong>q.back()</strong><br>返回<strong>队尾</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>front()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5 priority_queue"></a>5 priority_queue</h1><h2 id="5-1-基础概念"><a href="#5-1-基础概念" class="headerlink" title="5.1 基础概念"></a>5.1 基础概念</h2><p>在 <code>#inlcude &lt;queue&gt;</code> 中使用</p><blockquote><p>优先队列(priority_queue)，<strong>底层通常使用堆（heap）</strong> 实现。元素被赋予优先级，最高优先级的元素会作为队首元素，有<strong>最高优先级先出</strong>的特征，当访问元素时，只能访问具有最高优先级的元素，可以在任何时候往优先队列里面加入元素，而优先队列底层的数据结构堆（heap）会随时调整结构，使得每次的队首元素都是优先级最高的。priority_queue 可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p></blockquote><h2 id="5-2-声明"><a href="#5-2-声明" class="headerlink" title="5.2 声明"></a>5.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 默认把最大的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br>priority_queue&lt;<span class="hljs-type">double</span>&gt; pq2;<br>priority_queue&lt;<span class="hljs-type">char</span>&gt; pq3;<br><span class="hljs-comment">// 把最小的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>，vector&lt;<span class="hljs-type">int</span>&gt;，greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq4;<br></code></pre></td></tr></table></figure><h2 id="5-3-优先级设置"><a href="#5-3-优先级设置" class="headerlink" title="5.3 优先级设置"></a>5.3 优先级设置</h2><h3 id="5-3-1-基本数据类型"><a href="#5-3-1-基本数据类型" class="headerlink" title="5.3.1 基本数据类型"></a>5.3.1 基本数据类型</h3><p>优先队列对基本数据类型的优先级设置一般是数字越大的优先级越高，如果是 char 类型，则是字典序最大的。</p><p>以 <code>int</code> 型为例下面两种是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; pq2;<br></code></pre></td></tr></table></figure><ul><li><p>第二个参数<code>vector&lt;int&gt;</code>填写的是承载底层数据结构堆 （heap）的容器，如果是其他类型可写为 <code>vector&lt;char&gt;</code>或<code>vector&lt;double&gt;</code></p></li><li><p>第三个参数 <code>less&lt;int&gt;</code> 则是对第一个参数的比较类，<strong>控制优先级</strong>是大是小，<code>less&lt;int&gt;</code> 表示数字大的优先级越大，而 <code>greater&lt;int&gt;</code> 表示数字小的优先级越大。</p></li></ul><h3 id="5-3-2-结构体类型"><a href="#5-3-2-结构体类型" class="headerlink" title="5.3.2 结构体类型"></a>5.3.2 结构体类型</h3><p><strong>方法一</strong>：重载 <code>operator&lt;</code><br>重载（overload）小于号“&lt;”，重载是指对已有的运算符进行重新定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 重载小于运算符，定义优先级</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">// 优先级由 age 实现大堆优先</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &lt; other.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法二</strong>：使用友元<code>friend</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// friend bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法三</strong>：使用 cmp 仿函数</p><p><code>priority_queue</code> 不直接支持使用普通函数（如 <code>cmp</code>）作为比较器，因为 <code>priority_queue</code> 需要一个<strong>类型</strong>而不是一个普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>        <span class="hljs-comment">// 优先级由 age 的大小决定</span><br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义仿函数 cmp 作为比较器</span><br>priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;<br></code></pre></td></tr></table></figure><blockquote><p>只能对小于号进行重载，重载大于号会编译错误，因为从数学上来讲只需要重载小于号即 f1&gt;f2&lt;&#x3D;&#x3D;&gt;f2&lt;f1。</p></blockquote><h2 id="5-4-遍历"><a href="#5-4-遍历" class="headerlink" title="5.4 遍历"></a>5.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出队首</span><br>    pq.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//队首出队</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-常用函数"><a href="#5-5-常用函数" class="headerlink" title="5.5 常用函数"></a>5.5 常用函数</h2><h3 id="push-插入元素"><a href="#push-插入元素" class="headerlink" title="push()  插入元素"></a><code>push()</code>  <strong>插入元素</strong></h3><blockquote><p><strong>pq.push(value)</strong><br>将元素value入队，每次调用排序算法按照优先级排序。</p></blockquote><hr><h3 id="pop-删除队首元素"><a href="#pop-删除队首元素" class="headerlink" title="pop()  删除队首元素"></a><code>pop()</code>  <strong>删除队首元素</strong></h3><blockquote><p><strong>q.pop()</strong><br>删除<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><hr><h3 id="top-返回队首元素"><a href="#top-返回队首元素" class="headerlink" title="top()  返回队首元素"></a><code>top()</code>  <strong>返回队首元素</strong></h3><blockquote><p><strong>pq.top()</strong><br>访问<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="6-deque"><a href="#6-deque" class="headerlink" title="6 deque"></a>6 deque</h1><h2 id="6-1-基础概念"><a href="#6-1-基础概念" class="headerlink" title="6.1 基础概念"></a>6.1 基础概念</h2><p>在 <code>#inlcude &lt;deque&gt;</code> 中使用</p><blockquote><p>双端队列(<code>deque</code>)，全名double-ended queue是一种具有<strong>队列</strong>和<strong>栈</strong>的性质的数据结构，它就像是vector和queue的结合。与vector相比，<code>deque</code>在头部增删元素仅需要O(1)的时间；与queue相比，<code>deque</code>像数组一样支持随机访问。双端队列中的元素可以从<strong>两端弹出</strong>，其限定<strong>插入</strong>和<strong>删除</strong>操作在<strong>两端</strong>进行，是一个支持在<strong>两端高效插入或删除元素</strong>的<strong>连续线性存储空间</strong>。 </p></blockquote><p><img src="/../../../cpp_assets/c_deque.png"></p><h2 id="6-2-deque与vector、list"><a href="#6-2-deque与vector、list" class="headerlink" title="6.2 deque与vector、list"></a>6.2 <code>deque</code>与<code>vector</code>、<code>list</code></h2><p><code>deque</code>的结构是一段一段的空间，每段空间都是一样大的，通过一个中控数组（指针数组）进行连接起来。想要扩容就在连接一块空间即可。当指针数组满了，就中控数组扩容即可。这样以来扩容的代价就很低。不需要拷贝原来的数组。对于头插尾插也很简单，就用专门的两个空间进行头插尾插即可，相比<code>vector</code>极大的缓解了扩容、头插头删问题。但是它的[]运算符不够极致。它的[]需要计算在哪个buff数组，在哪个buff数组的第几个。</p><ol><li><strong>内存比较</strong><ul><li><code>vector</code>：连续空间</li><li><code>list</code>：不连续空间</li><li><code>deque</code>：段连续空间</li></ul></li></ol><p><img src="/../../../cpp_assets/c_deque_mem.png"></p><ol start="2"><li>功能比较<ul><li><code>vector</code><ul><li>随机位置的插入和删除效率比较低</li><li>随机访问的效率高（下标运算）</li><li>不支持头添加，支持尾添加</li></ul></li><li><code>list</code><ul><li>随机位置的插入和删除效率高</li><li>不支持随机访问</li><li>支持头添加，支持尾添加</li></ul></li><li><code>deque</code><ul><li>随机位置的插入和删除效率不高（以512个字节为一个单位量）</li><li>支持随机访问（比<code>vector</code>慢，因为要做堆跳转），迭代器的结构较为复杂，会降低访问效率</li><li>支持头添加，支持尾添加</li></ul></li></ul></li><li><strong>使用选择</strong><ul><li>随机访问操作频率高，就选用<code>vector</code></li><li>插入删除频率高，头尾添加，就选用<code>list</code></li><li>随机访问+头添加，就选<code>deque</code></li></ul></li></ol><p><strong>函数</strong>基本功能目录如下<br><img src="/../../../cpp_assets/c_deque_fun.png"></p><hr><h2 id="6-3-声明"><a href="#6-3-声明" class="headerlink" title="6.3 声明"></a>6.3 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deque&lt;<span class="hljs-type">int</span>&gt; dq;       <span class="hljs-comment">// 空的队列，不能输出 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;   <span class="hljs-comment">// 大小为 3 的空队列 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">12</span>)</span></span>;<span class="hljs-comment">// 三个元素均为12 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq3</span><span class="hljs-params">(dq2)</span></span>; <span class="hljs-comment">// 复制dq2//参数类型要相同 </span><br></code></pre></td></tr></table></figure><h2 id="6-4-常用函数"><a href="#6-4-常用函数" class="headerlink" title="6.4 常用函数"></a>6.4 常用函数</h2><h3 id="front-返回头部元素"><a href="#front-返回头部元素" class="headerlink" title="front()  返回头部元素"></a><code>front()</code>  <strong>返回头部元素</strong></h3><blockquote><p><strong>dq.front()</strong><br>返回第一个元素的引用。</p></blockquote><hr><h3 id="back-返回尾部元素"><a href="#back-返回尾部元素" class="headerlink" title="back()  返回尾部元素"></a><code>back()</code>  <strong>返回尾部元素</strong></h3><blockquote><p><strong>dq.back()</strong><br>返回最后一个元素的引用。</p></blockquote><hr><h3 id="push-back-在尾部添加一个元素-1"><a href="#push-back-在尾部添加一个元素-1" class="headerlink" title="push_back()  在尾部添加一个元素"></a><code>push_back()</code>  <strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>dq.push_back(value)</strong><br><strong>添加</strong>值为value的元素到末尾。</p></blockquote><hr><h3 id="pop-back-在尾部删除一个元素"><a href="#pop-back-在尾部删除一个元素" class="headerlink" title="pop_back()  在尾部删除一个元素"></a><code>pop_back()</code>  <strong>在尾部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><br><strong>删除</strong>尾部第一个元素。</p></blockquote><hr><h3 id="push-front-在头部添加一个元素"><a href="#push-front-在头部添加一个元素" class="headerlink" title="push_front()  在头部添加一个元素"></a><code>push_front()</code>  <strong>在头部添加一个元素</strong></h3><blockquote><p><strong>dq.push_front(value);</strong><br><strong>添加</strong>值为value的元素到头部。</p></blockquote><hr><h3 id="pop-front-在头部删除一个元素"><a href="#pop-front-在头部删除一个元素" class="headerlink" title="pop_front()  在头部删除一个元素"></a><code>pop_front()</code>  <strong>在头部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><br><strong>删除</strong>头部第一个元素。</p></blockquote><hr><h3 id="insert-插入元素"><a href="#insert-插入元素" class="headerlink" title="insert() 插入元素"></a><code>insert()</code> <strong>插入元素</strong></h3><blockquote><p><strong>dq.insert(iterator, value)</strong>;<br>向iterator迭代器指向元素的前边添加一个元素value，并返回一个迭代器指向新插入的元素。</p></blockquote><hr><h3 id="erase-删除元素"><a href="#erase-删除元素" class="headerlink" title="erase()  删除元素"></a><code>erase()</code>  <strong>删除元素</strong></h3><blockquote><p><strong>dq.erase(iterator);</strong></p><p><strong>dq.erase(iterator1, iterator2)</strong></p><p>参数为一个迭代器，只删除迭代器指向的元素；参数为两个迭代器，删除两个迭代器之间的元素。</p></blockquote><h1 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h1><h2 id="7-1-基础概念"><a href="#7-1-基础概念" class="headerlink" title="7.1 基础概念"></a>7.1 基础概念</h2><p>在 <code>#include &lt;set&gt;</code> 中使用</p><blockquote><p>集合(<code>set</code>) 用于存储<strong>不重复</strong>的元素，并且会自动根据元素的值进行<strong>排序</strong>。</p></blockquote><ul><li><strong>不重复元素</strong>：<code>set</code> 中的元素不能重复。如果尝试插入相同的元素，它会被忽略。</li><li><strong>自动排序</strong>：<code>set</code> 会根据元素的大小自动进行排序，默认是按升序排序。如果想使用自定义的排序规则，也可以提供比较函数。</li><li><strong>高效的查找、插入和删除</strong>：<code>set</code> 通常使用红黑树或类似的平衡树结构实现，所以查找、插入和删除操作的时间复杂度是 O(log N)，其中 N 是集合中的元素个数。</li></ul><h2 id="7-2-声明"><a href="#7-2-声明" class="headerlink" title="7.2 声明"></a>7.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s;    <br>set&lt;<span class="hljs-type">double</span>&gt; s;    <br>set&lt;<span class="hljs-type">char</span>&gt; s;    <br>set&lt;<span class="hljs-keyword">struct</span> node&gt; s;    <br>set&lt;set&lt;<span class="hljs-type">int</span>&gt; &gt; s;<br></code></pre></td></tr></table></figure><h2 id="7-3-遍历"><a href="#7-3-遍历" class="headerlink" title="7.3 遍历"></a>7.3 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">//  auto 可以代替 set&lt;int&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="7-4-set-排序"><a href="#7-4-set-排序" class="headerlink" title="7.4 set 排序"></a>7.4 set 排序</h2><p>对于基本数据类型可以直接使用 <code>greater&lt;&gt;</code> 实现降序排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; s; <span class="hljs-comment">// &gt;&gt; 可能会被识别为流运算符，中间可以加一个空格&gt; &gt;</span><br></code></pre></td></tr></table></figure><p>结构体类型的自定义排序可以使用如下方法：<br><strong>方法一：</strong> 重载 <code>operator&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Person&amp; p) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> age &lt; p.age;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>set&lt;Person&gt; person;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong> 使用 cmp 仿函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br><span class="hljs-comment">// 建议使用引用提高效率</span><br><span class="hljs-comment">// bool operator()(Person const&amp; a, Person const&amp; b)&#123;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person a, Person b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义比较器来排序 </span><br>set&lt;Person, cmp&gt; s;<br></code></pre></td></tr></table></figure><h2 id="7-5-常用函数"><a href="#7-5-常用函数" class="headerlink" title="7.5 常用函数"></a>7.5 常用函数</h2><h3 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>s.insert(value)</strong><br>插入元素到集合中，插入之后集合会自动排序。</p></blockquote><hr><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>s.find(value)</strong><br>查找元素返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向 <code>set.end()</code>。</p></blockquote><hr><h3 id="count-计数"><a href="#count-计数" class="headerlink" title="count() 计数"></a><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>s.count(value)</strong><br>返回指定元素的数量，set中元素是唯一的，如果存在则返回1，不存在则返回0。</p></blockquote><hr><h3 id="erase-删除"><a href="#erase-删除" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>s.erase(value)</strong><br>删除指定的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="8-map"><a href="#8-map" class="headerlink" title="8 map"></a>8 map</h1><h2 id="8-1-基础概念"><a href="#8-1-基础概念" class="headerlink" title="8.1 基础概念"></a>8.1 基础概念</h2><p>在 <code>#inlcude &lt;map&gt;</code> 中使用<br><code>map</code> 就是一种存储<strong>键值对</strong>的数据结构，由键和值构成，一个键对应一个值，我们可以通过键获取到该键所对应的值。</p><ul><li>第一个可以称为关键字(<code>key</code>)，每个关键字只能在 <code>map</code> 中出现一次；</li><li>第二个可能称为该关键字的值(<code>value</code>)；</li></ul><blockquote><p><code>map</code> 相当于一个通讯录，<code>map</code> 中记录的每一个昵称和对应的号码，就好比是一个键值对。<strong>注意每个key只能出现一次</strong>，就像我们的通讯录，如果有了两个小明，那我们就搞不清楚哪个才是小明，所以 <code>key</code> 不能重复。</p></blockquote><p><code>map</code> 主要用于资料一对一映射(one-to-one)的情況，<code>map</code> 內部的实现自建一颗红黑树，这颗树具有对数据<strong>自动排序</strong>的功能，也就是说在 <code>map</code> 内部所有的数据都是有序的。</p><h2 id="8-2-声明"><a href="#8-2-声明" class="headerlink" title="8.2 声明"></a>8.2 声明</h2><p><code>key</code> 和 <code>value</code> 可以是任意你需要的类型，包括自定义类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp1;<br>map&lt;string, string&gt; mp2;<br></code></pre></td></tr></table></figure><h2 id="8-3-遍历"><a href="#8-3-遍历" class="headerlink" title="8.3 遍历"></a>8.3 遍历</h2><p><code>it-&gt;first</code> 和 <code>(*it).first</code> 等价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br><span class="hljs-comment">//  auto 可以代替 map&lt;int, string&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="8-4-插入元素的区别"><a href="#8-4-插入元素的区别" class="headerlink" title="8.4 插入元素的区别"></a>8.4 插入元素的区别</h2><p>以下三种方法虽然都可以实现数据的插入，但是它们是有区别的（第一种和第二种在效果上是完成一样的）</p><ul><li>用 <code>insert</code> 函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当 <code>map</code> 中有这个关键字时，<code>insert</code> 操作是不能在插入数据的</li><li>数组方式插入时可以覆盖以前该关键字对应的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp;<br> <br><span class="hljs-comment">// 第一种 用insert函數插入pair</span><br>mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">000</span>, <span class="hljs-string">&quot;zhu&quot;</span>));<br> <br><span class="hljs-comment">// 第二种 用insert函数插入value_type数据</span><br>mp.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">001</span>, <span class="hljs-string">&quot;zhuzhu&quot;</span>));<br> <br><span class="hljs-comment">// 第三种 用&quot;array&quot;方式插入</span><br>mp[<span class="hljs-number">111</span>] = <span class="hljs-string">&quot;og&quot;</span>;<br>mp[<span class="hljs-number">222</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="8-5-常用函数"><a href="#8-5-常用函数" class="headerlink" title="8.5 常用函数"></a>8.5 常用函数</h2><h3 id="insert-插入-1"><a href="#insert-插入-1" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>mp.insert(pair&lt;类型1, 类型2&gt;(key, value))</strong><br>将pair作为整个元素插入</p></blockquote><hr><h3 id="find-查找-1"><a href="#find-查找-1" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>mp.find(key)</strong><br>查找关键 <code>key</code> 返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向 <code>map.end()</code>。</p></blockquote><hr><h3 id="count-计数-1"><a href="#count-计数-1" class="headerlink" title="count() 计数"></a><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>mp.count(key)</strong><br>返回指定元素的数量，因为 <code>key</code>值不会重复，所以只有0和1，如果存在则返回1，不存在则返回0。</p></blockquote><hr><h3 id="erase-删除-1"><a href="#erase-删除-1" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>mp.erase(key)</strong><br>删除指定关键字的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="9-pair"><a href="#9-pair" class="headerlink" title="9 pair"></a>9 pair</h1><p><code>pair</code> 本质上就是一个内部有两个名字固定的成员变量的结构体，这两个成员变量为：<code>first</code> 成员和 <code>second</code> 成员。使用之前要添加头文件:<code>#include &lt;utility&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//两者是等价的</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>string first;<br><span class="hljs-type">int</span> second;<br>&#125; p;<br><span class="hljs-comment">//定义的同时初始化</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zhuzhu&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//pair的访问</span><br>p.first = <span class="hljs-string">&quot;hhhhh&#x27;</span><br><span class="hljs-string">p.second = 15;</span><br></code></pre></td></tr></table></figure><p>两个 <code>pair</code> 类型数据可以直接使用<code> =、!=、&lt;、&lt;=、&gt;、&gt;=</code>比较</p><ol><li>先以 <code>first</code> 的大小来比较</li><li>当 <code>first</code> 相等时，比较 <code>second</code> 的大小</li></ol><p><code>pair</code> 能够存储两个值，并且值的类型可以不同。可以用在很多标准容器中，特别是需要存储一对<strong>相关联</strong>的值时，比如说x和y坐标，<code>pair</code> 是一种非常好用的模板类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt; s;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; v;<br><br>set.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;) <span class="hljs-comment">// 使用&#123;&#125;表示元素</span><br></code></pre></td></tr></table></figure><blockquote><p>其实<code>map</code>中的每个元素就是一个 <code>pair&lt;const Key, T&gt;</code>，其中 <code>Key</code> 是键，<code>T</code> 是值。<code>map</code>像一个对<code>Key</code>值自动排序的<code>pair</code>数组。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>埃氏筛质数判定</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>从 2 开始，将每个质数的倍数都标记为非质数，最终剩下未被标记的就是质数。<br>举例说明（筛选 2~30 的质数）：</p><ol><li>初始时，默认 2~30 全部为质数。</li><li>2 是质数，标记 2 的所有倍数（4, 6, 8…）不是质数。</li><li>找到下一个未被标记的数：3，是质数，标记 3 的倍数（6, 9, 12…）不是质数。</li><li>接着是 5、7……依此类推，直到 $\sqrt30$ ≈ 5 为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> not_prime[N];  <span class="hljs-comment">// true表示不是质数，false表示质数，默认全是质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// 埃氏筛标记 0~n</span><br>    not_prime[<span class="hljs-number">0</span>] = not_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++)  <br>        <span class="hljs-keyword">if</span>(!not_prime[i])  <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt;= n; j += i)  <br>                not_prime[j] = <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dns">正式课：<span class="hljs-number">51*24=1224</span><br>直播课：<span class="hljs-number">7*180=1260</span><br>正常补课：<span class="hljs-number">4*100+2*24</span>+<span class="hljs-number">2*24=496</span><br>插班补课：<span class="hljs-number">2*100=200</span><br>集训补课：<span class="hljs-number">1</span>*<span class="hljs-number">300=300</span><br>预热课：<span class="hljs-number">6*96=576</span><br>体验课：<span class="hljs-number">5*100=500</span><br>清华附：<span class="hljs-number">1</span>*<span class="hljs-number">400=400</span><br><span class="hljs-number">1224+1260</span>+<span class="hljs-number">496+200</span>+<span class="hljs-number">300+576</span>+<span class="hljs-number">500+400</span>=<span class="hljs-number">4956</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-模拟枚举"><a href="#1-模拟枚举" class="headerlink" title="1 模拟枚举"></a>1 模拟枚举</h1><p>枚举算法是我们在日常中使用到的最多的一个算法，枚举算法的核心思想就是：<strong>枚举所有的可能</strong>。枚举算法简单粗暴，暴力的枚举所有可能速度可能比较慢，但是总能得出正确答案。</p><p>枚举算法的三要素：<strong>枚举对象</strong>、<strong>枚举范围</strong>和<strong>判定条件</strong></p><blockquote><p>比如密码锁，枚举 000～999 的情况<br>枚举对象：密码<br>枚举范围：000～999<br>判定条件：否密码是否正确(能否打开锁)</p></blockquote><h1 id="2-递归算法"><a href="#2-递归算法" class="headerlink" title="2 递归算法"></a>2 递归算法</h1><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……</p></blockquote><p>这就是语言上的递归，在程序设计领域，递归是指函数 (或方法)<strong>直接</strong>或<strong>间接</strong>调用自身的一种操作，如下图所示。<br><img src="/../../../cpp_assets/c_recursion.png" alt="Pasted-image-202503062344352c9c59d453412a7c.png"></p><p>递归的两大要素</p><ul><li>具有递归边界条件：所描述问题的最简单情况，它本身不再使用递归的定义。</li><li>递归定义：使问题向边界条件转化的规则！</li></ul><p>递归执行的过程中遇到调用函数，程序就先记住当前执行的位置，然后将值拷贝过去，遇到函数就故技重施重复以上操作，直到到达递归边界，再一层一层的回去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在递归函数前面的正序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br>cout &lt;&lt; n;<br><span class="hljs-built_in">funcA</span>(n + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//在递归函数后面的逆序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br><span class="hljs-built_in">funcB</span>(n + <span class="hljs-number">1</span>);<br>cout &lt;&lt; n;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong>否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p></blockquote><h1 id="3-递推算法"><a href="#3-递推算法" class="headerlink" title="3 递推算法"></a>3 递推算法</h1><p>递推算法是一种用<strong>若干步可重复运算</strong>来描述复杂问题的方法。通常是通过计算前面的一些<br>项来得出序列中的指定项的值。<br>比如斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//f[i]记录第i项斐波那契数列是多少</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++） <br>f[i] = f[i - <span class="hljs-number">2</span>] + f[i - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//a[i]记录i条直线分割平面有几个部分</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 原有的 ＋ 新的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>a[i] = a[i - <span class="hljs-number">1</span>] + i; <br></code></pre></td></tr></table></figure><h1 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h1><p>贪心算法（greedy algorithm），又称贪婪算法，在对问题求解时，总是做出在当前看来是<br>最好的选择。<br>不从整体最优上加以考虑，算法得到的是在某种意义上的<strong>局部最优解</strong>。<br>在解决贪心算法的问题时，需要保证每一步所作的贪心选择，能够最终导致问题的整体最优解。</p><h1 id="5-前缀和与差分"><a href="#5-前缀和与差分" class="headerlink" title="5 前缀和与差分"></a>5 前缀和与差分</h1><h2 id="5-1-前缀和"><a href="#5-1-前缀和" class="headerlink" title="5.1 前缀和"></a>5.1 前缀和</h2><p>前缀和是一个常见的算法技巧，用于<strong>快速计算数组中某个区间内元素的和</strong><br>它的基本思想是<strong>预处理</strong>出数组的前缀和数组，然后利用前缀和数组来快速计算任意区间的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></td></tr></table></figure><h2 id="5-2-差分"><a href="#5-2-差分" class="headerlink" title="5.2 差分"></a>5.2 差分</h2><p>差分是一种数学运算方法，一维差分是指数列中<strong>相邻两项之间的差值</strong></p><p>对原数组［l,r］整体增加 c 时，差分数组只需要修改第 l 项和第 r+1 项<br><img src="/../../../cpp_assets/c_dif.png" alt="Pasted-image-202503062344352c9c59d453412a7c.png"></p><p>因为差分数组只是与前面项的差值，所以从第一项累加到第 i 项即可得到原数组第 i 项的数值，可以结合前缀和快速计算</p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h1><h2 id="6-1-常用数学函数"><a href="#6-1-常用数学函数" class="headerlink" title="6.1 常用数学函数"></a>6.1 常用数学函数</h2><ul><li><code>max(a, b)</code> 求同类型两者的较大者</li><li><code>min(a, b)</code> 求同类型两者的较小者</li><li><code>pow(a, b)</code> 求a的b次方</li><li><code>sqrt(x)</code> 求x的开方根</li><li><code>abs(x)</code> 求整数x的绝对值</li><li><code>fabs(x)</code> 求浮点数x的绝对值</li><li><code>round(x)</code> 四舍五入取整</li><li><code>floor(x)</code> 向下取整</li><li><code>ceil(x)</code> 向上取整</li></ul><h2 id="6-2-for-each-注意事项"><a href="#6-2-for-each-注意事项" class="headerlink" title="6.2 for each 注意事项"></a>6.2 for each 注意事项</h2><p><code>for(auto i : arr)</code> i是每一个元素的副本，可以用来遍历容器，但不能修改元素<br><code>for(auto &amp; i : arr)</code> i的引用可以直接修改arr中的实际元素     </p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符数组与字符串</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字符数组"><a href="#1-字符数组" class="headerlink" title="1 字符数组"></a>1 字符数组</h1><ul><li><code>strlen(charr)</code> 返回字符串的长度，不包含结束符\0</li><li><code>strcpy(charr1, charr2)</code> 复制字符串，字符串charr2复制给charr1，返回charr1</li><li><code>strncpy(charr1, charr2)</code> 将charr2前n个字符复制给charr1</li><li><code>strcat(charr1, charr2)</code> 拼接字符串，字符串charr2拼接在charr1后面，返回charr1</li><li><code>strncat(charr1, charr2)</code> 将字符串charr2前n个字符拼接到charr1<ul><li><strong>注</strong>：如果添加或者复制后的charr1数组越界则会报错</li></ul></li><li><code>strcmp(charr1,charr2)</code> 比较字符串，如果charr1&gt;charr2 返回正整数，charr1&#x3D;charr2 返回0，charr1&lt;charr2 返回负整数</li><li><code>strncmp(charr1,charr2)</code> 比较charr1和charr2的前n个字符</li></ul><p>字符数组转 <code>int</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">atoi</span>(a);<br></code></pre></td></tr></table></figure><p>字符数组转 &#96;string</p><ul><li><p>直接赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s = a;<br></code></pre></td></tr></table></figure></li><li><p>构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;  <br><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(a)</span></span>;  <span class="hljs-comment">// 全部转换</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(a, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 指定长度转换</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2-string类"><a href="#2-string类" class="headerlink" title="2 string类"></a>2 string类</h1><h2 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h2><p>在 <code>#inlcude &lt;string&gt;</code> 中使用</p><blockquote><p><code>string</code>不是<strong>基本数据类型</strong>，是C++中对<strong>char</strong>封装成的<strong>类</strong>。主要用于<strong>字符串</strong>处理，可以使用<strong>输入输出流</strong>方式直接进行<code>string</code>操作，也可以通过<strong>文件</strong>等手段进行<code>string</code>操作。</p></blockquote><p><img src="/../../../cpp_assets/c_string.png"></p><h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <span class="hljs-comment">//空字符串</span><br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>; <span class="hljs-comment">//5个a</span><br>string s2 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//s2为123456</span><br></code></pre></td></tr></table></figure><h2 id="2-3-输入输出"><a href="#2-3-输入输出" class="headerlink" title="2.3 输入输出"></a>2.3 输入输出</h2><ul><li><p><code>cin &gt;&gt; s;</code>   读到空格、回车、文件结束符停止</p></li><li><p><code>getline(cin, s);</code> 读入一整行</p></li><li><p><code>cout &lt;&lt; s;</code> 输出整个字符串</p></li><li><p><code>cout &lt;&lt; s[2];</code> 按下标输出</p></li></ul><h2 id="2-4-遍历"><a href="#2-4-遍历" class="headerlink" title="2.4 遍历"></a>2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-5-常用函数"><a href="#2-5-常用函数" class="headerlink" title="2.5 常用函数"></a>2.5 常用函数</h2><ul><li><code>str.length()</code>&#x2F;<code>str.size()</code> 返回字符串真实长度，不包含结束符\0</li><li><code>sizeof(type)</code>数据类型用括号  <code>sizeof var_name</code>  变量名可以不用括号 </li><li><code>str.empty()</code> 字符串判空，空串返回<code>true</code>，非空返回<code>false</code></li><li><code>str1.insert(pos, str2)</code> 在str1下标pos处插入str2</li><li><code>str.substr(pos,len)</code> 返回一个从下标pos开始截取长度为len的字符串</li><li><code>str.erase(pos, len)</code> 删除从下标pos开始的len个字符</li><li><code>str1.replace(pos, len, str2) </code> 将str1中下标为pos开始的len个元素替换为str2</li><li><code>str.find(s, pos)</code> 从str中下标为pos的位置开始查找，返回s第一次出现的下标，查找不到返回 <code>string::npos</code></li><li><code>str.clear()</code> 清空str中的内容</li><li>string的拼接复制比较可以直接使用<code>+</code> <code>=</code> <code>&gt; &lt; &gt;= &lt;= != ==</code></li></ul><h4 id="size-获取大小"><a href="#size-获取大小" class="headerlink" title="size()  获取大小"></a><code>size()</code>  <strong>获取大小</strong></h4><p>语法:</p><blockquote><p><strong>s.size()</strong><br>返回<strong>元素数目</strong></p></blockquote><hr><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length() 获取长度"></a><code>length()</code> <strong>获取长度</strong></h4><p>语法:</p><blockquote><p><strong>s.length()</strong><br>返回<strong>字符串长度</strong>, 与**size()**返回的数字相同</p></blockquote><hr><h4 id="empty-判空"><a href="#empty-判空" class="headerlink" title="empty() 判空"></a><code>empty()</code> <strong>判空</strong></h4><p>语法:</p><blockquote><p><strong>s.empty()</strong><br>若为空, 返回<strong>true</strong>, 非空返回<strong>false</strong></p></blockquote><hr><h4 id="clear-清空"><a href="#clear-清空" class="headerlink" title="clear() 清空"></a><code>clear()</code> <strong>清空</strong></h4><p>语法:</p><blockquote><p><strong>s.clear</strong>()<br><strong>清空所有元素</strong></p></blockquote><hr><h4 id="push-back-尾部插入"><a href="#push-back-尾部插入" class="headerlink" title="push_back() 尾部插入"></a><code>push_back()</code> <strong>尾部插入</strong></h4><p>语法:</p><blockquote><p><strong>s.push_back(c)</strong><br><strong>尾部插入一个字符</strong>，可用+&#x3D;代替</p></blockquote><hr><h4 id="pop-back-尾部删除"><a href="#pop-back-尾部删除" class="headerlink" title="pop_back() 尾部删除"></a><code>pop_back()</code> <strong>尾部删除</strong></h4><p>语法:</p><blockquote><p><strong>s.pop_back()</strong><br><strong>尾部删除一个元素</strong></p></blockquote><hr><h4 id="back-访问尾部"><a href="#back-访问尾部" class="headerlink" title="back() 访问尾部"></a><code>back()</code> <strong>访问尾部</strong></h4><p>语法:</p><blockquote><p><strong>s.back()</strong><br><strong>访问尾部元素</strong></p></blockquote><hr><h4 id="front-访问头部"><a href="#front-访问头部" class="headerlink" title="front() 访问头部"></a><code>front()</code> <strong>访问头部</strong></h4><p>语法:</p><blockquote><p><strong>s.front()</strong><br><strong>访问头部第一个元素</strong>，可用s[0]代替</p></blockquote><hr><h4 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h4><p>语法:</p><blockquote><p> <strong>s1.insert(pos, s2)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bd&quot;</span>); <span class="hljs-comment">//在下标2处插入bd</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span> (<span class="hljs-number">4</span>, s2); <span class="hljs-comment">//在下标4处插入s2</span><br></code></pre></td></tr></table></figure><hr><h4 id="erase-删除"><a href="#erase-删除" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h4><p>语法:</p><blockquote><p><strong>s.erase(pos, num)</strong><br><strong>s.erase(pos)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//从下标2开始删除4个字符</span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//从下标3开始删除后面所有字符</span><br></code></pre></td></tr></table></figure><hr><h4 id="substr-截取"><a href="#substr-截取" class="headerlink" title="substr() 截取"></a><code>substr()</code> <strong>截取</strong></h4><p>语法:</p><blockquote><p><strong>s.substr(pos, num)</strong><br><strong>s.substr(pos)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标1开始截取3个字符</span><br>s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始截取整个s2</span><br></code></pre></td></tr></table></figure><hr><h4 id="find-查找"><a href="#find-查找" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h4><p>语法:</p><blockquote><p><strong>s1.find(s2, pos)</strong><br><strong>s1.find(s2)</strong><br>查到返回<strong>下标</strong>, 查不到返回 <strong>string::npos</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向后查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向后查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr><h4 id="rfind-逆序查找"><a href="#rfind-逆序查找" class="headerlink" title="rfind 逆序查找"></a><code>rfind</code> <strong>逆序查找</strong></h4><p>语法:</p><blockquote><p><strong>s1.rfind(s2, pos)</strong><br><strong>s1.rfind(s2)</strong><br>查到返回<strong>下标</strong>, 查不到返回 <strong>string::npos</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//逆序查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向前查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向前查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr><h4 id="reverse-逆置"><a href="#reverse-逆置" class="headerlink" title="reverse() 逆置"></a><code>reverse()</code> <strong>逆置</strong></h4><p>语法:</p><blockquote><p><strong>reverse(s.begin, s.end)</strong> &#x2F;&#x2F;包含在&lt;algorithm&gt;中<br><strong>字符串逆置</strong></p></blockquote><hr><h4 id="to-string-int-转-string"><a href="#to-string-int-转-string" class="headerlink" title="to_string() int 转 string"></a><code>to_string()</code> <strong>int 转 string</strong></h4><p>语法</p><blockquote><p> <strong>to_string(int)</strong><br> 返回一个<strong>string</strong></p></blockquote><hr><h4 id="stoi-string-转-int"><a href="#stoi-string-转-int" class="headerlink" title="stoi() string 转 int"></a><code>stoi()</code> <strong>string 转 int</strong></h4><p>语法:</p><blockquote><p><strong>stoi(string)</strong><br>返回一个<strong>int</strong></p></blockquote><hr><h4 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy() 复制"></a><code>copy()</code> <strong>复制</strong></h4><p>语法:</p><blockquote><p><strong>s.copy(a, num, pos)</strong><br><strong>s.copy(a, num)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];<br>s.<span class="hljs-built_in">copy</span>(a, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始复制5个字符到字符数组a</span><br>s.<span class="hljs-built_in">copy</span>(a,<span class="hljs-number">6</span>); <span class="hljs-comment">//从下标0开始复制6个字符到字符数组a</span><br></code></pre></td></tr></table></figure><h1 id="3-字符数组和string类的区别"><a href="#3-字符数组和string类的区别" class="headerlink" title="3  字符数组和string类的区别"></a>3  字符数组和string类的区别</h1><ul><li><code>string</code>是一个类，<code>string s=&quot;abcd&quot;;</code>中的s是一个对象</li><li>初始化方式不同<ul><li>字符数组后面有 [] ，string类型后面没有[]</li><li>初始化的关键字一个是<code>char</code> 一个是<code>string</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> charr2[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>string str1;<br>string str2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>都可以使用<code>cin cout</code>的方式进行输入输出，<code>getline</code>使用有区别</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>]; <br>cin.<span class="hljs-built_in">getline</span>(charr1,<span class="hljs-number">20</span>);<br>string str;<br><span class="hljs-built_in">getline</span>(cin,str);<br></code></pre></td></tr></table></figure><ul><li>都可以使用下标来访问元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序总结</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h1><p>从左往右相邻的数两两比较，如果左边大于右边则交换，每一轮冒泡会选出一个未排序数字中的最大值放到最后，每一轮确定一个数字的最终位置，排序完n个数字需要n-1轮。</p><ul><li><p>外层循环通过 <code>i</code> 控制遍历次数，最大到 <code>n-1</code>。每轮比较中最大的元素都会被“冒泡”到数组的末尾，因此内层循环的范围是 <code>n - i - 1</code>。</p></li><li><p><code>swapped</code> 用于记录当前轮次是否有元素交换。如果某轮中没有发生交换，意味着数组已经有序，可以提前退出循环，避免不必要的比较。</p></li><li><p>冒泡排序在最差情况下的时间复杂度是 O(n²)，但在最佳情况下（数组已经有序时），通过 <code>swapped</code> 变量，时间复杂度可以优化为 O(n)。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 每次循环开始时重置标志位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;  <span class="hljs-comment">//排好的放在后面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 比较相邻元素</span><br>                <span class="hljs-built_in">swap</span>(a[j], a[j + <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 交换元素</span><br>                swapped = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 记录交换发生</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果没有发生交换，数组已经有序，提前退出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h1><p>从左往右扫描，每一轮选出一个当前未排序数字中的最小值，放到前面，每一轮确定一个数字的最终位置，排完n个数字需要n-1轮。 </p><ul><li><p><strong>外层循环</strong>通过 <code>i</code> 控制遍历次数，最大到 <code>n-1</code>，每次遍历选择数组中未排序部分的第一个元素。</p></li><li><p><strong>内层循环</strong>通过 <code>j</code> 遍历未排序的部分，从 <code>i + 1</code> 开始到 <code>n</code>。内层循环的目的是找到当前未排序部分的最小元素，并记录其索引 <code>minIndex</code>。</p></li><li><p>在每轮结束时，将当前元素 <code>a[i]</code> 与找到的最小元素 <code>a[minIndex]</code> 进行交换。</p></li><li><p>即使数组已经有序，选择排序也仍然需要 O(n²) 的比较次数，因为每次都需要遍历未排序部分。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">int</span> minIndex = i;  <span class="hljs-comment">// 假设当前元素为最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)  <span class="hljs-comment">// 排好的放在前面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[minIndex]) minIndex = j;  <span class="hljs-comment">// 找到更小的元素，更新最小值索引</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[minIndex]);  <span class="hljs-comment">// 交换最小值到当前排序位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h1><p><strong>外层循环</strong> (<code>for (int i = 1; i &lt; n; i++)</code>)：从第二个元素开始遍历，作为当前要插入的元素 <code>x</code>。</p><p><strong><code>x</code> 变量</strong>：存储当前要插入的元素，以便在内层循环中进行比较和插入操作。</p><p>**已排序部分的下标 <code>j</code>**：<code>j</code> 初始化为 <code>i - 1</code>，表示已排序部分的最后一个元素。</p><p><strong>内层循环</strong> (<code>while (j &gt;= 0 &amp;&amp; x &lt; a[j])</code>)：</p><ul><li>在已排序部分中查找 <code>x</code> 的插入位置。</li><li><strong>越界检查</strong>：首先判断 <code>j &gt;= 0</code>，确保访问 <code>a[j]</code> 不会越界。</li><li>如果 <code>a[j]</code> 大于 <code>x</code>，则将 <code>a[j]</code> 向右移动，腾出 <code>j + 1</code> 的位置来插入 <code>x</code>。</li></ul><p><strong>插入操作</strong> (<code>a[j + 1] = x</code>)：当找到合适位置后，将 <code>x</code> 插入到 <code>j + 1</code> 的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 从第二个元素遍历要插入的元素</span><br>        <span class="hljs-type">int</span> x = a[i];  <span class="hljs-comment">// 当前要插入的元素</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 已排序的最后一个元素下标</span><br>        <span class="hljs-comment">// 在已排序部分中找到 x 的插入位置</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[j]) &#123;  <span class="hljs-comment">// 先判断j&gt;=0，防止越界错误</span><br>            a[j + <span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 元素向右移动，为x空出位置</span><br>            j--;  <span class="hljs-comment">// 移动到前一个元素</span><br>        &#125;<br>        a[j + <span class="hljs-number">1</span>] = x;  <span class="hljs-comment">// 将 x 插入到找到的位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-桶排序"><a href="#4-桶排序" class="headerlink" title="4 桶排序"></a>4 桶排序</h1><p>**<code>cnt[N] = &#123;0&#125;</code>**：定义一个大小为 <code>N</code> 的数组 <code>cnt</code>，用于统计每个元素的出现次数，初始化为 0。</p><p><strong>输入读取和计数</strong>：使用 <code>for</code> 循环读取 <code>n</code> 个整数输入，检查 <code>x</code> 是否在合法范围内 <code>[0, N)</code>，并通过 <code>cnt[x]++</code> 对每个 <code>x</code> 的出现次数进行统计。</p><p><strong>输出</strong>：第二个 <code>for</code> 循环遍历 <code>cnt</code> 数组，通过嵌套循环输出每个数 <code>i</code> 的值，输出的次数取决于 <code>cnt[i]</code> 的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> cnt[N] = &#123;<span class="hljs-number">0</span>&#125;, n;<br>cin &gt;&gt; n;  <span class="hljs-comment">// 读取元素个数</span><br><span class="hljs-comment">// 读取每个元素并进行计数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; N) cnt[x]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt[i]; ++j)<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 按照计数输出数字 i</span><br></code></pre></td></tr></table></figure><h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h1><ol><li>选取一个数作为<strong>基准数</strong></li><li>小于基准数的值放左半区，大于基准数的值放右半区</li><li>再对左右区间重复1、2步，直到各区间只剩一个数</li></ol><p>通过<strong>分治法</strong>，每次递归时选取一个基准值，然后通过双指针将数组划分成两部分，使得左边部分的值小于等于基准值，右边部分的值大于等于基准值。然后递归地对两部分进行排序，直到数组被完全排序。</p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p>递归终止的条件是 <code>l &gt;= r</code>，也就是说当前区间长度为 0 或 1 时，不需要继续排序。</p><p><strong>基准值</strong>：<code>x = a[(l + r) &gt;&gt; 1]</code> 通过 <code>(l + r) &gt;&gt; 1</code> 计算出中间元素的下标，并将它作为基准值 <code>x</code>。</p><p><strong>双指针初始化</strong>：</p><ul><li><code>i = l - 1</code>，指向比基准值小的区域。</li><li><code>j = r + 1</code>，指向比基准值大的区域。</li></ul><p><strong>主循环条件</strong>：<code>while (i &lt; j)</code>，保证左右指针在数组内并且没有交错。</p><p><strong>内循环（左指针 <code>i</code>）</strong>：<code>do i++; while (a[i] &lt; x);</code> 从左向右找到第一个大于等于基准值的元素。</p><p><strong>内循环（右指针 <code>j</code>）</strong>：<code>do j--; while (a[j] &gt; x);</code> 从右向左找到第一个小于等于基准值的元素。</p><blockquote><p>此处必须使用严格的<code>&gt;</code> <code>&lt;</code>，如果使用<code>&gt;=</code> <code>&lt;=</code>选取的基准值是最大值，指针<code>i</code>不会停止，会一直<code>++</code>直到越界</p></blockquote><p><strong>元素交换</strong>：当 <code>i &lt; j</code> 时，交换 <code>a[i]</code> 和 <code>a[j]</code>，确保基准值左边的元素都小于等于它，右边的元素都大于等于它。</p><p><strong>左半部分递归</strong>：对 <code>l</code> 到 <code>j</code> 的部分继续执行快速排序。此时 <code>j</code> 是划分完成后，左半部分的最大值位置。</p><p><strong>右半部分递归</strong>：对 <code>j + 1</code> 到 <code>r</code> 的部分继续执行快速排序。</p><p><strong>注意：</strong> 因为<code>do-while</code>的存在，退出 <code>while</code> 时，j 最终会停在 <strong>（1+r）&#x2F;2</strong> 的位置，也就是 <strong>i &#x3D; j 或 i &#x3D; j + 1</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归结束条件：当区间元素只有1个元素或者没有元素时</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br>    <br><span class="hljs-comment">// 初始化双指针i和j，</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">//后面会先++或--，所以指向边界的前一个或后一个元素</span><br>    <span class="hljs-type">int</span> pivot = a[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 选择中间位置的值作为基准值</span><br>    <br>    <span class="hljs-comment">// 双指针划分过程</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-comment">// 左指针向右移动，指针左侧都是小于基准值的，找到第一个大于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot);<br>        <span class="hljs-comment">// 右指针向左移动，指针右侧都是大于基准值的，找到第一个小于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot);<br>        <span class="hljs-comment">// 如果i和j两个指针还没有相遇，交换a[i]和a[j]</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br><br><span class="hljs-comment">// 不重不漏</span><br>    <span class="hljs-built_in">quick_sort</span>(a, l, j);  <span class="hljs-comment">// 递归调用，对左半部分（l到j）进行快速排序</span><br>    <span class="hljs-built_in">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 递归调用，对右半部分（j+1到r）进行快速排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果每次选的<code>pivot</code>能让左右两段近似等分，会生成一颗有 logn 层的均衡的二叉树，每层 i, j两指针将会遍历所有 n 个元素，时间复杂度为 O(nlogn)。<br>如果每次选的<code>pivot</code>只能分离出一个元素，会退化成有 n 层的链，i, j两指针走的总步数&#x3D; n+(n－1)+…+1，时间复杂度退化为 O(n²)。<br><img src="/../../../cpp_assets/c_quick_sort.png" alt="Pasted-image-20250310154403c0d33279d726e024.png"></p><p>在快速排序和快速选择算法中，<strong>分区方法</strong> 是最核心的步骤。它们的核心目标都是将数组划分为两个部分，但实现方式和性能特点不同。</p><h2 id="5-1-Hoare-分区法"><a href="#5-1-Hoare-分区法" class="headerlink" title="5.1 Hoare 分区法"></a>5.1 Hoare 分区法</h2><p>由快速排序的发明者 Tony Hoare 提出，是最原始的分区方案。</p><ul><li><strong>双向指针扫描</strong><ul><li>左指针 <code>i</code> 从数组左端向右移动</li><li>右指针 <code>j</code> 从数组右端向左移动</li><li>直到找到需要交换的元素对</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组被划分为：<code>[ &lt;= pivot ]</code> + <code>[ &gt;= pivot ]</code></li><li>注意：<strong>不保证枢轴值在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hoare_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = a[l + (r - l) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 选择中间元素作为枢轴</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 因为可能把两个和 pivot 相等的值交换，所以不稳定</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot); <span class="hljs-comment">// 找左边第一个 &gt;= pivot 的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot); <span class="hljs-comment">// 找右边第一个 &lt;= pivot 的元素</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">return</span> j;         <span class="hljs-comment">// 返回分界点</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设数组为 <code>[3, 1, 4, 2, 5]</code>，选择中间元素 <code>4</code> 为枢轴：</p><ol><li><code>i</code> 找到 <code>4</code>（位置2），<code>j</code> 找到 <code>2</code>（位置3） → 交换 → <code>[3,1,2,4,5]</code></li><li><code>i</code> 移动到 <code>4</code>（位置3），<code>j</code> 移动到 <code>2</code>（位置2） → <code>i &gt;= j</code> → 返回 <code>j=2</code></li></ol><h2 id="5-2-填坑法"><a href="#5-2-填坑法" class="headerlink" title="5.2 填坑法"></a>5.2 填坑法</h2><p> 填坑法，左右指针交替覆盖，是快速排序中一种常见的分区实现方式，可以看作是 Lomuto 分区法的变体。</p><ul><li><strong>枢轴选择</strong>：固定选择左端点 <code>a[l]</code> 作为枢轴值 <code>pivot</code>。</li><li><strong>填坑操作</strong>：<ul><li><strong>右指针扫描</strong>：从右向左找到第一个 <code>&lt; pivot</code> 的元素，将其值覆盖到左指针位置（填左坑）。</li><li><strong>左指针扫描</strong>：从左向右找到第一个 <code>&gt; pivot</code> 的元素，将其值覆盖到右指针位置（填右坑）。</li><li>循环直到左右指针相遇，最后将枢轴值 <code>pivot</code> 放入相遇点。</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组结构：<code>[ &lt;= pivot ]</code> + <code>pivot</code> + <code>[ &gt;= pivot ]</code></li><li><strong>枢轴值一定在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <br><span class="hljs-type">int</span> pivot = a[l]; <span class="hljs-comment">//枢轴 </span><br><span class="hljs-keyword">while</span> (l &lt; r) &#123; <br><span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= pivot) r--; <br>a[l] = a[r]; <br><span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= pivot) l++; <br>a[r] = a[l]; <br>&#125; <br>a[l] = pivot; <br><span class="hljs-keyword">return</span> l; <span class="hljs-comment">//返回枢轴位置 </span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h1><p>归并排序主要使用了分治思想，字面上的解释是“<strong>分而治之</strong>”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>“分”而“治”之，先“分”后“治”</p><ul><li>“分”：将问题划分成若干子问题然后递归求解</li><li>“治”：将子问题的答案整合在一起</li></ul><p><img src="/../../../cpp_assets/c_merge_sort.png" alt="Pasted-image-202503071129090c2390f01aa20eb3.png"></p><p>归并排序将待排序序列划分成若干个子序列，将子序列合并为一个有序序列。具体来说通过递归将数组分成两半，分别排序，递归到最后，实际是把单个元素看作一个有序序列，开始<strong>两两归并</strong>，形成一个两个元素的有序序列，再两两归并，形成一个四个元素的有序序列，不断合并两个有序的子数组来达到排序的效果。<br><img src="/../../../cpp_assets/c_merge_sort_tree.png" alt="Pasted-image-202503310022534718d6a70a594701.png"></p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p><strong>终止条件</strong>：如果 <code>l &gt;= r</code>（即数组只剩一个或没有元素时），直接返回。</p><ul><li><code>mid = (l + r) &gt;&gt; 1</code>：通过取中间位置 <code>mid</code> 将当前区间 <code>[l, r]</code> 分为两个子区间 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code>。</li><li>递归调用 <code>merge_sort(a, l, mid)</code> 对左半部分排序，<code>merge_sort(a, mid + 1, r)</code> 对右半部分排序。</li></ul><p><strong>合并两个有序部分</strong>：</p><ul><li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向左半部分 <code>[l, mid]</code> 和右半部分 <code>[mid + 1, r]</code> 的起始位置。通过比较 <code>a[i]</code> 和 <code>a[j]</code> 的值，将较小的值放入临时数组 <code>tmp[]</code>（因为是<code>&lt;=</code>，相等的时候把左边元素放入临时数组，所以稳定）。</li><li>如果左半部分未遍历完，将剩余部分加入 <code>tmp[]</code>。</li><li>如果右半部分未遍历完，也将其加入 <code>tmp[]</code>。</li><li>最后，将临时数组 <code>tmp[]</code> 中的元素复制回原数组 <code>a[]</code>，完成本次合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归终止条件：如果子序列中只有1个元素或0个元素，返回</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算中间索引，将数组一分为二</span><br>    <span class="hljs-comment">// l + (r - l) / 2  防止溢出</span><br>    <br>    <span class="hljs-built_in">merge_sort</span>(a, l, mid); <span class="hljs-comment">// 递归排序左半部分</span><br>    <span class="hljs-built_in">merge_sort</span>(a, mid + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// 递归排序右半部分</span><br><br>    <span class="hljs-comment">// 合并两个已排序的部分</span><br><span class="hljs-type">int</span> k = l; <span class="hljs-comment">// 临时数组的索引</span><br><span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左半部分和右半部分的指针</span><br>     <br>    <span class="hljs-comment">// 合并过程：将较小的元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-comment">// 如果左半部分当前元素小于等于右半部分，加入临时数组</span><br>        <span class="hljs-comment">// 正是因为这里是 &lt;= ，如果元素相等先取前面的，所以稳定</span><br>        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) tmp[k++] = a[i++]; <br>        <span class="hljs-comment">// 否则，加入右半部分的当前元素</span><br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++]; <br>    &#125;<br>    <br>    <span class="hljs-comment">// 将左半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++]; <br>    <span class="hljs-comment">// 将右半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = a[j++]; <br><br>    <span class="hljs-comment">// 将临时数组的内容复制回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= r; i++) a[i] = tmp[i]; <br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">快速排序</th><th align="center">归并排序</th></tr></thead><tbody><tr><td align="center">分治</td><td align="center">先交换，后拆分</td><td align="center">先拆分，后合并</td></tr><tr><td align="center">稳定性</td><td align="center">不稳定</td><td align="center">稳定</td></tr></tbody></table><h1 id="7-sort-排序"><a href="#7-sort-排序" class="headerlink" title="7 sort()排序"></a>7 sort()排序</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p><code>sort()</code>函数是一个比较<strong>灵活</strong>的函数。很多解释是：<code>sort()</code>函数是类似于快速排序的方法，时间复杂度为n*log2(n)，执行效率较高。</p><blockquote><p>STL中的<code>sort()</code>并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过 深，有出现最坏情况的倾向，还会改用堆排序。</p></blockquote><h2 id="7-2-sort-的使用方法"><a href="#7-2-sort-的使用方法" class="headerlink" title="7.2 sort()的使用方法"></a>7.2 sort()的使用方法</h2><p>在C++中使用<code>sort()</code>函数需要使用<code>#include &lt;algorithm&gt;</code>头文件，algorithm意为”算法”，是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(begin, end, cmp);<br></code></pre></td></tr></table></figure><p><code>sort()</code>函数可以对给定区间的元素进行排序，它有三个参数：</p><ul><li>其中<code>begin</code>为待排序数组的起始地址</li><li><code>end</code>为指向待排序数组结束地址下一个位置的指针</li><li><code>cmp</code>参数为排序准则，如果不写，<strong>默认从小到大</strong>进行排序。如果我们想从大到小排序可以将<code>cmp</code>参数写为<code>greater&lt;int&gt;()</code>，<code>&lt;&gt;</code>中表示排序数组的类型，C++11中可以透明比较器<code>greater&lt;&gt;()</code>。如果需要按照其他的排序准则，那么需要我们自己定义一个<code>bool</code>类型的函数来传入。</li></ul><p>使用<code>sort()</code>不仅仅可以从大到小或者从小到大排，还可以按照一定的准则进行排序，编写<code>cmp</code>函数传入<code>sort()</code>函数。比如按照个位从小到大比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a % <span class="hljs-number">10</span> &gt; b % <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对<strong>结构体</strong>进行排序，比如定义一个结构体包含学生的姓名和年龄，按照年龄从小到大排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a, Student b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上的代码示例中使用了<strong>值传递</strong>，每次调用函数都会创建<code>Student</code>对象的副本，增加额外的开销，降低排序的效率，使用<strong>引用传递</strong>可以避免拷贝开销，更加高效。值传递会创建参数的副本，对于大型对象或复杂数据结构，可能涉及大量的内存分配和数据复制，引用传递避免了这些操作，因为它直接操作原始对象。</p><table><thead><tr><th>特性</th><th>值传递</th><th>引用传递</th></tr></thead><tbody><tr><td>数据传递方式</td><td>副本传递，函数操作的是实参的副本</td><td>引用传递，函数操作的是实参的原数据</td></tr><tr><td>内存开销</td><td>需要创建副本，开销较大，尤其对于大型对象</td><td>无需创建副本，内存开销小</td></tr><tr><td>是否修改实参</td><td>函数内部的修改不会影响实参</td><td>函数内部的修改会直接影响实参</td></tr><tr><td>安全性</td><td>相对更安全，因为函数无法修改外部数据</td><td>可能产生副作用，修改不应修改的数据</td></tr><tr><td>适用场景</td><td>当不希望修改外部数据，或数据结构比较简单时使用</td><td>当需要修改实参，或数据结构较大时使用</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a,<span class="hljs-type">const</span> Student&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用参数</strong>：<code>const Student&amp; a</code> 和 <code>const Student&amp; b</code> 表示对 <code>Student</code> 类型的常量引用，这样函数内部无法修改 <code>Student</code> 的内容，同时避免了复制带来的性能损失。</p><p><strong>const 关键字</strong>：使用 <code>const</code> 关键字表明函数不会修改传入的对象，这也是一个良好的编码习惯。 </p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整数二分"><a href="#1-整数二分" class="headerlink" title="1 整数二分"></a>1 整数二分</h1><ol><li>指针的跳跃次数 <code>logn</code></li><li><code>l + 1 = r</code> 时结束，也就是 <code>l</code> 和 <code>r</code> 紧挨的时候</li><li>可行区的指针最后一定指向答案</li><li>开区间可以正确处理边界（<code>l</code>和<code>r</code>初始化在数组的两侧）</li></ol><p><strong>注意：</strong> 访问<code>a[l]</code>或<code>a[r]</code>的时候注意边界问题</p><p>例如目标值在左侧，需要判断 <code>a[l] == x</code>，<code>l</code>有可能一直是-1，此时访问<code>a[l]</code>会出现下标越界</p><h2 id="1-1-最大化查找"><a href="#1-1-最大化查找" class="headerlink" title="1.1 最大化查找"></a>1.1 最大化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> q)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid] &lt;= q) l = mid;  <span class="hljs-comment">// l 一直在可行区内</span><br><span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// r 一直在不可行区内</span><br>&#125;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_binary1.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><h2 id="1-2-最小化查找"><a href="#1-2-最小化查找" class="headerlink" title="1.2 最小化查找"></a>1.2 最小化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid] &gt;= x) r = mid;  <span class="hljs-comment">// r 一直在可行区内</span><br><span class="hljs-keyword">else</span> l = mid;  <span class="hljs-comment">// l 一直在不可行区内</span><br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_binary2.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><h2 id="1-3-二分函数"><a href="#1-3-二分函数" class="headerlink" title="1.3 二分函数"></a>1.3 二分函数</h2><h3 id="1-3-1-lower-bound-begin-end-x-第一个-x"><a href="#1-3-1-lower-bound-begin-end-x-第一个-x" class="headerlink" title="1.3.1 lower_bound(begin, end, x) 第一个 &gt;&#x3D;x"></a>1.3.1 lower_bound(begin, end, x) 第一个 &gt;&#x3D;x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于等于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置（由于r一直在右边界未发生移动）</li></ul><p><img src="/../../../cpp_assets/c_binary_fun1.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回值为地址，减去起始地址a为下标值</span><br><span class="hljs-type">int</span> index = <span class="hljs-built_in">lower_bound</span>(a, a + n, x) - a;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-upper-bound-begin-end-x-第一个-x"><a href="#1-3-2-upper-bound-begin-end-x-第一个-x" class="headerlink" title="1.3.2 upper_bound(begin, end, x) 第一个 &gt;x"></a>1.3.2 upper_bound(begin, end, x) 第一个 &gt;x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置</li></ul><p><img src="/../../../cpp_assets/c_binary_fun2.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><blockquote><p>用<code>upper_bound</code>返回值 - a - 1 就是最后一个小于等于x的下标 </p></blockquote><h1 id="2-浮点数二分"><a href="#2-浮点数二分" class="headerlink" title="2 浮点数二分"></a>2 浮点数二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;  <span class="hljs-comment">// eps表示精度，比题目要求小数位多两位即可</span><br><span class="hljs-keyword">while</span>(r - l &gt; eps) &#123;<br><span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-二分答案"><a href="#3-二分答案" class="headerlink" title="3 二分答案"></a>3 二分答案</h1><p>二分答案与二分查找类似，要求满足条件的<strong>答案是单调有序的</strong>。<br>原理：在答案可能的范围<code>(L, R)</code>内二分查找答案，不断检查当前答案是否满足题目的要求，根据检查结果更新查找的区间，最终取得最符合题目要求的答案。</p><p>同样可以使用以下板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> ans)</span> </span>&#123;<br><span class="hljs-comment">// 根据题意，符合条件返回true，否则false</span><br>&#125;<br><br><span class="hljs-comment">// 假设这里分析得出答案最小值为min，最大值为max</span><br><br><span class="hljs-type">int</span> l = min - <span class="hljs-number">1</span>, r = max + <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 根据题目答案范围设置 l 和 r，注意初始值要在边界两侧，开区间</span><br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 下面 l 和 r 的顺序根据题目进行调整</span><br><span class="hljs-keyword">if</span>(check[mid]) l = mid;  <span class="hljs-comment">// 满足题意</span><br><span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// 不满足题意</span><br>&#125;<br><span class="hljs-keyword">return</span> l;  <span class="hljs-comment">// 根据题意进行调整</span><br></code></pre></td></tr></table></figure><blockquote><p>关于开区间，由于最终<code>l</code>和<code>r</code>一定会停在相邻的位置，左边是<code>l</code>，右边是<code>r</code>。<br>最终返回的答案，不论使用的是<code>l</code>还是<code>r</code>，只要作为答案的指针能够在整个答案的闭区间内移动即可。<br>比如：<br>最终答案返回<code>r</code>，<code>r</code>的初始值可以是<code>max</code>，而不用取外侧的<code>max + 1</code>，因为最终<code>r</code>可以取到<code>max</code>；但<code>l</code>必须取到<code>min - 1</code>，因为最终答案有可能是<code>min</code>，而<code>l</code>如果占到<code>min</code>，则会出现<code>r</code>取不到最终答案的情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找（唯一值）</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在 n 个元素有序的（升序）整型数组 nums 中查找目标值 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li><strong>数组为有序数组</strong></li><li><strong>数组中无重复元素</strong><br>一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的</li></ul><p>根据<strong>循环不变量</strong>规则，二分查找的过程中，想清楚区间的定义，区间的定义就是不变量，保持不变量，在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分区间的定义一般为两种，左闭右闭[left, right]，或者左闭右开[left, right)。</p><h1 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h1><ul><li>左闭右开，左初始边界 <code>left = 0</code>，右初始边界 <code>right = nums.size()</code></li><li><code>while(left &lt; right)</code>，因为左闭右开，右边取不到，left &#x3D;&#x3D; right 没有意义</li><li><code>right</code> 更新为 <code>mid</code>，因为当前 <code>target&lt;nums[mid]</code>，下一个区间不会再去比较 nums[mid]，target 一定在 mid 左边，又因为右开取不到右区间，所以 right 更新为 mid</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为 <code>target&gt;nums[mid]</code>，target 一定在 mid 右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;  <br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size();  <br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;  <br>        <span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  //防止溢出<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h1><ul><li>左闭右闭，左初始边界 <code>left = 0</code>，右初始边界 <code>right = nums.size() - 1</code></li><li><code>while(left &lt;= right)</code>，因为左闭右闭，left &#x3D;&#x3D; right 有意义可以取到</li><li><code>right</code> 更新为 <code>mid - 1</code>，因为当前 <code>target&lt;nums[mid]</code>，target 一定在 mid 左边，又因为右闭可以取到，所以 right 更新为 mid - 1</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为 <code>target&gt;nums[mid]</code>，target 一定在 mid 右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;<br><span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br><span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h1><p>字节：数据类型占用的空间大小  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a; <span class="hljs-comment">// 整数类型 4字节  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l; <span class="hljs-comment">// 长整数类型 8字节  </span><br><span class="hljs-type">char</span> c; <span class="hljs-comment">// 字符类型 1字节  </span><br><span class="hljs-type">double</span> d; <span class="hljs-comment">// 浮点数类型 8字节  </span><br></code></pre></td></tr></table></figure><h1 id="2-基本运算"><a href="#2-基本运算" class="headerlink" title="2 基本运算"></a>2 基本运算</h1><p><code>+ - * /</code><br>对于 <code>/</code> 除： 整数&#x2F;整数 &#x3D; 整数 10 &#x2F; 3 &#x3D; 3 如果其中有浮点数，则结果有小数，如 10 &#x2F; 3.0 &#x3D; 3.3333    <code>%</code> 取余，如 10 % 3 &#x3D; 1 15 % 4 &#x3D;3<br><strong>类型自动转换</strong>：在运算过程中，如果数据类型不一致，自动将低精度转化为高精度<br><code>char &lt; int &lt; long long &lt; double</code>  </p><h1 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3 输入输出"></a>3 输入输出</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; a;  <span class="hljs-comment">// 输入  </span><br>cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// 输出 endl 换行  </span><br><span class="hljs-comment">// 格式化输出  </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a的值为%d&quot;</span>, a); <span class="hljs-comment">// %d叫做占位符  </span><br><span class="hljs-comment">// %d 整数 %c 字符 %f 浮点数  </span><br></code></pre></td></tr></table></figure><h1 id="4-分支结构"><a href="#4-分支结构" class="headerlink" title="4 分支结构"></a>4 分支结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>) &#123;  <br>代码块<span class="hljs-number">1</span>  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>) &#123;  <br>代码块<span class="hljs-number">2</span>  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>代码块<span class="hljs-number">3</span>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>如果条件1成立则执行代码块1，否则如果条件2成立则执行代码块2，如果前面都不成立，则执行代码块3<br><strong>注意</strong>：任何一个条件成立就停止判断<br>条件里可以用什么运算？  </p><ul><li>关系运算符 <code>==  !=  &gt;=  &lt;=  &gt;  &lt;</code></li><li>逻辑运算符 <code>&amp;&amp;</code>且（两个都满足才满足）  <code>||</code>或（只要一个满足就满足）  <code>!</code>非（相反）</li></ul><h1 id="5-循环结构"><a href="#5-循环结构" class="headerlink" title="5 循环结构"></a>5 循环结构</h1><p><code>for</code> 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(初始化; 条件; 步长) &#123;<br>循环体;<br>&#125;<br><span class="hljs-comment">//第一次循环先执行初始化语句，之后判断是否满足条件，满足则进入循环执行循环体，不满足则跳出循环，执行循环体之后执行步长语句</span><br></code></pre></td></tr></table></figure><p>常见的两种n遍循环的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从0开始，到 &lt; n，取不到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>&#125;<br><span class="hljs-comment">// 从1开始，到 &lt;= n,能取到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(条件) &#123;<br>循环体;<br>&#125;<br><span class="hljs-comment">// 条件满足则进入循环体，不满足则跳出</span><br></code></pre></td></tr></table></figure><p><code>do-while</code>循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>循环体;<br>&#125; <span class="hljs-keyword">while</span>(条件);<br><span class="hljs-comment">// 不管是否满足条件，至少先执行一次循环体，然后再判断条件，决定是否继续循环</span><br></code></pre></td></tr></table></figure><p>三种循环通用：</p><ul><li><code>break</code>：终止当前的循环</li><li><code>continue</code>：跳过本轮循环</li></ul><h1 id="6-数组"><a href="#6-数组" class="headerlink" title="6 数组"></a>6 数组</h1><p>需要存储很多相同类型的变量，可以使用数组。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[数组长度];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-type">double</span> d[<span class="hljs-number">10000</span>];<br></code></pre></td></tr></table></figure><blockquote><p>数组访问通过下标（索引）完成，下标从0开始，不能越界。</p></blockquote><p>数组的遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维数组</strong><br>可以理解为数组里面的元素还是一个数组，或者理解为一个矩阵，里面都是相同类型的元素。<br>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[行数][列数]; <span class="hljs-comment">// 先行后列</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/Pasted%20image%2020250612193944.png"></p><p>对于二维数组的访问，也是通过下标，先行后列。<br>二维数组遍历，借助循环嵌套完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n行m列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>cin &gt;&gt; a[i][j];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 内层循环整个结束之后，外层循环才会执行一次</span><br></code></pre></td></tr></table></figure><h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h1><p>把常用功能进行封装，把相同的功能提取出来，不同的地方作为参数。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回值类型 函数名(参数<span class="hljs-number">1</span>类型 参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>类型 参数<span class="hljs-number">2</span>) &#123;<br>函数体;<br>返回;<br>&#125;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 在主函数调用自定义函数</span><br><span class="hljs-type">int</span> max_num = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h1><p>把不同类型的变量封装成一个自定义类型，就叫结构体。<br>比如自己创造一个学生类型。<br>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> 结构体类型名 &#123;<br>类型<span class="hljs-number">1</span> 变量<span class="hljs-number">1</span>;<br>类型<span class="hljs-number">2</span> 变量<span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码写完，是我们自己创造了一个类型为<code>student</code>的数据类型，但还没有创建变量，格式和正常的<code>int</code>一样，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stu中包括name和age</span><br>student stu;<br><span class="hljs-comment">// 也可以创建数组，数组中的每一个元素都是一个结构体</span><br>student s[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>创建结构体变量还有一种简便方法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125; stu;<br></code></pre></td></tr></table></figure><p>结构体成员的访问：<br>使用<code>.</code>来访问结构体变量里面的成员，对于每个成员都像一个普通变量一样使用，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; stu.name &gt;&gt; stu.age;<br><span class="hljs-comment">// 结构体数组使用如下</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; s[i].name &gt;&gt; s[i].age;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器填充函数</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-fill-按元素填充"><a href="#1-fill-按元素填充" class="headerlink" title="1 fill() 按元素填充"></a>1 fill() 按元素填充</h1><ul><li>用于将容器或数组的指定范围内的元素赋值为指定值（按元素类型填充）。</li><li>属于 C++ STL 算法（<code>&lt;algorithm&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址到结束地址的下一位置全部赋为目标值</span><br><span class="hljs-built_in">fill</span>(起始地址, 结束地址下一位, 值);<br><br><span class="hljs-built_in">fill</span>(a, a + n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 一维数组</span><br><span class="hljs-built_in">fill</span>(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>] + n * n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 二维数组</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 动态数组</span><br></code></pre></td></tr></table></figure><h1 id="2-memset-按字节填充"><a href="#2-memset-按字节填充" class="headerlink" title="2 memset() 按字节填充"></a>2 memset() 按字节填充</h1><ul><li>用于将一块内存的每个字节设置为指定的值（按字节填充）。</li><li>属于 C 标准库函数（<code>&lt;cstring&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址将要填充的字节数都填充为目标值</span><br><span class="hljs-built_in">memset</span>(起始地址, 值， 要填充的字节数);<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-comment">// 所有元素初始化为0</span><br><br><span class="hljs-type">char</span> c[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(c, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-built_in">sizeof</span>(c));  <span class="hljs-comment">// 所有元素初始化为A</span><br></code></pre></td></tr></table></figure><blockquote><p>不能直接用于非字节类型，比如 <code>int a[5]; memset(a, 1, sizeof(a));</code> 并不会将每个 <code>int</code> 设为 <code>1</code>，而是每个字节设为 <code>0x01</code>，导致每个 <code>int</code> 的实际值为 <code>0x01010101</code>（16843009）。</p></blockquote><h1 id="3-对比"><a href="#3-对比" class="headerlink" title="3 对比"></a>3 对比</h1><table><thead><tr><th>特性</th><th><code>memset</code></th><th><code>fill</code></th></tr></thead><tbody><tr><td><strong>填充单位</strong></td><td>字节</td><td>元素</td></tr><tr><td><strong>头文件</strong></td><td><code>&lt;cstring&gt;</code></td><td><code>&lt;algorithm&gt;</code></td></tr><tr><td><strong>效率</strong></td><td>极高（硬件优化）</td><td>较高（通用循环赋值）</td></tr><tr><td><strong>适用类型</strong></td><td><code>char</code>、内存块</td><td>任意类型（如 <code>int</code>、<code>double</code>）</td></tr><tr><td><strong>安全性</strong></td><td>低（易误用导致数据错误）</td><td>高（类型安全）</td></tr><tr><td><strong>典型用途</strong></td><td>清零内存、初始化字符数组</td><td>初始化 STL 容器、非字节类型数组</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>广度优先搜索</strong>（Breadth First Search)：英文缩写为（BFS），是一种用于搜索树或图的算法。从起始节点开始逐层扩展搜索，直到达到目标节点。它以广度的方式探索图中的节点，即先访问离起始节点最近的节点，然后逐渐扩展到距离更远的节点。</p><p>广度优先搜索的实现：</p><ol><li>将起始节点放入队列中，并将其标记为已访问。</li><li>从队首取出一个节点作为当前节点。</li><li>遍历当前节点的所有邻居节点：如果邻居节点没有被访问过，则将其放入队列中并标记为已访问。</li><li>重复步骤2和3，直到队列为空或找到目标节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br>step step[N][N];  <span class="hljs-comment">// 记录到达某点的最短步数</span><br>queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">// 辅助广搜的队列</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 步数初始化为-1，在记录步数的同时也可以记录哪些点走过</span><br><span class="hljs-built_in">fill</span>(step[<span class="hljs-number">0</span>], step[<span class="hljs-number">0</span>] + N * N, <span class="hljs-number">-1</span>)<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">bfs</span>(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy) &#123;<br>q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);  <span class="hljs-comment">// 起始节点入队</span><br>step[sx][sy] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点设为0步，也可能是1步，并且达到了标记已访问的作用</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 队列不为空，就要继续搜</span><br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;  <span class="hljs-comment">// 当前节点的x坐标</span><br><span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;  <span class="hljs-comment">// 当前节点的y坐标</span><br>q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 取出当前节点</span><br><br><span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br><span class="hljs-comment">// 遇到终点做一些事情，比如最短步数、判断能否到达终点</span><br><span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 结束</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br><span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br><span class="hljs-comment">// 如果下一个点越界了 不能走</span><br><span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br><span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br><span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || step[nx][ny] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <br>q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);  <span class="hljs-comment">// 能走的点就入队</span><br><span class="hljs-comment">// 走到下一个点的步数等于这个点的步数+1</span><br>step[nx][ny] = step[x][y] + <span class="hljs-number">1</span>;  <br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特别注意：要在<strong>入队时就对节点进行标记</strong>，如果在出队时标记，两个点都指向某个未访问的节点时，它会被<strong>重复入队</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>深度优先搜索算法</strong>（Depth First Search）：英文缩写为 DFS，是一种用于搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。深度优先搜索采用了回溯思想，该算法沿着树的深度遍历树的节点，会尽可能深的搜索树的分支。</p><ul><li>回溯：会搜出每一种可能的路线（求路径，通常N&lt;20）</li><li>不回溯：会搜出每一个能走的点（求能否到达）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br><span class="hljs-type">bool</span> mp[N][N];  <span class="hljs-comment">// 到过位置的标记</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;  <span class="hljs-comment">// 当前访问的点是(x, y)</span><br><span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br><span class="hljs-comment">// 遇到终点做一些事情，比如打印路径、路径数、判断能否到达终点</span><br><span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 返回</span><br>&#125;<br><br>vis[x][y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记此点被访问</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;  <span class="hljs-comment">// 分别搜索四个方向</span><br><span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br><span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br><span class="hljs-comment">// 如果下一个点越界了 不能走</span><br><span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br><span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br><span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || vis[nx][ny]) <span class="hljs-keyword">continue</span>; <br><span class="hljs-built_in">dfs</span>(nx, ny);  <span class="hljs-comment">// 开始搜索下一个合法的节点</span><br>&#125;<br><span class="hljs-comment">// 这个点的上下左右都搜完了，回溯到上一个节点，此点标记为未访问</span><br>vis[x][y] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 根据需求选择是否要回溯</span><br><span class="hljs-comment">// 回溯 会搜出每一种可能的路线</span><br><span class="hljs-comment">// 不回溯 会搜出每一个能走的点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录路径</span><br><span class="hljs-type">int</span> path[N * N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pathsize;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> 终点 &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pathsize; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)-&gt;&quot;</span>, path[i][<span class="hljs-number">0</span>], path[i][<span class="hljs-number">1</span>]);<br>&#125;<br>cout &lt;&lt; 终点 &lt;&lt; endl;<br>&#125;<br><br>vis[x][y] = <span class="hljs-literal">true</span>;<br>path[pathsize][<span class="hljs-number">0</span>] = x;  <span class="hljs-comment">// 添加路径</span><br>path[pathsize++][<span class="hljs-number">1</span>] = y;<br><br><span class="hljs-keyword">for</span>() 搜索下一个点<br><br>vis[x][y] = <span class="hljs-literal">false</span>;<br>pathsize--;  <span class="hljs-comment">// 删除路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于连通块问题，可以在main函数中遍历地图，遇到能构成连通块的符号即可进入dfs，对于进入dfs的点，将其设置为不可构成连通块的符号，并不断搜索其周边连通的符号。在main函数中每次进入dfs相当于遇到一个新的连通块并标记，可以进行计数。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-图的概念"><a href="#1-图的概念" class="headerlink" title="1 图的概念"></a>1 图的概念</h1><p>图是一种由<strong>结点</strong>和<strong>边</strong>组成的数据结构，其中结点表示图中的<strong>对象</strong>，边表示这些对象之间的<strong>关系</strong>。</p><ul><li>结点(Vertex)：也称为顶点，是图中的基本单元，表示一个实体或一个抽象概念。</li><li>边(Edge)：结点之间的连线，表示结点之间的关系。</li></ul><hr><ul><li>无向图：由没有方向的边组成的图，也称为无向网络或无向图形。<ul><li>无向边表示两个结点之间的双向关系。</li></ul></li><li>有向图：由有方向的边组成的图，也称为有向网络或有向图形。<ul><li>有向边从一个结点指向另一个结点，表示一个方向的关系。</li><li>在有向图中结点也称为起点或终点。</li></ul></li><li>带权图：边上带有权值的图。<ul><li>权值：可以形象地理解为通过这条边的花费的时间、距离、金额等等。</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717153210%201.png"></p><hr><ul><li>无向完全图：图中任意两个顶点之间都存在边。<ul><li>一个 n 阶的完全无向图含有n ×（n－1) &#x2F; 2 条边</li></ul></li><li>有向完全图：图中任意两个顶点之间都存在方向相反的两条边。<ul><li>一个 n 阶的完全有向图含有n ×（n－1）条边</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717155915%201.png"></p><hr><ul><li>自环：一个结点连接到自身的边</li><li>重边：两个结点之间存在多条边</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717153349%201.png"></p><ul><li>简单图(Simple Graph)：一种无向图或有向图，其中不存在自环和重边。</li><li>多重图(Multigraph)：一种有向图或无向图，其中存在自环或重边。</li></ul><hr><ul><li>稀疏图：图中的边很少，边之间的连接相对稀疏。</li><li>稠密图：图中的边很多，边之间的连接非常密集。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717160209%201.png"></p><h1 id="2-图的简单性质"><a href="#2-图的简单性质" class="headerlink" title="2 图的简单性质"></a>2 图的简单性质</h1><h2 id="2-1-度数"><a href="#2-1-度数" class="headerlink" title="2.1 度数"></a>2.1 度数</h2><p>度数：指与一个结点相连的边的数量。</p><ul><li>在无向图中，一个结点的度数就是它的连接数。</li><li>在有向图中，一个结点的入度是指指向该结点的边的数量，出度是指从该结点出发的边的数量。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717160748%201.png"></p><h2 id="2-2-路径"><a href="#2-2-路径" class="headerlink" title="2.2 路径"></a>2.2 路径</h2><ul><li>路径：指从一个结点到另一个结点的连续边构成的序列，路径的长度是指该路径中边的数量。如果两个结点之间存在路径，则这两个结点是连通的。</li><li>简单路径：指从一个结点到另一个结点的连续边构成的序列，序列中的结点不可以重复，即同一条边最多经过一次。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161538%201.png"></p><ul><li>环路：一个路径，它的起点和终点相同，且路径上的每个结点可以重复，即同一条边可以多次经过。</li><li>简单环路：一个路径，它的起点和终点相同，且路径上的每个结点都不重复（除了起点和终点，即同一条边不可以多次经过）。一个图如果不包括任何环它就是无环图。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161242%201.png"></p><h2 id="2-3-连通性"><a href="#2-3-连通性" class="headerlink" title="2.3 连通性"></a>2.3 连通性</h2><ul><li>连通性：如果对于任意两个结点之间都存在路径，这个图是连通的。如果一个图不是连通的，则可以分为多个连通分量。</li><li>对于有向图，存在强连通和弱连通之分：<ul><li>强连通：任意两个结点 u 和 v 之间存在一条从 u 到 v 的有向路径，同时存在一条从 v 到 u 的有向路径。</li><li>弱连通：将有向图中的所有边都看作无向边后得到的连通图。</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161902%201.png"></p><ul><li>连通分量：一个无向图的极大连通子图<ul><li>首先，它是这个无向图的一个连通子图(保证了连通)</li><li>其次，它不是这个无向图的其他连通子图的子图 (保证了极大)</li></ul></li><li>强连通分量：一个有向图的极大强连通子图</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162039%201.png"></p><h1 id="3-图的存储"><a href="#3-图的存储" class="headerlink" title="3 图的存储"></a>3 图的存储</h1><h2 id="3-1-邻接矩阵"><a href="#3-1-邻接矩阵" class="headerlink" title="3.1 邻接矩阵"></a>3.1 邻接矩阵</h2><p>邻接矩阵：一种二维数组其中每个元素表示两个结点之间的边。</p><h3 id="3-1-1-无向图"><a href="#3-1-1-无向图" class="headerlink" title="3.1.1 无向图"></a>3.1.1 无向图</h3><p>无向图的邻接矩阵存储：如果两个结点之间存在边，则数组中对应的元素为1，否则为 0。</p><p>在无向图中，邻接矩阵是一个对称矩阵，且主对角线一定为0。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162713%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 是否相连</span><br>mp[x][y］= mp[y][x] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="3-1-2-有向图"><a href="#3-1-2-有向图" class="headerlink" title="3.1.2 有向图"></a>3.1.2 有向图</h3><p>有向图的邻接矩阵存储：如果结点 x 有一条指向结点 y 的边，那么 mp[x][y] 就标记为 1。</p><p>与无向图不同，有向图不一定满足<code> mp[x][y］= mp[y][x]</code></p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162954%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 是否指向 结点 y</span><br>mp[x][y] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="3-1-3-带权图"><a href="#3-1-3-带权图" class="headerlink" title="3.1.3 带权图"></a>3.1.3 带权图</h3><p>带权图的邻接矩阵存储：<code>mp[x][y]</code> 表示结点 x 到结点 y 边的权值。</p><p>在边不存在的情况下，会适当地取较大的常数，与普通权值进行区分。<br>带权图输入<strong>注意重边！注意重边！注意重边！</strong></p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717163306%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 之间的权值</span><br>mp[x][y] = len;<br></code></pre></td></tr></table></figure><ul><li>邻接矩阵的优点：查询两个结点之间是否存在边的时间复杂度为O(1)，适用于稠密图。</li><li>邻接矩阵的缺点：占用空间较大，尤其是对于稀疏图时，浪费大量的空间。</li></ul><h2 id="3-2-边集数组"><a href="#3-2-边集数组" class="headerlink" title="3.2 边集数组"></a>3.2 边集数组</h2><h2 id="3-3-邻接表"><a href="#3-3-邻接表" class="headerlink" title="3.3 邻接表"></a>3.3 邻接表</h2><h1 id="4-特殊图"><a href="#4-特殊图" class="headerlink" title="4 特殊图"></a>4 特殊图</h1><h2 id="4-1-欧拉路与欧拉回路"><a href="#4-1-欧拉路与欧拉回路" class="headerlink" title="4.1 欧拉路与欧拉回路"></a>4.1 欧拉路与欧拉回路</h2><ul><li>欧拉路：是一种在图中经过每条边恰好一次的路径，但<strong>不要求回到起点</strong>。</li><li>欧拉回路：是一种从起点开始、经过所有边恰好一次、最终<strong>回到起点</strong>的回路。</li></ul><p>欧拉图：存在一条路径可以经过图上所有边恰好一次，并且最终回到起点的图。也就是说，如果一个图存在欧拉回路，那么这个图就是<strong>欧拉图</strong>。</p><ul><li><p>欧拉图&#x2F;欧拉回路的判断：</p><ul><li>无向图：所有顶点的度数必须都是偶数</li><li>有向图：所有顶点的度数必须都是偶数，并且入度和出度必须相等</li></ul></li><li><p>欧拉路的判断：</p><ul><li>无向图：恰好有两个顶点的度数是奇数，其余顶点的度数都是偶数</li><li>有向图：至多一个顶点的出度与入度之差为1，至多一个顶点的入度与出度之差为1，其他顶点的入度和出度相等</li></ul></li></ul><p>如果一个图不存在欧拉路，则称该图是<strong>非欧拉图</strong>。</p><h2 id="4-2-负权回路"><a href="#4-2-负权回路" class="headerlink" title="4.2 负权回路"></a>4.2 负权回路</h2><p>如果存在一个环，而这个环上所有权值之和是负数，那这就是个<strong>负权环</strong>，也叫<strong>负权回路</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1 Dijkstra 算法"></a>1 Dijkstra 算法</h1><p>Dijkstra（迪杰斯特拉）算法适用于<strong>单源最短路径</strong>问题，即从一个起点出发，计算到所有其他点的最短路径。它只能用于<strong>边权非负</strong>的图（所有边的权重 ≥ 0），无法解決<strong>带负权的图</strong>的最短路问题。</p><p>Dijkstra 算法的核心思想是<strong>贪心算法</strong>，将所有节点分为<strong>已确定</strong>最短路径的节点和<strong>未确定</strong>最短路径的节点:</p><ol><li>初始时，将所有顶点的最短距离设为∞，源点的距离设为0</li><li>每次从未确定节点中选择距离最小的节点，作为当前节点，将其标记为已确定</li><li>遍历当前节点的所有邻居，更新该节点的所有邻居节点的距离（<strong>松弛</strong>操作）</li><li>重复上述过程，直到所有节点都被加入已确定集合</li></ol><blockquote><p>“松弛”就是检查当前路径是否更短，如果是，就更新最短距离。</p></blockquote><ul><li>邻接矩阵+迭代</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点 边 起始点 图 距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">// 未确定节点的距离设为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始节点距离设为0</span><br><br><span class="hljs-comment">// 一次确定一个节点的最短路，n个节点需要n次循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;  <span class="hljs-comment">// id标记当前节点，初始化为0，距离为无穷大</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <span class="hljs-comment">// 在未确定节点中寻找距离最小的节点</span><br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; dis[id]) id = j;  <br>  <br>        vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 将当前节点标记为已确定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <br>        <span class="hljs-comment">// 松弛，当前节点的邻居，从当前节点出发路径更短</span><br>            <span class="hljs-keyword">if</span> (mp[id][j] != INT_MAX &amp;&amp; dis[id] + mp[id][j] &lt; dis[j])  <br>                dis[j] = dis[id] + mp[id][j];  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归实现（数据稍大会栈溢出）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点  边  起始点  图  距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 当前节点</span><br>    <span class="hljs-type">int</span> mini = INT_MAX, ni = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未确定节点中的最短距离和节点编号</span><br>    vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为已确定</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-keyword">if</span>(!vis[i]) &#123;  <span class="hljs-comment">// 遍历还未确定的节点</span><br>        <span class="hljs-comment">// 当前节点能访问到的邻居 并且 从当前节点出发的路径更短</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != INT_MAX &amp;&amp; dis[id] + mp[id][i] &lt; dis[i])  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>            <span class="hljs-comment">// 在所有还未确定的节点中寻距离最短的</span><br>            <span class="hljs-keyword">if</span>(dis[i] &lt; mini) &#123; <br>                mini = dis[i];  <span class="hljs-comment">// 更新最短距离</span><br>                ni = i;  <span class="hljs-comment">// 更新节点编号</span><br>            &#125;  <br>        &#125;    <br>&#125;  <br><span class="hljs-comment">// 如果找到了未确定节点中的最短距离节点，作为当前节点传入dij</span><br><span class="hljs-keyword">if</span>(ni != <span class="hljs-number">-1</span>) <span class="hljs-built_in">dij</span>(ni);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;  <br>    <span class="hljs-built_in">fill</span>(mp[<span class="hljs-number">0</span>], mp[<span class="hljs-number">0</span>] + N * N, INT_MAX);  <span class="hljs-comment">// 边初始化为无穷大</span><br>    <span class="hljs-keyword">while</span>(m--) &#123;  <br>        <span class="hljs-type">int</span> u, v, w;  <br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  <br>        mp[u][v] = <span class="hljs-built_in">min</span>(mp[u][v], w);  <span class="hljs-comment">// 处理重边  </span><br>    &#125;  <br>  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">//  距离初始化为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//  起始点距离初始化为0</span><br>    <span class="hljs-built_in">dij</span>(s);  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <br>        <span class="hljs-keyword">if</span>(dis[i] != INT_MAX) cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Bellman-Ford-算法"><a href="#2-Bellman-Ford-算法" class="headerlink" title="2 Bellman-Ford 算法"></a>2 Bellman-Ford 算法</h1><p>Bellman-Ford（贝尔曼-福特）算法是用于解决<strong>单源最短路径</strong>问题的经典算法，它可以处理图中包含负权边的情况，并能检测出图中是否存在负环。</p><p>Bellman-Ford算法的核心是“<strong>不断松弛边</strong>”。对所有边进行 <code>n - 1</code> 次松弛（n为顶点个数），之后再跑一次检测负环。</p><ol><li>初始化：将所有顶点的最短距离估计值设为∞，源点的距离设为0</li><li>松弛操作：重复 n-1 次松弛，每次遍历所有边，对每条边进行松弛操作</li><li>检查负环：再进行一次松弛操作，如果还能更新则说明存在负环</li></ol><blockquote><p>为什么进行 n-1 次松弛，因为进行一次 Bellman-Ford，距离起点一条边的点的最短路确定， 进行两次，距离起点两条边的点的最短路确定， 总共n个点，最短路最多经过 n-1 条边，所以进行 n-1 次松弛即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N];  <span class="hljs-comment">// 节点数 边数 起始点 目标点 距离</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> u;  <br>    <span class="hljs-type">int</span> v;  <br>    <span class="hljs-type">int</span> w;  <br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight) : <span class="hljs-built_in">u</span>(from), <span class="hljs-built_in">v</span>(to), <span class="hljs-built_in">w</span>(weight) &#123;&#125;  <br>&#125;;  <br>vector&lt;Edge&gt; egs;   <span class="hljs-comment">// 使用边集数组进行存储，方便对每一条</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bf</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-comment">// 除起始点之外的距离设为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// n-1 次操作，每次确定距离为 i 的节点最短路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;  <span class="hljs-comment">// 每次操作对所有边进行</span><br>        <span class="hljs-comment">// 当前边的起始点 当前边的到达点 当前边的权值</span><br>            <span class="hljs-type">int</span> from = egs[j].u, to = egs[j].v, weight = egs[j].w;  <br>            <span class="hljs-keyword">if</span>(dis[from] + weight &lt; dis[to])  <span class="hljs-comment">// 松弛操作</span><br>                dis[to] = dis[from] + weight;  <br>        &#125;  <br>    &#125;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;  <br>    egs.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 占位 vector 的 0 号位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        <span class="hljs-type">int</span> x, y, z;  <br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;  <br>        <span class="hljs-comment">// 直接将 Edge(x,y,z) push_back 进 vector</span><br>        egs.<span class="hljs-built_in">emplace_back</span>(x, y, z);  <br>    &#125;  <br>  <br>    <span class="hljs-built_in">bf</span>();  <br>  <br>    cout &lt;&lt; dis[t];  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-SPFA-算法"><a href="#3-SPFA-算法" class="headerlink" title="3 SPFA 算法"></a>3 SPFA 算法</h1><p>SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的队列优化版本，用于求<strong>单源最短路径</strong>，减少了不必要的冗余运算，同样可以处理存在负权边的情况。</p><p>与 Bellman-Ford 每次都遍历所有边不同，SPFA 利用队列优化了 Bellman-Ford 算法中不必要的松弛操作，只对发生了松弛操作的结点的邻接结点进行松弛。</p><ol><li>初始化所有节点到起始点的距离为 ∞，源点为 0</li><li>将源点入队，并标记为在队列中</li><li>当队列不为空时：<ul><li>取出队首节点作为当前节点，弹出并标记为不在队列中</li><li>遍历从当前节点的所有临接边，尝试松弛操作</li><li>如果松弛成功，判断这个邻居节点是否在队列中，如果不在则入队</li></ul></li><li>重复以上操作直到队列为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N], mp[N][N];  <span class="hljs-comment">// 节点 边 源点 终点 距离 图 </span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// 辅助队列</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 标记节点是否在队列</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-comment">// 除源点外的其他节点距离初始化为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 源点入队</span><br>    vis[s] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 并把源点标记为在队列</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <br>        <span class="hljs-type">int</span> id = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>        q.<span class="hljs-built_in">pop</span>();  <br>        vis[id] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为不在队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 遍历所有邻居节点</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != <span class="hljs-number">1e9</span> &amp;&amp; dis[id] + mp[id][i] &lt; dis[i]) &#123;  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>                <span class="hljs-comment">// 如果不在队列则入队，并标记为在队列</span><br>                <span class="hljs-keyword">if</span>(!vis[i]) &#123; <br>                    q.<span class="hljs-built_in">push</span>(i);  <br>                    vis[i] = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125;       <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SPFA 每轮更新中将“更近一层”的节点的最短路径传递出去，这个过程和 BFS 逐层访问节点的方式有点相似。</p></blockquote><h1 id="4-Floyd-算法"><a href="#4-Floyd-算法" class="headerlink" title="4 Floyd 算法"></a>4 Floyd 算法</h1>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1 树的概念"></a>1 树的概念</h1><p>树作为一种非线性的数据结构，是由$n(n ≥ 0)$个结点组成的有限集合。<br>如果 $n &#x3D; 0$ 称为空树，如果 $n &gt; 0$，树有且仅有一个特定的结点——根结点。<br>除根结点外的其他结点划分为互不相交的有限集，每个集合又是一棵树，称为根结点的子树。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718155005%201.png"></p><hr><ul><li>树的度：结点拥有的子树的数量为结点的度，树的度定义为树的所有结点中度的最大值。</li><li>度为 0 的结点为<strong>叶子结点</strong>，度不为 0 的结点为分支结点。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718155659%201.png"></p><hr><p>树的前驱和后继：</p><ul><li>除根结点没有前驱外，其余每个结点都有唯一的一个<strong>前驱结点</strong>。</li><li>除叶子结点没有后继外，每个结点都可以有多个<strong>后继结点</strong>。</li><li>结点的直接后继称为结点的<strong>孩子</strong>，结点的直接前驱称为结点的<strong>父亲</strong>，同一个双亲的不同结点互称<strong>兄弟</strong>。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718160119%201.png"></p><hr><p>树中结点的层次：树中根结点为第 1 层，根结点的孩子为第2层，依次类推。<br>树的深度（高度）：树中结点的最大层次。（部分题目中根结点为第 0 层）</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718160402%201.png"></p><hr><ul><li>$n$ 个结点的树，有且仅有 $n－1$  条边</li><li>树中任意两个结点之间有且仅有一条简单路径（路径上的结点都不相同的路径）</li></ul><h1 id="2-树的存储"><a href="#2-树的存储" class="headerlink" title="2 树的存储"></a>2 树的存储</h1><h2 id="2-1-双亲表示法"><a href="#2-1-双亲表示法" class="headerlink" title="2.1 双亲表示法"></a>2.1 双亲表示法</h2><p>对父节点进行存储</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718161156%201.png"></p><p>第一行一个整数 $n$，表示结点个数<br>第二行 $n－1$ 个数，第 $i$ 个数是结点 $i + 1$ 的父节点编号（第 1 个数的值是 2 号结点的父结点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, tree[N];<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) cin &gt;&gt; tree[i];<br></code></pre></td></tr></table></figure><h2 id="2-2-孩子表示法"><a href="#2-2-孩子表示法" class="headerlink" title="2.2 孩子表示法"></a>2.2 孩子表示法</h2><p>对孩子节点进行存储</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718161351%201.png"></p><p>第一行一个整数 $n$，表示结点个数<br>第二行 $n－1$ 个数，第 $i$ 个数是结点 $i + 1$ 的父节点编号（第 1 个数的值是 2 号结点的父结点）</p><p>使用 <code>vector</code> 存储每一个结点的所有孩子，因此<code>tree[i]</code> 里存储的是 i 结点的所有孩子结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>tree[x].<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3 二叉树"></a>3 二叉树</h1><h2 id="3-1-二叉树的概念"><a href="#3-1-二叉树的概念" class="headerlink" title="3.1 二叉树的概念"></a>3.1 二叉树的概念</h2><p>二叉树（Binary Tree，简称BT）是一种度数 <strong>最大为 2</strong> 的树，即二叉树的每个结点<strong>最多</strong>有两个子结点。每个结点的子结点分别称为左孩子、右孩子，它的两棵子树称为左子树、右子树。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718162657%201.png"></p><hr><p>一棵深度为 $k$ 且有 $2^k－1$ 个结点的二叉树称为<strong>满二叉树</strong>。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718165447%201.png"></p><hr><p>若二叉树的高度为 $k$，除第 $k$ 层外，其它各层 $1～k－1$的结点数都达到<strong>最大个数</strong>，且第 $k$ 层缺少的结点是从右到左并连续的，这就是<strong>完全二叉树</strong>。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718165830%201.png"></p><h2 id="3-2-二叉树的性质"><a href="#3-2-二叉树的性质" class="headerlink" title="3.2 二叉树的性质"></a>3.2 二叉树的性质</h2><ul><li><strong>「性质一」</strong> 在二叉树的第 $i$ 层上最多有$2^{i-1}$个结点（i &gt;&#x3D;1）。第 1 层最多 1 个结点，第 2 层最多 2个结点，第 3 层最多 4 个结点。（像二进制位权）</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718163730%201.png"></p><ul><li><strong>「性质二」</strong> 深度为 $k$ 的二叉树至多有 $2^k-1$ 个结点（$k &gt;&#x3D;1$)（像二进制全 1 的情况）</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718163900%201.png"></p><ul><li><strong>「性质三」</strong> 对任意一棵二叉树，如果其叶子结点的数量为 $n_0$，度为 $2$ 的结点数为 $n_2$，则一定满足$n_0 &#x3D; n_2 + 1$。</li></ul><blockquote><p>证明：<br>结点总数 $n$ 等于 $0$  度结点 $n_0$、$1$ 度结点 $n_1$，$2$  度结点 $n_2$ 之和。即 $\textcolor{red}{n &#x3D; n_0 + n_1 + n_2}$  (式子1)<br>1 度结点有 1 个孩子，2 度结点有 2 个孩子，树中只有根结点不是任何结点的孩子，故二叉树中结点总数又可以表示为 $\textcolor{red}{n &#x3D; n_1 + 2n_2 + 1}$ (式子2)<br>由式子1和式子2得到 $\textcolor{red}{n_0 &#x3D; n_2 + 1}$。</p></blockquote><ul><li><strong>「性质四」</strong> 具有 $n(n≥0)$ 个结点的完全二叉树的深度为 $\lfloor log_2n \rfloor+1$。（$\lfloor \rfloor$表示下取整）<ul><li>其实就是最多把最后一层填满，为$2^k-1$，对于61来说，不足64，$2^6&#x3D;64$，6层就够了。</li></ul></li></ul><blockquote><p>证明：<br>深度为 $k$ 的完全二叉树，前面 $k－1$ 层一定是满的，所以 $n &gt; 2^{k-1}－ 1$，同时 $n ≤ 2^k-1$，得到 $\textcolor{red}{2^{k-1}－ 1 &lt; n ≤ 2^k－1}$，所以 $k&#x3D; \lfloor log_2n \rfloor+1$。</p></blockquote><ul><li><strong>「性质五」</strong> 如将一棵有 $n$ 个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号 1，2，…，n，则有以下关系：<ul><li>若 $i&#x3D;1$，则结点 $i$ 为根，无父结点</li><li>若 $i&gt;1$，则 $i$ 的父结点编号为 $\lfloor i&#x2F;2 \rfloor$</li><li>若 $2 × i &gt; n$，则 $i$ 无左孩子，否则其左孩子编号为 $2×i$</li><li>若 $2×i+1&gt;n$，则 $i$ 无右孩子，否则其右孩子编号为$２×ｉ+ 1$</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718174304%201.png"></p><h1 id="4-二叉树遍历"><a href="#4-二叉树遍历" class="headerlink" title="4 二叉树遍历"></a>4 二叉树遍历</h1><p>先中后由<strong>根的位置决定</strong></p><h2 id="4-1-先序遍历"><a href="#4-1-先序遍历" class="headerlink" title="4.1 先序遍历"></a>4.1 先序遍历</h2><p>先序遍历也叫做先根遍历。<br>顺序：<strong>根 → 左 → 右</strong><br>首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树，如果二叉树为空则返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719104738%201.png"></p><ol><li>输出当前结点的值</li><li>递归去处理左子树</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-type">int</span> left;<br><span class="hljs-type">int</span> right;<br>&#125; t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>cout &lt;&lt; t[id].value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点的值</span><br><span class="hljs-keyword">if</span>(t[id].left) <span class="hljs-built_in">pre_order</span>(t[id].left); <span class="hljs-comment">// 有左孩子访问左孩子</span><br><span class="hljs-keyword">if</span>(t[id].right) <span class="hljs-built_in">pre_order</span>(t[id].right);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br><br><span class="hljs-comment">// 完全二叉树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-中序遍历"><a href="#4-2-中序遍历" class="headerlink" title="4.2 中序遍历"></a>4.2 中序遍历</h2><p>中序遍历也叫做中根遍历。<br>顺序：<strong>左 → 根 → 右</strong><br>首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树，若二叉树为空则结束返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719105039%201.png"></p><ol><li>递归去处理左子树</li><li>输出当前结点的值</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h2><p>后序遍历也叫做后根遍历。<br>顺序：<strong>左 → 右 → 根</strong><br>首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点，若二叉树为空则结束返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719105326%201.png"></p><ol><li>递归去处理左子树</li><li>递归去处理右子树</li><li>输出当前结点的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 有右孩子访问右孩子</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-层次遍历"><a href="#4-4-层次遍历" class="headerlink" title="4.4 层次遍历"></a>4.4 层次遍历</h2><p>二叉树的层次遍历，就是指从二叉树的第一层（根结点）开始，从上至下逐层遍历，在同一层中，则按照从左到右的顺序对结点逐个访问。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719113102%201.png"></p><h1 id="5-二叉树重建"><a href="#5-二叉树重建" class="headerlink" title="5 二叉树重建"></a>5 二叉树重建</h1><h2 id="5-1-重建思路"><a href="#5-1-重建思路" class="headerlink" title="5.1 重建思路"></a>5.1 重建思路</h2><p>二叉树有三种不同的遍历方式：先序遍历，中序遍历和后序遍历。<br>中序遍历+另外任意一种遍历方式，可以<strong>唯一确定一颗二叉树</strong>。先序遍历与后序遍历<strong>不一定</strong>能唯一确定一个二叉树。</p><p>操作步骤：</p><ol><li>通过先序&#x2F;后序，判断<strong>根结点</strong></li><li>通过根结点在中序里判断<strong>左右子树</strong></li><li>在先序&#x2F;后序中找到左右节点，重复操作，画出树的结构。</li></ol><p><img src="/../../../cpp_assets/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%201.gif"></p><h2 id="5-2-重建代码"><a href="#5-2-重建代码" class="headerlink" title="5.2 重建代码"></a>5.2 重建代码</h2><h3 id="5-2-1-求先序"><a href="#5-2-1-求先序" class="headerlink" title="5.2.1 求先序"></a>5.2.1 求先序</h3><p>已知中序和后序，求先序。<br>后序遍历的最后一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求先序序列，所以是先输出，再递归左子树，再递归右子树。</p><ul><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>后序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="/../../../cpp_assets/11_clear_compress%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_pre</span><span class="hljs-params">(string in, string post)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(post.<span class="hljs-built_in">back</span>());  <br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 先序，先输出根节点，再递归左子树和右子树</span><br>    string in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id), post_left = post.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), post_right = post.<span class="hljs-built_in">substr</span>(id, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_pre</span>(in_left, post_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_pre</span>(in_right, post_right);  <span class="hljs-comment">// 递归右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-求后序"><a href="#5-2-2-求后序" class="headerlink" title="5.2.2 求后序"></a>5.2.2 求后序</h3><p>已知先序和中序，求后序。<br>先序遍历的第一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求后序序列，所以是先递归左子树，再递归右子树，再输出。</p><ul><li>先序<ul><li>左子树：1 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250719184128%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_post</span><span class="hljs-params">(string pre, string in)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(pre.<span class="hljs-built_in">front</span>());  <br>    string pre_left = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, id), in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string pre_right = pre.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_post</span>(pre_left, in_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_post</span>(pre_right, in_right);  <span class="hljs-comment">// 递归右子树</span><br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 后序，先递归左子树和右子树，再输出根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-二叉搜索树"><a href="#6-二叉搜索树" class="headerlink" title="6 二叉搜索树"></a>6 二叉搜索树</h1><p>二叉搜索树（Binary Search Tree，BST）是一种应用非常广泛的二叉树，又称二叉查找树，二叉排序树，可以用二叉树进行组织。一般用亲子结构表示一个结点，即一个树结点中，除了数据 <code>data</code> 以外，还包含 <code>left</code>，<code>right</code> 和 <code>parent</code>。<br><strong>二叉搜索树</strong>具有的性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于它根结点的值。</li><li>左右子树也是一棵二叉搜索树。</li></ul><p>搜索过程总结：</p><ul><li>比根结点数据大，且右子树不空，则向右子树搜索，若右子树空则数据不存在。</li><li>比根结点数据小，且左子树不空，则向左子树搜索，若左子树空则数据不存在。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250719192504%201.png"></p><p>根据二叉搜索树的性质和图示，可以得出二叉搜索树中的<strong>最大值在树的最右侧</strong>，<strong>最小值在树的最左侧</strong>。</p><blockquote><p>由于二叉搜索树可以用二叉树进行组织，因此，该搜索的过程可以用二叉树递归遍历实现。搜索效率平均$O(log_2N)$。<br>但存在这样的一种特殊情况，此时的二叉搜索树退化为一条单链，搜索效率降为 $O(n)$。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719193119%201.png"></p></blockquote><h1 id="7-哈夫曼树"><a href="#7-哈夫曼树" class="headerlink" title="7 哈夫曼树"></a>7 哈夫曼树</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><p>哈夫曼树（Huffman Tree），又称<strong>最优二叉树</strong>，是一种<strong>带权路径长度最短</strong>的二叉树，广泛应用于<strong>数据压缩</strong>（如 ZIP、JPEG、MP3 等编码技术）。它由 David A. Huffman 在 1952 年提出，权值越大的节点越靠近根结点，越小的节点就越远离根节点，是贪心算法（Greedy Algorithm）的经典应用。</p><ul><li>权值（Weight）：每个叶子节点可以赋予一个权值（Weight），通常表示字符出现的频率或概率。</li><li>路径长度（Path Length）：从根节点到某个节点所经过的边的数量。</li><li>带权路径长度（Weighted Path Length）：树中所有叶子节点的权值乘以其路径长度的总和。</li></ul><p>哈夫曼树的目标：构造 <strong>WPL</strong> 最小的二叉树，以提高编码效率。</p><h2 id="7-2-构建步骤"><a href="#7-2-构建步骤" class="headerlink" title="7.2 构建步骤"></a>7.2 构建步骤</h2><ol><li>初始化：将所有节点视为独立的树，每个树仅含一个节点。</li><li>选择最小权值的两棵树：从森林中选出<strong>权值最小</strong>的两棵树（节点）。</li><li>合并两棵树：把这两棵树作为左右子树构成一个新节点，其权值为两个子树的权值之和。</li><li>重复步骤 2~3，直到森林中只剩一棵树，即为<strong>哈夫曼树</strong>。</li></ol><p><img src="/../../../cpp_assets/PixPin_2025-07-19_23-08-34%201.gif"></p><p>在判别树中，若带权路径长度越小，说明判别次数越少，在底层的执行效率上也会相应更高，这也是体现最优二叉树“优”的地方之一。</p><h2 id="7-3-哈夫曼编码"><a href="#7-3-哈夫曼编码" class="headerlink" title="7.3 哈夫曼编码"></a>7.3 哈夫曼编码</h2><p>哈夫曼编码是从哈夫曼树中生成的一种<strong>变长编码</strong>：</p><ul><li>高频字符用短编码，低频字符用长编码。</li><li><strong>无前缀冲突</strong>（任何编码都不是另一个编码的前缀）。</li><li>从根节点出发，<strong>左边编码为0，右边编码为1</strong>。</li><li>从根节点到叶子节点的路径就是该字符的编码。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1 单链表"></a>1 单链表</h1><p>链表是一种物理存储单元上<strong>非连续、非顺序的存储结构</strong>，插入和删除速度快，并且不需要像数组一样预先开辟空间链表结构可以充分利用计算机内存空间，实现灵活地内存动态管理。</p><p><img src="/../../../cpp_assets/c_linklist_info%201.png" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><p>链表由一系列结点组成，每个结点包括两个部分：</p><ul><li>存储数据元素的数据域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="1-1-链表的创建"><a href="#1-1-链表的创建" class="headerlink" title="1.1 链表的创建"></a>1.1 链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>node *next;  /存储下一个结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><ul><li>使用 <code>new</code> 运算符来动态申请空间</li><li>使用 <code>-&gt;</code> 结构体指针运算符来访问内部成员</li><li>头结点数据域通常不做存储（删除结点只能通过它前一个结点指向它后一个结点，头结点没有前一个结点）</li></ul><p><code>*head.data</code> 和 <code>head-&gt;data</code> 效果是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>tail-&gt;next = p;  <span class="hljs-comment">//连到尾结点后面</span><br>tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-链表的遍历"><a href="#1-2-链表的遍历" class="headerlink" title="1.2 链表的遍历"></a>1.2 链表的遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *p = head;  <span class="hljs-comment">//使用p作为当前结点，从头开始遍历</span><br><span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//判断下一个结点是否为空</span><br>cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出下一个结点的数据，因为头结点无数据</span><br>p = p-&gt;next;  <span class="hljs-comment">//p更新为下一个结点</span><br>&#125; <br></code></pre></td></tr></table></figure><h2 id="1-3-链表的删除"><a href="#1-3-链表的删除" class="headerlink" title="1.3 链表的删除"></a>1.3 链表的删除</h2><p>删除单链表中p结点的下一个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;next = p-&gt;next-&gt;next;  <span class="hljs-comment">//将p所指的下一个结点修改为下一个结点的下一个结点</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_link_delete%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="1-4-链表的插入"><a href="#1-4-链表的插入" class="headerlink" title="1.4 链表的插入"></a>1.4 链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//先将新结点的指针域指向p的下一个结点</span><br>p-&gt;next = s;  <span class="hljs-comment">//再将p的下一个结点修改为s</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_link_insert%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="1-5-链表和数组"><a href="#1-5-链表和数组" class="headerlink" title="1.5 链表和数组"></a>1.5 链表和数组</h2><p><strong>数组：</strong></p><ul><li>优点：<br>随机访问性强，查找速度快。</li><li>缺点：<br>插入和删除效率低，，可能浪费内存，，内存空间要求高，数组大小固定，不能动态拓展。</li></ul><p><strong>链表：</strong></p><ul><li>优点：<br>插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</li><li>缺点：<br>不能随机查找，必须从第一个开始遍历，查找效率低。</li></ul><table><thead><tr><th align="center"></th><th align="center">查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td align="center">数组</td><td align="center">O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td align="center">链表</td><td align="center">O(n)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h1 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2 双向链表"></a>2 双向链表</h1><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有<strong>两个指针</strong>，分别指向<strong>直接后继</strong>和<strong>直接前驱</strong>，所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的<strong>前驱结点</strong>和<strong>后继结点</strong>。</p><p><img src="/../../../cpp_assets/c_double_link%201.png" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><p>双向链表每个节点有三个部分：</p><ul><li>存储数据元素的数据域</li><li>存储上一个节点地址的指针域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="2-1-双链表的创建"><a href="#2-1-双链表的创建" class="headerlink" title="2.1 双链表的创建"></a>2.1 双链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>node *pre, *next;  /存储前驱和后继结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;pre = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//前驱指针初始化为空</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>p-&gt;pre = tail;  <span class="hljs-comment">//前驱指针指向前驱节点tail</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>tail-&gt;next = p;  <span class="hljs-comment">//尾结点的后继指针指向p</span><br>tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-双链表的删除"><a href="#2-2-双链表的删除" class="headerlink" title="2.2 双链表的删除"></a>2.2 双链表的删除</h2><p>删除双链表中p结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;pre-&gt;next = p-&gt;next;  <span class="hljs-comment">//将p上一个结点的后继指针指向p的下一个结点</span><br>p-&gt;next-&gt;pre = p-&gt;pre;  <span class="hljs-comment">//将p下一个结点的前驱指针指向p的上一个结点</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_double_delete%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="2-3-双链表的插入"><a href="#2-3-双链表的插入" class="headerlink" title="2.3 双链表的插入"></a>2.3 双链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//新结点的后继指针域指向p的下一个结点</span><br>s-&gt;pre = p;  <span class="hljs-comment">//新结点的前驱指针指向p</span><br>p-&gt;next-&gt;pre = s;  <span class="hljs-comment">// p的下一个结点的前驱指针指向s</span><br>p-&gt;next = s;  <span class="hljs-comment">//p的后继指针指向s</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_double_insert%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="2-4-双向循环链表"><a href="#2-4-双向循环链表" class="headerlink" title="2.4 双向循环链表"></a>2.4 双向循环链表</h2><p>双向循环链表：最后一个结点的后继指针指向头结点，且头结点的前驱指针指向最后一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">head-&gt;pre = tail;<br>tail-&gt;next = head;<br></code></pre></td></tr></table></figure><h2 id="2-5-双链表优缺点"><a href="#2-5-双链表优缺点" class="headerlink" title="2.5 双链表优缺点"></a>2.5 双链表优缺点</h2><ul><li><strong>优点：</strong><br>从双向链表中的任意一个结点开始，都可以很方便地访问前驱结点和后继结点</li><li><strong>缺点：</strong><br>增加删除节点复杂，需要多分配一个指针存储空间</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度加减</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1 高精度加法"></a>1 高精度加法</h1><p>主要有以下几步：</p><ol><li><strong>输入处理</strong>：使用字符串来存储大整数，避免数值范围限制。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相加</strong>：从最低位开始，逐位相加并处理进位。</li><li><strong>最高进位</strong>：在最后检查是否有剩余进位。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N], b[N], c[N];  <span class="hljs-comment">// 方便进位和数位对齐的逆序整型数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 计算长度</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();<br><span class="hljs-comment">// 逆序存储到整型数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) a[i] = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) b[i] = num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// 循环较长数字的位数</span><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>c[i] += a[i] + b[i];  <span class="hljs-comment">// 这一位加上两个数的和</span><br>c[i + <span class="hljs-number">1</span>] += c[i] / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10进位到下一位</span><br>c[i] %= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10要取余</span><br>&#125; <br><br><span class="hljs-keyword">if</span>(c[len]) len++;  <span class="hljs-comment">// 如果最高位有进位，长度加1</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; c[i];  <span class="hljs-comment">// 逆序输出</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 分别计算两数的最后一位数下标，并初始化进位</span><br>    <span class="hljs-type">int</span> i = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br><br>    string res;<br>    <span class="hljs-comment">// 只要有数字没加完 或 有进位没处理就继续运算</span><br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>        <span class="hljs-type">int</span> sum = carry;  <span class="hljs-comment">// 这一位的结果先赋为进位值</span><br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>) sum += num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第一个数没加完就加</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span>) sum += num2[j--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第二个数没加完就加</span><br><br>        carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 计算是否有进位</span><br>        res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 对10取余处理进位</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 翻转答案</span><br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 确保 num1 是较长的数字</span><br><span class="hljs-keyword">if</span>(num<span class="hljs-number">1.l</span>ength() &lt; num<span class="hljs-number">2.l</span>ength()) <span class="hljs-built_in">swap</span>(num1, num2);<br><br>string res;  <span class="hljs-comment">// 最终答案</span><br><span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位，初始为0</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();  <span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 从最低位开始相加，加到较长数字的位数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <br><span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br><span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br><span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这一位的总和等于：两数相加并加上进位</span><br><span class="hljs-type">int</span> sum = digit1 + digit2 + carry;<br>carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 下一位的进位等于这一位总和对10整除</span><br>res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 最终这一位的结果要对10取余，并且恢复为字符串</span><br>&#125;<br><br><span class="hljs-comment">// 如果还有进位，说明最高位也发生了进位，超出了原有最长位数，要单独处理</span><br><span class="hljs-keyword">if</span>(carry) res += carry + <span class="hljs-string">&#x27;0&#x27;</span>; <br><br><span class="hljs-comment">// 由于前面是从最低位开始加的，这里要对结果进行翻转</span><br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2 高精度减法"></a>2 高精度减法</h1><p>主要有以下几步</p><ol><li><strong>比较大小</strong>：比较两个数字字符串的大小，确定减数和被减数，并标记负号。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相减</strong>：从最低位开始，逐位相减并处理借位。</li><li><strong>结果处理</strong>：移除结果中的前导零，判断是否添加负号。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">subBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-type">char</span> op = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 记录符号</span><br><span class="hljs-comment">// 确保 num1 &gt; num2，否则记录负号并交换</span><br><span class="hljs-keyword">if</span>(num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() || num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() == num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &amp;&amp; num1 &lt; num2) &#123;<br>op = <span class="hljs-string">&#x27;-&#x27;</span>;<br><span class="hljs-built_in">swap</span>(num1, num2);<br>&#125;<br><br>string res;  <span class="hljs-comment">// 最终答案</span><br>    <span class="hljs-type">int</span> borrow = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 借位，初始为0</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), len2 = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 运算按较长数字的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<br><span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br><span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br><span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这一位的结果等于：两数相减并减去借位</span><br><span class="hljs-type">int</span> dif = digit1 - digit2 - borrow;<br><span class="hljs-comment">// 判断是否需要借位</span><br><span class="hljs-keyword">if</span>(dif &lt; <span class="hljs-number">0</span>) borrow = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> borrow = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 这一位的结果先加10再取余，可以处理需要借位的负数，并 + &#x27;0&#x27; 转字符</span><br>res += (dif + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理前导0，但注意保留一个，因为结果可能为0</span><br><span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;0&#x27;</span>) res.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 处理负号</span><br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) res += <span class="hljs-string">&#x27;-&#x27;</span>;<br><br><span class="hljs-comment">// 翻转字符串</span><br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准输入输出</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><code>cin &gt;&gt;</code> <code>cout &lt;&lt;</code>  </p><p><code>scanf()</code>  <code>printf()</code> </p><p><code>getchar(c)</code> 字符输入  <code>putchar(c)</code> 字符输出</p><p><code>gets(str)</code> 读取一整行，回车或EOF停止，不会判断上限，不安全</p><p><code>fgets(str, 100, stdin)</code> 读取一整行，读取最多100个字符存到str中</p><p><code>cin.getline(str, 100)</code>  <code>getline(cin, str)</code> 读取一整行，读取最多100个字符存到str中</p><p><strong>注意</strong>：当同时使用<code>cin&gt;&gt;</code>, <code>getline()</code>时，在<code>cin&gt;&gt;</code>之后，<code>getline()</code>之前，需要将回车符作为输入流cin以清除缓存，在<code>cin</code>和<code>getline()</code>中间插入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; <br>...<br>str=<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">getline</span>(cin,str);<br>...<br><span class="hljs-built_in">getline</span>()<br></code></pre></td></tr></table></figure><p>如果不这样做的话，在控制台上就不会出现<code>getline()</code>的输入提示，而是直接跳过，因为程序默认将之前的变量作为输入流。</p><table><thead><tr><th align="center">数据类型</th><th align="center">占位符</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">%d</td></tr><tr><td align="center">long long</td><td align="center">%lld</td></tr><tr><td align="center">float</td><td align="center">%f</td></tr><tr><td align="center">double</td><td align="center">scanf 用 %lf，printf 用 %f</td></tr><tr><td align="center">char</td><td align="center">%c</td></tr></tbody></table><ul><li><p>无论单双精度，<code>printf</code> 都会将浮点数提升为双精度，所以在输出时不区分单双精度</p></li><li><p><code>printf()</code> 特殊输出格式</p><ul><li><p><code>%md</code> 右对齐m位输出，高位用空格补齐</p></li><li><p><code>%0md</code> 右对齐m位输出，高位用0补齐</p></li><li><p><code>%.mf</code> 浮点数保留m位小数</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件读取</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>如果需要从文件读入数据，并把输出数据保存为文件，需要使用文件读取。</p><ul><li><code>freopen</code>为<code>file reopen</code>，意为文件重新打开，实现重定向标准输入输出</li><li>第一个参数为文件名可以修改，输入文件为<code>.in</code>，输出文件为<code>.out</code></li><li>第二个参数，<code>r</code>代表读(read)，<code>w</code>代表写(write)</li><li>第三个参数，<code>stdin</code>标准输入，<code>stdout</code>标准输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br></code></pre></td></tr></table></figure><p><code>main</code>函数开头加上这两行，程序会打开与编译器同目录下的<code>test.in</code>文件，从中读取输入数据，代码部分不需要修改，运行结果会保存到编译器同目录下的<code>test.out</code>文件，没有此命名文件则会自动创建此文件。</p><p>文件使用完成之后需要关闭文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fclose</span>(stdin);  <span class="hljs-comment">// 关闭输入文件</span><br><span class="hljs-built_in">fclose</span>(stdout);  <span class="hljs-comment">// 关闭输出文件</span><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>cout &lt;&lt; a;<br><br><span class="hljs-built_in">fclose</span>(stdin); <br><span class="hljs-built_in">fclose</span>(stdout);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件目录关系默认如下：<br><img src="/../../../cpp_assets/c_dir.png" alt="Pasted-image-2025043021535005a39c529573ea8f.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Linux-系统概述"><a href="#1-Linux-系统概述" class="headerlink" title="1 Linux 系统概述"></a>1 Linux 系统概述</h1><ul><li>Linux 发行时间: 1991年</li><li>Linux 的创始人: 林纳斯·托瓦兹</li><li>Linux 的吉祥物: 企鹅</li><li>官网地址: <a href="https://www.kernel.org/">https://www.kernel.org/</a></li></ul><blockquote><p><strong>Linux 发行版</strong> &#x3D; Linux 内核 + 系统库 + 系统软件</p><p>Linux 的内核完全开源免费，但是 Linux 的发行版不一定免费。</p></blockquote><p>Linux 是目前服务器端用到的最多的操作系统，支持 7 * 24小时高性能服务。<br>常见的 Linux 发行版：</p><ul><li>RedHat: 世界最大的 Linux 发行版厂商，已经被 IBM 收购</li><li>Ubuntu: 桌面操作系统做最好的</li><li>CentOS: 目前中国市场使用最多的 Linux 版本，目前已经被 RedHat 收购,但依然免费</li><li>Deepin: 深度公司开发的 Linux 版本，国内做的最好的 Linux 发行版</li></ul><p><img src="/../../../tool_assets/1739856296312.png" alt="1739856296312"></p><h1 id="2-Linux-的目录结构"><a href="#2-Linux-的目录结构" class="headerlink" title="2 Linux 的目录结构"></a>2 Linux 的目录结构</h1><ul><li>Linux 和 Windows, Mac 一样, 都是文件系统, 采用文件和文件夹的形式来管理数据</li></ul><ul><li>只不过在 Linux 操作系统中，是没有盘符概念的，任何文件(文件夹)都是从根目录开始进行拆分的</li><li>且 Linux 中采用的是<strong>目录树结构</strong>，Windows 中采用的是<strong>森系结构</strong></li></ul><p>Linux 中常用的目录结构:</p><ul><li><code>/etc</code>：存放 Linux 配置文件的目录</li><li><code>/opt</code>：存放应用程序的目录</li><li><code>/bin</code>：终端指令集存放的目录</li><li><code>/sbin</code>：超级管理员用户使用的指令集，包括用户的创建删除等指令</li><li><code>/home</code>：普通用户的家目录</li><li><code>/root</code>：超级管理员的家目录,</li></ul><p><img src="/../../../tool_assets/666666666.png" alt="666666666"></p><h1 id="3-基础命令"><a href="#3-基础命令" class="headerlink" title="3 基础命令"></a>3 基础命令</h1><p>Linux指令的构成：<code>command [-options] [arguments]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">linux指令 = 命令(做什么) + 选项(怎么做) + 参数(对谁做)  <br><br>command: 命令名, 相应功能的英文单词或单词的缩写  <br>-options: 选项, 可用来对命令进行控制, 也可以省略  <br>arguments: 传给命令的参数, 可以是零个、一个或者多个<br></code></pre></td></tr></table></figure><h2 id="3-1-文件与目录操作"><a href="#3-1-文件与目录操作" class="headerlink" title="3.1 文件与目录操作"></a>3.1 文件与目录操作</h2><h3 id="3-1-1-路径导航"><a href="#3-1-1-路径导航" class="headerlink" title="3.1.1 路径导航"></a>3.1.1 路径导航</h3><h4 id="ls（列出内容）"><a href="#ls（列出内容）" class="headerlink" title="ls（列出内容）"></a>ls（列出内容）</h4><p><code>ls</code> 源自 <strong>list</strong>，用于<strong>查看指定位置的文件和子目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [-a -l -h] [路径信息]<br><br>-a  # all, 显示所有文件（包括以.开头的隐藏文件）<br>-l  # long format, 以长格式列出文件（权限、所有者、大小、修改时间等）<br>-h# human-readable, 以人类可读的格式（如 KB、MB）显示文件大小（需配合 -l 使用）<br></code></pre></td></tr></table></figure><p>选项可以随意自由组合，且选项的顺序可以随意调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls# 列出当前目录的文件和子目录（不包括隐藏的）<br>ls -lh  # 以长格式显示文件信息，并以易读的方式显示文件大小<br>ls -al  # 以长格式显示文件信息，包括隐藏文件<br>ls -alh # 以长格式显示文件信息，包括隐藏文件，并以易读的方式显示文件大小<br></code></pre></td></tr></table></figure><p><code>ls</code> 参数可以查看指定路径的文件信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /      # 查看根目录的文件和子目录<br>ls -a aa  # 显示当前目录下的 aa 目录中的文件内容，包括隐藏文件<br>ll        # 完全等价于 ls -l, 可以快速查看文件的详细信息（也可以搭配 -h -a 使用）<br></code></pre></td></tr></table></figure><h4 id="cd（切换目录）"><a href="#cd（切换目录）" class="headerlink" title="cd（切换目录）"></a>cd（切换目录）</h4><p><code>cd</code> 源自 <strong>change directory</strong>，用于<strong>改变工作目录</strong>。</p><ul><li>绝对路径：从根目录出发，直到目标文件的目录层级</li><li>相对路径：从当前目录出发，直到目标文件目录层级</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd [绝对路径或相对路径]<br><br>..    # 代表上一级目录<br>../   # 同上，代表上一级目录<br>./    # 代表当前路径，可以省略<br></code></pre></td></tr></table></figure><ul><li><code>cd</code> 命令无需选项，只有参数，表示要切换到哪个目录下</li><li><code>cd</code> 命令不写参数直接执行，表示回到用户的家目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc  # 切换到 /etc 目录<br>cd       # 回家，root 账号家目录是 /root，其他账号家目录是 /home<br>cd ~     # 返回家目录，即 cd ~ 等价于 cd，都是回家<br>cd -     # 返回上一次操作的工作目录<br></code></pre></td></tr></table></figure><h4 id="pwd（当前路径）"><a href="#pwd（当前路径）" class="headerlink" title="pwd（当前路径）"></a>pwd（当前路径）</h4><p><code>pwd</code> 源自 <strong>print work directory</strong>，用于<strong>打印工作目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd    # 当前在哪个目录, 就打印什么路径.<br></code></pre></td></tr></table></figure><h3 id="3-1-2-增删改"><a href="#3-1-2-增删改" class="headerlink" title="3.1.2 增删改"></a>3.1.2 增删改</h3><h4 id="mkdir（创建目录）"><a href="#mkdir（创建目录）" class="headerlink" title="mkdir（创建目录）"></a>mkdir（创建目录）</h4><p><code>mkdir</code> 源自 <strong>make directory</strong>，用于<strong>创建新文件夹</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [-p] 目录名称<br>-p    # parents, 自动创建所需的父目录（如果不存在）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单级目录</span><br>mkdir aa            # 在当前目录下创建 aa 文件夹<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建多级目录</span><br>mkdir aa/bb/cc      # 创建多级目录，如果 aa/bb 目录不存在，则：报错<br>mkdir -p aa/bb/cc   # 自动创建所需要的目录<br></code></pre></td></tr></table></figure><h4 id="touch（创建文件）"><a href="#touch（创建文件）" class="headerlink" title="touch（创建文件）"></a>touch（创建文件）</h4><p><code>touch</code> 用于<strong>修改文件时间戳</strong>或<strong>创建空文件</strong>。</p><ul><li><code>touch</code> 可以创建一个新的文件，文件的扩展名随意，甚至可以是不存在的扩展名</li><li><code>touch</code> 创建的文件如果存在不报错，但是没有新文件产生</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单个文件</span><br>touch 1.txt        <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性创建多个文件</span><br>touch 1.txt 2.jpg 3.mp3<br></code></pre></td></tr></table></figure><h4 id="cp（复制）"><a href="#cp（复制）" class="headerlink" title="cp（复制）"></a>cp（复制）</h4><p><code>cp</code> 源自 <strong>copy</strong>，用于<strong>拷贝文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp 源文件 目标文件<br>cp -r 源目录 目标目录<br>-r      # recursive, 递归复制目录（包括子目录和文件）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝文件</span><br>cp 1.txt /aa         # 拷贝 1.txt 到 /aa 目录下<br>cp 1.txt /aa/2.txt   # 拷贝 1.txt 到 /aa 目录下，并命名为 2.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝目录</span><br>cp -r aa bb          # 递归拷贝 aa 文件夹到 bb 文件夹下<br></code></pre></td></tr></table></figure><h4 id="mv（移动-重命名）"><a href="#mv（移动-重命名）" class="headerlink" title="mv（移动&#x2F;重命名）"></a>mv（移动&#x2F;重命名）</h4><p><code>mv</code> 源自 <strong>move</strong>，用于 <strong>移动</strong>或<strong>重命名文件</strong>文件和目录，类似于 windows 剪切。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 源文件 目标路径  # 将文件移动到目标路径<br>mv 旧名字 新名字    # 重命名（本质是在同一目录下移动）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动</span><br>mv file.txt /tmp/          # 移动 file.txt 到 /tmp 目录<br>mv folder/ /backup/        # 移动 folder 到 /backup 目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重命名</span><br>mv old.txt new.txt         # 文件重命名<br>mv old_dir/ new_dir/       # 目录重命名<br></code></pre></td></tr></table></figure><h4 id="rm（删除）"><a href="#rm（删除）" class="headerlink" title="rm（删除）"></a>rm（删除）</h4><p><code>rm</code> 源自 <strong>remove</strong>，用于 <strong>删除文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名<br>rm -r 目录名<br>-r      # recursive, 递归删除目录（包括子目录和文件）<br>-f      # force, 强制删除，不进行询问<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件</span><br>rm 1.txt    # 删除当前目录下的 1.txt<br>rm /*.txt   # 删除根目录下的所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件夹</span><br>rm -r aa    # 删除当前目录下的 aa 文件夹<br>rm -rf /bb  # 强制删除根目录下的 bb 文件夹不进行提示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性删除多个</span><br>rm -rf /*              # 通过 * 通配符删除所有文件<br>rm 1.txt 2.jpg 3.mp3   # 一次性删除这三项文件<br></code></pre></td></tr></table></figure><h3 id="3-1-3-内容查看"><a href="#3-1-3-内容查看" class="headerlink" title="3.1.3 内容查看"></a>3.1.3 内容查看</h3><h4 id="cat（全量查看）"><a href="#cat（全量查看）" class="headerlink" title="cat（全量查看）"></a>cat（全量查看）</h4><p><code>cat</code> 源自 <strong>concatenate</strong>，连接、查看文件内容，常用于<strong>查看小型文本文件</strong>。</p><ul><li>一次性输出全部内容，大文件显示不全，且过于消耗内存，适合小文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名<br>-n  # number, 显示行号<br></code></pre></td></tr></table></figure><h4 id="more（分页查看）"><a href="#more（分页查看）" class="headerlink" title="more（分页查看）"></a>more（分页查看）</h4><p><code>more</code> 是一个分页查看工具，主要用于<strong>查看中型文本文件</strong>。</p><ul><li>分页查看文件，支持手动翻页，更加灵活，但同样消耗内存。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">more 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Enter          向下一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">D(down)/Space  向下一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">B(back)        向上一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Q(quit)        退出</span><br></code></pre></td></tr></table></figure><h4 id="tail（查看尾部，日志监控）"><a href="#tail（查看尾部，日志监控）" class="headerlink" title="tail（查看尾部，日志监控）"></a>tail（查看尾部，日志监控）</h4><p><code>tail</code> 意为“尾部”，用于<strong>查看文件末尾内容</strong> ，适合监控日志文件或实时查看新增内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail [-n NUM -f] 文件名<br>-n NUM   # number, 显示末尾 NUM 行（默认 10）, n 可以省略，简写为 -NUM<br>-f       # follow, 实时跟踪文件更新<br><br>tail 1.txt           # 查看文件末尾 10 行（默认）<br>tail -5 1.txt        # 查看文件末尾 5 行<br>tail -100f log.txt   # 动态查看文件末尾 100 行<br></code></pre></td></tr></table></figure><h2 id="3-2-搜索与过滤"><a href="#3-2-搜索与过滤" class="headerlink" title="3.2 搜索与过滤"></a>3.2 搜索与过滤</h2><h3 id="3-2-1-文件搜索"><a href="#3-2-1-文件搜索" class="headerlink" title="3.2.1 文件搜索"></a>3.2.1 文件搜索</h3><h4 id="which（查找命令路径）"><a href="#which（查找命令路径）" class="headerlink" title="which（查找命令路径）"></a>which（查找命令路径）</h4><p><code>which</code> 用于<strong>查找命令的完整路径</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">which 命令名<br><br>which ls        # 输出：/usr/bin/ls<br>which ifconfig  # 输出：/usr/sbin/ifconfig<br></code></pre></td></tr></table></figure><h4 id="find（按条件递归查找文件）"><a href="#find（按条件递归查找文件）" class="headerlink" title="find（按条件递归查找文件）"></a>find（按条件递归查找文件）</h4><p><code>find</code> 通过条件筛选，用于<strong>查找符合条件的文件和目录</strong>。</p><ul><li>不指定路径时：默认从当前目录递归搜索</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [路径] [筛选条件]<br>-name 按名称过滤<br>-size 按大小过滤  <br>-size +100M 大于100MB  <br>-size -1G 小于1GB<br>-type 按类型过滤  <br>-type f 文件  <br>-type d 目录 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按名称搜索</span><br>find / -name &#x27;abc*&#x27;         # 查找根目录下所有 abc 开头的文件<br>find /path -name &quot;*.txt&quot;    # 查找 /path 目录下所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按大小搜索</span><br>find / -size +1G            # 查找根目录下大于 1GB 的文件<br>find ~ -size -10M           # 查找家目录下小于 10MB 的文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按类型搜索</span><br>find / -type d -name &quot;log&quot;  # 搜索名为 log 的目录<br></code></pre></td></tr></table></figure><h3 id="3-2-2-内容过滤"><a href="#3-2-2-内容过滤" class="headerlink" title="3.2.2 内容过滤"></a>3.2.2 内容过滤</h3><h4 id="grep（文本匹配）"><a href="#grep（文本匹配）" class="headerlink" title="grep（文本匹配）"></a>grep（文本匹配）</h4><p><code>grep</code> 源自 <strong>global regular expression print</strong>（全局正则表达式打印），用于<strong>搜索符合条件的文本并打印所在行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [-n] &quot;要搜索的内容&quot; 文件名<br>-n       # number, 显示行号<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep &#x27;world&#x27; 1.txt  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep -n &#x27;python&#x27; 1.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容： 2: python world good</span><br></code></pre></td></tr></table></figure><h4 id="wc（行-词-字节统计）"><a href="#wc（行-词-字节统计）" class="headerlink" title="wc（行&#x2F;词&#x2F;字节统计）"></a>wc（行&#x2F;词&#x2F;字节统计）</h4><p><code>wc</code> 源自 <strong>word count</strong>，用于<strong>统计文本行数、单词数、字节数</strong>。</p><ul><li>单词按照空格划分</li><li>在默认的 UTF-8 编码下，1汉字 &#x3D; 3字节，1汉字 &#x3D; 1字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc [-l -w -c -m] 文件名<br>-l             # line, 行数<br>-w             # word, 单词数<br>-c             # character, 字节数<br>-m             # multibyte, 字符数<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：hello world</span><br>wc 1.txt       # 输出：1 2 12 ，分别代表行数、单词数、字节数<br>wc -wlc 1.txt  # 同上，包括 -lwc 都一样，没有顺序之分<br></code></pre></td></tr></table></figure><h2 id="3-3-文本打印"><a href="#3-3-文本打印" class="headerlink" title="3.3 文本打印"></a>3.3 文本打印</h2><h3 id="echo（输出文本-变量）"><a href="#echo（输出文本-变量）" class="headerlink" title="echo（输出文本&#x2F;变量）"></a>echo（输出文本&#x2F;变量）</h3><p><code>echo</code> 意为“回声”，功能类似于 Python 的 <code>print</code>，用于 <strong>输出文本或变量内容到标准输出（屏幕）</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [-n -e] &#x27;内容&#x27;<br>-n不自动换行（末尾不加换行符）<br>-e启用转义字符（如 \n 换行）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出文本到屏幕</span><br>echo &quot;Hello, World!&quot;      # 输出：Hello, World!<br>echo - e &quot;Hello\nWorld!&quot;  # 输出两行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出变量到屏幕</span><br>name=&#x27;zhu&#x27;                # = 两侧不能有空格<br>echo &quot;my name is $name&quot;   # 使用 $ 表示变量，输出：my name is zhu<br></code></pre></td></tr></table></figure><h2 id="3-4-数据流控制"><a href="#3-4-数据流控制" class="headerlink" title="3.4 数据流控制"></a>3.4 数据流控制</h2><h3 id="3-4-1-（输出重定向）"><a href="#3-4-1-（输出重定向）" class="headerlink" title="3.4.1 &gt;&#x2F;&gt;&gt;（输出重定向）"></a>3.4.1 <code>&gt;</code>&#x2F;<code>&gt;&gt;</code>（输出重定向）</h3><p>重定向通过符号控制数据的输入&#x2F;输出方向，用于<strong>控制数据的流向</strong>（如输出到文件或管道）。</p><ul><li>重定向是命令与文件间的传递，用于保存输出或读取文件输入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">    <span class="hljs-comment"># 覆盖写入文件（若文件不存在则创建）</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;    <span class="hljs-comment"># 追加到文件末尾</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速创建文件</span><br>echo &quot;This is line 1&quot; &gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加文本</span><br>echo &quot;This is line 2&quot; &gt;&gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重定向输出</span><br>ls /usr/bin &gt; cmd.txt   # 将输出信息重定向到 cmd.txt 中，相当于写入<br></code></pre></td></tr></table></figure><h3 id="3-4-2-（管道符）"><a href="#3-4-2-（管道符）" class="headerlink" title="3.4.2 |（管道符）"></a>3.4.2 <code>|</code>（管道符）</h3><p>管道（Pipe <code>|</code> ）用于将 <strong>前一个命令的输出</strong> 作为 <strong>后一个命令的输入</strong>，实现多命令协作处理数据。</p><ul><li>管道符是命令与命令间的传递，用于多命令协作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令1 | 命令2 | 命令3...<br><br>ls / | wc -w    # 输出：20，统计根目录下的目录数<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br>cat 1.txt | grep &#x27;python&#x27; | wc -w   # 输出：3，先查文件，再过滤，再统计单词<br></code></pre></td></tr></table></figure><h3 id="3-4-3-（命令替换）"><a href="#3-4-3-（命令替换）" class="headerlink" title="3.4.3 `&#x2F;$()（命令替换）"></a>3.4.3 <code>`</code>&#x2F;<code>$()</code>（命令替换）</h3><p>反引号<code>`</code>用于 **命令替换**，可以将 **命令的输出结果** 作为字符串嵌入到其他命令中，现代脚本中可以使用 <code>$( )</code> 语法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `ls / | wc -w`<br>echo $(ls / | wc -w)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出：20</span><br></code></pre></td></tr></table></figure><h2 id="3-5-vi-vim-命令"><a href="#3-5-vi-vim-命令" class="headerlink" title="3.5 vi&#x2F;vim 命令"></a>3.5 vi&#x2F;vim 命令</h2><p><code>vi</code> 全称叫: Visual Interface，类似于 windows 的记事本，是 Linux 中最经典的文本编辑器。<br><code>vim</code> 是 vi 的加强版本，兼容 vi 的所有指令，不仅能编辑文本，而且还具有 shell 程序编辑的功能，可以不同颜色的字体来辨别语法的正确性。</p><ul><li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li><li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 文件名<br>vim 文件名<br></code></pre></td></tr></table></figure><p><code>vi</code> &#x2F; <code>vim</code> 编辑器的三种工作模式：</p><ul><li><strong>命令模式</strong>（默认&#x2F;Command mode）<br>从键盘上输入的任何字符都被当做命令来解释，但输入的命令并不回显在屏幕上。若输入的字符不是 vi 的合法命令，vi 会响铃报警。</li><li><strong>输入模式</strong>（Insert mode）<br>也就是所谓的编辑模式、插入模式。用户输入的任何字符都被 vi 当做文件内容保存起来，并将其显示在屏幕上。</li><li><strong>底线命令模式</strong>（Last line mode）<br>底线命令模式也称命令行模式。此时 vi 会在屏幕最后一行显示一个<code>:</code>作为末行模式的说明符，等待用户输入命令，多数文件管理命令都是在此模式下执行的。</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250729181400.png"></p><ul><li>命令模式：<ul><li><code>iao</code> 进入编辑模式</li><li><code>:</code> 进入底线命令模式</li><li><code>dd</code> 删除当前行</li><li><code>ndd</code> 向下删除 n 行</li><li><code>yy</code> 复制当前行</li><li><code>nyy</code> 向下复制 n 行</li><li><code>p</code> 粘贴</li><li><code>gg</code> 回到行首（文件开头）</li><li><code>G</code> 回到行尾（文件结尾）</li><li><code>u</code> 撤销</li><li><code>Ctrl</code>+<code>r</code>：反撤销</li><li><code>/文本</code>：查询文本并高亮显示</li></ul></li><li>底线命令模式：<ul><li><code>:q</code> 退出不保存</li><li><code>:q!</code> 强制退出不保存</li><li><code>:wq</code> write quit 退出并保存（快捷键<code>ZZ</code>）</li><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 隐藏行号</li><li><code>:noh</code>&#x2F;<code>:nohl</code> no highlight，取消高亮显示</li></ul></li><li>输入模式：<ul><li><code>ESC</code> 回到命令模式</li></ul></li></ul><h2 id="3-6-命令手册"><a href="#3-6-命令手册" class="headerlink" title="3.6 命令手册"></a>3.6 命令手册</h2><p>大多数手册都是全英文的，可以通过重定向符：<code>man ls &gt; ls-man.txt</code>，输出手册到文件，然后通过翻译软件查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助文档.</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: 命令名 --<span class="hljs-built_in">help</span></span>  <br>ls --help  <br>​  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助手册</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: man 命令名  manual，手册</span><br>man ls<br></code></pre></td></tr></table></figure><h1 id="4-用户和权限"><a href="#4-用户和权限" class="headerlink" title="4 用户和权限"></a>4 用户和权限</h1><p>在 Linux 系统中，拥有最大权限的账户名为：<code>root</code>（超级管理员）。<br>普通用户的权限，一般在其 HOME 目录内是不受限的，一旦出了 HOME 目录，大多数地方，普通用户仅有只读和执行权限，无修改权限。</p><h2 id="4-1-用户和用户组"><a href="#4-1-用户和用户组" class="headerlink" title="4.1 用户和用户组"></a>4.1 用户和用户组</h2><p>Linux系统中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组中</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250729213542.png"></p><p>Linux中关于权限的管控级别有2个级别，分别是：</p><ul><li>针对<strong>用户</strong>的权限控制</li><li>针对<strong>用户组</strong>的权限控制</li></ul><h3 id="4-1-1-用户组管理"><a href="#4-1-1-用户组管理" class="headerlink" title="4.1.1 用户组管理"></a>4.1.1 用户组管理</h3><h4 id="getent-group（查看所有用户组）"><a href="#getent-group（查看所有用户组）" class="headerlink" title="getent group（查看所有用户组）"></a>getent group（查看所有用户组）</h4><p><code>getent</code> 源自 <strong>get entries</strong>（entry: 条目）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent group<br></code></pre></td></tr></table></figure><h4 id="groupadd（创建用户组）"><a href="#groupadd（创建用户组）" class="headerlink" title="groupadd（创建用户组）"></a>groupadd（创建用户组）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> 组名<br></code></pre></td></tr></table></figure><h4 id="groupdel（删除用户组）"><a href="#groupdel（删除用户组）" class="headerlink" title="groupdel（删除用户组）"></a>groupdel（删除用户组）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupdel 组名<br></code></pre></td></tr></table></figure><h3 id="4-1-2-用户管理"><a href="#4-1-2-用户管理" class="headerlink" title="4.1.2 用户管理"></a>4.1.2 用户管理</h3><h4 id="getent-passwd（查看所有用户）"><a href="#getent-passwd（查看所有用户）" class="headerlink" title="getent passwd（查看所有用户）"></a>getent passwd（查看所有用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent passwd<br></code></pre></td></tr></table></figure><h4 id="useradd（创建用户）"><a href="#useradd（创建用户）" class="headerlink" title="useradd（创建用户）"></a>useradd（创建用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd [-g 组名] 用户名<br>-g   # group，指定用户所在组。不写会创建和用户名一模一样的组名，并添加用户到该组中<br></code></pre></td></tr></table></figure><h4 id="userdel（删除用户）"><a href="#userdel（删除用户）" class="headerlink" title="userdel（删除用户）"></a>userdel（删除用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel [-r] 用户名<br>-r   # remove，删除用户的同时，把 /home 目录下该用户的目录也删除<br></code></pre></td></tr></table></figure><h4 id="usermod（修改用户属性）"><a href="#usermod（修改用户属性）" class="headerlink" title="usermod（修改用户属性）"></a>usermod（修改用户属性）</h4><p><code>usermod</code> 源自 <strong>user modify</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -aG 组名 用户名<br>-aG    # append group，追加用户到附加组<br></code></pre></td></tr></table></figure><h4 id="id（查看用户）"><a href="#id（查看用户）" class="headerlink" title="id（查看用户）"></a>id（查看用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id [用户名]    # 不指定用户名会查看自身<br></code></pre></td></tr></table></figure><h4 id="passwd（修改用户密码）"><a href="#passwd（修改用户密码）" class="headerlink" title="passwd（修改用户密码）"></a>passwd（修改用户密码）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">passwd</span> 用户名<br></code></pre></td></tr></table></figure><h3 id="4-1-3-切换用户及借调权限"><a href="#4-1-3-切换用户及借调权限" class="headerlink" title="4.1.3 切换用户及借调权限"></a>4.1.3 切换用户及借调权限</h3><h4 id="su（切换用户）"><a href="#su（切换用户）" class="headerlink" title="su（切换用户）"></a>su（切换用户）</h4><p><code>su</code> 源自 <strong>swith user</strong>，用于<strong>切换用户</strong>。</p><ul><li>使用普通用户，切换到其它用户需要输入密码，如切换到 root 用户</li><li>使用 root 用户切换到其它用户，无需密码，可以直接切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su [用户名]      # 省略用户名表示切换到 root<br></code></pre></td></tr></table></figure><blockquote><p>切换用户后，可以通过 <code>exit</code> 命令退回上一个用户，也可以使用快捷键：<code>Ctrl</code> + <code>D</code>。</p></blockquote><h4 id="sudo（借调权限）"><a href="#sudo（借调权限）" class="headerlink" title="sudo（借调权限）"></a>sudo（借调权限）</h4><p><code>sudo</code> 源自 <strong>superuser do</strong>，临时借调权限，为普通的命令授权，<strong>临时以 root 身份执行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo 要执行的命令<br></code></pre></td></tr></table></figure><blockquote><p>权限记录在 etc 目录下的 sudoers 文件中，root 用户可以通过 visudo 命令修改。如果没有权限, 则会记录该行为到日志。</p></blockquote><h2 id="4-2-查看权限信息"><a href="#4-2-查看权限信息" class="headerlink" title="4.2  查看权限信息"></a>4.2  查看权限信息</h2><p>使用 <code>ll</code> 显示如下信息结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件类型和权限 硬链接数 所有者  所属组  文件大小  最后修改时间   文件名/目录名<br>-rw-r--r--       1     user   group   1234    Jul 29 10:00  file.txt<br>drwxr-xr-x       2     user   group   4096    Jul 28 15:32  my_folder<br></code></pre></td></tr></table></figure><ol><li>第 1 个字符：文件类型<ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录，源自 directory</li><li><code>l</code> 软链接，源自 link</li></ul></li><li>第 2-10 个字符：权限（所有者、所属组、其他用户）<ul><li><code>r</code> 读，源自 read</li><li><code>w</code> 写，源自 write</li><li><code>x</code> 执行，源自 execute</li><li><code>-</code> 无</li></ul></li></ol><p><img src="/../../../tool_assets/Pasted%20image%2020250729230728.png"></p><blockquote><p><strong>注意：</strong> 文件&#x2F;目录的所有者和所属组是两个独立的属性，所有者并不是一定要在所属组内。</p></blockquote><h2 id="4-3-修改权限信息"><a href="#4-3-修改权限信息" class="headerlink" title="4.3 修改权限信息"></a>4.3 修改权限信息</h2><h3 id="4-3-1-chmod（修改文件权限）"><a href="#4-3-1-chmod（修改文件权限）" class="headerlink" title="4.3.1 chmod（修改文件权限）"></a>4.3.1 chmod（修改文件权限）</h3><p><code>chmod</code> 源自 <strong>change mode</strong>，用于修改文件或目录的<strong>访问权限</strong>，即读（r）、写（w）、执行（x）权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [-R] [权限设置] 文件/目录<br>-R 递归修改目录及其内容权限<br></code></pre></td></tr></table></figure><ul><li>符号模式（ugo+rwx）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x 1.txt  # 所有者:rwx, 所属组:r-x, 其它用户: --x<br>chmod -x 1.txt    # 所有者, 所属组, 其它权限都去掉 x 权限<br>chmod u+x,g-r,o=rw 1.txt# 所有者 +x 权限, 所属组 -r 权限, 其它权限为: rw-<br></code></pre></td></tr></table></figure><ul><li>数字模式（八进制）</li></ul><table><thead><tr><th align="center">数字</th><th align="center">权限</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">4</td><td align="center"><code>r</code></td><td align="center">读</td></tr><tr><td align="center">2</td><td align="center"><code>w</code></td><td align="center">写</td></tr><tr><td align="center">1</td><td align="center"><code>x</code></td><td align="center">执行</td></tr><tr><td align="center">0</td><td align="center"><code>-</code></td><td align="center">无权限</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">三类用户（所有者 / 组 / 其他用户）分别对应一个数字，组合成三位数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7 = 4 (r) + 2 (w) + 1 (x) = rwx</span><br>chmod 764 file.txt  # 所有者：rwx，组：rw-，其他：r--<br>chmod 777 1.txt# 俗称: 满权限.<br></code></pre></td></tr></table></figure><h3 id="4-3-2-chown（修改文件归属）"><a href="#4-3-2-chown（修改文件归属）" class="headerlink" title="4.3.2 chown（修改文件归属）"></a>4.3.2 chown（修改文件归属）</h3><p><code>chown</code>源自 <strong>change owner</strong>，用于修改文件或目录的<strong>所有者</strong>和<strong>所属用户组</strong>。</p><p>普通用户无法修改所属为其它用户或组，所以此命令只适用于 root 用户执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown [-R] [用户] [:用户组] 文件/目录<br>-R 递归修改目录及其内容所属<br><br>chown zhangsan 1.txt   # 改变文件所有者<br>chown :python  1.txt   # 改变文件所属组<br>chown lisi:dev 1.txt   # 改变所有者和组<br>chown -R wangwu aa     # 改变所有者，包括目录子级<br></code></pre></td></tr></table></figure><h1 id="5-Linux-实用操作"><a href="#5-Linux-实用操作" class="headerlink" title="5 Linux 实用操作"></a>5 Linux 实用操作</h1><h2 id="5-1-常用快捷键"><a href="#5-1-常用快捷键" class="headerlink" title="5.1 常用快捷键"></a>5.1 常用快捷键</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Ctrl + C      # 强制结束（执行）<br>Ctrl + L      # 清屏，等价于 clear<br>Ctrl + D      # 强制登出账号，回到上一个账号，等价于 exit<br><br>Ctrl + A      # 跳转到命令 行首<br>Ctrl + E      # 跳转到命令 行尾<br>Ctrl + ←      # 上一个单词<br>Ctrl + →      # 下一个单词<br><br>history       # 查看历史命令<br>!命令名  # 在历史命令中匹配最近的命令<br>Ctrl + r      # 在历史命令中搜索命令<br></code></pre></td></tr></table></figure><h2 id="5-2-软件安装与服务管理"><a href="#5-2-软件安装与服务管理" class="headerlink" title="5.2 软件安装与服务管理"></a>5.2 软件安装与服务管理</h2><h3 id="5-2-1-yum（软件包管理）"><a href="#5-2-1-yum（软件包管理）" class="headerlink" title="5.2.1 yum（软件包管理）"></a>5.2.1 yum（软件包管理）</h3><p><code>yum</code> 是 Yellowdog Updater, Modified 的缩写，基于 rpm (Red Hat Package Manager) 的高级封装，自动解决依赖 + 仓库管理。类似于 windows 或 mac 的<strong>应用商店</strong>，直接从中查找并安装。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>安装软件</strong></td><td><code>yum install package</code></td><td>安装指定软件包及其依赖</td></tr><tr><td><strong>更新软件</strong></td><td><code>yum update package</code></td><td>更新指定软件包（不指定则更新所有）</td></tr><tr><td><strong>卸载软件</strong></td><td><code>yum remove package</code></td><td>删除软件包（保留配置文件）</td></tr><tr><td><strong>搜索软件</strong></td><td><code>yum search keyword</code></td><td>根据关键词搜索软件包</td></tr><tr><td><strong>列出已安装</strong></td><td><code>yum list installed</code></td><td>显示所有已安装的软件包</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum [-y] [install | update | remove | search] 包名<br>-y     # yes，在安装过程中自动回答 yes<br><br>yum -y install wget   # 通过 yum 安装 wget<br></code></pre></td></tr></table></figure><blockquote><p> Debian&#x2F;Ubuntu 系统中使用 <code>apt</code> 包管理工具，和 <code>yum</code> 格式一样，更改为 <code>apt</code> 即可。</p></blockquote><h3 id="5-2-2-systemctl（服务管理）"><a href="#5-2-2-systemctl（服务管理）" class="headerlink" title="5.2.2 systemctl（服务管理）"></a>5.2.2 systemctl（服务管理）</h3><p><code>systemctl</code> 源自 <strong>system control</strong>，是 Linux 系统中用于<strong>管理 systemd 系统和服务管理器</strong>的核心工具。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>启动服务</strong></td><td><code>systemctl start nginx</code></td><td>启动服务</td></tr><tr><td><strong>停止服务</strong></td><td><code>systemctl stop nginx</code></td><td>停止服务</td></tr><tr><td><strong>重启服务</strong></td><td><code>systemctl restart nginx</code></td><td>重启服务</td></tr><tr><td><strong>查看状态</strong></td><td><code>systemctl status nginx</code></td><td>显示服务运行状态和日志片段</td></tr><tr><td><strong>启用开机自启</strong></td><td><code>systemctl enable nginx</code></td><td>设置服务开机自启动</td></tr><tr><td><strong>禁用开机自启</strong></td><td><code>systemctl disable nginx</code></td><td>取消服务开机自启动</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status | enable | disable] 服务名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用服务</span><br>NetworkManager   # 主网络服务<br>network   # 副网络服务<br>firewalld   # 防火墙<br>sshd   # 远程连接服务<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关掉防火墙并取消开机自启动</span><br>systemctl stop firewalld<br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><h2 id="5-3-网络操作"><a href="#5-3-网络操作" class="headerlink" title="5.3 网络操作"></a>5.3 网络操作</h2><h3 id="5-3-1-诊断工具"><a href="#5-3-1-诊断工具" class="headerlink" title="5.3.1 诊断工具"></a>5.3.1 诊断工具</h3><h4 id="ifconfig（ip配置）"><a href="#ifconfig（ip配置）" class="headerlink" title="ifconfig（ip配置）"></a>ifconfig（ip配置）</h4><p><code>ifconfig</code> 源自 <strong>interface configuration</strong>，用于<strong>查看和配置网络接口</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h4 id="ping（连通性测试）"><a href="#ping（连通性测试）" class="headerlink" title="ping（连通性测试）"></a>ping（连通性测试）</h4><p><code>ping</code> 源自 <strong>Packet InterNet Groper</strong>，发送 ICMP 请求包，<strong>测试网络是否通畅及延迟</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping [-c Num] 域名 | ip<br>-c Num    # count，发送 N 次请求后停止<br><br>ping -c 3 baidu.com   # 向百度发送 3 次请求测试连通性<br></code></pre></td></tr></table></figure><h4 id="netstat（端口监听）"><a href="#netstat（端口监听）" class="headerlink" title="netstat（端口监听）"></a>netstat（端口监听）</h4><p><code>netstat</code> 源自 <strong>network statistics</strong>，用于<strong>查看网络连接、监听端口、路由信息</strong>。</p><ul><li>IP地址，设备在网络中的唯一标识</li><li>端口号，程序在设备上的唯一标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp   # 查看本机所有端口号<br>-anp           # 来源: all network port<br><br>netstat -anp | grep 3306    # 使用 grep 过滤查看 3306 端口号占用情况<br></code></pre></td></tr></table></figure><blockquote><p>计算机程序之间的通讯，通过 IP 只能确定计算机，但是无法确定具体的程序。通过端口可以确定计算机上具体的程序，确保程序之间进行沟通。<br>Linux 系统端口号范围: 0 ~ 65535，其中0 ~ 1023已经被用作系统端口或者保留端口了。</p></blockquote><h3 id="5-3-2-数据传输"><a href="#5-3-2-数据传输" class="headerlink" title="5.3.2 数据传输"></a>5.3.2 数据传输</h3><h4 id="wget（下载文件）"><a href="#wget（下载文件）" class="headerlink" title="wget（下载文件）"></a>wget（下载文件）</h4><p><code>wget</code> 源自 <strong>web get</strong>，用于<strong>从网络上下载文件</strong>，支持 HTTP、HTTPS、FTP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget url地址<br><br>wget https://img-home.csdnimg.cn/images/20201124032511.png   # 下载图片<br></code></pre></td></tr></table></figure><h4 id="curl（发送请求）"><a href="#curl（发送请求）" class="headerlink" title="curl（发送请求）"></a>curl（发送请求）</h4><p><code>curl</code> 源自 <strong>client URL</strong>，用于<strong>模拟浏览器发送请求</strong>，常用于测试 API、下载网页内容等，支持多种协议（HTTP、FTP、SFTP、SMTP）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl url地址<br><br>curl https://www.bilibili.com/    # 爬取哔哩哔哩网页代码<br></code></pre></td></tr></table></figure><h4 id="lrzsz（上传和下载）"><a href="#lrzsz（上传和下载）" class="headerlink" title="lrzsz（上传和下载）"></a>lrzsz（上传和下载）</h4><p><code>lrzsz</code> 源自 <strong>Linux Receive ZMODEM Send ZMODEM</strong>，也就是 Linux ZMODEM 收发工具，用于在终端环境中<strong>上传（<code>rz</code>）或下载（<code>sz</code>）文件</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rz           # 弹出文件选择窗口，选择文件后自动上传到当前目录<br>sz 文件名  # 弹出保存对话框，选择保存路径即可<br></code></pre></td></tr></table></figure><p>或者在 FinalShell、Tabby 等工具中直接拖拽即可上传下载。</p><p><img src="/../../../tool_assets/Pasted%20image%2020250730224752.png"></p><h2 id="5-4-进程管理"><a href="#5-4-进程管理" class="headerlink" title="5.4 进程管理"></a>5.4 进程管理</h2><p>程序运行在操作系统中，是被操作系统所管理的。为方便管理运行的程序，每一个程序在运行的时候都会被操作系统注册为系统中的一个<strong>进程</strong>，并会为每一个进程都分配一个独有的 PID。</p><h3 id="5-4-1-ps（查看进程）"><a href="#5-4-1-ps（查看进程）" class="headerlink" title="5.4.1 ps（查看进程）"></a>5.4.1 ps（查看进程）</h3><p><code>ps</code> 源自 <strong>process status</strong>，用于显示当前系统的<strong>进程状态信息</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps [-e -f]<br>-e       # every，列出所有进程<br>-f       # full format，显示完整格式<br><br>ps -ef                # 查看本机运行的所有进程<br>ps -ef | grep mysql  # 查看本机和MySQL相关的进程.<br></code></pre></td></tr></table></figure><h3 id="5-4-2-kill（结束进程）"><a href="#5-4-2-kill（结束进程）" class="headerlink" title="5.4.2 kill（结束进程）"></a>5.4.2 kill（结束进程）</h3><p>向进程发送信号（默认 <code>SIGTERM</code>），用于<strong>终止或控制进程</strong>。</p><table><thead><tr><th>信号编号</th><th>信号名</th><th>作用</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>SIGHUP</code></td><td>重启进程（重新加载配置）</td></tr><tr><td><code>2</code></td><td><code>SIGINT</code></td><td>中断进程（等同 <code>Ctrl+C</code>）</td></tr><tr><td><code>9</code></td><td><code>SIGKILL</code></td><td>强制终止（不可被忽略）</td></tr><tr><td><code>15</code></td><td><code>SIGTERM</code></td><td>优雅终止（默认信号）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill [-编号] PID<br><br>kill -9 进程的 PID# 强制杀死进程，不使用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制。<br></code></pre></td></tr></table></figure><h2 id="5-5-软链接和硬链接"><a href="#5-5-软链接和硬链接" class="headerlink" title="5.5 软链接和硬链接"></a>5.5 软链接和硬链接</h2><p><code>ln</code> 源自 <strong>link</strong>，用于<strong>文件共享</strong>。</p><ul><li>软链接：是一个独立的文件，内容为源文件的路径</li><li>硬链接：是文件系统的目录项，直接指向源文件的 inode</li></ul><table><thead><tr><th><strong>特性</strong></th><th>软链接（Symbolic Link）</th><th>硬链接（Hard Link）</th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>类似 Windows 的快捷方式</td><td>是原始文件的另一个名称（指向相同 inode）</td></tr><tr><td><strong>inode 号</strong></td><td>与源文件不同（新 inode）</td><td>与源文件相同（共享 inode）</td></tr><tr><td><strong>源文件删除</strong></td><td>软链接失效（“断链”）</td><td>硬链接仍有效（数据未删除）</td></tr><tr><td><strong>文件大小</strong></td><td>存储链接路径的字节数（较小）</td><td>不额外占用空间（与源文件共享数据块）</td></tr><tr><td><strong>命令</strong></td><td><code>ln -s 源文件 链接名</code></td><td><code>ln 源文件 链接名</code></td></tr></tbody></table><ul><li>软链接：若源文件被删除，软链接变成“悬空链接”（无法访问）</li><li>硬链接：删除源文件后，硬链接仍能访问数据（直到所有硬链接被删除）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">软链接，类似于 windows 的快捷方式</span><br>ln -s 要链接文件/目录的路径 软链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 ipcfg 配置文件创建软链接 ip</span> <br>ln -s /etc/sysconfig/network-scripts/ifcfg-ens33 ip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">硬链接，原始文件的别名，有点类似 C++ 的引用</span><br>ln 要链接文件的路径 硬链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 a.txt 的硬链接 b.txt</span><br>ln a.txt b.txt<br></code></pre></td></tr></table></figure><blockquote><p><strong>inode</strong>（Index Node）是 Linux&#x2F;Unix 文件系统中的一种<strong>元数据结构</strong>，用于存储文件的<strong>核心属性</strong>（如权限、大小、所有者、数据块位置等），但不包含文件名。每个文件或目录都有一个唯一的 inode，通过 inode 号标识。</p></blockquote><h2 id="5-6-压缩与解压缩"><a href="#5-6-压缩与解压缩" class="headerlink" title="5.6 压缩与解压缩"></a>5.6 压缩与解压缩</h2><p>区分压缩协议好坏, 可以参考三个维度: 压缩速度(写)，解压速度(读)，压缩后文件占比。</p><h3 id="5-6-1-tar"><a href="#5-6-1-tar" class="headerlink" title="5.6.1 tar"></a>5.6.1 tar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [-c -x -f -v -z] 目标文件 源文件或目录<br>-c   # create，创建新的归档文件（打包）<br>-x   # extract，解压归档文件<br>-f   # file，指定归档文件名（必须直接跟文件名，如 -f archive.tar）<br>-v   # verbose，显示操作过程的详细信息<br>-z   # gzip，使用 gzip 压缩/解压（生成 .tar.gz 或 .tgz 文件），文件更小<br>-C   # directory，指定解压到的目录（需放在选项最后）<br></code></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf 压缩包名.tar 要被压缩的文件1 文件2 文件夹        # 打包文件不压缩<br>tar -zcvf 压缩包名.tar.gz 要被压缩的文件1 文件2 文件夹    # 打包并用 gzip 压缩<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不指定 -C 默认解压到当前路径</span><br>tar -xvf 压缩包名.tar [-C 解压路径]      # 解压 tar 压缩包<br>tar -zxvf 压缩包名.tar.gz [-C 解压路径]  # 解压 tar.gz 压缩包<br></code></pre></td></tr></table></figure><h3 id="5-6-2-zip"><a href="#5-6-2-zip" class="headerlink" title="5.6.2 zip"></a>5.6.2 zip</h3><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip [-r] 压缩包名.zip 要被压缩的文件1 文件2 文件夹<br>-r    # 被压缩的包含文件夹的时候，需要使用-r选项<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip 压缩包名.zip [-d 解压路径]<br>-d    # 不指定 -d 默认解压到当前路径<br></code></pre></td></tr></table></figure><h1 id="6-远程连接虚拟机"><a href="#6-远程连接虚拟机" class="headerlink" title="6 远程连接虚拟机"></a>6 远程连接虚拟机</h1><ul><li>vim 编辑 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 文件</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250731141856.png"></p><ul><li>修改 VMware 的信息</li></ul><p><img src="/../../../tool_assets/1717040397072.png"></p><ul><li>修改本机 VMNet8 网卡信息</li></ul><p><img src="/../../../tool_assets/1717041247890.png"></p><ul><li>FinalShell 新建连接</li></ul><p><img src="/../../../tool_assets/1717041411950.png"></p><p>另外要确保 <code>services.msc</code> 中 Vmware 的 DHCP 和 NAT 服务在启动状态。</p><p><img src="/../../../tool_assets/Pasted%20image%2020250731142125.png"></p>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用指南</title>
    <link href="/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统！</p><h1 id="1-安装和配置Git"><a href="#1-安装和配置Git" class="headerlink" title="1 安装和配置Git"></a>1 安装和配置Git</h1><h2 id="1-1-Linux环境"><a href="#1-1-Linux环境" class="headerlink" title="1.1 Linux环境"></a>1.1 Linux环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否安装 git</span><br>git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS 系列</span><br>sudo yum install git <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu 系列</span><br>sudo apt install git<br></code></pre></td></tr></table></figure><h2 id="1-2-macOS环境"><a href="#1-2-macOS环境" class="headerlink" title="1.2 macOS环境"></a>1.2 macOS环境</h2><p>使用Homebrew可以很方便地安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 Homebrew 是否安装</span><br>brew -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Homebrew</span><br>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>brew install git<br></code></pre></td></tr></table></figure><h2 id="1-3-Windows环境"><a href="#1-3-Windows环境" class="headerlink" title="1.3 Windows环境"></a>1.3 Windows环境</h2><p>可以先安装一个包管理工具<a href="https://scoop.sh/">Scoop</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>scoop install git<br></code></pre></td></tr></table></figure><h2 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h2><p>由于Git是分布式版本控制系统，所以安装之后还要配置个人信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure><h1 id="2-版本库"><a href="#2-版本库" class="headerlink" title="2 版本库"></a>2 版本库</h1><p><strong>版本库又名仓库</strong>（Repository），可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪。</p><h2 id="2-1-创建版本库"><a href="#2-1-创建版本库" class="headerlink" title="2.1 创建版本库"></a>2.1 创建版本库</h2><p>进入文件夹执行<code>git init</code>命令就可以把这个目录变成Git管理的仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><blockquote><p>目录下会自动生成一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，不要乱动。</p></blockquote><p>如果想要把<code>.git</code>目录生成到别的文件夹，可以使用下面的命令指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init --separate-git-dir=D:/Develop/GitRecord<br></code></pre></td></tr></table></figure><p>实际是生成了一个<code>.git</code>文件里面写入了<code>gitdir: D:/Develop/GitRecord</code>。</p><h2 id="2-2-添加文件到版本库"><a href="#2-2-添加文件到版本库" class="headerlink" title="2.2 添加文件到版本库"></a>2.2 添加文件到版本库</h2><p>假设当前有一个仓库叫做DemoProject，在这个目录下创建文件<code>readme.txt</code>，把文件放入仓库一共需要两步。使用<code>add</code>添加多个文件到仓库，使用<code>commit</code>一次性提交到仓库。</p><ol><li><p>使用<code>git add</code>把文件添加到仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add readme.txt<br></code></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p></li><li><p>使用<code>git commit</code>把文件提交到仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;提交说明&quot;<br></code></pre></td></tr></table></figure></li></ol><p>如果想要把已有目录交给<code>git</code>管理，可以使用<code>git add .</code>将所有文件全部添加到暂存区，然后一次性<code>git commit</code>进行提交。</p><blockquote><p>所有的版本控制系统，都只能跟踪文本文件的改动，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化。另外不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。</p></blockquote><h2 id="2-3-Git工作流程"><a href="#2-3-Git工作流程" class="headerlink" title="2.3 Git工作流程"></a>2.3 Git工作流程</h2><p>牢记Git分为以下三个核心区域，它们是并列关系，构成了Git的核心工作流。</p><ul><li>**工作区 (Working Directory &#x2F; Working Tree)**：电脑上看到的实际目录，实际开发的地方</li><li>**暂存区 (Staging Area &#x2F; Index)**：一个缓存区，保存了 <code>git add</code> 准备提交的文件快照</li><li>**版本库 (Local Repository)**：已经 <code>git commit</code> 的所有历史版本</li></ul><blockquote><p>工作区有一个隐藏目录<code>.git</code>不算工作区，里面存储的是Git的<strong>版本库</strong>。暂存区（<code>index</code> 文件）虽然物理上位于 <code>.git</code> 目录中，但它不属于版本库。</p></blockquote><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的<strong>暂存区</strong>，还有Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><img src="/../../../tool_assets/repo.png"></p><p>了解了工作区和版本库，对于很多操作就明白实际是做什么了。</p><ul><li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区</li><li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支</li></ul><blockquote><p><strong>Git管理的是修改，而不是文件。</strong> 每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p></blockquote><h1 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3 版本管理"></a>3 版本管理</h1><h2 id="3-1-查看信息"><a href="#3-1-查看信息" class="headerlink" title="3.1 查看信息"></a>3.1 查看信息</h2><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，比如是否有文件修改（新增、删除都属于修改）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>modified:   readme.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br></code></pre></td></tr></table></figure><p><code>git diff</code>命令可以知道某个文件具体修改了什么内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff readme.txt<br></code></pre></td></tr></table></figure><p>提交修改和提交新文件是一样的，第一步<code>git add</code>，第二步<code>git commit</code>。</p><h2 id="3-2-版本回退"><a href="#3-2-版本回退" class="headerlink" title="3.2 版本回退"></a>3.2 版本回退</h2><p>每一次<code>commit</code>相当于一个版本，使用<code>git log</code>可以查看版本历史记录，加上<code>--pretty=oneline</code>参数可以让显示更清晰。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log [--pretty=oneline]<br></code></pre></td></tr></table></figure><p>使用<code>git reset</code>回到指定版本，Git中<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，更早的版本是<code>HEAD~n</code>，n表示上n个版本，也可以直接指定版本号（不用写全，Git会自动去找）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><h2 id="3-3-撤销修改"><a href="#3-3-撤销修改" class="headerlink" title="3.3 撤销修改"></a>3.3 撤销修改</h2><h3 id="3-3-1-未到暂存区"><a href="#3-3-1-未到暂存区" class="headerlink" title="3.3.1 未到暂存区"></a>3.3.1 未到暂存区</h3><p>使用<code>git checkout -- file</code>可以丢弃工作区的修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure><blockquote><p><code>--</code>  双破折号非常重要，它告诉 Git后面的参数是一个文件路径，而不是一个分支名。</p></blockquote><p>Git会执行以下操作：</p><ol><li>查找<strong>暂存区</strong>中 <code>readme.txt</code> 的版本（找不到会从 <code>HEAD</code>，即最后一次提交中恢复。）</li><li>用这个版本的文件<strong>覆盖</strong>工作目录中的 <code>readme.txt</code></li></ol><p>本质上这是一个反向的 <code>git add</code> 操作：<br><code>git add &lt;file&gt;</code> 会将工作目录中的文件快照存入暂存区（index）。<br><code>git checkout -- &lt;file&gt;</code> 会将暂存区里的文件快照<strong>还原</strong>到工作目录，从而丢弃对文件所做的所有本地修改。</p><h3 id="3-3-2-已到暂存区"><a href="#3-3-2-已到暂存区" class="headerlink" title="3.3.2 已到暂存区"></a>3.3.2 已到暂存区</h3><ol><li>使用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD readme.txt<br></code></pre></td></tr></table></figure></li></ol><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><ol start="2"><li>放回工作区后，暂存区是干净的，工作区有所修改，再使用未到暂存区的处理方式<code>git checkout -- file</code>。</li></ol><h2 id="3-4-删除文件"><a href="#3-4-删除文件" class="headerlink" title="3.4 删除文件"></a>3.4 删除文件</h2><p>当删除文件之后，工作区和版本库不一致，有两种选择。</p><ol><li>确实要从版本库删除该文件</li></ol><p>和添加文件类似，第一步<code>git rm</code>从暂存区移除，第二步<code>git commit</code>提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm readme.txt<br><br>git commit<br></code></pre></td></tr></table></figure><blockquote><p>先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和直接使用<code>git rm &lt;file&gt;</code>效果是完全相同的。</p></blockquote><ol start="2"><li>误删文件，想要恢复</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h1 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4 远程仓库"></a>4 远程仓库</h1><h2 id="4-1-SSH密钥配置"><a href="#4-1-SSH密钥配置" class="headerlink" title="4.1 SSH密钥配置"></a>4.1 SSH密钥配置</h2><ol><li>生成SSH密钥对</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>生成在C:\Users\你的用户名.ssh目录下，<code>id_ed25519.pub</code>是公钥，<code>id_ed25519</code>是私钥。</p><ol start="2"><li><p>将公钥添加到 GitHub</p><ul><li>打开 <code>C:\Users\你的用户名\.ssh\id_ed25519.pub</code>，复制内容</li><li>进入 GitHub → Settings → SSH and GPG keys → 添加新 SSH 密钥</li></ul></li><li><p>SSH测试连接</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果看到 <code>Hi 你的用户名! You&#39;ve successfully authenticated...</code> 说明 SSH 配置成功。</p><h2 id="4-2-添加到远程库"><a href="#4-2-添加到远程库" class="headerlink" title="4.2 添加到远程库"></a>4.2 添加到远程库</h2><ol><li>先在Github创建远程仓库，在本地仓库执行以下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure></li></ol><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><ol start="2"><li>使用<code>git remote -v</code>可以检查远程仓库地址：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure></li></ol><p>如果能显示下列信息，说明远程仓库配置没问题，可以进行推送和拉取了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">origin  git@github.com:账户名/仓库名.git (fetch)<br>origin  git@github.com:账户名/仓库名.git (push)<br></code></pre></td></tr></table></figure><h2 id="4-3-推送到远程库"><a href="#4-3-推送到远程库" class="headerlink" title="4.3 推送到远程库"></a>4.3 推送到远程库</h2><p>使用远程库比本地工作流程多一步push，为下面三步：</p><ol><li>把改动放入暂存区<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;文件&gt;<br></code></pre></td></tr></table></figure></li><li>把暂存区改动提交到本地仓库，生成一个新的commit<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;说明&quot;<br></code></pre></td></tr></table></figure></li><li>把本地仓库的commit推送到远程仓库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：如果远程仓库的默认分支是 <code>main</code>，命令里的 <code>master</code> 改成 <code>main</code> 即可。<br>Github后来把默认主分支改成<code>main</code>了。</p></blockquote><hr><p>每次推送执行<code>git push origin master</code>命令较长，推荐<strong>在第一次推送时</strong>加上<code>-u</code>参数，除了推送之外，它还会把本地分支 <code>master</code> 与远程分支 <code>origin/master</code> 关联起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin master<br></code></pre></td></tr></table></figure><p>与远程分支关联以后就可以简化命令，直接使用<code>push</code>推送，使用<code>pull</code>拉取，Git 就会自动知道本地的 <code>master</code> 对应远程的 <code>origin/master</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br>git pull<br></code></pre></td></tr></table></figure><h2 id="4-4-从远程库克隆"><a href="#4-4-从远程库克隆" class="headerlink" title="4.4 从远程库克隆"></a>4.4 从远程库克隆</h2><p>在本地目录运行下面命令即可克隆一个本地库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure><p><code>git clone</code> 下来的仓库，Git 会自动创建一个名为 <code>origin</code> 的远程别名，本地分支和远程分支已经自动关联了，一般直接 <code>git push / git pull</code> 就可以，不需要再手动 <code>-u</code>。</p><h1 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5 分支管理"></a>5 分支管理</h1>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Seaborn基本图表</title>
    <link href="/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/"/>
    <url>/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Seaborn 是对 Matplotlib 进行了更高级的封装，而且也能和 Pandas 无缝整合，可以用更少的代码构建出更好的统计图表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 联网加载官方的小费数据集</span><br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> ssl<br><br>ssl._create_default_https_context = ssl._create_unverified_context<br><br>tips_df = sns.load_dataset(<span class="hljs-string">&#x27;tips&#x27;</span>)<br>tips_df.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 244 entries, 0 to 243Data columns (total 7 columns): #   Column      Non-Null Count  Dtype---  ------      --------------  -----0   total_bill  244 non-null    float64 1   tip         244 non-null    float64 2   sex         244 non-null    category 3   smoker      244 non-null    category 4   day         244 non-null    category 5   time        244 non-null    category 6   size        244 non-null    int64dtypes: category(4), float64(2), int64(1)memory usage: 7.4 KB</code></pre><p>首先设置主题更好看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.set_theme()<br></code></pre></td></tr></table></figure><h1 id="1-直方图"><a href="#1-直方图" class="headerlink" title="1 直方图"></a>1 直方图</h1><p>Seaborn中的方法非常统一，基本上都可以直接给数据集，通过 <code>x</code>&#x2F;<code>y</code>设置坐标轴数据来源，大多数也可以使用 <code>hue</code>参数对某一字段进行分组聚合，通过 <code>palette</code>参数设置颜色搭配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, palette=<span class="hljs-string">&#x27;Dark2&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_6_1.png" alt="png"></p><p>直方图设置 <code>kde=True</code>参数可以得到核密度估计图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, kde=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_8_2.png" alt="png"></p><h1 id="2-核密度图"><a href="#2-核密度图" class="headerlink" title="2 核密度图"></a>2 核密度图</h1><p>核密度估计图（KDE，Kernel Density Estimate Plot）是一种用于显示数据分布的统计<br>图表，它通过平滑直方图的方法来估计数据的概率密度函数，使得分布图看起来更加<br>连续和平滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.kdeplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Density&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_11_1.png" alt="png"></p><h1 id="3-散点图"><a href="#3-散点图" class="headerlink" title="3 散点图"></a>3 散点图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.scatterplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_13_1.png" alt="png"></p><p>通过 <code>regplot()</code>函数绘制散点图，同时会拟合回归曲线，这个函数不支持使用 <code>hue</code>进行分组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.regplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_15_1.png" alt="png"></p><p>可以通过 <code>lmplot()</code>函数绘制分组回归曲线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.lmplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.FacetGrid at 0x169a85210&gt;</code></pre><p><img src="/../../../../ai_assets/output_17_1.png" alt="png"></p><p>通过 <code>jointplot()</code>函数绘制在每个轴上包含单个变量的散点图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.jointplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.JointGrid at 0x16b18afe0&gt;</code></pre><p><img src="/../../../../ai_assets/output_19_1.png" alt="png"></p><h1 id="4-箱线图"><a href="#4-箱线图" class="headerlink" title="4 箱线图"></a>4 箱线图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.boxplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;total_bill&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;total_bill&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_21_1.png" alt="png"></p><h1 id="5-小提琴图"><a href="#5-小提琴图" class="headerlink" title="5 小提琴图"></a>5 小提琴图</h1><p>相较于箱线图，小提琴图没有标注异常点而是显示了数据的整个范围，另一方面，小提琴图很好的展示了数据的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_24_1.png" alt="png"></p><p>按性别分组统计使用颜色区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, split=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_26_1%201.png" alt="png"></p><h1 id="6-成对关系图"><a href="#6-成对关系图" class="headerlink" title="6 成对关系图"></a>6 成对关系图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.pairplot(data=tips_df, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.PairGrid at 0x175b91570&gt;</code></pre><p><img src="/../../../../ai_assets/output_28_1.png" alt="png"></p><h1 id="7-自定义颜色"><a href="#7-自定义颜色" class="headerlink" title="7 自定义颜色"></a>7 自定义颜色</h1><p>使用Seaborn自带的调色板设置颜色，上述的绘图函数都可以设置 <code>palette</code>参数进行设置。</p><p><img src="/../../../../ai_assets/output_31_1.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Seaborn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Matplotlib数据可视化</title>
    <link href="/2024/08/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2024/08/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绘图流程"><a href="#1-绘图流程" class="headerlink" title="1 绘图流程"></a>1 绘图流程</h1><ol><li>创建画布 <code>plt.figure()</code></li><li>绘制图像 <code>plt.plot(x, y)</code>等</li><li>显示图像 <code>plt.show()</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_2_0.png" alt="svg"></p><p>使用以下魔法方法可以在画图的时候生成矢量图，图片更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">%config InlineBackend.figure_format=<span class="hljs-string">&#x27;svg&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="2-常用图形"><a href="#2-常用图形" class="headerlink" title="2 常用图形"></a>2 常用图形</h1><h2 id="2-1-折线图"><a href="#2-1-折线图" class="headerlink" title="2.1 折线图"></a>2.1 折线图</h2><p>绘制连续数据的折线图，适用于显示随时间或序列变化的趋势。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>&#x2F;<code>y</code>：横纵坐标数据</li><li><code>linestyle</code>：线的样式<ul><li><code>&#39;-&#39;</code></li><li><code>&#39;--&#39;</code></li><li><code>&#39;-.&#39;</code></li><li><code>&#39;:&#39;</code></li></ul></li><li><code>marker</code>：标记点的样式<ul><li><code>&#39;o&#39;</code></li><li><code>&#39;s&#39;</code></li><li><code>&#39;^&#39;</code></li></ul></li><li><code>color</code>：线的颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br><br>plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_8_0.png" alt="svg"></p><h2 id="2-2-柱形图"><a href="#2-2-柱形图" class="headerlink" title="2.2 柱形图"></a>2.2 柱形图</h2><p>绘制垂直的柱状图，用于比较不同类别的数量或数值大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.bar(x, height, width=<span class="hljs-number">0.8</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>：柱子横坐标</li><li><code>height</code>：柱子的高度</li><li><code>width</code>：柱子宽度（0~1）</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br>height = [<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>]<br><br>plt.bar(x, height, color=<span class="hljs-string">&#x27;b&#x27;</span>, width=<span class="hljs-number">0.5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_11_0.png" alt="svg"></p><h2 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 条形图</h2><p>绘制横向的柱状图，在类别名称较长时更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.barh(y, width, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>y</code>: 柱子的纵坐标</li><li><code>width</code>: 柱子的长度</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">y = [<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>]<br>width = [<span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">50</span>]<br><br>plt.barh(y, width)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_14_0.png" alt="svg"></p><h2 id="2-4-直方图"><a href="#2-4-直方图" class="headerlink" title="2.4 直方图"></a>2.4 直方图</h2><p>用于展示数据的分布情况，将数据分成若干个区间 (bin)，并统计每个区间内的数据数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.hist(data, bins=<span class="hljs-number">10</span>, color=<span class="hljs-string">&#x27;purple&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>data</code>：一维数据集</li><li><code>bins</code>：分组数量</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>data = np.random.randn(<span class="hljs-number">1000</span>)<br><br>plt.hist(data, bins=<span class="hljs-number">20</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_17_0.png" alt="svg"></p><h2 id="2-5-饼图"><a href="#2-5-饼图" class="headerlink" title="2.5 饼图"></a>2.5 饼图</h2><p>用于展示不同类别在总体中所占的比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.pie(sizes, labels=labels, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>, explode=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>sizes</code>：各部分的数值</li><li><code>labels</code>：各部分的名称</li><li><code>autopct</code>：显示百分比的格式字符串</li><li><code>explode</code>：突出显示指定扇形，控制凸起程度</li><li><code>pctdistance</code>：百分比离圆心的距离，单位为半径</li><li><code>labeldistance</code>：标签离圆心的距离，单位为半径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lan = [<span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C#&#x27;</span>, <span class="hljs-string">&#x27;Others&#x27;</span>]<br>rate = [<span class="hljs-number">8.84</span>, <span class="hljs-number">24.45</span>, <span class="hljs-number">8.35</span>, <span class="hljs-number">1.92</span>, <span class="hljs-number">1.38</span>, <span class="hljs-number">9.29</span>, <span class="hljs-number">6.94</span>, <span class="hljs-number">38.83</span>]<br>ex = [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>plt.pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_20_0.png" alt="svg"></p><h2 id="2-6-散点图"><a href="#2-6-散点图" class="headerlink" title="2.6 散点图"></a>2.6 散点图</h2><p>用于展示两个变量之间的关系，每个数据点在图上表示为一个点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, s=<span class="hljs-number">50</span>, alpha=<span class="hljs-number">0.6</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>&#x2F;<code>y</code>：横纵坐标</li><li><code>color</code>：点的颜色（只能指定一个）</li><li><code>c</code>：可以使用颜色列表</li><li><code>s</code>：点的大小</li><li><code>alpha</code>：点的透明度</li><li><code>label</code>：图例</li><li><code>cmap</code>: 颜色映射，将数值映射到颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">sx = np.random.rand(<span class="hljs-number">100</span>)<br>sy = np.random.rand(<span class="hljs-number">100</span>)<br>colors = np.random.rand(<span class="hljs-number">100</span>)<br>sizes = <span class="hljs-number">100</span> * np.random.rand(<span class="hljs-number">100</span>)<br><br>plt.scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_23_0.png" alt="svg"></p><h2 id="2-7-箱线图"><a href="#2-7-箱线图" class="headerlink" title="2.7 箱线图"></a>2.7 箱线图</h2><p>箱线图又叫箱型图或盒须图，是一种用于展示一组数据分散情况的统计图表。</p><ul><li>箱子中间线：中位数（Median）</li><li>箱子上边界：上四分位（Q3）</li><li>箱子下边界：下四分位（Q1）</li><li>箱子的长度：四分位距离（IQR）</li><li>“最大值”：其实是上须（upper whisker），不被离群值影响的范围，Q3+1.5*IQR</li><li>“最小值”：下须（lower whisker），Q1-1.5*IQR</li><li>离群值：异常值，超出须的点</li></ul><p><img src="/../../../../ai_assets/output_26_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">box_data = &#123;  <br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">82</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">70</span>, <span class="hljs-number">90</span>, <span class="hljs-number">76</span>, <span class="hljs-number">84</span>, <span class="hljs-number">83</span>, <span class="hljs-number">95</span>],  <br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">79</span>, <span class="hljs-number">93</span>, <span class="hljs-number">88</span>, <span class="hljs-number">82</span>, <span class="hljs-number">87</span>, <span class="hljs-number">89</span>, <span class="hljs-number">92</span>],  <br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">72</span>, <span class="hljs-number">68</span>, <span class="hljs-number">65</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>]  <br>&#125;  <br>  <br>plt.boxplot(box_data.values(), tick_labels=box_data.keys())  <br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_27_0.png"></p><h1 id="3-图表元素"><a href="#3-图表元素" class="headerlink" title="3 图表元素"></a>3 图表元素</h1><h2 id="3-1-中文问题"><a href="#3-1-中文问题" class="headerlink" title="3.1 中文问题"></a>3.1 中文问题</h2><p>Matplotlib中文兼容有问题，可以使用SimSun（宋体），SimHei（黑体），Kaiti（楷体）等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># plt.rcParams[&#x27;font.family&#x27;] = [&#x27;Microsoft YaHei&#x27;]  # Windows正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># Mac正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 正常显示负号</span><br></code></pre></td></tr></table></figure><h2 id="3-2-图表标题与网格线"><a href="#3-2-图表标题与网格线" class="headerlink" title="3.2 图表标题与网格线"></a>3.2 图表标题与网格线</h2><ul><li><code>plt.title()</code>：设置图表标题<ul><li><code>fontdict</code>：设置字体</li><li><code>loc</code>：设置标题位置</li></ul></li><li><code>plt.grid()</code>：设置网格线<ul><li><code>axis</code>：控制轴向，有 <code>x</code>、<code>y</code>、<code>both</code></li><li><code>linestyle</code>：线的样式，<code>:</code>、<code>--</code>、<code>-.</code>、<code>-</code></li><li><code>linewidth</code>：线的粗细</li><li><code>alpha</code>：透明度</li><li><code>color</code>：颜色</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.title(<span class="hljs-string">&#x27;趋势图&#x27;</span>, loc=<span class="hljs-string">&#x27;left&#x27;</span>)<br>plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_30_0.png" alt="svg"></p><h2 id="3-3-坐标轴相关"><a href="#3-3-坐标轴相关" class="headerlink" title="3.3 坐标轴相关"></a>3.3 坐标轴相关</h2><ul><li><code>plt.xlabel()</code>：设置x轴标题</li><li><code>plt.ylabel()</code>：设置y轴标题</li><li><code>plt.xlim()</code>：设置x轴范围</li><li><code>plt.ylim()</code>：设置y轴范围</li><li><code>plt.xticks(&#39;刻度位置（数值）&#39;, &#39;显示值&#39;)</code>：设置x轴显示的刻度值</li><li><code>plt.yticks(&#39;刻度位置&#39;, &#39;显示值&#39;)</code>：设置y轴显示的刻度值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xlabel(<span class="hljs-string">&#x27;月份&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;销售额&#x27;</span>)<br><br>idx = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br>mon = [<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;月&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br><br>plt.xticks(idx, mon)<br>plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">13</span>)<br>plt.ylim(<span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(10000.0, 100000.0)</code></pre><p><img src="/../../../../ai_assets/output_33_1.png" alt="svg"></p><h2 id="3-4-显示图例"><a href="#3-4-显示图例" class="headerlink" title="3.4 显示图例"></a>3.4 显示图例</h2><p>设置完 <code>label</code>参数之后，使用 <code>plt.legend()</code>才能显示图例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成数据</span><br>x1 = np.arange(-<span class="hljs-number">1</span>*np.pi, np.pi, <span class="hljs-number">0.05</span>)<br>y1 = np.sin(x1)<br>y2 = np.cos(x1)<br><br><span class="hljs-comment"># 设置x轴刻度</span><br>plt.xticks([-<span class="hljs-number">1</span>*np.pi, -<span class="hljs-number">0.5</span>*np.pi, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>*np.pi, np.pi],<br>           [<span class="hljs-string">&#x27;-π&#x27;</span>, <span class="hljs-string">&#x27;-1/2π&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1/2π&#x27;</span>, <span class="hljs-string">&#x27;π&#x27;</span>])<br><br><span class="hljs-comment"># 作图</span><br>plt.plot(x1, y1, label=<span class="hljs-string">&#x27;y1=sin(x)&#x27;</span>)<br>plt.plot(x1, y2, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>,label=<span class="hljs-string">&#x27;y2=cos(x)&#x27;</span>)<br><br>plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x1e60c67bf70&gt;</code></pre><p><img src="/../../../../ai_assets/output_36_1.png" alt="svg"></p><h1 id="4-一图多表"><a href="#4-一图多表" class="headerlink" title="4 一图多表"></a>4 一图多表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, figsize=(width, height))<br></code></pre></td></tr></table></figure><ul><li>nrows：子图的行数</li><li>ncols：子图的列数</li><li>figsize：画布的大小</li><li>fig：返回的画布对象，用于调整整体的属性</li><li>axs：返回的子图数组，用于绘制各个子图，是一个Numpy数组，可以通过 <code>axs[0, 1]</code>访问特定子图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_39_0.png" alt="svg"></p><p>上一章的图形依次放入子图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].barh(y, width)<br>axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].hist(data, bins=<span class="hljs-number">20</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.collections.PathCollection at 0x1e60cec4880&gt;</code></pre><p>为了精确地控制子图，使用对象式写法 <code>axs.set_方法名</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;语言占比图&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;语言占比图&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_44_0.png" alt="svg"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Pandas数据操作和清洗</title>
    <link href="/2024/08/18/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/"/>
    <url>/2024/08/18/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本数据操作"><a href="#1-基本数据操作" class="headerlink" title="1 基本数据操作"></a>1 基本数据操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df1 = pd.read_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(df1)<br>df2 = pd.DataFrame(data=&#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;钱七&#x27;</span>], <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">66</span>], <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">99</span>], <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">77</span>]&#125;)<br><span class="hljs-built_in">print</span>(df2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60   姓名  语文  数学  英语0  赵六  50  88  201  钱七  66  99  77</code></pre><h2 id="1-1-新增列-行"><a href="#1-1-新增列-行" class="headerlink" title="1.1 新增列&#x2F;行"></a>1.1 新增列&#x2F;行</h2><p>增加列使用 <code>df[&#39;新列名&#39;] = 新列值</code>，会在原数据上直接添加，如果列名已存在则会覆盖原列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;历史&#x27;</span>] = [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>  </tbody></table></div><p>使用 <code>df.loc[&#39;新索引&#39;] = 新行值</code>，会在原数据上直接添加，如果索引已存在则会覆盖原索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[<span class="hljs-number">1001</span>] = [<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">199</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">66</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><p>使用 <code>assign()</code>方法实现列的新增，返回一个新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(<br>    新列<span class="hljs-number">1</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">111</span>,<span class="hljs-number">1111</span>],<br>    新列<span class="hljs-number">2</span>=[<span class="hljs-number">6</span>, <span class="hljs-number">66</span>, <span class="hljs-number">666</span>, <span class="hljs-number">6666</span>]  <br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>      <th>新列1</th>      <th>新列2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>      <td>1</td>      <td>6</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>      <td>11</td>      <td>66</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>      <td>111</td>      <td>666</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>      <td>1111</td>      <td>6666</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(加权分=<span class="hljs-keyword">lambda</span> x: df1[<span class="hljs-string">&#x27;语文&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;数学&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;英语&#x27;</span>]*<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>      <td>84.0</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>      <td>129.6</td>    </tr>  </tbody></table></div><h2 id="1-2-删除列-行"><a href="#1-2-删除列-行" class="headerlink" title="1.2 删除列&#x2F;行"></a>1.2 删除列&#x2F;行</h2><p>使用 <code>drop</code>函数删除，默认沿着0轴，也就是行进行删除，使用 <code>axis=1</code>表示对列操作，返回新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-string">&#x27;历史&#x27;</span>, axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-number">1001</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>  </tbody></table></div><h2 id="1-3-修改元素值"><a href="#1-3-修改元素值" class="headerlink" title="1.3 修改元素值"></a>1.3 修改元素值</h2><h3 id="1-3-1-直接修改"><a href="#1-3-1-直接修改" class="headerlink" title="1.3.1 直接修改"></a>1.3.1 直接修改</h3><p>通过索引操作会直接修改原表的值，一般不建议在原表直接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[df1[<span class="hljs-string">&#x27;姓名&#x27;</span>] == <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>] = <span class="hljs-number">666</span><br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><h3 id="1-3-2-replace函数"><a href="#1-3-2-replace函数" class="headerlink" title="1.3.2 replace函数"></a>1.3.2 replace函数</h3><p><code>replace()</code>：替换指定值（任意类型都可以），返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.replace(val, new_val, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.replace(<span class="hljs-number">80</span>, <span class="hljs-number">999</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>999</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>999</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><p>Pandas字符串和Python原生字符串的操作几乎一致，只需要在操作前加上一个 <code>.str</code>即可。</p><p><code>str.replace()</code>：替换指定字符串，只能是字符串，返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.<span class="hljs-built_in">str</span>.replace(<span class="hljs-built_in">str</span>, new_str, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;姓名&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;朱八八&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0        张三1       朱八八2        王五1001    猪猪侠Name: 姓名, dtype: object</code></pre><blockquote><p><code>str</code>中只包含文本对象，而 <code>object</code>中什么类型（数字、文本、布尔）都能往里装，实际应用中当做字符串处理即可</p></blockquote><h2 id="1-4-选取数据"><a href="#1-4-选取数据" class="headerlink" title="1.4 选取数据"></a>1.4 选取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><h3 id="1-4-1-使用索引"><a href="#1-4-1-使用索引" class="headerlink" title="1.4.1 使用索引"></a>1.4.1 使用索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>88</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>82</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>80</td>      <td>60</td>    </tr>    <tr>      <th>1001</th>      <td>199</td>      <td>50</td>    </tr>  </tbody></table></div><h3 id="1-4-2-有条件筛选"><a href="#1-4-2-有条件筛选" class="headerlink" title="1.4.2 有条件筛选"></a>1.4.2 有条件筛选</h3><p>使用 <code>loc</code>筛选出语文大于80并且数学比最低分高的人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[(df1[<span class="hljs-string">&#x27;语文&#x27;</span>] &gt; <span class="hljs-number">80</span>) &amp; (df1[<span class="hljs-string">&#x27;数学&#x27;</span>] &gt; df1[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>  </tbody></table></div><h1 id="2-合并与连接"><a href="#2-合并与连接" class="headerlink" title="2 合并与连接"></a>2 合并与连接</h1><h2 id="2-1-纵向连接"><a href="#2-1-纵向连接" class="headerlink" title="2.1 纵向连接"></a>2.1 纵向连接</h2><p><code>concat()</code>：多表连接，默认按照列字段连接，类似SQL中的UNION。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span>, 表<span class="hljs-number">3</span>], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&#x27;outer&#x27;</span>, ignore_index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认纵向连接</li><li>join：对不齐的标签如何处理<ul><li><code>&#39;outer&#39;</code>：默认值，取并集</li><li><code>&#39;inner&#39;</code>：取交集</li></ul></li><li>ignore_index：是否重建索引，默认False，不重建可能有重复索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([df1, df2])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80.0</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50.0</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70.0</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66.0</td>    </tr>    <tr>      <th>0</th>      <td>赵六</td>      <td>50</td>      <td>88</td>      <td>20</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>钱七</td>      <td>66</td>      <td>99</td>      <td>77</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="2-2-横向连接"><a href="#2-2-横向连接" class="headerlink" title="2.2 横向连接"></a>2.2 横向连接</h2><p><code>merge()</code>：类似SQL的JOIN，需要指定连接依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">merge(left, right, how=<span class="hljs-string">&#x27;inner&#x27;</span>, on=<span class="hljs-literal">None</span>, left_on=<span class="hljs-literal">None</span>, right_on=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>left&#x2F;right：要连接的左表和右表</li><li>how：连接方式<ul><li><code>&#39;inner&#39;</code>：内连接（默认）</li><li><code>&#39;left&#39;</code>：左连接</li><li><code>&#39;right&#39;</code>：右连接</li><li><code>&#39;outer&#39;</code>：外连接</li></ul></li><li>on：两边都有的列名，作为连接键</li><li>left_on&#x2F;right_on：两表列名不一样时使用</li><li>left_index&#x2F;right_index：都设置为True，使用索引作为连接键</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>,<span class="hljs-number">58</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>,<span class="hljs-number">70</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>,<span class="hljs-number">88</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>,<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>])<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">76</span>],<span class="hljs-string">&#x27;舞蹈&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>,<span class="hljs-string">&#x27;刘强&#x27;</span>])<br>display(df1)<br>display(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>  </tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>93</td>      <td>87</td>    </tr>    <tr>      <th>王明</th>      <td>80</td>      <td>99</td>    </tr>    <tr>      <th>铁蛋</th>      <td>85</td>      <td>95</td>    </tr>    <tr>      <th>刘强</th>      <td>76</td>      <td>85</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 内连接</span><br>pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;inner&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93</td>      <td>87</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80</td>      <td>99</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85</td>      <td>95</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 左连接</span><br>df3 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全连接</span><br>df4 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;outer&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h1 id="3-排序与TOP-N"><a href="#3-排序与TOP-N" class="headerlink" title="3 排序与TOP-N"></a>3 排序与TOP-N</h1><h2 id="3-1-索引排序与值排序"><a href="#3-1-索引排序与值排序" class="headerlink" title="3.1 索引排序与值排序"></a>3.1 索引排序与值排序</h2><p><code>sort_index()</code>：按照索引排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp_df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>]&#125;,<br>                        index = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Cathy&#x27;</span>, <span class="hljs-string">&#x27;David&#x27;</span>])<br>display(tmp_df)<br>display(tmp_df.sort_index())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>Bob</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>Alice</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>Cathy</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>David</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>  </tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>Alice</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>Bob</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>Cathy</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>David</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>  </tbody></table></div><p><code>sort_values()</code>：按每一列或多列的值进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.sort_values(by, ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>by：列名或列名列表</li><li>ascending：排序规则<ul><li><code>True</code>：升序排序（默认）</li><li><code>False</code>：降序排序</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文升序排序，语文相同按照数学降序排序</span><br>sort_df3 = df3.sort_values([<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>], ascending=[<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])<br>sort_df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="3-2-TOP-N问题"><a href="#3-2-TOP-N问题" class="headerlink" title="3.2 TOP-N问题"></a>3.2 TOP-N问题</h2><p>排序之后使用 <code>head(n)</code>可以完成TOP-N问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sort_df3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>  </tbody></table></div><p>解决TOP-N问题时，并不需要对所有数据进行排序，使用 <code>nlargest()</code>和 <code>nsmallest()</code>更加高效：</p><ul><li><code>nlargest(n, 列)</code>：返回指定列最大的前n项</li><li><code>nsmallest(n, 列)</code>：返回指定列最小的前n项</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nlargest(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nsmallest(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;语文&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>  </tbody></table></div><h2 id="3-3-rank函数"><a href="#3-3-rank函数" class="headerlink" title="3.3 rank函数"></a>3.3 rank函数</h2><p>类似MySQL的开窗函数，用于新增一列排名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank = pd.concat([df1, df1])<br>df_rank<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank[<span class="hljs-string">&#x27;排名&#x27;</span>] = df_rank.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).rank(method=<span class="hljs-string">&#x27;min&#x27;</span>)<br>df_rank.sort_values(<span class="hljs-string">&#x27;排名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>排名</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>1.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>1.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>3.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>3.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>5.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>5.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>7.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>7.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>9.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>9.0</td>    </tr>  </tbody></table></div><h1 id="4-特殊值处理"><a href="#4-特殊值处理" class="headerlink" title="4 特殊值处理"></a>4 特殊值处理</h1><h2 id="4-1-缺失值处理"><a href="#4-1-缺失值处理" class="headerlink" title="4.1 缺失值处理"></a>4.1 缺失值处理</h2><h3 id="4-1-1-识别缺失值"><a href="#4-1-1-识别缺失值" class="headerlink" title="4.1.1 识别缺失值"></a>4.1.1 识别缺失值</h3><p><code>isna()</code>：返回布尔值，标记缺失值位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.isna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>True</td>      <td>True</td>      <td>True</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>李华</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>李雷</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>True</td>      <td>True</td>    </tr>    <tr>      <th>王明</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>铁蛋</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>True</td>      <td>True</td>    </tr>  </tbody></table></div><h3 id="4-1-2-删除缺失值"><a href="#4-1-2-删除缺失值" class="headerlink" title="4.1.2 删除缺失值"></a>4.1.2 删除缺失值</h3><p><code>dropna()</code>：删除缺失值所在行或列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.dropna(axis=<span class="hljs-number">0</span>, how=<span class="hljs-string">&#x27;any&#x27;</span>, subset=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认为0删除行，1表示删除列</li><li>how：<ul><li><code>&#39;any&#39;</code>：只要有一个NaN就删除（默认）</li><li><code>&#39;all&#39;</code>：全部为NaN才删除</li></ul></li><li>subset：指定在哪些列上检查是否为NaN，多列需要使用 <code>[]</code></li><li>inplace：是否在原表修改，默认为False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p>返回新对象，如需修改原数据需设置 <code>inplace</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除所有出现空值的行</span><br>df4.dropna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>通过设置 <code>subset</code>参数删除指定列出现空值的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只删除语文和数学列出现空值的行</span><br>df4.dropna(subset=[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h3 id="4-1-3-填充空缺值"><a href="#4-1-3-填充空缺值" class="headerlink" title="4.1.3 填充空缺值"></a>4.1.3 填充空缺值</h3><p><code>fillna()</code>将空缺值填充为指定值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.fillna(value=<span class="hljs-literal">None</span>, method=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>value：数值或字典</li><li>method：基于近邻值填充<ul><li><code>&#39;ffill&#39;</code>：用前一个值填充</li><li><code>&#39;bfill&#39;</code>：用后一个值填充</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>全部填充为指定值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>0.0</td>      <td>0.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>0.0</td>      <td>0.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p><code>fillna(&#123;&#39;列名1&#39;: 值1, &#39;列名2&#39;, 值2...&#125;)</code>可以设定每个列的空值如何填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 篮球填充为50，舞蹈填充为平均值</span><br>df3.fillna(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;舞蹈&#x27;</span>: df3[<span class="hljs-string">&#x27;舞蹈&#x27;</span>].mean()&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>50.0</td>      <td>93.666667</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>50.0</td>      <td>93.666667</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.000000</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.000000</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.000000</td>    </tr>  </tbody></table></div><h2 id="4-2-去除重复项"><a href="#4-2-去除重复项" class="headerlink" title="4.2 去除重复项"></a>4.2 去除重复项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">99</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>])<br>df5 = pd.concat([df3, tmp])<br>df5.reset_index(names=<span class="hljs-string">&#x27;姓名&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>6</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p><code>drop_duplicates()</code>：删除重复行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.drop_duplicates(subset=<span class="hljs-literal">None</span>, keep=<span class="hljs-string">&#x27;first&#x27;</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>subset：指定在哪些列上检查是否重复，多列需要使用 <code>[]</code>，默认为所有列</li><li>keep：保留哪个重复项<ul><li><code>&#39;first&#39;</code>：保留第一次出现的（默认）</li><li><code>&#39;last&#39;</code>：保留最后一次出现的</li><li><code>False</code>：重复项全部删除</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除完全重复的行</span><br>df5.drop_duplicates()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p>按照姓名的重复值进行删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>保留最后一个出现的重复值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>, keep=<span class="hljs-string">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>6</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h1 id="5-类型转换与数据变形"><a href="#5-类型转换与数据变形" class="headerlink" title="5 类型转换与数据变形"></a>5 类型转换与数据变形</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="5-1-数据类型转换"><a href="#5-1-数据类型转换" class="headerlink" title="5.1 数据类型转换"></a>5.1 数据类型转换</h2><ul><li><code>dtypes</code>：查看每列的数据类型</li><li><code>astype()</code>：转换数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果有空值，转换为int会报错，需要先处理</span><br>display(df4.dtypes)<br>df4[<span class="hljs-string">&#x27;篮球&#x27;</span>] = df4[<span class="hljs-string">&#x27;篮球&#x27;</span>].fillna(<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;i4&#x27;</span>)<br>display(df4.dtypes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文    float64数学    float64英语    float64篮球    float64舞蹈    float64dtype: object语文    float64数学    float64英语    float64篮球      int32舞蹈    float64dtype: object</code></pre><ul><li><code>to_datetime()</code>: 将字符串转换为日期时间类型</li><li><code>round(n)</code>：保留n位小数</li><li><code>astype(&#39;category&#39;)</code>：转换为分类数据类型</li></ul><p>有一种特殊的数据类型 <code>category</code> 对应于统计学中的分类变量。这种变量的特点是：</p><ul><li>有限且固定：取值是有限的、通常是固定的一组可能的值</li><li>标签或名称：数据本质上是标签或名称，而不是可以进行数学运算的数值</li></ul><p>常见例子： 性别（男&#x2F;女）、血型（A&#x2F;B&#x2F;O&#x2F;AB）、等级（高&#x2F;中&#x2F;低）、国家名称等。</p><p><code>category</code> 对于每种类别存储一次，然后用较小的整数来表示 Series 中的每个值，并映射回实际的类别名称，可以大大节省内存并且提高性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;列&#x27;</span>].astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-2-行列转置"><a href="#5-2-行列转置" class="headerlink" title="5.2 行列转置"></a>5.2 行列转置</h2><p>行变列，列变行，使用 <code>df.T</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.T<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>韩梅梅</th>      <th>李雷</th>      <th>李华</th>      <th>王明</th>      <th>铁蛋</th>    </tr>  </thead>  <tbody>    <tr>      <th>语文</th>      <td>93.0</td>      <td>80.0</td>      <td>85.0</td>      <td>85.0</td>      <td>58.0</td>    </tr>    <tr>      <th>数学</th>      <td>87.0</td>      <td>99.0</td>      <td>95.0</td>      <td>85.0</td>      <td>70.0</td>    </tr>    <tr>      <th>英语</th>      <td>80.0</td>      <td>85.0</td>      <td>97.0</td>      <td>65.0</td>      <td>88.0</td>    </tr>    <tr>      <th>篮球</th>      <td>NaN</td>      <td>NaN</td>      <td>93.0</td>      <td>80.0</td>      <td>85.0</td>    </tr>    <tr>      <th>舞蹈</th>      <td>NaN</td>      <td>NaN</td>      <td>87.0</td>      <td>99.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><h2 id="5-3-分列操作"><a href="#5-3-分列操作" class="headerlink" title="5.3 分列操作"></a>5.3 分列操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Full_Name&#x27;</span>: [<span class="hljs-string">&#x27;Alice Smith&#x27;</span>, <span class="hljs-string">&#x27;Bob Johnson&#x27;</span>, <span class="hljs-string">&#x27;Charlie Brown&#x27;</span>]&#125;)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie Brown</td>    </tr>  </tbody></table></div><p>利用字符串方法按分隔符拆分字符串列，生成多列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分割，返回列表</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      [Alice, Smith]1      [Bob, Johnson]2    [Charlie, Brown]Name: Full_Name, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用expand参数变成多列</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[[<span class="hljs-string">&#x27;First_Name&#x27;</span>, <span class="hljs-string">&#x27;Last_Name&#x27;</span>]] =  df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>      <th>First_Name</th>      <th>Last_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice Smith</td>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob Johnson</td>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie Brown</td>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><h1 id="6-文本与分箱处理"><a href="#6-文本与分箱处理" class="headerlink" title="6 文本与分箱处理"></a>6 文本与分箱处理</h1><h2 id="6-1-文本数据处理"><a href="#6-1-文本数据处理" class="headerlink" title="6.1 文本数据处理"></a>6.1 文本数据处理</h2><p>Pandas中文本数据使用 <code>object</code>类型存储，先使用一个 <code>.str</code>把其当做 <code>str</code>进行处理，然后就和Python原生的字符串处理方式一致了，字符串处理函数会对<strong>每个元素单独进行处理</strong>。常用字符串处理函数：</p><ul><li><code>lower()</code>：转换为小写</li><li><code>upper()</code>：转换为大写</li><li><code>replace(old, new)</code>：替换指定字符串</li><li><code>split(sep)</code>：按指定分隔符拆分字符串，返回一个列表</li><li><code>strip()</code>：去除字符串两端的空白字符</li><li><code>contains(sub)</code>：判断是否包含指定子字符串，返回布尔值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;First_Name&#x27;</span>].<span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.strings.accessor.StringMethods at 0x2be226bf700&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>] = df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.upper()<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>      <th>First_Name</th>      <th>Last_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>ALICE SMITH</td>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>BOB JOHNSON</td>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>CHARLIE BROWN</td>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><h2 id="6-2-数据分箱"><a href="#6-2-数据分箱" class="headerlink" title="6.2 数据分箱"></a>6.2 数据分箱</h2><p><code>cut</code>：把数据离散化，用于一维数组的分类和打标，返回一个Series区间对象，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.cut(x, bins, right=<span class="hljs-literal">True</span>, labels=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>x：要分箱的序列</li><li>bins：分箱方式<ul><li>整数：等宽分为几段</li><li>列表：自定义分箱边界</li></ul></li><li>right：是否包含右边界，默认包含</li><li>labels：给分箱结果贴标签</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df7 = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;班级&#x27;</span>: [<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>],<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;小刚&#x27;</span>,<span class="hljs-string">&#x27;小李&#x27;</span>,<span class="hljs-string">&#x27;小张&#x27;</span>,<span class="hljs-string">&#x27;小赵&#x27;</span>],<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">35</span>, <span class="hljs-number">83</span>, <span class="hljs-number">45</span>, <span class="hljs-number">95</span>, <span class="hljs-number">72</span>],<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">92</span>],<br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">95</span>, <span class="hljs-number">80</span>, <span class="hljs-number">78</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">90</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">level = pd.cut(df7[<span class="hljs-string">&#x27;语文&#x27;</span>], bins=[<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>], labels=[<span class="hljs-string">&#x27;不及格&#x27;</span>, <span class="hljs-string">&#x27;及格&#x27;</span>, <span class="hljs-string">&#x27;中等&#x27;</span>, <span class="hljs-string">&#x27;良好&#x27;</span>, <span class="hljs-string">&#x27;优秀&#x27;</span>])<br>level<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     及格1    不及格2     良好3    不及格4     优秀5     中等Name: 语文, dtype: categoryCategories (5, object): [&#39;不及格&#39; &lt; &#39;及格&#39; &lt; &#39;中等&#39; &lt; &#39;良好&#39; &lt; &#39;优秀&#39;]</code></pre><p>给原数组加上一列分箱区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>] = level<br>df7<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>语文水平</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>一班</td>      <td>小明</td>      <td>70</td>      <td>90</td>      <td>95</td>      <td>及格</td>    </tr>    <tr>      <th>1</th>      <td>一班</td>      <td>小红</td>      <td>35</td>      <td>85</td>      <td>80</td>      <td>不及格</td>    </tr>    <tr>      <th>2</th>      <td>一班</td>      <td>小刚</td>      <td>83</td>      <td>88</td>      <td>78</td>      <td>良好</td>    </tr>    <tr>      <th>3</th>      <td>二班</td>      <td>小李</td>      <td>45</td>      <td>75</td>      <td>85</td>      <td>不及格</td>    </tr>    <tr>      <th>4</th>      <td>二班</td>      <td>小张</td>      <td>95</td>      <td>80</td>      <td>88</td>      <td>优秀</td>    </tr>    <tr>      <th>5</th>      <td>二班</td>      <td>小赵</td>      <td>72</td>      <td>92</td>      <td>90</td>      <td>中等</td>    </tr>  </tbody></table></div><h1 id="7-数据透视"><a href="#7-数据透视" class="headerlink" title="7 数据透视"></a>7 数据透视</h1><h2 id="7-1-分组"><a href="#7-1-分组" class="headerlink" title="7.1 分组"></a>7.1 分组</h2><p><code>groupby()</code>：按照列进行分组，对每组应用聚合函数，多列参数需要使用 <code>[]</code>括住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002BE22601180&gt;</code></pre><p>分组得到的是一个分组对象，分组对象本身不返回结果，分组对象有以下属性和方法可以使用：</p><ul><li><code>groups</code>：查看分组数据</li><li><code>get_group(name)</code>：获取某个组的数据</li><li><code>size()</code>：返回各组的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各组数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).groups)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一班数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).get_group(<span class="hljs-string">&#x27;一班&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各班人数：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).size())<br></code></pre></td></tr></table></figure><pre><code class="hljs">各组数据： &#123;&#39;一班&#39;: [0, 1, 2], &#39;二班&#39;: [3, 4, 5]&#125;一班数据：    班级  姓名  语文  数学  英语 语文水平0  一班  小明  70  90  95   及格1  一班  小红  35  85  80  不及格2  一班  小刚  83  88  78   良好各班人数： 班级一班    3二班    3dtype: int64</code></pre><p>进一步可以使用聚合函数，类似SQL的聚合函数，常用：</p><ul><li><code>sum()</code>：求和</li><li><code>mean()</code>：平均值</li><li><code>max()</code>：最大值</li><li><code>min()</code>：最小值</li><li><code>median()</code>：中位数</li><li><code>var()</code>：方差</li><li><code>std()</code>：标准差</li><li><code>size()</code>：所有元素个数</li><li><code>count()</code>：非空元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby(分组字段)[聚合字段].聚合函数()<br></code></pre></td></tr></table></figure><p>聚合函数指定 <code>numeric_only=True</code>参数，可以只对数值型数据进行聚合计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">sum</span>(numeric_only=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>188</td>      <td>263</td>      <td>253</td>    </tr>    <tr>      <th>二班</th>      <td>212</td>      <td>247</td>      <td>263</td>    </tr>  </tbody></table></div><p>还可以对指定列进行分组聚合，通过列表传入，聚合的依据列默认会变为索引，可以使用 <code>as_index=False</code>使其不变成索引，保留为普通列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>, as_index=<span class="hljs-literal">False</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].mean()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>语文</th>      <th>数学</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>一班</td>      <td>62.666667</td>      <td>87.666667</td>    </tr>    <tr>      <th>1</th>      <td>二班</td>      <td>70.666667</td>      <td>82.333333</td>    </tr>  </tbody></table></div><h2 id="7-2-聚合"><a href="#7-2-聚合" class="headerlink" title="7.2 聚合"></a>7.2 聚合</h2><p><code>agg()</code>：对分组后的数据应用多个聚合函数，使分组聚合更加灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([<span class="hljs-string">&#x27;列名1&#x27;</span>, <span class="hljs-string">&#x27;列名2&#x27;</span>]).agg(&#123;<br>    <span class="hljs-string">&#x27;指定列1&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列2&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列3&#x27;</span>: [<span class="hljs-string">&#x27;聚合函数1&#x27;</span>, <span class="hljs-string">&#x27;聚合函数2&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对语文数学同时计算最小值和最大值</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].agg(&#123;<span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead tr th &#123;    text-align: left;&#125;.dataframe thead tr:last-of-type th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr>      <th></th>      <th colspan="2" halign="left">语文</th>      <th colspan="2" halign="left">数学</th>    </tr>    <tr>      <th></th>      <th>min</th>      <th>max</th>      <th>min</th>      <th>max</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>35</td>      <td>83</td>      <td>85</td>      <td>90</td>    </tr>    <tr>      <th>二班</th>      <td>45</td>      <td>95</td>      <td>75</td>      <td>92</td>    </tr>  </tbody></table></div><p>不同列使用不同聚合函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文计算平均分，数学计算最高分和最低分</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;mean&#x27;</span>,<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead tr th &#123;    text-align: left;&#125;.dataframe thead tr:last-of-type th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr>      <th></th>      <th>语文</th>      <th colspan="2" halign="left">数学</th>    </tr>    <tr>      <th></th>      <th>mean</th>      <th>max</th>      <th>min</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>62.666667</td>      <td>90</td>      <td>85</td>    </tr>    <tr>      <th>二班</th>      <td>70.666667</td>      <td>92</td>      <td>75</td>    </tr>  </tbody></table></div><p>另外 <code>agg()</code>当中也可以使用自定义函数，或者直接使用lambda函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[<span class="hljs-string">&#x27;数学&#x27;</span>].agg(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">班级一班     5二班    17Name: 数学, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>()<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>数学</th>    </tr>    <tr>      <th>班级</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>5</td>    </tr>    <tr>      <th>二班</th>      <td>17</td>    </tr>  </tbody></table></div><h2 id="7-3-过滤"><a href="#7-3-过滤" class="headerlink" title="7.3 过滤"></a>7.3 过滤</h2><p>根据分组后的统计信息对组进行筛选，<code>filter()</code>接收一个函数作为参数，该函数接收每个组，返回 <code>True</code>或 <code>False</code>决定是否保留该组，结果返回的是符合过滤条件的组内所有成员，而不是仅返回符合条件的组的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>].mean() &gt; <span class="hljs-number">65</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>语文水平</th>    </tr>  </thead>  <tbody>    <tr>      <th>3</th>      <td>二班</td>      <td>小李</td>      <td>45</td>      <td>75</td>      <td>85</td>      <td>不及格</td>    </tr>    <tr>      <th>4</th>      <td>二班</td>      <td>小张</td>      <td>95</td>      <td>80</td>      <td>88</td>      <td>优秀</td>    </tr>    <tr>      <th>5</th>      <td>二班</td>      <td>小赵</td>      <td>72</td>      <td>92</td>      <td>90</td>      <td>中等</td>    </tr>  </tbody></table></div><h2 id="7-4-交叉表"><a href="#7-4-交叉表" class="headerlink" title="7.4 交叉表"></a>7.4 交叉表</h2><p>交叉表是一种特殊的透视表，主要用于计算两个或多个分类变量的频率分布（计数），统计行中每一个唯一值对应的列每一个唯一值分组个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(index, columns, margins=<span class="hljs-literal">False</span>, normalize=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>margins：是否添加行和列的总计</li><li>normalize：是否将频率转化为百分比</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>语文水平</th>      <th>不及格</th>      <th>及格</th>      <th>中等</th>      <th>良好</th>      <th>优秀</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>1</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>二班</th>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>], margins=<span class="hljs-literal">True</span>, normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>语文水平</th>      <th>不及格</th>      <th>及格</th>      <th>中等</th>      <th>良好</th>      <th>优秀</th>      <th>All</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>0.166667</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.5</td>    </tr>    <tr>      <th>二班</th>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.5</td>    </tr>    <tr>      <th>All</th>      <td>0.333333</td>      <td>0.166667</td>      <td>0.166667</td>      <td>0.166667</td>      <td>0.166667</td>      <td>1.0</td>    </tr>  </tbody></table></div><h2 id="7-5-透视表"><a href="#7-5-透视表" class="headerlink" title="7.5 透视表"></a>7.5 透视表</h2><p>透视表更加灵活，不只是计数，可以使用各种聚合函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.pivot_table(values, index, columns, aggfunc=<span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>values：要聚合计算的数值列</li><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>aggfunc：聚合函数，默认为 <code>mean</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>df = pd.DataFrame(data = &#123;<br>    <span class="hljs-string">&#x27;销售人员&#x27;</span>: [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>],<br>    <span class="hljs-string">&#x27;地区&#x27;</span>: [<span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>],<br>    <span class="hljs-string">&#x27;销售额&#x27;</span>: [<span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">250</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>]<br>    &#125;<br>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>销售人员</th>      <th>地区</th>      <th>销售额</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice</td>      <td>北区</td>      <td>150</td>    </tr>    <tr>      <th>1</th>      <td>Bob</td>      <td>南区</td>      <td>200</td>    </tr>    <tr>      <th>2</th>      <td>Alice</td>      <td>南区</td>      <td>250</td>    </tr>    <tr>      <th>3</th>      <td>Bob</td>      <td>北区</td>      <td>300</td>    </tr>    <tr>      <th>4</th>      <td>Alice</td>      <td>南区</td>      <td>100</td>    </tr>    <tr>      <th>5</th>      <td>Bob</td>      <td>南区</td>      <td>400</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(values=<span class="hljs-string">&#x27;销售额&#x27;</span>, index=<span class="hljs-string">&#x27;销售人员&#x27;</span>, columns=<span class="hljs-string">&#x27;地区&#x27;</span>, aggfunc=<span class="hljs-string">&#x27;max&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>地区</th>      <th>北区</th>      <th>南区</th>    </tr>    <tr>      <th>销售人员</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>Alice</th>      <td>150</td>      <td>250</td>    </tr>    <tr>      <th>Bob</th>      <td>300</td>      <td>400</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Pandas索引运算</title>
    <link href="/2024/08/16/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/"/>
    <url>/2024/08/16/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>Pandas索引操作有两种常见类型：</p><ul><li>基于位置的索引（Position-based Indexing）</li><li>基于标签的索引（Label-based Indexing）</li></ul><p>实际操作中，第二种操作更常用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h1 id="1-DataFrame结构"><a href="#1-DataFrame结构" class="headerlink" title="1 DataFrame结构"></a>1 DataFrame结构</h1><h2 id="1-1-column-index-value"><a href="#1-1-column-index-value" class="headerlink" title="1.1 column&#x2F;index&#x2F;value"></a>1.1 column&#x2F;index&#x2F;value</h2><p>DataFrame主要包含以下三个部分：</p><ul><li><code>column</code>：列标签（Index对象）</li><li><code>index</code>：行标签（Index对象）</li><li><code>value</code>：数据域</li></ul><p>基于标签定位就是靠 <code>Index</code>对象，在此之外还有动态映射出来的虚拟列号和行号，可以直接基于数组下标进行定位，也就是基于位置定位。</p><p><img src="/../../../../ai_assets/output_5_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_excel(<span class="hljs-string">&#x27;data/source_data.xlsx&#x27;</span>)<br>df.index = np.arange(<span class="hljs-number">1001</span>, <span class="hljs-number">1008</span>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="1-2-单独取列-行"><a href="#1-2-单独取列-行" class="headerlink" title="1.2 单独取列&#x2F;行"></a>1.2 单独取列&#x2F;行</h2><p><code>DataFrame</code>的行和列单独取出来都是一个 <code>Series</code>对象，事实上，<code>DataFrame</code>对象就是将多个 <code>Series</code>对象组合到一起的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一列，两种方式</span><br><span class="hljs-built_in">print</span>(df[<span class="hljs-string">&#x27;客单价&#x27;</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.客单价)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float641001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一行，两种方式</span><br><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-number">1005</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object</code></pre><h1 id="2-基于位置定位"><a href="#2-基于位置定位" class="headerlink" title="2 基于位置定位"></a>2 基于位置定位</h1><p>基于位置索引使用 <code>iloc[行号, 列号]</code>进行选取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><p>DataFrame索引方式大体分为下面四种，其中行和列类似Numpy的索引运算，可以使用切片索引、花式索引、布尔索引。</p><ul><li><code>df[列][行]</code>：先选列再选行，链式索引，不推荐</li><li><code>df.loc[行][列]/df.iloc[行][列]</code>：先取行再取列，链式索引可能产生副本，修改不会反映到原对象，不推荐</li><li><code>df.loc[行, 列]</code>：标签方式一次性定位，推荐！</li><li><code>df.iloc[行, 列]</code>：位置方式一次性定位，推荐！</li></ul><h2 id="2-1-行选取"><a href="#2-1-行选取" class="headerlink" title="2.1 行选取"></a>2.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 连续选取，使用切片索引</span><br>df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>  </tbody></table></div><p>花式索引需要构造列表，将列表作为单个参数传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 跨行选取，使用花式索引</span><br>df.iloc[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="2-2-列选取"><a href="#2-2-列选取" class="headerlink" title="2.2 列选取"></a>2.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[:, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>    </tr>  </tbody></table></div><h2 id="2-3-行列交叉选取"><a href="#2-3-行列交叉选取" class="headerlink" title="2.3 行列交叉选取"></a>2.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>C区</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>20068.20</td>    </tr>  </tbody></table></div><h1 id="3-基于标签定位"><a href="#3-基于标签定位" class="headerlink" title="3 基于标签定位"></a>3 基于标签定位</h1><p>基于标签定位使用 <code>loc[&#39;行标签&#39;, &#39;列标签&#39;]</code>进行选取。</p><p>注意：<code>loc</code>的切片是包含结束值的！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="3-1-行选取"><a href="#3-1-行选取" class="headerlink" title="3.1 行选取"></a>3.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[<span class="hljs-number">1003</span>: <span class="hljs-number">1005</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>  </tbody></table></div><p>结合布尔索引将判断结果作为掩码可以进行筛选数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; <span class="hljs-number">80</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.1</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.2</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.6</td>    </tr>  </tbody></table></div><h2 id="3-2-列选取"><a href="#3-2-列选取" class="headerlink" title="3.2 列选取"></a>3.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>58.79</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>92.91</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>89.33</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>56.04</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[:, [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>58.79</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>92.91</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>89.33</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>56.04</td>    </tr>  </tbody></table></div><h2 id="3-3-行列交叉选取"><a href="#3-3-行列交叉选取" class="headerlink" title="3.3 行列交叉选取"></a>3.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;B区&#x27;</span>) | (df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;C区&#x27;</span>), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>56.04</td>    </tr>  </tbody></table></div><h3 id="3-3-1-query函数"><a href="#3-3-1-query函数" class="headerlink" title="3.3.1 query函数"></a>3.3.1 query函数</h3><p><code>query(exp, inplace=False</code>)&#96;：可以使用Python布尔表达式进行选取符合条件的行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&quot;访客数 &gt; 3000 and 访客数 &lt; 20000&quot;</span>)[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>  </tbody></table></div><h3 id="3-3-2-isin函数"><a href="#3-3-2-isin函数" class="headerlink" title="3.3.2 isin函数"></a>3.3.2 isin函数</h3><p><code>isin()</code>函数：判断是否等于列表中的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;投放地区&#x27;</span>].isin([<span class="hljs-string">&#x27;B区&#x27;</span>, <span class="hljs-string">&#x27;C区&#x27;</span>]), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>56.04</td>    </tr>  </tbody></table></div><h2 id="3-4-多条件索引"><a href="#3-4-多条件索引" class="headerlink" title="3.4 多条件索引"></a>3.4 多条件索引</h2><p>在使用索引筛选出数据之后，只需要加个统计函数的尾巴就可以直接算出统计数值。</p><ul><li><code>mean()</code>  #计算均值</li><li><code>std()</code>  #计算标准差</li><li><code>median()</code>  #计算中位数</li><li><code>max()</code>  #计算最大值</li><li><code>min()</code>  #计算最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;客单价平均值&#x27;</span>, df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">客单价平均值 64.01571428571428</code></pre><p>搭配布尔索引进一步进行统计筛选，使用 <code>&amp;</code>、<code>|</code>时，表达式注意必须要用括号 <code>()</code>括起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;访客数&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;访客数&#x27;</span>].mean()) &amp; (df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.1</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Numpy结构化数组</title>
    <link href="/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <url>/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建结构化数组"><a href="#1-创建结构化数组" class="headerlink" title="1 创建结构化数组"></a>1 创建结构化数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p>类似C++的结构体，但更加强大，数组的每个元素可以包含多个字段，可以单独处理数组的每一个字段。</p><h2 id="1-1-字典方式"><a href="#1-1-字典方式" class="headerlink" title="1.1 字典方式"></a>1.1 字典方式</h2><p><code>dtype</code>的参数是一个字典：</p><ul><li><code>names</code>：指定字段名称</li><li><code>formats</code>：指定数据类型，可以使用Python类型或Numpy类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dtype = &#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;<br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=my_dtype)<br>arr.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><h2 id="1-2-列表元组方式"><a href="#1-2-列表元组方式" class="headerlink" title="1.2 列表元组方式"></a>1.2 列表元组方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype([<br>    (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;U10&#x27;</span>),<br>    (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">int</span>),<br>    (<span class="hljs-string">&#x27;weight&#x27;</span>, <span class="hljs-string">&#x27;f8&#x27;</span>),<br>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><p>如果类型名称不重要可以省略，仅仅指定数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype(<span class="hljs-string">&#x27;U10, i8, f8&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;f0&#39;, &#39;&lt;U10&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;), (&#39;f2&#39;, &#39;&lt;f8&#39;)])</code></pre><p>Numpy数据类型符号表：</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="center"><strong>‘b’</strong></td><td align="center">字节型 (Boolean or raw bytes)</td><td align="left"><code>np.dtype(&#39;b&#39;)</code></td></tr><tr><td align="center"><strong>‘i’</strong></td><td align="center">有符号整型 (Signed integer)</td><td align="left"><code>np.dtype(&#39;i4&#39;) == np.int32</code></td></tr><tr><td align="center"><strong>‘u’</strong></td><td align="center">无符号整型 (Unsigned integer)</td><td align="left"><code>np.dtype(&#39;u1&#39;) == np.uint8</code></td></tr><tr><td align="center"><strong>‘f’</strong></td><td align="center">浮点型 (Floating-point)</td><td align="left"><code>np.dtype(&#39;f8&#39;) == np.float64</code></td></tr><tr><td align="center"><strong>‘c’</strong></td><td align="center">复数浮点型 (Complex floating-point)</td><td align="left"><code>np.dtype(&#39;c16&#39;) == np.complex128</code></td></tr><tr><td align="center"><strong>‘S’, ‘a’</strong></td><td align="center">字节字符串 (Byte string)</td><td align="left"><code>np.dtype(&#39;S5&#39;)</code></td></tr><tr><td align="center"><strong>‘U’</strong></td><td align="center">Unicode编码字符串 (Unicode string)</td><td align="left"><code>np.dtype(&#39;U&#39;) == np.str_</code></td></tr><tr><td align="center"><strong>‘V’</strong></td><td align="center">原生数据 (Raw data, void)</td><td align="left"><code>np.dtype(&#39;V&#39;) == np.void</code></td></tr></tbody></table><h1 id="2-访问结构化数组"><a href="#2-访问结构化数组" class="headerlink" title="2 访问结构化数组"></a>2 访问结构化数组</h1><p>数组的每一个字段依然是一个数组，可以用索引、聚合等操作。这里的操作有点像SQL，字段名像列，索引号像行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建结构化数组</span><br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=&#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;)<br><br>arr[<span class="hljs-string">&#x27;name&#x27;</span>] = [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>]<br>arr[<span class="hljs-string">&#x27;age&#x27;</span>] = [<span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">20</span>, <span class="hljs-number">35</span>]<br>arr[<span class="hljs-string">&#x27;weight&#x27;</span>] = [<span class="hljs-number">110.2</span>, <span class="hljs-number">125.3</span>, <span class="hljs-number">103.1</span>, <span class="hljs-number">159.6</span>]<br>arr[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;赵六&#39;], dtype=&#39;&lt;U10&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;arr：&#x27;</span>, arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n通过字段名访问age列表：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过索引访问第一个元素：&#x27;</span>, arr[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;组合字段和索引访问第一个人的名字：&#x27;</span>, arr[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>], arr[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr： [(&#39;张三&#39;, 18, 110.2) (&#39;李四&#39;, 28, 125.3) (&#39;王五&#39;, 20, 103.1) (&#39;赵六&#39;, 35, 159.6)]通过字段名访问age列表： [18 28 20 35]通过索引访问第一个元素： (&#39;张三&#39;, 18, 110.2)组合字段和索引访问第一个人的名字： 张三 张三</code></pre><p>结合布尔索引可以对元素进行筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 年龄小于25岁的人</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>])<br><br><span class="hljs-comment"># 年龄小于25岁的人的姓名和年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>][[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>]])<br></code></pre></td></tr></table></figure><pre><code class="hljs">年龄小于25岁的人的信息 [(&#39;张三&#39;, 18, 110.2) (&#39;王五&#39;, 20, 103.1)]年龄小于25岁的人的信息 [(&#39;张三&#39;, 18) (&#39;王五&#39;, 20)]</code></pre><p>结合描述统计方法对字段进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算平均年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均年龄：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均年龄： 25.25</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Pandas数据结构</title>
    <link href="/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>Numpy和Pandas的关系：就像先掌握算术才能学代数一样，NumPy就是数据分析的”算术基础”，虽然可以直接用计算器（Pandas），但理解底层原理才能走得更远。</p><p>Pandas 核心数据机构是 <code>Series</code>(数据系列)、<code>DataFrame</code>(数据窗&#x2F;数据框)，<code>Series</code>可以看做表中的一列，<code>DataFrame</code>则是整个表格，由多个列构成。除此之外还有一个特殊的 <code>Index</code>类，为 <code>Series</code>和 <code>DataFrame</code>提供索引功能。</p><h1 id="1-Series对象"><a href="#1-Series对象" class="headerlink" title="1 Series对象"></a>1 Series对象</h1><h2 id="1-1-创建-Series-对象"><a href="#1-1-创建-Series-对象" class="headerlink" title="1.1 创建 Series 对象"></a>1.1 创建 Series 对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p><code>Series</code>对象内部结构：一个ndarray用来保存数据，一个index用来保存索引。类似Numpy的一维数组，但是增加了“标签”，具有数据和索引。</p><p><img src="/../../../../ai_assets/output_5_1%201.png" alt="png"></p><ul><li>通过列表和数组创建<ul><li><code>data</code>：数据</li><li><code>index</code>：索引</li><li><code>name</code>：名称</li></ul></li></ul><p>其中 <code>name</code>的作用：</p><ol><li>创建 <code>DataFrame</code>时自动变成列名</li><li>合并时作为对齐依据</li><li>导出csv时成为列名</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 = pd.Series(data=np.arange(<span class="hljs-number">4</span>), index=[<span class="hljs-string">&#x27;春&#x27;</span>, <span class="hljs-string">&#x27;夏&#x27;</span>, <span class="hljs-string">&#x27;秋&#x27;</span>, <span class="hljs-string">&#x27;冬&#x27;</span>], name=<span class="hljs-string">&#x27;季节&#x27;</span>)<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    0夏    1秋    2冬    3Name: 季节, dtype: int64</code></pre><ul><li>通过字典创建<ul><li>字典的键就是索引</li><li>字典的值就是数据</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=&#123;<span class="hljs-string">&#x27;春&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;夏&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;秋&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;冬&#x27;</span>: <span class="hljs-number">4</span>&#125;)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    1夏    2秋    3冬    4dtype: int64</code></pre><h2 id="1-2-Series-的运算"><a href="#1-2-Series-的运算" class="headerlink" title="1.2 Series 的运算"></a>1.2 Series 的运算</h2><p>由于 Pandas 是基于 Numpy 开发的，所以很多性质和数组是一样的，比如<strong>矢量化运算和广播</strong>。</p><h3 id="1-2-1-标量运算"><a href="#1-2-1-标量运算" class="headerlink" title="1.2.1 标量运算"></a>1.2.1 标量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += <span class="hljs-number">10</span><br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    10夏    11秋    12冬    13Name: 季节, dtype: int64</code></pre><h3 id="1-2-2-矢量运算"><a href="#1-2-2-矢量运算" class="headerlink" title="1.2.2 矢量运算"></a>1.2.2 矢量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += ser2<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    11夏    13秋    15冬    17Name: 季节, dtype: int64</code></pre><h2 id="1-3-Series-的属性"><a href="#1-3-Series-的属性" class="headerlink" title="1.3 Series 的属性"></a>1.3 Series 的属性</h2><ul><li><code>dtype</code>：返回 <code>Series</code>对象的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;int64&#39;)</code></pre><ul><li><code>size</code>：返回 <code>Series</code>对象中元素的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.size<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><ul><li><code>index</code>：返回 <code>Series</code>对象的索引 <code>Index</code>对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;索引对象&#x27;</span>, ser1.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体索引&#x27;</span>, ser1.index[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">索引对象 Index([&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;], dtype=&#39;object&#39;)通过下标取出具体索引 春</code></pre><ul><li><code>values</code>：以 <code>ndarray</code>的形式返回 <code>Series</code>对象的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ser1.values)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体值&#x27;</span>, ser1.values[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">[11 13 15 17]通过下标取出具体值 11</code></pre><h2 id="1-4-Series-的方法"><a href="#1-4-Series-的方法" class="headerlink" title="1.4 Series 的方法"></a>1.4 Series 的方法</h2><h3 id="1-4-1-描述性统计"><a href="#1-4-1-描述性统计" class="headerlink" title="1.4.1 描述性统计"></a>1.4.1 描述性统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;计数：&#x27;</span>, ser1.count())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;求和：&#x27;</span>, ser1.<span class="hljs-built_in">sum</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;均值：&#x27;</span>, ser1.mean())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;中位数：&#x27;</span>, ser1.median())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最小值：&#x27;</span>, ser1.<span class="hljs-built_in">min</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最大值：&#x27;</span>, ser1.<span class="hljs-built_in">max</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;标准差：&#x27;</span>, ser1.std())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方差：&#x27;</span>, ser1.var())<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数： 4求和： 56均值： 14.0中位数： 14.0最小值： 11最大值： 17标准差： 2.581988897471611方差： 6.666666666666667</code></pre><ul><li><code>describe()</code>：获取描述性统计信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.describe()<br></code></pre></td></tr></table></figure><pre><code class="hljs">count     4.000000mean     14.000000std       2.581989min      11.00000025%      12.50000050%      14.00000075%      15.500000max      17.000000Name: 季节, dtype: float64</code></pre><p><code>describe()</code>返回的是一个 <code>Series</code>对象，所以可以通过索引访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均值：&#x27;</span>, ser1.describe()[<span class="hljs-string">&#x27;mean&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值，最小值：\n<span class="hljs-subst">&#123;ser1.describe()[[<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均值： 14.0最大值，最小值：max    17.0min    11.0Name: 季节, dtype: float64</code></pre><h3 id="1-4-2-处理数据"><a href="#1-4-2-处理数据" class="headerlink" title="1.4.2 处理数据"></a>1.4.2 处理数据</h3><ul><li><code>isnull()</code>：空值判断</li><li><code>notnull()</code>：非空值判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, np.nan, <span class="hljs-number">30</span>, np.nan])<br>ser2.isnull()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2     True3    False4     Truedtype: bool</code></pre><ul><li><code>dropna()</code>：删除空值</li><li><code>fillna()</code>：填充空值</li></ul><p>处理数据的方法都有一个 <code>inplace</code>参数，默认为 <code>False</code>。</p><ul><li><code>inplace=False</code>：处理完成返回新的对象</li><li><code>inplace=True</code>：在原对象上进行处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.dropna()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.fillna(<span class="hljs-number">66</span>, inplace=<span class="hljs-literal">True</span>)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.04    66.0dtype: float64</code></pre><ul><li><code>duplicated()</code>：检测重复数据</li><li><code>drop_duplicates()</code>：删除重复数据</li><li><code>unique</code>：去除重复数据，返回一个数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.duplicated()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    False3    False4     Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.drop_duplicates()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.unique()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 20., 66., 30.])</code></pre><h3 id="1-4-3-排序"><a href="#1-4-3-排序" class="headerlink" title="1.4.3 排序"></a>1.4.3 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用 <code>ascending=False</code>参数可以实现降序排列，排序结果返回一个新的 <code>Series</code> 对象，原对象不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3 = pd.Series(data=[<span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>], index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_index()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Bob      30Eve      10Jack     50John     20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_values(ascending=<span class="hljs-literal">False</span>, inplace=<span class="hljs-literal">True</span>)<br>ser3<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack     50Bob      30John     20Alice    10Eve      10dtype: int64</code></pre><ul><li><code>head(n)</code>：返回前 n 个元素，默认 n&#x3D;5</li><li><code>tail(n)</code>：返回后 n 个元素，默认 n&#x3D;5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack    50Bob     30John    20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.tail(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Eve      10dtype: int64</code></pre><h3 id="1-4-4-绘制图表"><a href="#1-4-4-绘制图表" class="headerlink" title="1.4.4 绘制图表"></a>1.4.4 绘制图表</h3><p><code>Series</code>对象可以直接绘制图表，默认绘制折线图，还可以绘制柱状图、饼图等，只需指定 <code>kind</code>参数即可。默认会使用索引作为横坐标，值作为纵坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: &gt;</code></pre><p><img src="/../../../../ai_assets/output_53_1.png" alt="png"></p><h1 id="2-DataFrame-对象"><a href="#2-DataFrame-对象" class="headerlink" title="2 DataFrame 对象"></a>2 DataFrame 对象</h1><p><code>DataFrame</code>是一个二维的表格型数据结构，既有行索引，也有列索引，可以将其看作由多个 <code>Series</code>按列组成的一个字典。是 Pandas 中最常用的数据结构，可以用来保存和处理异质的二维数据，每个列可以是不同的数据类型，这也是和 NumPy 数组的最大区别。</p><p>数据表格三要素贯穿 Pandas 数据分析的始终：</p><ul><li><code>column</code>：对应着列名，也就是列索引</li><li><code>index</code>：代表行索引</li><li><code>value</code>：则指代具体的数据值</li></ul><h2 id="2-1-创建-DataFrame-对象"><a href="#2-1-创建-DataFrame-对象" class="headerlink" title="2.1 创建 DataFrame 对象"></a>2.1 创建 DataFrame 对象</h2><h3 id="2-1-1-通过二维数组-列表创建"><a href="#2-1-1-通过二维数组-列表创建" class="headerlink" title="2.1.1 通过二维数组&#x2F;列表创建"></a>2.1.1 通过二维数组&#x2F;列表创建</h3><p><code>data</code>指定数据，<code>columns</code>指定列名，<code>index</code>指定行索引。<br>如果没有指定索引，则默认从 0 开始。如果没有指定列名，则默认从 0 开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">score = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, size=(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br>course = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]<br>stu_id = [<span class="hljs-string">&#x27;1001&#x27;</span>, <span class="hljs-string">&#x27;1002&#x27;</span>, <span class="hljs-string">&#x27;1003&#x27;</span>, <span class="hljs-string">&#x27;1004&#x27;</span>, <span class="hljs-string">&#x27;1005&#x27;</span>]<br>df1 = pd.DataFrame(data=score, columns=course, index=stu_id)<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>89</td>      <td>98</td>      <td>58</td>    </tr>    <tr>      <th>1002</th>      <td>15</td>      <td>48</td>      <td>24</td>    </tr>    <tr>      <th>1003</th>      <td>48</td>      <td>42</td>      <td>60</td>    </tr>    <tr>      <th>1004</th>      <td>62</td>      <td>17</td>      <td>46</td>    </tr>    <tr>      <th>1005</th>      <td>18</td>      <td>54</td>      <td>71</td>    </tr>  </tbody></table></div><h3 id="2-1-2-通过字典创建"><a href="#2-1-2-通过字典创建" class="headerlink" title="2.1.2 通过字典创建"></a>2.1.2 通过字典创建</h3><p>字典嵌套列表：按照列名进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">info1 = &#123;<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>],<br>    <span class="hljs-string">&#x27;年龄&#x27;</span>: [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>],<br>    <span class="hljs-string">&#x27;性别&#x27;</span>: [<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>]<br>&#125;<br>df2 = pd.DataFrame(data=info1)<br>df2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>年龄</th>      <th>性别</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>18</td>      <td>男</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>19</td>      <td>女</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>20</td>      <td>男</td>    </tr>    <tr>      <th>3</th>      <td>赵六</td>      <td>21</td>      <td>女</td>    </tr>  </tbody></table></div><p>列表嵌套列表：按照行进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">info2 = [<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;<br>]<br>df3 = pd.DataFrame(data=info2)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>年龄</th>      <th>性别</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>18</td>      <td>男</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>19</td>      <td>女</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>20</td>      <td>男</td>    </tr>    <tr>      <th>3</th>      <td>赵六</td>      <td>21</td>      <td>女</td>    </tr>  </tbody></table></div><h2 id="2-2-数据读取和存储"><a href="#2-2-数据读取和存储" class="headerlink" title="2.2 数据读取和存储"></a>2.2 数据读取和存储</h2><p>实际应用中，单独创建数据结构的情况较少，更多的是通过读取外部数据文件来创建数据结构。</p><h3 id="2-2-1-读取-Excel"><a href="#2-2-1-读取-Excel" class="headerlink" title="2.2.1 读取 Excel"></a>2.2.1 读取 Excel</h3><p>通过 <code>read_excel</code>读取 Excel 文件，默认读取第一个 sheet，可以通过 <code>sheet_name</code>参数指定读取的 sheet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>张三</th>      <th>88</th>      <th>100</th>      <th>90</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>1</th>      <td>王五</td>      <td>80</td>      <td>92</td>      <td>60</td>    </tr>  </tbody></table></div><p>Pandas 默认会将第一行数据作为列名，如果想自定义列名，可以将 <code>header=None</code>告诉Pandas数据中没有表头，然后通过 <code>names</code>参数指定列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>, header=<span class="hljs-literal">None</span>, names=[<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>92</td>      <td>60</td>    </tr>  </tbody></table></div><p>此外读取数据还有很多参数，比如：</p><ul><li><code>index_col</code>：指定哪一列作为行索引</li><li><code>usecols</code>：指定读取哪些列</li><li><code>nrows</code>：指定读取多少行</li><li><code>dtype</code>：指定列的数据类型</li></ul><h3 id="2-2-2-读取-CSV"><a href="#2-2-2-读取-CSV" class="headerlink" title="2.2.2 读取 CSV"></a>2.2.2 读取 CSV</h3><p>通过 <code>read_csv</code>函数可以读取 CSV 和 TSV 文件，默认使用UTF-8编码格式，如果是其他编码格式，可以通过 <code>encoding</code>参数指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>  </tbody></table></div><p>大多数CSV文件以逗号分隔，如果是其他字符分<br>隔，可以通过 <code>sep</code>参数指定分隔符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>, sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在某些Python版本读取中文路径会报错，因为默认读取引擎是C语言，可以通过 <code>engine</code>参数指定为Python引擎。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>mengine=<span class="hljs-string">&#x27;python&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-3-连接MySQL"><a href="#2-2-3-连接MySQL" class="headerlink" title="2.2.3 连接MySQL"></a>2.2.3 连接MySQL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要安装pymysql，部分版本需要额外安装sqlalchemy</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+pymysql://root:123456@127.0.0.1:3306/sql_practice03?charset=utf8&#x27;</span>)<br><span class="hljs-comment"># mysql 表示数据库类型</span><br><span class="hljs-comment"># pymysql 表示python操作数据库的包</span><br><span class="hljs-comment"># root:123456 表示数据库的账号和密码，用冒号连接</span><br><span class="hljs-comment"># 127.0.0.1:3306/sql_practice03 表示数据库的ip和端口，以及名叫sql_practice03的库</span><br><span class="hljs-comment"># charset=utf8 规定编码格式</span><br></code></pre></td></tr></table></figure><p>数据库读取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取整张表</span><br>pd.read_sql(<span class="hljs-string">&#x27;dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>DEPTNO</th>      <th>DNAME</th>      <th>LOC</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>10</td>      <td>ACCOUNTING</td>      <td>NEW YORK</td>    </tr>    <tr>      <th>1</th>      <td>20</td>      <td>RESEARCH</td>      <td>DALLAS</td>    </tr>    <tr>      <th>2</th>      <td>30</td>      <td>SALES</td>      <td>CHICAGO</td>    </tr>    <tr>      <th>3</th>      <td>40</td>      <td>OPERATIONS</td>      <td>BOSTON</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SQL语句查询指定内容</span><br>pd.read_sql(<span class="hljs-string">&#x27;select DEPTNO, DNAME from dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>DEPTNO</th>      <th>DNAME</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>10</td>      <td>ACCOUNTING</td>    </tr>    <tr>      <th>1</th>      <td>20</td>      <td>RESEARCH</td>    </tr>    <tr>      <th>2</th>      <td>30</td>      <td>SALES</td>    </tr>    <tr>      <th>3</th>      <td>40</td>      <td>OPERATIONS</td>    </tr>  </tbody></table></div><p>写入数据到数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_sql(<span class="hljs-string">&#x27;df_score_table&#x27;</span>, engine, index=<span class="hljs-literal">False</span>, if_exists=<span class="hljs-string">&#x27;append&#x27;</span>)<br><span class="hljs-comment"># index：是否将index写入数据库</span><br><span class="hljs-comment"># if_exists：如果表存在如何操作 </span><br><span class="hljs-comment">#     append：追加  </span><br><span class="hljs-comment">#     replace：覆盖</span><br><span class="hljs-comment">#     fail：报错</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">3</code></pre><h3 id="2-2-4-读取其他文件"><a href="#2-2-4-读取其他文件" class="headerlink" title="2.2.4 读取其他文件"></a>2.2.4 读取其他文件</h3><p>Excel和CSV是最常用的，其他文件读取简单了解，读取文件的大部分参数是通用的。</p><ul><li><code>read_table()</code>： 读取文本文件</li><li><code>read_json()</code>： 读取 JSON 文件</li></ul><h3 id="2-2-5-存储数据"><a href="#2-2-5-存储数据" class="headerlink" title="2.2.5 存储数据"></a>2.2.5 存储数据</h3><p>在Pandas中存储数据直接使用 <code>to_xxx()</code>方法即可，默认会把索引也存储进去，如果不需要索引，可以通过 <code>index=False</code>参数去掉索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="2-3-DataFrame-的属性"><a href="#2-3-DataFrame-的属性" class="headerlink" title="2.3 DataFrame 的属性"></a>2.3 DataFrame 的属性</h2><ul><li><code>columns</code>：列索引</li><li><code>index</code>：行索引</li><li><code>values</code>：数据值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df4)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n列索引：&#x27;</span>, df4.columns)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;行索引：&#x27;</span>, df4.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据值：\n&#x27;</span>, df4.values)<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60列索引： Index([&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;], dtype=&#39;object&#39;)行索引： RangeIndex(start=0, stop=3, step=1)数据值： [[&#39;张三&#39; 88 100 90] [&#39;李四&#39; 82 65 52] [&#39;王五&#39; 80 100 60]]</code></pre><ul><li><code>dtypes</code>：每一列的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.dtypes<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    object语文     int64数学     int64英语     int64dtype: object</code></pre><ul><li><code>ndim</code>：维度</li><li><code>shape</code>：形状</li><li><code>size</code>：元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;维度&#x27;</span>, df4.ndim)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;形状&#x27;</span>, df4.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;元素个数&#x27;</span>, df4.size)<br></code></pre></td></tr></table></figure><pre><code class="hljs">维度 2形状 (3, 4)元素个数 12</code></pre><h2 id="2-4-DataFrame-的方法"><a href="#2-4-DataFrame-的方法" class="headerlink" title="2.4 DataFrame 的方法"></a>2.4 DataFrame 的方法</h2><h3 id="2-4-1-快速查看"><a href="#2-4-1-快速查看" class="headerlink" title="2.4.1 快速查看"></a>2.4.1 快速查看</h3><ul><li><code>info()</code>：查看DataFrame的基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 3 entries, 0 to 2Data columns (total 4 columns): #   Column  Non-Null Count  Dtype---  ------  --------------  ----- 0   姓名      3 non-null      object 1   语文      3 non-null      int64 2   数学      3 non-null      int64 3   英语      3 non-null      int64dtypes: int64(3), object(1)memory usage: 224.0+ bytes</code></pre><ul><li><code>describe()</code>：获取统计性描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>3.000000</td>      <td>3.000000</td>      <td>3.000000</td>    </tr>    <tr>      <th>mean</th>      <td>83.333333</td>      <td>88.333333</td>      <td>67.333333</td>    </tr>    <tr>      <th>std</th>      <td>4.163332</td>      <td>20.207259</td>      <td>20.033306</td>    </tr>    <tr>      <th>min</th>      <td>80.000000</td>      <td>65.000000</td>      <td>52.000000</td>    </tr>    <tr>      <th>25%</th>      <td>81.000000</td>      <td>82.500000</td>      <td>56.000000</td>    </tr>    <tr>      <th>50%</th>      <td>82.000000</td>      <td>100.000000</td>      <td>60.000000</td>    </tr>    <tr>      <th>75%</th>      <td>85.000000</td>      <td>100.000000</td>      <td>75.000000</td>    </tr>    <tr>      <th>max</th>      <td>88.000000</td>      <td>100.000000</td>      <td>90.000000</td>    </tr>  </tbody></table></div><ul><li><code>head(n)</code>：查看前n行数据，默认n&#x3D;5</li><li><code>tail(n)</code>：查看后n行数据，默认n&#x3D;5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.head(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.tail(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>  </tbody></table></div><ul><li><code>value_counts()</code>：统计每一个唯一值出现的次数，索引为唯一值，值为出现的次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;数学&#x27;</span>].value_counts()<br></code></pre></td></tr></table></figure><pre><code class="hljs">数学100    265     1Name: count, dtype: int64</code></pre><h3 id="2-4-2-描述性统计"><a href="#2-4-2-描述性统计" class="headerlink" title="2.4.2 描述性统计"></a>2.4.2 描述性统计</h3><p>DataFrame也有很多统计性描述信息的方法，和Series一致，不过多了一个 <code>axis</code>参数控制聚合轴向：</p><ul><li><code>axis=0</code>：按列进行统计（默认）</li><li><code>axis=1</code>：按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计数：\n<span class="hljs-subst">&#123;df4.count()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;求和：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;均值：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].mean(axis=<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;中位数：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].median()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数：姓名    3语文    3数学    3英语    3dtype: int64求和：姓名    张三李四王五语文       250数学       265英语       202dtype: object均值：0    92.6666671    66.3333332    80.000000dtype: float64中位数：语文     82.0数学    100.0英语     60.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最小值：\n<span class="hljs-subst">&#123;df4[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">max</span>(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;标准差：\n<span class="hljs-subst">&#123;df4.std(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;方差：\n<span class="hljs-subst">&#123;df4.var(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最小值：65最大值：语文     88数学    100英语     90dtype: int64标准差：语文     4.163332数学    20.207259英语    20.033306dtype: float64方差：语文     17.333333数学    408.333333英语    401.333333dtype: float64</code></pre><ul><li><code>idxmax()</code>：求最大值位置</li><li><code>idxmin()</code>：求最小值位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">display(df4.idxmax())<br>display(df4.idxmin())<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    2语文    0数学    0英语    0dtype: int64姓名    0语文    2数学    1英语    1dtype: int64</code></pre><h3 id="2-4-3-累计运算"><a href="#2-4-3-累计运算" class="headerlink" title="2.4.3 累计运算"></a>2.4.3 累计运算</h3><ul><li><code>cumsum()</code>：累计和</li><li><code>cumprod()</code>：累计积</li><li><code>cummax()</code>：累计最大值</li><li><code>cummin()</code>：累计最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cumsum()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>张三李四</td>      <td>170</td>      <td>165</td>      <td>142</td>    </tr>    <tr>      <th>2</th>      <td>张三李四王五</td>      <td>250</td>      <td>265</td>      <td>202</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cummin()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>张三</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>张三</td>      <td>80</td>      <td>65</td>      <td>52</td>    </tr>  </tbody></table></div><ul><li><code>diff()</code>：计算与上一个值的差值</li><li><code>pct_change()</code>：计算与上一个值的百分比变化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].diff()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>-6.0</td>      <td>-35.0</td>      <td>-38.0</td>    </tr>    <tr>      <th>2</th>      <td>-2.0</td>      <td>35.0</td>      <td>8.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].pct_change()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>-0.068182</td>      <td>-0.350000</td>      <td>-0.422222</td>    </tr>    <tr>      <th>2</th>      <td>-0.024390</td>      <td>0.538462</td>      <td>0.153846</td>    </tr>  </tbody></table></div><h3 id="2-4-4-排序"><a href="#2-4-4-排序" class="headerlink" title="2.4.4 排序"></a>2.4.4 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用 <code>ascending=False</code>参数可以实现降序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_index(ascending=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_values(<span class="hljs-string">&#x27;英语&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>  </tbody></table></div><h3 id="2-4-5-apply自定义函数"><a href="#2-4-5-apply自定义函数" class="headerlink" title="2.4.5 apply自定义函数"></a>2.4.5 apply自定义函数</h3><p>可以将一个函数应用（apply）到 Series 的每个元素上，或者 DataFrame 的每一行或每一列上。</p><p>当作用于 Series（DataFrame 的一列）时，apply() 会将函数依次作用于 Series 中的每一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_score</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">80</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;高&#x27;</span><br>    <span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">60</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;中&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;低&#x27;</span><br>  <br>df4[<span class="hljs-string">&#x27;英语&#x27;</span>].apply(check_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    高1    低2    中Name: 英语, dtype: object</code></pre><p>当作用于 DataFrame 时，apply() 可以将函数作用于每一列或每一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.apply(func, axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>func：要应用的函数</li><li>axis：指定函数应用方向<ul><li><code>0</code>：默认值，将函数应用到每一列，接收对象是Series</li><li><code>1</code>：将函数应用到每一行，接收对象是Series</li></ul></li></ul><p>沿列应用时，函数接收到的一列数据，通常用于聚合（如求和、最大值等）或对整列进行转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算每一科最高分和最低分的差值</span><br>df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].apply(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文     8数学    35英语    38dtype: int64</code></pre><p>沿行应用时，函数接收到的是一行数据，索引为列名，通常用于使用多列计算新值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;加权分&#x27;</span>] = df4.apply(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;数学&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;英语&#x27;</span>] * <span class="hljs-number">0.2</span>, axis=<span class="hljs-number">1</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><h1 id="3-Index-对象"><a href="#3-Index-对象" class="headerlink" title="3 Index 对象"></a>3 Index 对象</h1><p><code>Index</code>用来唯一标识 DataFrame 中的每一行数据，就像数据库表中的主键一样，但它不强制要求是唯一的，类似于一维数组，存储着用于标记各行数据的标签。</p><h2 id="3-1-Index-的特点"><a href="#3-1-Index-的特点" class="headerlink" title="3.1 Index 的特点"></a>3.1 Index 的特点</h2><ol><li>标签：作为行标签使用，用来访问特定行 <code>df.loc[行标签]</code></li><li>对齐：两个 <code>DataFrame</code>之间运算（比如加法、合并等）时，Pandas根据 <code>Index</code>和 <code>Column</code>自动将数据对齐，而不需要行和列的顺序相同</li><li>不可变性：<code>Index</code>对象一旦创建，不允许被修改，所有修改索引必须整体修改</li></ol><h2 id="3-2-Index-常用操作"><a href="#3-2-Index-常用操作" class="headerlink" title="3.2 Index 常用操作"></a>3.2 Index 常用操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>index</code>：查看index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.index<br></code></pre></td></tr></table></figure><pre><code class="hljs">RangeIndex(start=0, stop=3, step=1)</code></pre><p><code>set_index()</code>：将普通列设为行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.set_index(keys, drop=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>keys：新索引的列名或列名列表</li><li>drop：用于创建新索引的列是否从表中删除，默认为True</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df5 = df4.set_index(<span class="hljs-string">&#x27;姓名&#x27;</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>    <tr>      <th>姓名</th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>张三</th>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>李四</th>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>王五</th>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>reset_index</code>：<code>set_index</code>的逆操作，将索引重置为普通列，并且创建一个新的 <code>RangeIndex</code>作为索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.reset_index(drop=<span class="hljs-literal">False</span>, name=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>drop：是否删除原有索引，不转化为普通列，默认为False</li><li>names：指定转为为普通列之后的名称</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.reset_index(names=<span class="hljs-string">&#x27;大名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>大名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>rename()</code>：重命名行索引或列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.rename(columns=<span class="hljs-literal">None</span>, index=<span class="hljs-literal">None</span>, axis=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>columns：重命名列索引，{‘旧列名’: ‘新列名’, …}</li><li>index：重命名行索引，{‘旧行名’: ‘新行名’, …}</li><li>axis：指定重命名行索引还是列索引，0或’index’表示行索引，1或’columns’表示列索引，默认0</li><li>inplace：是否在原数据上修改，默认False表示不修改原数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(columns=&#123;<span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-string">&#x27;Math&#x27;</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>Chinese</th>      <th>Math</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(index=&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1001</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>Chinese</th>      <th>Math</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1001</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Numpy数组运算和函数</title>
    <link href="/2024/08/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2024/08/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Numpy非常重要的一个特性就是<strong>矢量化</strong>，对数组进行运算时，所有运算会自动作用于数组中的每一个成员，而不需要编写循环。</p><h1 id="1-数组和标量的运算"><a href="#1-数组和标量的运算" class="headerlink" title="1 数组和标量的运算"></a>1 数组和标量的运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>数组和数值进行加减乘除、取模求幂等运算，对应的运算会作用到数组的每一个元素上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr + 10为：<span class="hljs-subst">&#123;arr + <span class="hljs-number">10</span>&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr * 2为：<span class="hljs-subst">&#123;arr * <span class="hljs-number">2</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr + 10为：[10 11 12 13 14 15 16 17 18 19]arr * 2为：[ 0  2  4  6  8 10 12 14 16 18]</code></pre><p>数组还可以和数值进行关系运算，在布尔索引中也有所应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr % 2 == 0为：<span class="hljs-subst">&#123;arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr % 2 == 0为：[ True False  True False  True False  True False  True False]</code></pre><p>使用 <code>数组.T</code>可以很方便的对矩阵进行转置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr转置数组：\n<span class="hljs-subst">&#123;arr.T&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr转置数组：[[ 0  5 10] [ 1  6 11] [ 2  7 12] [ 3  8 13] [ 4  9 14]]</code></pre><h1 id="2-数组和数组的运算"><a href="#2-数组和数组的运算" class="headerlink" title="2 数组和数组的运算"></a>2 数组和数组的运算</h1><h2 id="2-1-相同形状运算"><a href="#2-1-相同形状运算" class="headerlink" title="2.1 相同形状运算"></a>2.1 相同形状运算</h2><p>数组和数组之间的运算会作用到两个数组对应的元素上，要求两个数组的形状相同。</p><p>注意：<code>a * b</code>不是矩阵乘法，而是逐元素相乘，也就是哈达玛积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>)<br>arr2 = np.full(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 * arr2为：\n<span class="hljs-subst">&#123;arr1 * arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以直接应用于布尔索引</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 &lt; arr2为：\n<span class="hljs-subst">&#123;arr1 &lt; arr2&#125;</span>\n&#x27;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[ 0  1  2  3  4  5  6  7  8  9 10]arr2为：[10 10 10 10 10 10 10 10 10 10 10]arr1 + arr2为：[10 11 12 13 14 15 16 17 18 19 20]arr1 * arr2为：[  0  10  20  30  40  50  60  70  80  90 100]arr1 &lt; arr2为：[ True  True  True  True  True  True  True  True  True  True False]</code></pre><h2 id="2-2-矩阵乘法"><a href="#2-2-矩阵乘法" class="headerlink" title="2.2 矩阵乘法"></a>2.2 矩阵乘法</h2><p>矩阵乘法有前提条件，A的列数必须和B的行数相等，也就是两个矩阵必须有<strong>相同的内维</strong>。</p><ul><li>A的形状为(m, n)，B的形状为(n, p)，n就是内维</li><li>内维 &#x3D; A的列数 &#x3D; B的行数（内维必须相等，乘积才有定义）</li><li>外维 &#x3D; m × p（外维是AB乘积结果的形状）</li><li>矩阵乘积AB存在，但BA不一定存在，即便存在，AB和BA通常也不同</li></ul><p>$$<br>\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \ a_{21} &amp; a_{22} &amp; a_{23} \end{bmatrix} \times \begin{bmatrix} b_{11} &amp; b_{12} \ b_{21} &amp; b_{22} \ b_{31} &amp; b_{32} \end{bmatrix} &#x3D; \begin{bmatrix} (a_{11}b_{11} + a_{12}b_{21} + a_{13}b_{31}) &amp; (a_{11}b_{12} + a_{12}b_{22} + a_{13}b_{32}) \ (a_{21}b_{11} + a_{22}b_{21} + a_{23}b_{31}) &amp; (a_{21}b_{12} + a_{22}b_{22} + a_{23}b_{32}) \end{bmatrix}<br>$$</p><p>矩阵乘法 C&#x3D;A×B 的核心运算就是在对 A 的行向量和 B 的列向量进行点积。</p><p><img src="/../../../../ai_assets/02_matrix_multi.png" alt="png"></p><p>在Numpy中可以使用矩阵乘法运算符 <code>arr1 @ arr2</code>或函数 <code>np.dot(arr1, arr2)</code>的方式计算矩阵乘法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2*3矩阵 × 3*2矩阵</span><br>arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>arr2 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 推荐矩阵乘法运算符</span><br><span class="hljs-built_in">print</span>(arr1 @ arr2, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 函数方式</span><br><span class="hljs-built_in">print</span>(np.dot(arr1, arr2))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[22 28] [49 64]][[22 28] [49 64]]</code></pre><h2 id="2-3-广播机制"><a href="#2-3-广播机制" class="headerlink" title="2.3 广播机制"></a>2.3 广播机制</h2><p>两个数组之间做二元运算，并不必须是完全相同的形状，通过Numpy的广播机制，将原本形状不同的数组变成形状相同的数组，也可以进行二元运算。</p><p>广播机制：在数组之间运算时，自动扩展维度较小的数组，使其形状和维度与较大数组匹配，从而进行运算。</p><ul><li>虚拟扩展<ul><li>Numpy的扩展不是真的复制，而是逻辑上的扩展</li></ul></li><li>维度对齐<ul><li>从尾部维度逐个比较，如果维度相同，继续向前比较</li><li>如果维度不同，但其中一个数组在这个维度上大小为1，则可以扩展为较大的数组，</li><li>否则不能对齐则报错</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br>arr2 = np.full((<span class="hljs-number">5</span>), <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr2为：[1 1 1 1 1]arr1 + arr2为：[[ 1  2  3  4  5] [ 6  7  8  9 10] [11 12 13 14 15]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1*3 和 3*1 的矩阵运算</span><br>arr1 = np.full((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>)<br>arr2 = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为:\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为:\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为:[[1 1 1]]arr2为:[[1] [1] [1]]arr1 + arr2为：[[2 2 2] [2 2 2] [2 2 2]]</code></pre><p><img src="/../../../../ai_assets/02_ndarray_broad.png" alt="png"></p><h1 id="3-通用函数"><a href="#3-通用函数" class="headerlink" title="3 通用函数"></a>3 通用函数</h1><h2 id="3-1-一元函数"><a href="#3-1-一元函数" class="headerlink" title="3.1 一元函数"></a>3.1 一元函数</h2><p>一元函数的参数是一个数组对象，函数会矢量化地对数组每一个元素进行运算。</p><ul><li><code>abs()</code>&#x2F;<code>fabs()</code>：求绝对值</li><li><code>sqrt()</code>：求平方根，相当于 <code>arr ** 0.5</code></li><li><code>square()</code>：求平方，相当于 <code>arr ** 2</code></li><li><code>exp()</code>：求${e^x}$的函数</li><li><code>log()</code>&#x2F;<code>log10()</code>&#x2F;<code>log2()</code>：对数函数</li><li><code>sign()</code>：求元素的符号（1：正数；0：零；-1：负数）</li><li><code>isnan()</code>：判断元素是否为NaN，NaN对应 <code>True</code>，否则为 <code>False</code></li><li><code>ceil()</code>&#x2F;<code>floor()</code>：上取整&#x2F;下取整</li><li><code>sin()</code>&#x2F;<code>cos()</code>&#x2F;<code>tan()</code>：三角函数</li><li><code>arcsin()</code>&#x2F;<code>arccos()</code>&#x2F;<code>arctan()</code>：反三角函数</li><li><code>rint()</code>：四舍五入函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;abs函数：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">abs</span>(arr)&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;square函数：<span class="hljs-subst">&#123;np.square(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;exp函数：<span class="hljs-subst">&#123;np.exp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sign函数：<span class="hljs-subst">&#123;np.sign(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[ 0  1  2 -3 -5  6  7 -8]abs函数：[0 1 2 3 5 6 7 8]square函数：[ 0  1  4  9 25 36 49 64]exp函数：[1.00000000e+00 2.71828183e+00 7.38905610e+00 4.97870684e-02 6.73794700e-03 4.03428793e+02 1.09663316e+03 3.35462628e-04]sign函数：[ 0  1  1 -1 -1  1  1 -1]</code></pre><h2 id="3-2-二元函数"><a href="#3-2-二元函数" class="headerlink" title="3.2 二元函数"></a>3.2 二元函数</h2><p>二元函数的参数是两个数组对象，函数会对两个数组的对应元素进行运算。</p><ul><li><code>add(x, y)</code>&#x2F;<code>subtract(x, y)</code>：加法函数&#x2F;减法函数</li><li><code>multiply(x, y)</code>&#x2F;<code>divide(x, y)</code>：乘法函数&#x2F;除法函数</li><li><code>floor_divide(x, y)</code>&#x2F;<code>mod(x, y)</code>：整除函数&#x2F;求模函数</li><li><code>power(x, y)</code>：求${x^y}$</li></ul><p><code>axis</code>指定的是数组<strong>将会被折叠的维度，而不是将要返回的维度</strong>，因此 <code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合值。</p><ul><li><code>cumsum()</code>：返回一维数组，计算累加和</li><li><code>cumpord()</code>：返回一维数组，计算累乘积</li></ul><p>多维数组默认统计全部维度，如果想要按指定轴进行统计，可以设置 <code>axis</code>参数，0按列统计，值为1按行统计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum累加：\n<span class="hljs-subst">&#123;np.cumsum(arr)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿0轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿1轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumprod累乘：\n<span class="hljs-subst">&#123;np.cumprod(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]cumsum累加：[ 1  3  6 10 15 21 28 36 45 55 66 78]cumsum沿0轴累加：[[ 1  2  3  4] [ 6  8 10 12] [15 18 21 24]]cumsum沿1轴累加：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]cumprod累乘：[        1         2         6        24       120       720      5040     40320    362880   3628800  39916800 479001600]</code></pre><ul><li><code>reduce()</code>：对数据进行聚合</li><li><code>accumulate()</code>：显示每一个元素的聚合过程</li></ul><p>可以对 <code>add()</code>&#x2F;<code>subtract()</code>等运算进行聚合，可以使用 <code>axis</code>指定聚合维度，默认折叠0轴，按列进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;默认add聚合：<span class="hljs-subst">&#123;np.add.reduce(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add使用axis=1聚合：<span class="hljs-subst">&#123;np.add.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add累加过程：\n<span class="hljs-subst">&#123;np.add.accumulate(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;multiply使用axis=1聚合：<span class="hljs-subst">&#123;np.multiply.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]默认add聚合：[15 18 21 24]add使用axis=1聚合：[10 26 42]add累加过程：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]multiply使用axis=1聚合：[   24  1680 11880]</code></pre><h2 id="3-3-其他函数"><a href="#3-3-其他函数" class="headerlink" title="3.3 其他函数"></a>3.3 其他函数</h2><p><code>where(condition, x, y)</code>：相当于 <code>x if condition else y</code>，只不过是矢量化对数组每一个元素操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;where之后为：\n<span class="hljs-subst">&#123;np.where(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-number">66</span>, <span class="hljs-number">11</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]where之后为：[[66 11 66 11 66] [11 66 11 66 11] [66 11 66 11 66]]</code></pre><ul><li><code>all()</code>：判断数组是否都是True，全为True返回True，否则返回False</li><li><code>any()</code>：判断数组是否存在True，有True返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[87 73 24 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Truenp.any(arr)为：True[87 73  0 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Falsenp.any(arr)为：True</code></pre><p>结合布尔逻辑，判断是否存在符合条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 是否存在大于90的元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr &gt; <span class="hljs-number">90</span>)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 是否全都大于10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr &gt; <span class="hljs-number">10</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">TrueFalse</code></pre><ul><li><code>concatenate([arr1, arr2, arr3])</code>：拼接数组，要求维度相同</li><li><code>vstack()</code>&#x2F;<code>hstack()</code>：按列拼接，按行拼接</li></ul><p>二维数组拼接时，<code>axis</code>默认为0，沿行的方向按列拼接，1为按行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一维数组拼接：&#x27;</span>, np.concatenate([arr1, arr2]), end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr3 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>arr4 = np.arange(<span class="hljs-number">10</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组1：\n&#x27;</span>, arr3, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组2：\n&#x27;</span>, arr4, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;二维数组拼接：\n&#x27;</span>, np.concatenate([arr3, arr4]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\naxis=1拼接：\n&#x27;</span>, np.concatenate([arr3, arr3], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">一维数组拼接： [1 2 3 4 5 6]数组1： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]数组2： [[0 1 2 3 4] [5 6 7 8 9]]二维数组拼接： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14] [ 0  1  2  3  4] [ 5  6  7  8  9]]axis=1拼接： [[ 0  1  2  3  4  0  1  2  3  4] [ 5  6  7  8  9  5  6  7  8  9] [10 11 12 13 14 10 11 12 13 14]]</code></pre><ul><li><code>split(arr, [断点位置])</code>：分割数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维数组</span><br>arr1 = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;分割点3, 5：&#x27;</span>, np.split(arr1, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]))<br><br><span class="hljs-comment"># 二维数组</span><br>arr2 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n按行平均分成3个数组：\n&#x27;</span>, np.split(arr2, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第3行分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">2</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第2列分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">1</span>], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">分割点3, 5： [array([0, 1, 2]), array([3, 4]), array([5, 6, 7, 8, 9])]按行平均分成3个数组： [array([[0, 1, 2, 3, 4]]), array([[5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第3行分割： [array([[0, 1, 2, 3, 4],       [5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第2列分割： [array([[ 0],       [ 5],       [10]]), array([[ 1,  2,  3,  4],       [ 6,  7,  8,  9],       [11, 12, 13, 14]])]</code></pre><ul><li><code>unique()</code>：去除重复元素，返回有序数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>np.unique(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 3, 5, 6])</code></pre><ul><li><code>copy()</code>：返回拷贝后的新数组，拷贝后的数组是独立的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>new_arr = np.copy(arr)<br>new_arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ul><li><code>append()</code>：数组末尾追加元素，返回新的数组</li><li><code>insert()</code>：指定位置插入元素，返回新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.append(arr, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;尾部追加元素：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.insert(arr, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;在下标2插入一个10：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[0 1 2 3 4]尾部追加元素：[ 0  1  2  3  4 10]在下标2插入一个10：[ 0  1 10  2  3  4]</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Numpy索引和布尔逻辑</title>
    <link href="/2024/08/13/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/"/>
    <url>/2024/08/13/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1 普通索引"></a>1 普通索引</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>和Python中的 <code>list</code>索引类似，在多维数组中有特色用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0][1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[-1][1]为：<span class="hljs-subst">&#123;arr[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 在一个[]内使用逗号分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0, 1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>) <span class="hljs-comment"># 等价于 arr[0][1]</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1 2 3] [4 5 6] [7 8 9]]arr[0][1]为：2arr[-1][1]为：8arr[0, 1]为：2</code></pre><h1 id="2-切片索引"><a href="#2-切片索引" class="headerlink" title="2 切片索引"></a>2 切片索引</h1><p>对于一维数组来说，切片索引与 <code>list</code>非常相似，语法为 <code>[起始索引, 结束索引, 步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:6:2]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5 6 7 8 9]arr[1:6:2]为：[2 4 6]</code></pre><p>对于二维数组来说，切片有些不同，语法为 <code>[起始行:结束行:步长, 起始列:结束列:步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:3, 0:3]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">0</span>:<span class="hljs-number">3</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[1:3, 0:3]为：[[4 5 6] [7 8 9]]</code></pre><blockquote><p>注意：切片得到的是视图，而不是复制。</p></blockquote><h1 id="3-花式索引"><a href="#3-花式索引" class="headerlink" title="3 花式索引"></a>3 花式索引</h1><p>花式索引：将索引数组作为一个 <code>ndarray</code>的索引，这个索引数组可以是 <code>ndarray</code>，也可以是Python中的 <code>list</code>，<code>tuple</code>等可迭代类型。</p><p>一维数组就是依次取对应索引的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[1, -1, 2]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5]arr[[1, -1, 2]]为：[2 5 3]</code></pre><p>对于二维数组来说，需要两个数组参数，每个数组代表一个轴上的索引，按照两个轴的索引一一对应，取出对应值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 索引为[0, 1], [1, 2], [3, 0]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 3], [1, 2, 0]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 如果其中一个轴的值一样，可以简化为一个值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 2, 3], 1]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[[0, 1, 3], [1, 2, 0]]为：[ 2  6 10]arr[[0, 1, 2, 3], 1]为：[ 2  5  8 11]</code></pre><p>对多个维度同样适用，和标准的索引一样，第一个索引指的是行，第二个索引指的是列。利用花哨的索引获得的<strong>结果形状与索引数组的形状一致</strong>，而不是与被索引数据的形状一致</p><p>花式索引结合切片索引，非常灵活，见下图：</p><p><img src="/../../../../ai_assets/02_slice_index.png" alt="png"></p><h1 id="4-布尔索引"><a href="#4-布尔索引" class="headerlink" title="4 布尔索引"></a>4 布尔索引</h1><p>布尔索引就是利用布尔数组作为掩码，利用数组的矢量化特性，选出原数组中所有 <code>True</code>对应的元素，而 <code>False</code>对应的元素不会被选中。布尔数组除了手动构造之外，还可以通过表达式生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 指定布尔值</span><br>arr1 = arr[[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 通过表达式生成</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr &gt; 5 为：\n<span class="hljs-subst">&#123;arr &gt; <span class="hljs-number">5</span>&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[arr &gt; 5]为：\n<span class="hljs-subst">&#123;arr[arr &gt; <span class="hljs-number">5</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0 1 2 3 4 5 6 7 8 9]arr1为：[0 1 4 7 9]arr &gt; 5 为：[False False False False False False  True  True  True  True]arr[arr &gt; 5]为：[6 7 8 9]</code></pre><p><code>~</code>可以对布尔数组进行取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;~(arr &gt; 5)为：\n<span class="hljs-subst">&#123;~(arr &gt; <span class="hljs-number">5</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[~(arr &gt; 5)]为：\n<span class="hljs-subst">&#123;arr[~(arr &gt; <span class="hljs-number">5</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">~(arr &gt; 5)为：[ True  True  True  True  True  True False False False False]arr[~(arr &gt; 5)]为：[0 1 2 3 4 5]</code></pre><p>可以使用比较运算 <code>&gt; &lt;=</code>等，搭配逻辑运算 <code>&amp; |</code>筛选出符合条件的布尔数组，再将布尔数组作为掩码取出满足条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;(arr &gt; 5) &amp; (arr % 2 == 0)为：\n<span class="hljs-subst">&#123;(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) | (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) | (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(arr &gt; 5) &amp; (arr % 2 == 0)为：[False False False False False False  True False  True False]arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：[6 8]arr[(arr &gt; 5) | (arr % 2 == 0)]为：[0 2 4 6 7 8 9]</code></pre><p>搭配 <code>where()</code>函数，保留想要的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>np.where(arr &gt; <span class="hljs-number">5</span>, arr, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 大于5的保留，否则替换为-1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([-1, -1, -1, -1, -1, -1,  6,  7,  8,  9])</code></pre><p>结合 <code>sum()</code>函数，统计符合条件的元素个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">5</code></pre><h1 id="5-内存关系"><a href="#5-内存关系" class="headerlink" title="5 内存关系"></a>5 内存关系</h1><ul><li>切片索引虽然创建了新的数组对象，但是新数组和原数组实际指向同一块内存，存在数据共享。</li><li>花式索引和布尔索引也会创建新的数组对象，不过新数组会完全复制原数组的元素，不存在数据共享。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br>arr_slice = arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 切片数组修改会影响原数组</span><br>arr_slice[<span class="hljs-number">2</span>] = <span class="hljs-number">66</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以使用base查看来源</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice来源于：<span class="hljs-subst">&#123;arr_slice.base&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr来源于：<span class="hljs-subst">&#123;arr.base&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr_slice为：[2 3 4 5]arr为：[ 0  1  2  3 66  5  6  7  8  9]arr_slice为：[ 2  3 66  5]arr_slice来源于：[ 0  1  2  3 66  5  6  7  8  9]arr来源于：None</code></pre><h1 id="6-图像案例"><a href="#6-图像案例" class="headerlink" title="6 图像案例"></a>6 图像案例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/123.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b124cbb80&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反向切片，反转图像</span><br>plt.imshow(img[::-<span class="hljs-number">1</span>, ::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b125bdcc0&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57_rev.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片抠图</span><br>plt.imshow(img[<span class="hljs-number">430</span>:<span class="hljs-number">610</span>, <span class="hljs-number">350</span>:<span class="hljs-number">510</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128501c0&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57_big.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/F35C.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128c2860&gt;</code></pre><p><img src="/../../../../ai_assets/02_f35.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片步长降采样</span><br>plt.imshow(img[<span class="hljs-number">3400</span>:<span class="hljs-number">4200</span>:<span class="hljs-number">15</span>, <span class="hljs-number">8000</span>:<span class="hljs-number">8300</span>:<span class="hljs-number">15</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b12954f70&gt;</code></pre><p><img src="/../../../../ai_assets/02_f35_big.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Numpy基础属性和方法</title>
    <link href="/2024/08/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2024/08/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>命令模式下的快捷键：</p><ul><li>Alt + Enter运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter运行当前单元格</li><li>j &#x2F; k、Shift + j &#x2F; Shift + k选中下方&#x2F;上方单元格、连续选中下方&#x2F;上方单元格</li><li>a &#x2F; b在下方&#x2F;上方插入新的单元格</li><li>c &#x2F; x复制单元格 &#x2F; 剪切单元格</li><li>v &#x2F; Shift + v在下方&#x2F;上方粘贴单元格</li><li>dd &#x2F; z删除单元格 &#x2F; 恢复删除的单元格</li><li>Shift + l显示或隐藏当前&#x2F;所有单元格行号</li><li>Space &#x2F; Shift + Space向下&#x2F;向上滚动页面</li></ul><p>编辑模式下的快捷键：</p><ul><li>Shift + Tab获得提示信息</li><li>Ctrl + ]&#x2F; Ctrl + [增加&#x2F;减少缩进</li><li>Alt + Enter运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter运行当前单元格</li><li>Ctrl + Left &#x2F; Right光标移到行首&#x2F;行尾</li><li>Ctrl + Up &#x2F; Down光标移动代码开头&#x2F;结尾处</li><li>Up &#x2F; Down光标上移&#x2F;下移一行或移到上&#x2F;下一个单元格</li></ul><h1 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1 数组的创建"></a>1 数组的创建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><ol><li>使用 <code>array</code>函数，通过 <code>list</code>创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># array(list)</span><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>arr, <span class="hljs-built_in">type</span>(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(array([1, 2, 3, 4, 5]), numpy.ndarray)</code></pre><ol start="2"><li>使用 <code>arange</code>函数，指定范围生成数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># arange(起始值, 结束值, 步长)</span><br>arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)  <br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ol start="3"><li>使用 <code>linspace</code>函数，生成等差数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># linspace(起始值, 结束值, 元素个数)</span><br>arr = np.linspace(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 10.,  20.,  30.,  40.,  50.,  60.,  70.,  80.,  90., 100.])</code></pre><ol start="4"><li>使用 <code>logspace</code>函数，生成等比数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># logspace(起始指数, 结束指数, num=元素个数, base=底数)</span><br><span class="hljs-comment"># 由起始指数、结束指数和底数确定起始值和结束值，在范围内根据元素个数自动推算公比</span><br>arr = np.logspace(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, num=<span class="hljs-number">5</span>, base=<span class="hljs-number">2</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([   4.,   16.,   64.,  256., 1024.])</code></pre><ol start="5"><li>使用 <code>fromstring</code>函数，从字符串提取数据创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fromstring(str, sep=’分隔符&#x27;, [dtype=&#x27;数据类型&#x27;])</span><br>arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1., 2., 3., 4., 5.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5])</code></pre><ol start="6"><li>使用 <code>random</code>函数生成随机数，创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># randint: 生成随机整数</span><br><span class="hljs-comment"># random.randint(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, size=<span class="hljs-number">5</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([8, 1, 3, 8, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uniform: 生成随机浮点数</span><br><span class="hljs-comment"># random.uniform(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[8.89013018, 9.11208169, 2.86415079, 1.87278992, 9.49237558],       [2.72498312, 2.42432246, 1.96473966, 5.23585378, 5.84650235],       [9.42765155, 7.01779665, 3.07567507, 6.34309282, 4.26517489]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># rand: 生成[0, 1)内的随机浮点数</span><br><span class="hljs-comment"># random.rand(数组形状shape)</span><br>arr = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0.25282566, 0.93635239, 0.02265436, 0.89447073],       [0.81152905, 0.70119062, 0.96435302, 0.53702331],       [0.34787245, 0.58961185, 0.61218228, 0.07453859]])</code></pre><ol start="7"><li>填充指定值的数组</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zeros: 填充为0</span><br>arr = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0., 0.],       [0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ones: 填充为1</span><br>arr = np.ones(<span class="hljs-number">10</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># full: 填充为指定值</span><br>arr = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">66</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[66, 66, 66, 66],       [66, 66, 66, 66],       [66, 66, 66, 66]])</code></pre><ol start="8"><li>使用 <code>eye</code>函数创建单位矩阵</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># eye(矩阵边长)</span><br>arr = np.eye(<span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1., 0., 0., 0.],       [0., 1., 0., 0.],       [0., 0., 1., 0.],       [0., 0., 0., 1.]])</code></pre><p>创建数组时可以通过 <code>dtype</code>指定数组内元素类型，Numpy的每种数据类型有不同位数的版本，可以使用首字母＋字节数简写，如 <code>i8</code>是占用8字节的 <code>int64</code>。</p><ul><li>有符号整数 <code>int</code></li><li>无符号整数 <code>uint</code></li><li>浮点数 <code>float</code></li><li>复数 <code>complex</code></li><li>布尔 <code>bool</code></li><li>字符串 <code>string_</code>或 <code>S</code></li><li>Python对象 <code>object</code></li><li>结构化数据类型 <code>void</code></li></ul><h1 id="2-数组的属性"><a href="#2-数组的属性" class="headerlink" title="2 数组的属性"></a>2 数组的属性</h1><p><code>size</code>：获取数组的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的size为：<span class="hljs-subst">&#123;arr1.size&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的size为：<span class="hljs-subst">&#123;arr2.size&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的size为：3[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的size为：12</code></pre><p><code>shape</code>：获取数组的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的shape为：<span class="hljs-subst">&#123;arr1.shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的shape为：<span class="hljs-subst">&#123;arr2.shape&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的shape为：(3,)[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的shape为：(3, 4)</code></pre><p><code>dtype</code>：获取数组元素的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.rand(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的dtype为：<span class="hljs-subst">&#123;arr1.dtype&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的dtype为：<span class="hljs-subst">&#123;arr2.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的dtype为：int64[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的dtype为：float64</code></pre><p><code>ndim</code>：获取数组的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的ndim为：<span class="hljs-subst">&#123;arr1.ndim&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的ndim为：<span class="hljs-subst">&#123;arr2.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的ndim为：1[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的ndim为：2</code></pre><p><code>itemsize</code>：获取数组内每个元素所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的itemsize为：<span class="hljs-subst">&#123;arr1.itemsize&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的itemsize为：<span class="hljs-subst">&#123;arr2.itemsize&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的itemsize为：8[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的itemsize为：8</code></pre><p><code>nbytes</code>：获取数组所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的nbytes为：<span class="hljs-subst">&#123;arr1.nbytes&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的nbytes为：<span class="hljs-subst">&#123;arr2.nbytes&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的nbytes为：24[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的nbytes为：48</code></pre><h1 id="3-数组的方法"><a href="#3-数组的方法" class="headerlink" title="3 数组的方法"></a>3 数组的方法</h1><h2 id="3-1-描述性统计"><a href="#3-1-描述性统计" class="headerlink" title="3.1 描述性统计"></a>3.1 描述性统计</h2><p>Numpy中很多常用方法既可以写成对象的方法调用，也可以写成模块函数的调用。</p><p><code>arr.method()</code>和 <code>np.function(arr)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,        27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,        40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,        53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,        66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,        79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,        92,  93,  94,  95,  96,  97,  98,  99, 100])</code></pre><ul><li><code>sum()</code>：求总和</li><li><code>mean()</code>：求算术平均值</li><li><code>median()</code>：求中位数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">sum</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">sum</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;算术平均值：<span class="hljs-subst">&#123;np.mean(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中位数：<span class="hljs-subst">&#123;np.median(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">总和：5050总和：5050算术平均值：50.5中位数：50.5</code></pre><ul><li><code>amax()</code>&#x2F;<code>max()</code>：求最大值</li><li><code>amin()</code>&#x2F;<code>min()</code>：求最小值</li><li><code>ptp()</code>：求全距，即最大值-最小值。</li><li><code>quantile(arr, 分位点)</code>：求分位数。比如0.5表示计算50%分位数，也就是中位数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">max</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;np.amax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">min</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;np.amin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;全距：<span class="hljs-subst">&#123;np.ptp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;分位数：<span class="hljs-subst">&#123;np.quantile(arr, <span class="hljs-number">0.4</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最大值：100最大值：100最小值：1最小值：1全距：99分位数：40.6</code></pre><ul><li><code>var()</code>：求方差</li><li><code>std()</code>：求标准差</li><li><code>arr.std() / arr.mean()</code>：求变异系数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;arr.var()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;np.var(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;arr.std()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;np.std(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;变异系数：<span class="hljs-subst">&#123;arr.std() / arr.mean()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">方差：833.25方差：833.25标准差：28.86607004772212标准差：28.86607004772212变异系数：0.5716053474796459</code></pre><ul><li><code>argmax()</code>：返回最大值索引</li><li><code>argmin()</code>：返回最小值索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">66</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;np.argmax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;arr.argmax()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;np.argmin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;arr.argmin()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[12  5 66  9  1]最大值索引为：2最大值索引为：2最小值索引为：4最小值索引为：4</code></pre><p>可以使用 <code>axis</code>对指定维度进行聚合，<code>axis</code>指定的是数组将会被折叠的维度，而不是将要返回的维度，因此 <code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合。</p><p><img src="/../../../../ai_assets/02_axis.png" alt="png"></p><p><code>axis</code>的值就是 <code>shape</code>中对应下标的维度。</p><p>一维数组中 <code>axis=0</code>：0向维度折叠，也就是按整个数组聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br>arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">np.int64(45)</code></pre><p>二维数组中：</p><ul><li><code>axis=0</code>：0向维度折叠，也就是把行折叠，按列进行统计</li><li><code>axis=1</code>：1向维度折叠，也就是把列折叠，按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按列统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按行统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]按列统计： [15 18 21 24 27]按行统计： [10 35 60]</code></pre><h2 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h2><ul><li><code>reshape()</code>：调整数组形状，注意返回的是原数组的视图，而不是拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br>arr_shape = arr.reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_shape数组：\n<span class="hljs-subst">&#123;arr_shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单列数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单列数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单行数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单行数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342 9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]arr_shape数组：[[3.16428678 1.85703697 8.08660982 3.30281002] [1.65160879 6.65371342 9.35288329 2.33650475] [5.72465209 9.37121035 9.87604912 4.20079867]]二维单列数组：[[3.16428678] [1.85703697] [8.08660982] [3.30281002] [1.65160879] [6.65371342] [9.35288329] [2.33650475] [5.72465209] [9.37121035] [9.87604912] [4.20079867]]二维单行数组：[[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342  9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]]</code></pre><ul><li><code>astype(数据类型)</code>：将数组元素转换为指定类型，返回一个新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br>arr_int = arr.astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_int类型：<span class="hljs-subst">&#123;arr_int.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原类型：float64arr类型：float64arr_int类型：int64</code></pre><ul><li><code>fill()</code>：向数组填充指定元素，修改数组本身</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr.fill(<span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.])</code></pre><ul><li><code>sort()</code>：对原数组进行就地排序<ul><li><code>数组.sort()</code>：就地排序</li><li><code>np.sort(数组)</code>：排序返回新数组，原数组不变</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>arr_st = np.sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的新数组：<span class="hljs-subst">&#123;arr_st&#125;</span>&#x27;</span>)<br><br>arr.sort()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用数组.sort()的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的新数组：[2 5 5 6 6 7 7 7 7 8]使用数组.sort()的原数组：[2 5 5 6 6 7 7 7 7 8]</code></pre><ul><li><code>flatten()</code>：将多维数组扁平化为一维数组，返回一个新数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr.ndim&#125;</span>\n&#x27;</span>)<br><br>arr_f = arr.flatten()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;扁平化数组为：\n<span class="hljs-subst">&#123;arr_f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr_f.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]维度：2扁平化数组为：[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]维度：1</code></pre><ul><li><code>tolist()</code>：将数组转化为 <code>list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = arr.tolist()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ls))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;list&#39;&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2024/08/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01%20MySQL%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/08/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01%20MySQL%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据定义语言DDL"><a href="#1-数据定义语言DDL" class="headerlink" title="1 数据定义语言DDL"></a>1 数据定义语言DDL</h1><p>Data Definition Language：数据定义语言，用来定义数据库对象(数据库，表，字段)。</p><h2 id="1-1-库操作"><a href="#1-1-库操作" class="headerlink" title="1.1 库操作"></a>1.1 库操作</h2><p><strong>创建数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [CHARSET <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;utf8&#x27;</span>];<br></code></pre></td></tr></table></figure><p><strong>显示所有库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure><p><strong>使用指定数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure><p><strong>删除指定数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名<br></code></pre></td></tr></table></figure><h2 id="1-2-表操作"><a href="#1-2-表操作" class="headerlink" title="1.2 表操作"></a>1.2 表操作</h2><h3 id="1-2-1-创建表"><a href="#1-2-1-创建表" class="headerlink" title="1.2.1 创建表"></a>1.2.1 创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>    字段名<span class="hljs-number">1</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">1</span>注释],<br>    字段名<span class="hljs-number">2</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">2</span>注释],<br>    字段名<span class="hljs-number">3</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">3</span>注释]<br>) [COMMENT 表注释]<br></code></pre></td></tr></table></figure><p>常用主键自增 <code>AUTO_INCREMENT</code>。</p><ul><li>常用数据类型：<ul><li>整数：<code>INT</code></li><li>字符串：<code>VARCHAR(长度)</code></li><li>小数：<code>DECIMAL(总位数, 小数位)</code></li><li>时间：<code>DATETIME</code></li></ul></li><li>常用约束<ul><li>主键：<code>PRIMARY KEY</code></li><li>非空：<code>NOT NULL</code></li><li>唯一：<code>UNIQUE</code></li><li>默认：<code>DEFAULT</code></li><li>外键：<code>FOREIGN KEY</code>（影响效率）</li></ul></li></ul><h3 id="1-2-2-查询表"><a href="#1-2-2-查询表" class="headerlink" title="1.2.2 查询表"></a>1.2.2 查询表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询当前数据库所有表<br><span class="hljs-keyword">SHOW</span> TABLES;<br><br># 查询表结构<br><span class="hljs-keyword">DESC</span> 表名;<br><br># 查询建表语句<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h3 id="1-2-3-修改表"><a href="#1-2-3-修改表" class="headerlink" title="1.2.3 修改表"></a>1.2.3 修改表</h3><p><strong>增加字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 [约束];<br></code></pre></td></tr></table></figure><p><strong>删除字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br></code></pre></td></tr></table></figure><p><strong>修改字段类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 MODIFY 字段名 新类型;<br></code></pre></td></tr></table></figure><p><strong>修改字段名和类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 [约束];<br></code></pre></td></tr></table></figure><p><strong>修改表名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 旧表名 RENAME 新表名;<br></code></pre></td></tr></table></figure><h3 id="1-2-4-删除表"><a href="#1-2-4-删除表" class="headerlink" title="1.2.4 删除表"></a>1.2.4 删除表</h3><p><strong>删除整个表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>删除数据保留表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 主键自增序列不清零<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名;<br><br># 主键自增序列清零<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h1 id="2-数据操作语言DML"><a href="#2-数据操作语言DML" class="headerlink" title="2 数据操作语言DML"></a>2 数据操作语言DML</h1><p>Data Manipulation Language：数据操作语言，用来对数据库中表的数据记录进行增、删、改操作。</p><h2 id="2-1-增加INSERT"><a href="#2-1-增加INSERT" class="headerlink" title="2.1 增加INSERT"></a>2.1 增加INSERT</h2><p><strong>向指定字段添加数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>全部字段添加数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p><strong>批量添加数据（指定字段）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>批量添加数据（全部字段）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><h2 id="2-2-删除DELETE"><a href="#2-2-删除DELETE" class="headerlink" title="2.2 删除DELETE"></a>2.2 删除DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h2 id="2-3-修改UPDATE"><a href="#2-3-修改UPDATE" class="headerlink" title="2.3 修改UPDATE"></a>2.3 修改UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span> , 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span><br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h1 id="3-数据查询语言DQL"><a href="#3-数据查询语言DQL" class="headerlink" title="3 数据查询语言DQL"></a>3 数据查询语言DQL</h1><p>Data Query Language：数据查询语言，用来查询数据库表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br><span class="hljs-keyword">HAVING</span> 分组后条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 排序字段<br>LIMIT 分页参数;<br></code></pre></td></tr></table></figure><ol><li><code>FROM</code> 加载数据</li><li><code>WHERE</code> 对加载后的数据进行筛选</li><li><code>GROUP BY</code> 对筛选后的数据进行分组</li><li><code>HAVING</code> 对分组后的数据进行筛选</li><li><code>SELECT</code> 返回要查询的字段</li><li><code>ORDER BY</code> 对结果进行排序</li><li><code>LIMIT</code> 限制返回结果</li></ol><h2 id="3-1-基础查询"><a href="#3-1-基础查询" class="headerlink" title="3.1 基础查询"></a>3.1 基础查询</h2><p><strong>通用格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure><p><strong>查询所有字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>查询结果去重：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>比较运算符 <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code>都和Python相同，另有不同的有如下：<ul><li><code>字段 BETWEEN 最小值 AND 最大值</code>：在最小值和最大值范围内即可</li><li><code>字段 IN (值1, 值2...)</code>：在 <code>()</code>内满足任意即可</li><li><code>字段 LIKE &quot;占位符&quot;</code>：模糊查询，可以用 <code>_</code>代表一个字符，<code>%</code>代表任意个字符</li><li><code>IS NULL</code>：判空专用</li></ul></li><li>逻辑运算符：<ul><li><code>AND</code></li><li><code>OR</code></li><li><code>NOT</code></li></ul></li></ul><h2 id="3-2-聚合查询"><a href="#3-2-聚合查询" class="headerlink" title="3.2 聚合查询"></a>3.2 聚合查询</h2><p>前面的查询都是横向查询，根据条件一行一行的进行判断。<br>聚合函数查询是纵向查询，它将一列数据作为一个整体，进行纵向计算，然后返回一个结果值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>：按照列统计数量</li><li><code>MAX()</code>：按照列计算最大值</li><li><code>MIN()</code>：按照列计算最小值</li><li><code>AVG()</code>：按照列计算平均值</li><li><code>SUM()</code>：按照列计算数值和</li></ul><h2 id="3-3-分组查询"><a href="#3-3-分组查询" class="headerlink" title="3.3 分组查询"></a>3.3 分组查询</h2><p>按列进行分类，把相同的数据归为一类，然后可以对分类完的数据进行合并计算。</p><p>通常和聚合函数联合使用：</p><ol><li>先分组：把表数据按照指定列的值进行划分，值相同的数据划分到同一个组</li><li>再聚合：分别针对每一组数据使用聚合函数进行统计</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [聚合函数, 分组字段]<br>[<span class="hljs-keyword">WHERE</span> 条件]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br>[<span class="hljs-keyword">HAVING</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><p><code>WHERE</code>与 <code>HAVING</code>区别：</p><ul><li>执行时机不同：<ul><li><code>WHERE</code>是分组之前进行过滤，不满足 <code>WHERE</code>条件，不参与分组</li><li><code>HAVING</code> 是分组之后对结果进行过滤</li></ul></li><li>判断条件不同：<ul><li><code>WHERE</code> 不能对聚合函数进行判断</li><li><code>HAVING</code> 可以对聚合函数进行判断</li></ul></li></ul><h2 id="3-4-排序查询"><a href="#3-4-排序查询" class="headerlink" title="3.4 排序查询"></a>3.4 排序查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式, 字段<span class="hljs-number">2</span> 排序方式;<br></code></pre></td></tr></table></figure><p>排序方式：<br><code>ASC</code>：升序（默认值）<br><code>DESC</code>：降序</p><h2 id="3-5-分页查询"><a href="#3-5-分页查询" class="headerlink" title="3.5 分页查询"></a>3.5 分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br>LIMIT [起始行数,] 总行数;<br></code></pre></td></tr></table></figure><h1 id="4-多表查询"><a href="#4-多表查询" class="headerlink" title="4 多表查询"></a>4 多表查询</h1><p>多表查询 <code>SELECT 字段 FROM 表1, 表2</code>会产生笛卡尔积，也就是两个表的所有组合情况。要想消除笛卡尔积，只需要给多表查询加上连接查询的条件即可。</p><h2 id="4-1-连接查询"><a href="#4-1-连接查询" class="headerlink" title="4.1 连接查询"></a>4.1 连接查询</h2><h3 id="4-1-1-内连接"><a href="#4-1-1-内连接" class="headerlink" title="4.1.1 内连接"></a>4.1.1 内连接</h3><p><strong>隐式内连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p><strong>显式内连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br>[<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>内连接只能返回两个表中都存在匹配的行。</p><h3 id="4-1-2-外连接"><a href="#4-1-2-外连接" class="headerlink" title="4.1.2 外连接"></a>4.1.2 外连接</h3><p><strong>左外连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>左外连接是以左表为中心，返回左表所有行，以及右表匹配的行。即使右表没有匹配，则对应列显示 <code>NULL</code>。</p><p><strong>右外连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>右外连接是以右表为中心，返回右表所有行，以及左表匹配的行。即使左表没有匹配，则对应列显示 <code>NULL</code>。<br><img src="/../../../../ai_assets/Pasted%20image%2020250925231426.png"></p><h3 id="4-1-3-全连接"><a href="#4-1-3-全连接" class="headerlink" title="4.1.3 全连接"></a>4.1.3 全连接</h3><p>全连接 <code>FULL OUTER JOIN</code>是取两个表的并集，MySQL本身并不支持全连接，但可以借助 <code>UNION</code>实现。</p><p><code>UNION</code>合并，并且去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p><code>UNION ALL</code>合并但不去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><blockquote><p>在多表连接中，如果两个表的连接字段名相同，可以不使用 <code>ON a.id = b.id</code>，而使用更简洁的 <code>USING(id)</code>代替。</p></blockquote><h2 id="4-2-子查询"><a href="#4-2-子查询" class="headerlink" title="4.2 子查询"></a>4.2 子查询</h2><p>将查询的结果作为外部<strong>查询的条件、字段或表</strong>来使用，称为嵌套查询，又称子查询。子查询用来提供值、集合或表给外查询作比较或进一步处理。</p><h3 id="4-2-1-常见分类"><a href="#4-2-1-常见分类" class="headerlink" title="4.2.1 常见分类"></a>4.2.1 常见分类</h3><ul><li>相关子查询（Correlated Subquery）<ul><li>子查询<strong>内部引用外查询的列</strong>，子查询需要对外查询的每一行重新计算，每行执行效率较低</li></ul></li><li>非相关子查询（Non-correlated）<ul><li>子查询<strong>独立于外查询</strong>，单独执行一次得到结果，外查询再使用该结果</li></ul></li><li>按返回结果类型<ul><li>标量子查询（Scalar）：返回单个值（单行单列）。可用于 <code>= (子查询)</code>、<code>SELECT (子查询)</code> 等场景，若返回多行则报错</li><li>单行多列子查询：返回一行，通常用 <code>(a, b) = (SELECT x, y ...)</code> 方式比较</li><li>多行单列子查询：返回多行，通常用 <code>IN</code>、<code>ANY</code>、<code>SOME</code>、<code>EXISTS</code></li><li>多行多列子查询：返回多行多列，用 <code>(a, b) IN (SELECT x, y ...)</code> 方式比较，或<strong>当做派生表</strong>处理</li></ul></li></ul><h3 id="4-2-2-常用关键字"><a href="#4-2-2-常用关键字" class="headerlink" title="4.2.2 常用关键字"></a>4.2.2 常用关键字</h3><ul><li><code>IN</code>：判断一个值<strong>是否在集合</strong>里<ul><li><code>salary IN (SELECT salary FROM …)</code></li></ul></li><li><code>EXISTS</code>：判断是否存在<strong>至少一行</strong>结果<ul><li><code>EXISTS (SELECT 1 FROM …)</code></li></ul></li><li><code>ANY/SOME</code>：和集合中<strong>至少一个值</strong>比较<ul><li><code>salary &gt; ANY (SELECT salary FROM …)</code></li></ul></li><li><code>ALL</code>：和集合中<strong>所有值</strong>比较<ul><li><code>salary &gt; ALL (SELECT salary FROM …)</code></li></ul></li></ul><blockquote><p><code>NOT IN</code> 与 <code>NULL</code> 会导致结果为空集，常用 <code>NOT EXISTS</code> 来代替 <code>NOT IN</code>。</p></blockquote><h3 id="4-2-3-示例"><a href="#4-2-3-示例" class="headerlink" title="4.2.3 示例"></a>4.2.3 示例</h3><p><strong>标量子查询：</strong> 子查询只返回一个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 非相关标量子查询<br># 查询工资高于平均工资的员工姓名和工作<br><span class="hljs-keyword">SELECT</span> <br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <br>        <span class="hljs-keyword">FROM</span> emp<br>    );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 相关标量子查询<br># 查询工资高于本部门平均工资的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span> <br>    emp <span class="hljs-keyword">AS</span> e<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-operator">=</span> e.dept_id  # 子查询内部引用外部列<br>    );<br></code></pre></td></tr></table></figure><p><strong>多行多列子查询：</strong> 子查询返回多行多列数据，通常需要与 <code>IN</code>搭配使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    (dept, salary) <span class="hljs-keyword">IN</span> (<br>        <span class="hljs-keyword">SELECT</span> dept, <span class="hljs-built_in">MAX</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept<br>    );<br></code></pre></td></tr></table></figure><p><strong>派生表：</strong> 子查询结果作为派生表使用，通常需要起别名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span> e.name, e.dept_id, e.salary<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> dept_id, <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_id<br>) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">ON</span> e.dept_id <span class="hljs-operator">=</span> t.dept_id<br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-operator">=</span> t.max_salary;<br></code></pre></td></tr></table></figure><h1 id="5-开窗函数"><a href="#5-开窗函数" class="headerlink" title="5 开窗函数"></a>5 开窗函数</h1><p>MySQL 窗口函数（Window Functions）是 MySQL 8.0 引入的一项强大功能，窗口函数的作用类似于聚合函数，但它并不会像 <code>GROUP BY</code> 那样把多行聚合成一行，它会在原有表基础上，为<strong>每一行添加一个新列</strong>，返回计算结果。</p><ul><li><code>PARTITION BY</code>：将查询结果分成若干个<strong>独立的窗口（分区）</strong>，窗口函数会分别在每个分区上进行计算，类似于 <code>GROUP BY</code>，但它不合并行。</li><li><code>ORDER BY</code>：确定窗口内的顺序，对排名 &#x2F; 偏移函数非常重要。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqlFIRST_VAL">SELECT 字段列表,<br>函数() OVER(<br>    [PARTITION BY 分区列表]<br>    [ORDER BY 排序列表]<br>) [[AS] 别名]<br></code></pre></td></tr></table></figure><p>每加一个开窗函数，就可以在原有表基础上新增一列，具体取决于选用什么函数。</p><ul><li>排名函数<ul><li><code>ROW_NUMBER()</code>：为分区的每一行分配一个<strong>唯一</strong>的连续整数。1 2 3 4</li><li><code>RANK()</code>：为分区每一行分配排名，有相同排名，但会<strong>跳过后续排名</strong>。 1 2 2 4</li><li><code>DENSE_RANK()</code>：为分区每一行分配排名，有相同排名且<strong>连续</strong>。1 2 2 3</li></ul></li><li>分析&#x2F;位移函数<ul><li><code>LAG(expr, N)</code>：返回当前行<strong>前面第N行</strong>的 <code>expr</code>值，比如计算销售额与前N天的差异。</li><li><code>LEAD(expr, N)</code>：返回当前行<strong>后面第N行</strong>的 <code>expr</code>值，比如计算销售额与后N天的差异。</li><li><code>FIRST_VALUE(expr)</code>：返回窗口框架中<strong>第一行</strong>的 <code>expr</code>值，比如找出每个部门的最高薪水。</li><li><code>LAST_VALUE(expr)</code>：返回窗口框架中<strong>最后一行</strong>的 <code>expr</code>值，比如找出每个部门的最低薪水。</li></ul></li><li>聚合函数<ul><li><code>SUM()</code>：计算窗口内的总和</li><li><code>AVG()</code>：计算窗口内的平均值</li><li>…</li></ul></li></ul><p>窗口函数<strong>只能出现在 <code>SELECT</code>列表和 <code>ORDER BY</code>中</strong>（不能在 <code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code> 中直接使用，因为这些子句在 <code>SELECT</code>之前就执行了，而窗口函数是在 <code>SELECT</code>阶段才计算的）。</p><p>如果需要对窗口结果做过滤，应该使用子查询或 CTE。</p><p><strong>经典TOP-N问题：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> id, name, dept, salary,<br>    <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> dept <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span><br>    ) <span class="hljs-keyword">AS</span> rn<br>    <span class="hljs-keyword">FROM</span> employees<br>) t<br><span class="hljs-keyword">WHERE</span> rn <span class="hljs-operator">&lt;=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h1 id="6-CTE"><a href="#6-CTE" class="headerlink" title="6 CTE"></a>6 CTE</h1><p><strong>CTE（Common Table Expression，公共表表达式）</strong>就是<strong>临时结果集</strong>，可以在一个查询里先把它定义出来，在后续查询中使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cte_name  <span class="hljs-keyword">AS</span> (<br>    子查询<br>)<br><br><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> cte_name<br><span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13_Python数据结构与算法</title>
    <link href="/2024/08/08/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/08/08/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>鉴于C++章节已做详细说明，本节只做记录，不做详细讲解。</p><h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h1><h2 id="1-1-栈"><a href="#1-1-栈" class="headerlink" title="1.1 栈"></a>1.1 栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈顶-&gt; &#x27;</span> + <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items[::-<span class="hljs-number">1</span>]))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断栈是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入栈&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 top 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    st = Stack()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取栈顶&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、返回栈的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、遍历栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入栈的元素：&#x27;</span>).strip()<br>                    st.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取栈顶</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.top()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈顶元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> st.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 返回栈的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(st)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 遍历栈</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队列为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队首-&gt; &#x27;</span> + <span class="hljs-string">&#x27;-&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items)) + <span class="hljs-string">&#x27; &lt;-队尾&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断队列是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入队&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出队&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">front</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队首元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 front 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 rear 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取队首&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、取队尾&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、返回队列的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、遍历队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入队列的元素：&#x27;</span>).strip()<br>                    q.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取队首</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.front()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队首元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 取队尾</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.rear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队尾元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> q.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 返回队列的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队列中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(q)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 遍历队列</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-3-单链表"><a href="#1-3-单链表" class="headerlink" title="1.3 单链表"></a>1.3 单链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        elem = [data <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>]  <span class="hljs-comment"># 借助 迭代器 使用 列表推导式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, elem)) + <span class="hljs-string">&#x27;-&gt;None&#x27;</span> <span class="hljs-keyword">if</span> elem <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;空链表&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">yield</span> current.data<br>            current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            <span class="hljs-variable language_">self</span>.tail.<span class="hljs-built_in">next</span> = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prepend</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            new_node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-variable language_">self</span>.head = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, data, pos</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        向链表指定下标插入元素</span><br><span class="hljs-string">        :param data: 要插入的元素值</span><br><span class="hljs-string">        :param pos: 要插入的下标，从0开始</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 处理越界问题</span><br>        <span class="hljs-keyword">if</span> pos &gt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>) <span class="hljs-keyword">or</span> pos &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;索引超出界限！&#x27;</span>)<br><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 处理插入头结点和空链表插入的特殊情况</span><br>        <span class="hljs-keyword">if</span> pos == <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.prepend(data)<br>        <span class="hljs-comment"># 其他情况</span><br>        <span class="hljs-keyword">else</span>:<br>            current = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-comment"># 遍历到要插入位置的前一个节点</span><br>            <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos - <span class="hljs-number">1</span>):<br>                current = current.<span class="hljs-built_in">next</span><br><br>            new_node.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span> = new_node<br><br>            <span class="hljs-comment"># 如果插入到了尾节点，维护tail</span><br>            <span class="hljs-keyword">if</span> new_node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        删除链表中值为data的指定数量的节点</span><br><span class="hljs-string">        :param data: 要删除的值</span><br><span class="hljs-string">        :param num: 要删除的数量，1为默认，0表示删除所有</span><br><span class="hljs-string">        :return: 返回删除成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 1、处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法删除！&#x27;</span>)<br><br>        <span class="hljs-comment"># 已删节点数</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 2、处理头结点为目标值的情况</span><br>        <span class="hljs-comment"># 有头结点 且 头结点数据=要删除的数据 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.head.data == data <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-variable language_">self</span>.head = <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span><br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 更新链表长度</span><br>            <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 3、链表被删除为空，更新尾节点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 4、处理后续节点为目标值的情况</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空 且 有下一个节点 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>.data == data:<br>                <span class="hljs-comment"># 删除下一个节点，导致当前节点的下一个节点已经改变</span><br>                current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 更新链表长度</span><br>                <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>                <span class="hljs-comment"># 如果删除了尾结点，需要更新当前节点为尾结点</span><br>                <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-variable language_">self</span>.tail = current<br>            <span class="hljs-comment"># 只有没删除节点时才移动</span><br>            <span class="hljs-keyword">else</span>:<br>                current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replace</span>(<span class="hljs-params">self, data, new_data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        修改并替换链表中的指定值为新值</span><br><span class="hljs-string">        :param data: 要修改的值</span><br><span class="hljs-string">        :param new_data: 修改后的新值</span><br><span class="hljs-string">        :param num: 修改num个，1为默认，0表示替换所有</span><br><span class="hljs-string">        :return: 返回修改成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法修改！&#x27;</span>)<br><br>        cnt = <span class="hljs-number">0</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空  且 （要替换所有 或 已替换数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                current.data = new_data<br>                cnt += <span class="hljs-number">1</span><br>            current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data, <span class="hljs-built_in">all</span>=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        查找链表指定元素的位置</span><br><span class="hljs-string">        :param data: 要查找的元素</span><br><span class="hljs-string">        :param all: 是否要查询所有符合条件的下标，True表示查询所有，False只查询一个，默认为False</span><br><span class="hljs-string">        :return: 返回下标位置，没找到抛出ValueError错误</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        idx = <span class="hljs-number">0</span><br>        idxes = []<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                <span class="hljs-comment"># 查找全部符合条件的下标</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>:<br>                    idxes.append(idx)<br>                <span class="hljs-comment"># 只查一个下标</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> idx<br>            current = current.<span class="hljs-built_in">next</span><br>            idx += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> idxes:<br>            <span class="hljs-keyword">return</span> idxes<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断链表是否为空</span><br><span class="hljs-string">        :return: 为空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;清空当前链表&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ls = LinkedList()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、链表尾部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、链表头部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、指定下标插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、删除链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、修改链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、显示链表长度&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、显示所有元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、查询链表是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;10、清空链表&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 链表尾部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.append(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 链表头部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.prepend(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 指定下标插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x, pos = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值和下标（从0开始）：&#x27;</span>).strip().split()<br>                    ls.insert(x, <span class="hljs-built_in">int</span>(pos))<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 删除链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要删除的元素值 [可选：删除个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">1</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功删除<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 修改链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要替换的元素值和替换后的新值 [可选：替换个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">3</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">2</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功将<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点替换为<span class="hljs-subst">&#123;elems[<span class="hljs-number">1</span>]&#125;</span>，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找链表元素</span><br>                elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素 [可选：是否查询所有]：&#x27;</span>).strip().split()<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>], <span class="hljs-literal">True</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功！该元素下标为<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 显示链表长度</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;链表长度为：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ls)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 显示所有元素</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 查询链表是否为空</span><br>                <span class="hljs-keyword">if</span> ls.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;10&#x27;</span>:  <span class="hljs-comment"># 清空链表</span><br>                <span class="hljs-keyword">try</span>:<br>                    ls.clear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;链表清空成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-4-二叉树"><a href="#1-4-二叉树" class="headerlink" title="1.4 二叉树"></a>1.4 二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-comment"># 闭包捕获异常</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exception</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.right = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Node(<span class="hljs-subst">&#123;self.val&#125;</span>)&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Node(val=<span class="hljs-subst">&#123;self.val&#125;</span>, left=<span class="hljs-subst">&#123;self.left.val <span class="hljs-keyword">if</span> self.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>, right=<span class="hljs-subst">&#123;self.right.val <span class="hljs-keyword">if</span> self.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>)&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        向二叉树插入新元素，以逐层遍历的方式找到第一个出现的叶子结点插入</span><br><span class="hljs-string">        只用此方法构建二叉树，会构建出完全二叉树</span><br><span class="hljs-string">        :param data: 要插入的值</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 空树特殊处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.root = new_node<br>            <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 用队列实现逐层遍历，先将根节点入队</span><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])  <span class="hljs-comment"># 借助双端队列实现</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 取出队首元素</span><br>            node = queue.popleft()  <span class="hljs-comment"># O(1)时间完成</span><br><br>            <span class="hljs-comment"># 左子树非空，则将左子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-comment"># 左子树为空，将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.left = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-comment"># 右子树非空，则将右子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>            <span class="hljs-comment"># 右子树为空，则将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.right = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;广度优先搜索，逐层遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        res = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 取出当前节点</span><br>            node = queue.popleft()<br>            res.append(node.val)<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__preorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__preorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;私有方法，执行递归逻辑。先序遍历，根左右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 遍历结果放入列表</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__inorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__inorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;中序遍历，左根右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.left, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__postorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__postorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.right, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在二叉树查找指定元素</span><br><span class="hljs-string">        :param data: 待查找的元素</span><br><span class="hljs-string">        :return: 返回该元素所在节点</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            node = queue.popleft()<br><br>            <span class="hljs-comment"># 查找到目标元素，返回该节点</span><br>            <span class="hljs-keyword">if</span> node.val == data:<br>                <span class="hljs-keyword">return</span> node<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;找不到该元素！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    bt = BinaryTree()<br>    bt.add(<span class="hljs-string">&#x27;10&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;15&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;20&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;30&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;45&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;65&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、二叉树添加节点&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、逐层遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、先序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、中序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、后序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、返回节点数&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、树是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、清空树&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 二叉树添加节点</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>).strip()<br>                flag = bt.add(x)<br>                <span class="hljs-keyword">if</span> flag:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;插入成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 逐层遍历</span><br>                ls = bt.bfs()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;逐层遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 先序遍历</span><br>                ls = bt.preorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;先序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 中序遍历</span><br>                ls = bt.inorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 后序遍历</span><br>                ls = bt.postorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;后序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找元素</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素值：&#x27;</span>).strip()<br>                addr = bt.find(x)<br>                <span class="hljs-keyword">if</span> addr:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功，该元素所在节点为：<span class="hljs-subst">&#123;addr&#125;</span>&#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;左孩子值为：<span class="hljs-subst">&#123;addr.left.val <span class="hljs-keyword">if</span> addr.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>  右孩子值为：<span class="hljs-subst">&#123;addr.right.val <span class="hljs-keyword">if</span> addr.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 返回节点数</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前节点数：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(bt)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 树是否为空</span><br>                <span class="hljs-keyword">if</span> bt.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树为空&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树非空&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 清空树</span><br>                bt.clear()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树已清空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.lower() == <span class="hljs-string">&#x27;y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h1 id="2-排序"><a href="#2-排序" class="headerlink" title="2 排序"></a>2 排序</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>        swaped = <span class="hljs-literal">False</span>  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - i - <span class="hljs-number">1</span>):  <br>            <span class="hljs-keyword">if</span> ls[j] &gt; ls[j + <span class="hljs-number">1</span>]:  <br>                ls[j], ls[j + <span class="hljs-number">1</span>] = ls[j + <span class="hljs-number">1</span>], ls[j]  <br>                swaped = <span class="hljs-literal">True</span>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> swaped:  <br>            <span class="hljs-keyword">break</span>  <br></code></pre></td></tr></table></figure><h2 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):  <br>        idx = i  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):  <br>            <span class="hljs-keyword">if</span> ls[j] &lt; ls[idx]:  <br>                idx = j  <br>        ls[idx], ls[i] = ls[i], ls[idx]  <br></code></pre></td></tr></table></figure><h2 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):  <br>        x = ls[i]  <br>        j = i - <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x &lt; ls[j]:  <br>            ls[j + <span class="hljs-number">1</span>] = ls[j]  <br>            j -= <span class="hljs-number">1</span>  <br>        ls[j + <span class="hljs-number">1</span>] = x  <br></code></pre></td></tr></table></figure><h2 id="2-4-桶排序"><a href="#2-4-桶排序" class="headerlink" title="2.4 桶排序"></a>2.4 桶排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bucket_sort</span>(<span class="hljs-params">n</span>):  <br>    bucket = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)]  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:  <br>        bucket[i] += <span class="hljs-number">1</span>  <br>  <br>    ls.clear()  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        <span class="hljs-keyword">if</span> bucket[i] != <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bucket[i]):  <br>                ls.append(i)  <br></code></pre></td></tr></table></figure><h2 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a>2.5 快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    i = l - <span class="hljs-number">1</span>  <br>    j = r + <span class="hljs-number">1</span>  <br>    pivot = ls[l + r &gt;&gt; <span class="hljs-number">1</span>]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt; j:  <br>        i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[i] &lt; pivot:  <br>            i += <span class="hljs-number">1</span>  <br>        j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[j] &gt; pivot:  <br>            j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">if</span> i &lt; j:  <br>            ls[i], ls[j] = ls[j], ls[i]  <br>  <br>    quick_sort(l, j)  <br>    quick_sort(j + <span class="hljs-number">1</span>, r)  <br></code></pre></td></tr></table></figure><h2 id="2-6-归并排序"><a href="#2-6-归并排序" class="headerlink" title="2.6 归并排序"></a>2.6 归并排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>  <br>    merge_sort(l, mid)  <br>    merge_sort(mid + <span class="hljs-number">1</span>, r)  <br>  <br>    k = l  <br>    i = l  <br>    j = mid + <span class="hljs-number">1</span>  <br>    tmp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= r:  <br>        <span class="hljs-keyword">if</span> ls[i] &lt;= ls[j]:  <br>            tmp[k] = ls[i]  <br>            k += <span class="hljs-number">1</span>  <br>            i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">else</span>:  <br>            tmp[k] = ls[j]  <br>            k += <span class="hljs-number">1</span>  <br>            j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid:  <br>        tmp[k] = ls[i]  <br>        k += <span class="hljs-number">1</span>  <br>        i += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">while</span> j &lt;= r:  <br>        tmp[k] = ls[j]  <br>        k += <span class="hljs-number">1</span>  <br>        j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):  <br>        ls[i] = tmp[i]  <br></code></pre></td></tr></table></figure><h1 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3 二分查找"></a>3 二分查找</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]  <br><span class="hljs-built_in">print</span>(ls)  <br>x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;要查找的元素：&#x27;</span>))  <br>  <br>l, r = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ls)  <br><span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">if</span> ls[mid] &lt; x:  <br>        l = mid  <br>    <span class="hljs-keyword">else</span>:  <br>        r = mid  <br>  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一次出现<span class="hljs-subst">&#123;x&#125;</span>的下标为<span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12_Python面向对象高级</title>
    <link href="/2024/08/07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2024/08/07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-slots-限制属性"><a href="#1-slots-限制属性" class="headerlink" title="1 __slots__限制属性"></a>1 <code>__slots__</code>限制属性</h1><p>Python可以通过 <code>对象.属性</code>的方式很方便的添加属性值，但是这种方式太自由了，Python可以定义一个特殊的变量 <code>__slots__</code>来限制类的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;__age&#x27;</span>)  <br>    <span class="hljs-comment"># __slots__ = [&#x27;name&#x27;, &#x27;__age&#x27;]  这样也可以</span><br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br>    p1.age = <span class="hljs-number">20</span>  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br><br>    <span class="hljs-comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;gender&#x27;</span><br>    p1.gender = <span class="hljs-string">&#x27;男&#x27;</span><br></code></pre></td></tr></table></figure><p><code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的，除非在子类中也定义 <code>__slots__</code>，这样，子类实例允许定义的属性就是自身的 <code>__slots__</code>加上父类的 <code>__slots__</code>。</p><h1 id="2-property方法当属性"><a href="#2-property方法当属性" class="headerlink" title="2 @property方法当属性"></a>2 @property方法当属性</h1><p>如果直接把属性暴露出去，可以直接修改属性，但是没办法对值的合法性进行检验，所以可以将属性设为私有属性，然后通过 <code>getter</code>方法和 <code>setter</code>方法进行私有属性的获取和设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())  <br>    p1.set_age(<span class="hljs-number">20</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())<br></code></pre></td></tr></table></figure><p>但是调用方法终归是略显复杂，没有直接使用属性简单，作为追求简单的Python语言，内置的 <code>property</code>可以将方法当做属性使用，常用于 <code>getter</code>方法和 <code>setter</code>方法。<strong>既能检查参数，又可以用类似属性的简单方式来访问类的变量</strong>。</p><h2 id="2-1-装饰器方法"><a href="#2-1-装饰器方法" class="headerlink" title="2.1 装饰器方法"></a>2.1 装饰器方法</h2><ul><li><code>@property</code>修饰获取值的方法</li><li><code>获取值方法名.setter</code>修饰设置值的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br><span class="hljs-meta">    @property  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br><span class="hljs-meta">    @age.setter  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><blockquote><p>通过 <code>@property</code> 装饰器，创建了一个名为 <code>age</code> 的“公共接口”或“属性”。这个属性在外部看起来就像一个普通属性，可以用 <code>p1.age</code> 来访问它，但实际上，这个访问背后调用的是 <code>age()</code> 方法，而赋值时调用的则是 <code>age()</code> 方法下的 <code>age.setter</code>。</p></blockquote><h2 id="2-2-类属性方法"><a href="#2-2-类属性方法" class="headerlink" title="2.2 类属性方法"></a>2.2 类属性方法</h2><p><code>属性名 = property(获取值方法名, 设置值方法名)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><h1 id="3-枚举类"><a href="#3-枚举类" class="headerlink" title="3 枚举类"></a>3 枚举类</h1><p>枚举类就是一种实例有限且固定的特殊类，当需要定义一组命名常量时，可以选择枚举类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum  <br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Week</span>(<span class="hljs-title class_ inherited__">Enum</span>):  <br>    Mon = <span class="hljs-number">1</span>  <br>    Tue = <span class="hljs-number">2</span>  <br>    Wed = <span class="hljs-number">3</span>  <br>    Thu = <span class="hljs-number">4</span>  <br>    Fri = <span class="hljs-number">5</span>  <br>    Sat = <span class="hljs-number">6</span>  <br>    Sun = <span class="hljs-number">7</span>  <br>  <br><br><span class="hljs-comment"># 枚举类可以迭代</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> Week:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;item&#125;</span>---<span class="hljs-subst">&#123;item.name&#125;</span>的值为：<span class="hljs-subst">&#123;item.value&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Week.Mon---Mon的值为：1</span><br><span class="hljs-string">Week.Tue---Tue的值为：2</span><br><span class="hljs-string">Week.Wed---Wed的值为：3</span><br><span class="hljs-string">Week.Thu---Thu的值为：4</span><br><span class="hljs-string">Week.Fri---Fri的值为：5</span><br><span class="hljs-string">Week.Sat---Sat的值为：6</span><br><span class="hljs-string">Week.Sun---Sun的值为：7</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 直接访问枚举成员</span><br><span class="hljs-built_in">print</span>(Week.Mon)  <span class="hljs-comment"># Week.Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.name)  <span class="hljs-comment"># Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.value) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>枚举类正常情况下允许成员有重复值，如果使用 <code>@unique</code>可以控制枚举成员不能有重复值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<br><br><br><span class="hljs-meta">@unique</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    RED = <span class="hljs-number">1</span><br>    GREEN = <span class="hljs-number">2</span><br>    BLUE = <span class="hljs-number">3</span><br>    CRIMSON = <span class="hljs-number">1</span> <span class="hljs-comment"># 这里的重复会引发 ValueError</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11_Python网络编程</title>
    <link href="/2024/08/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/08/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络协议"><a href="#1-网络协议" class="headerlink" title="1 网络协议"></a>1 网络协议</h1><p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰 互联网协议入门（一）</a> 自下而上讲解互联网如何构成<br><a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">阮一峰 互联网协议入门（二）</a> 自上而下讲解互联网如何应用</p><h1 id="2-编解码"><a href="#2-编解码" class="headerlink" title="2 编解码"></a>2 编解码</h1><p>从网络或磁盘上读取字节流，读到的数据是 <code>bytes</code>。要把 <code>bytes</code>变为 <code>str</code>，就需要用 <code>decode()</code>方法，如果想要将 <code>str</code>转为 <code>bytes</code>，就需要使用 <code>encode()</code>方法。</p><ul><li><code>s.encode(码表)</code>编码，默认码表为 UTF-8</li><li><code>s.decode(码表)</code>解码，默认码表为 UTF-8</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;文件编码&#x27;</span>  <br>bs = s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <br><br><span class="hljs-comment"># b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span><br><span class="hljs-built_in">print</span>(bs)<br><br><span class="hljs-comment"># 文件编码</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span>.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>有一种特殊的编码方式，对于ASCII码表中的字符，可以使用 <code>b&#39;&#39;</code>包围字符串进行编码，但是注意不能对中文进行编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">b&#x27;hello python&#x27;</span>))<br></code></pre></td></tr></table></figure><h1 id="3-网络编程-收发一句话"><a href="#3-网络编程-收发一句话" class="headerlink" title="3 网络编程-收发一句话"></a>3 网络编程-收发一句话</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250918204805.png"></p><p><strong>只要确定主机和端口，我们就能实现程序之间的交流。</strong> 因此，Unix系统就把主机+端口，叫做”套接字”（<code>socket</code>）。有了它，就可以进行网络应用程序开发了。</p><p>TCP服务器端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br><span class="hljs-comment"># family：地址族，默认AF_INET（IPV4）  AF_INET6(IPV6)</span><br><span class="hljs-comment"># type：socket类型，默认SOCK_STREAM（TCP） SOCK_DGRAM(UDP)</span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号，注意参数必须为元组</span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制</span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息，阻塞到客户连接</span><br>sock, client = serve_socket.accept()  <br><br><span class="hljs-comment"># 5、编码并发送数据</span><br>sock.send(<span class="hljs-string">&#x27;你好我是服务器，欢迎来到socket&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 6、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = sock.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;服务器端收到来自：<span class="hljs-subst">&#123;client&#125;</span>的消息：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 7、释放资源，关闭当前连接，一般服务器不需要关闭</span><br>sock.close()<br></code></pre></td></tr></table></figure><p>TCP客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器的ip和端口号</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = client_socket.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;客户端收到：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 4、编码并发送数据 </span><br>client_socket.send(<span class="hljs-string">&#x27;我是客户端&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 5、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure><h1 id="4-网络编程-收发文件"><a href="#4-网络编程-收发文件" class="headerlink" title="4 网络编程-收发文件"></a>4 网络编程-收发文件</h1><p>TCP服务器端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号  </span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制  </span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息  </span><br>sock, client = serve_socket.accept()  <br>  <br><span class="hljs-comment"># 5、使用二进制写，接收数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rev_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:      <br>        data = sock.recv(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>      <br>        f.write(data)  <span class="hljs-comment"># 将接收数据写入本地文件</span><br>  <br><span class="hljs-comment"># 6、释放资源  </span><br>sock.close()<br></code></pre></td></tr></table></figure><p>TCP客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器ip和端口号  </span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、使用二进制读，发送数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;send_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:      <br>        data = f.read(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>     <br>        client_socket.send(data)  <span class="hljs-comment"># 将本地文件发送出去</span><br>  <br><span class="hljs-comment"># 4、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_Python正则表达式</title>
    <link href="/2024/08/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/08/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1 匹配规则"></a>1 匹配规则</h1><h2 id="1-普通字符"><a href="#1-普通字符" class="headerlink" title="1. 普通字符"></a>1. 普通字符</h2><p>大多数字符（字母、数字、汉字）就是普通字符，它们匹配自己。</p><ul><li><code>abc</code> 匹配字符串中的 <code>&quot;abc&quot;</code></li><li><code>你好</code> 匹配字符串中的 <code>&quot;你好&quot;</code></li></ul><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><ul><li><strong><code>.</code> (点号)<strong>：匹配</strong>任意一个</strong>字符（除了换行符 <code>\n</code>）。<ul><li><code>a.c</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;a@c&quot;</code>, <code>&quot;a c&quot;</code></li></ul></li><li><strong><code>\d</code><strong>：匹配任意一个</strong>数字</strong>。等价于 <code>[0-9]</code>。<ul><li><code>\d\d</code> 匹配 <code>&quot;12&quot;</code>, <code>&quot;05&quot;</code></li></ul></li><li><strong><code>\w</code><strong>：匹配任意一个</strong>字母、数字或下划线</strong>。等价于 <code>[A-Za-z0-9_]</code>。<ul><li><code>\w\w</code> 匹配 <code>&quot;Ab&quot;</code>, <code>&quot;a1&quot;</code>, <code>&quot;_x&quot;</code></li></ul></li><li><strong><code>\s</code><strong>：匹配任意一个</strong>空白字符</strong>（包括空格、制表符 <code>\t</code>、换行符 <code>\n</code> 等）。</li><li><strong><code>\D</code>, <code>\W</code>, <code>\S</code><strong>：分别是 <code>\d</code>, <code>\w</code>, <code>\s</code> 的</strong>反面</strong>。<ul><li><code>\D</code> 匹配<strong>非数字</strong>的任意字符。</li></ul></li><li><strong><code>[...]</code> (字符组)<strong>：匹配方括号内的</strong>任意一个</strong>字符。<ul><li><code>[aeiou]</code> 匹配任意一个元音字母。</li><li><code>[a-z]</code> 匹配任意一个小写字母（<code>-</code> 表示范围）。</li><li><code>[0-9a-fA-F]</code> 匹配一个十六进制数字。</li></ul></li><li><strong><code>[^...]</code> (否定字符组)<strong>：匹配</strong>不在</strong>方括号内的任意一个字符。<ul><li><code>[^0-9]</code> 匹配任意一个非数字字符。</li></ul></li></ul><h2 id="3-量词-控制字符出现的次数"><a href="#3-量词-控制字符出现的次数" class="headerlink" title="3. 量词 - 控制字符出现的次数"></a>3. 量词 - 控制字符出现的次数</h2><ul><li><strong><code>*</code><strong>：匹配</strong>零次或多次</strong>。<ul><li><code>ab*c</code> 匹配 <code>&quot;ac&quot;</code> (0次b), <code>&quot;abc&quot;</code> (1次b), <code>&quot;abbc&quot;</code> (多次b)</li></ul></li><li><strong><code>+</code><strong>：匹配</strong>一次或多次</strong>。<ul><li><code>ab+c</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;abbc&quot;</code>，但不匹配 <code>&quot;ac&quot;</code></li></ul></li><li><strong><code>?</code><strong>：匹配</strong>零次或一次</strong>（即可选的）。<ul><li><code>colou?r</code> 匹配 <code>&quot;color&quot;</code> 和 <code>&quot;colour&quot;</code> (u出现0次或1次)</li></ul></li><li>**<code>&#123;n&#125;</code>**：匹配确定的 <strong>n 次</strong>。<ul><li><code>\d&#123;4&#125;</code> 匹配恰好4个数字，如 <code>&quot;2024&quot;</code></li></ul></li><li><strong><code>&#123;n,&#125;</code><strong>：匹配</strong>至少 n 次</strong>。<ul><li><code>\d&#123;2,&#125;</code> 匹配至少2个数字，如 <code>&quot;12&quot;</code>, <code>&quot;123&quot;</code></li></ul></li><li><strong><code>&#123;n,m&#125;</code><strong>：匹配</strong>至少 n 次，最多 m 次</strong>。<ul><li><code>\d&#123;2,4&#125;</code> 匹配2到4个数字，如 <code>&quot;12&quot;</code>, <code>&quot;123&quot;</code>, <code>&quot;2024&quot;</code></li></ul></li></ul><h2 id="4-位置锚点-匹配位置，而不是字符"><a href="#4-位置锚点-匹配位置，而不是字符" class="headerlink" title="4. 位置锚点 - 匹配位置，而不是字符"></a>4. 位置锚点 - 匹配位置，而不是字符</h2><ul><li><strong><code>^</code><strong>：匹配字符串的</strong>开始</strong>位置。<ul><li><code>^Hello</code> 匹配以 <code>&quot;Hello&quot;</code> 开头的字符串。</li></ul></li><li><strong><code>$</code><strong>：匹配字符串的</strong>结束</strong>位置。<ul><li><code>world!$</code> 匹配以 <code>&quot;world!&quot;</code> 结尾的字符串。</li></ul></li><li><strong><code>\b</code><strong>：匹配一个</strong>单词的边界</strong>（即单词开头或结尾的空隙）。<ul><li><code>\bcat\b</code> 匹配单词 <code>&quot;cat&quot;</code>，但不匹配 <code>&quot;category&quot;</code> 或 <code>&quot;scatter&quot;</code> 中的 <code>&quot;cat&quot;</code>。</li></ul></li></ul><h2 id="5-分组与捕获"><a href="#5-分组与捕获" class="headerlink" title="5. 分组与捕获"></a>5. 分组与捕获</h2><ul><li>**<code>(...)</code>**：<ol><li><strong>分组</strong>：将多个字符组合成一个整体，以便对其使用量词。<ul><li><code>(abc)+</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;abcabc&quot;</code>。</li></ul></li><li><strong>捕获</strong>：提取匹配到的内容，供后续使用或替换。<ul><li>在替换操作中，可以用 <code>$1</code>, <code>$2</code> 来引用被括号捕获的内容。</li></ul></li></ol></li><li><strong><code>(?:...)</code><strong>：</strong>非捕获分组</strong>。只分组，不捕获，提高效率。</li></ul><h2 id="6-选择符"><a href="#6-选择符" class="headerlink" title="6. 选择符"></a>6. 选择符</h2><ul><li>**<code>|</code>**：表示“或”关系。<ul><li><code>cat|dog</code> 匹配 <code>&quot;cat&quot;</code> 或 <code>&quot;dog&quot;</code>。</li><li><code>gr(a|e)y</code> 匹配 <code>&quot;gray&quot;</code> 或 <code>&quot;grey&quot;</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-comment"># []表示范围，只匹配一个字符</span><br>[abc]           只能是 a b c 其中之一<br>[a-zA-Z]        a到z 或 A到Z<br><br><br><span class="hljs-comment"># ^ 表示 非</span><br>[^abc]          除 a b c 之外的任何字符<br><br><br><span class="hljs-comment"># &amp;&amp; 表示 且</span><br>[a-z&amp;&amp;[^e-g]]   a 到 z 且 除了 e 到 g（等同于[a-dh-z]）<br><br><br><span class="hljs-comment"># | 表示 或</span><br>[a-z|A-Z]       小写字母或大写字母<br><br><br><span class="hljs-comment"># 预定义字符</span><br>.    任何字符<br>\d   数字<br>\s   空白字符<br>\w   英文字母、数字、下划线<br><br>\D   非数字<br>\S   非空白字符<br>\W   非英文字母、数字、下划线<br><br><br><span class="hljs-comment"># 数量词</span><br>x?       <span class="hljs-number">0</span>个或<span class="hljs-number">1</span>个x<br>x*       <span class="hljs-number">0</span>个或多个x<br>x+       <span class="hljs-number">1</span>个或多个x<br>x&#123;n&#125;     正好n个x<br>x&#123;n,&#125;    至少n个x<br>x&#123;n, m&#125;  n到m个x<br><br><br><span class="hljs-comment"># \ 转义字符</span><br>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]\-[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]   数字-数字<br><br><span class="hljs-comment"># ^ 必须是开头  $ 必须是结尾</span><br>^hello    可以匹配 hello world  不能匹配 say hello<br>world$    可以匹配 hello world  不能匹配 world peace<br></code></pre></td></tr></table></figure><h1 id="2-Python应用"><a href="#2-Python应用" class="headerlink" title="2 Python应用"></a>2 Python应用</h1><h2 id="2-1-re模块"><a href="#2-1-re模块" class="headerlink" title="2.1 re模块"></a>2.1 re模块</h2><p><code>re</code>模块中包含正则表达式的所有功能，因为Python本来也有转义字符 <code>\</code>，所以 <code>\\</code>才能表示 <code>\</code>，为了方便，我们可以直接使用 <code>r&#39;&#39;</code>去除转义功能。<br>使用 <code>re.match()</code>方法判断是否匹配，如果匹配成功，返回一个 <code>Match</code>对象，否则返回 <code>None</code>。常见的判断方法就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;failed&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-2-字符串分割"><a href="#2-2-字符串分割" class="headerlink" title="2.2 字符串分割"></a>2.2 字符串分割</h2><p>使用正则表达式分割字符串比常规的 <code>split()</code>方法更加强大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通split()</span><br><span class="hljs-string">&#x27;1   2 3  4&#x27;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)   <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;]</span><br><br><span class="hljs-comment"># 正则split()</span><br>re.split(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>)<br><br>re.split(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27;1   2 3   4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br><br>re.split(<span class="hljs-string">r&#x27;[\s,;]+&#x27;</span>, <span class="hljs-string">&#x27;1  , 2,;, 3 ,4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="2-3-分组"><a href="#2-3-分组" class="headerlink" title="2.3 分组"></a>2.3 分组</h2><p><code>()</code>表示要提取的分组，如果正则表达式中定义了组，就可以在 <code>Match</code>对象上用 <code>group()</code>方法提取出子串来。<br><code>group()</code>和 <code>group(0)</code>表示匹配的完整字符串，<code>group(1)</code>和 <code>group(2)</code>依次代表第1、第2个子串，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re  <br>  <br>qq = <span class="hljs-string">&#x27;qq:12345678&#x27;</span>  <br>reg = <span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>  <br>m = re.<span class="hljs-keyword">match</span>(reg, qq)  <br><span class="hljs-built_in">print</span>(m)  <br><span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># qq</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 12345678</span><br></code></pre></td></tr></table></figure><h2 id="2-4-预编译"><a href="#2-4-预编译" class="headerlink" title="2.4 预编译"></a>2.4 预编译</h2><p>如果一个正则表达式要用很多次，可以使用预编译。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 预编译</span><br>re_qq = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>)<br><br><span class="hljs-comment"># 使用</span><br><span class="hljs-built_in">print</span>(re_qq.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;qq:41532531&#x27;</span>).group(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Python多进程和多线程</title>
    <link href="/2024/08/03/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/08/03/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-多任务"><a href="#1-多任务" class="headerlink" title="1 多任务"></a>1 多任务</h1><p>对于操作系统来说，一个任务就是一个<strong>进程（Process）</strong>，比如打开一个浏览器就是启动一个浏览器进程，打开两个记事本就启动了两个记事本进程，</p><p>有些进程内部要同时干多件事，比如Word同时进行打字和拼写检查，需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为<strong>线程（Thread）</strong>。线程是最小执行单元，一个进程至少有一个线程。</p><ul><li>串行：多个任务依次执行</li><li>并发：对于单核CPU，多个任务快速切换执行，看起来好像是多个任务一起执行的</li><li>并行：对于多核CPU，真正实现了多个任务同时执行</li></ul><p>多进程和多线程由操作系统进行调度，执行顺序具有随机性。</p><h1 id="2-多进程"><a href="#2-多进程" class="headerlink" title="2 多进程"></a>2 多进程</h1><h2 id="2-1-multiprocessing"><a href="#2-1-multiprocessing" class="headerlink" title="2.1 multiprocessing"></a>2.1 multiprocessing</h2><p>Windows可以使用跨平台的 <code>multiprocessing</code>，模块中提供了 <code>Process</code>类代表一个进程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;p-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有 <code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为进程起的名字，可以通过 <code>进程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>首音乐&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br><br><span class="hljs-comment"># 没有 __name__ == &#x27;__main__&#x27; 的保护会导致无限递归</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-comment"># 实例化进程对象</span><br>    p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;)  <br><br>    <span class="hljs-comment"># 启动进程</span><br>    p1.start()  <br>    p2.start()  <br><br>    <span class="hljs-comment"># 等待子进程结束后，再继续执行主进程</span><br>    p1.join()  <br>    p2.join()<br></code></pre></td></tr></table></figure><h2 id="2-2-获取进程编号"><a href="#2-2-获取进程编号" class="headerlink" title="2.2 获取进程编号"></a>2.2 获取进程编号</h2><p>每个程序（进程）在设备上都有唯一的进程编号（PID），程序释放时进程编号也会释放，实现了进程编号的重复利用。</p><ul><li>获取当前PID的方式：<ul><li>方式一：<code>os.getpid()</code></li><li>方式二：<code>multiprocessing.current_process().pid</code></li></ul></li><li>获取父进程PID的方式：<ul><li><code>os.getppid()</code></li></ul></li></ul><blockquote><p>在 <code>main</code>中创建的进程，如果没有指定，则它的父进程都是 <code>main</code>进程，而 <code>main</code>的父进程是 <code>Pycharm</code>程序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time, os  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f1的pid：34568, 34568 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f2的pid：40356, 40356 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;)  <br><br>    <span class="hljs-comment"># process-1 process-2</span><br>    <span class="hljs-built_in">print</span>(p1.name, p2.name)  <br>  <br>    p1.start()  <br>    p2.start()  <br>  <br>    <span class="hljs-comment"># main的pid:32240, 32240 父进程：35464</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;main的pid:<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3 数据隔离"></a>2.3 数据隔离</h2><p>多进程有以下特点：</p><ol><li>进程之间执行是<strong>无序</strong>的</li><li>进程之间有<strong>数据隔离</strong></li><li>主进程会<strong>等待所有子进程执行结束</strong>再结束</li></ol><p>每个进程都有自己独立的内存空间，进程之间的<strong>数据是相互隔离</strong>的，子进程中的资源是父进程资源的拷贝，互不影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>)  <br>    p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>)  <br>  <br>    ls = [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>] <br><br>    <span class="hljs-comment"># 主进程中的ls为[8, 7, 6, 5, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>  <br>    p1.start()  <br>    p2.start()<br></code></pre></td></tr></table></figure><h2 id="2-4-守护进程"><a href="#2-4-守护进程" class="headerlink" title="2.4 守护进程"></a>2.4 守护进程</h2><p>注意这个词的描述非常不准确。<br>正常来说，<strong>主进程会等待所有子进程执行结束之后才结束</strong>，但是有时候想要关闭主进程的同时关闭所有子进程，这个时候需要守护进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正常情况</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了努力工作中</span><br><span class="hljs-string"></span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果想要实现子进程和主进程同步关闭，有两种实现方法：</p><ol><li>设置子进程为守护进程，将属性 <code>daemon</code>设为 <code>True</code></li><li>手动杀死子进程，不过会导致子进程变为僵尸进程，会交由Python解释器自动回收</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 守护进程</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br><br>    <span class="hljs-comment"># 子进程p1设为了守护进程</span><br>    p1.daemon = <span class="hljs-literal">True</span>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-5-Manager实现数据共享"><a href="#2-5-Manager实现数据共享" class="headerlink" title="2.5 Manager实现数据共享"></a>2.5 Manager实现数据共享</h2><p>在多进程中数据共享可以使用 <code>multiprocessing</code>模块中的 <code>Manager()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-keyword">with</span> multiprocessing.Manager() <span class="hljs-keyword">as</span> manager:  <br>        <span class="hljs-comment"># 这个 ls 就可以共享</span><br>        ls = manager.<span class="hljs-built_in">list</span>()  <br>        p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(ls, ))  <br>        p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, args=(ls, ))<br></code></pre></td></tr></table></figure><h1 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3 多线程"></a>3 多线程</h1><h2 id="3-1-threading"><a href="#3-1-threading" class="headerlink" title="3.1 threading"></a>3.1 threading</h2><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。进程是CPU分配资源的基本单位，线程是CPU调度资源的最小单位，线程是依附于进程的，一个进程至少含有一个线程。</p><p>多线程之间有以下特点：</p><ol><li>线程之间执行是<strong>无序</strong>的</li><li>统一进程下的多线程之间<strong>共享</strong>全局变量</li><li>主线程会<strong>等待所有子线程执行结束</strong>再结束</li></ol><p>使用 <code>threading</code>模块中的 <code>Thread</code>类创建线程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = threading.Thread(target=coding, args=(name1, age1))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有 <code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为线程起的名字，可以通过 <code>线程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time, os, multiprocessing  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br>name1, age1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>name2, age2 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t1 = threading.Thread(target=coding, args=(name1, age1))  <br>    t2 = threading.Thread(target=music, args=(name2, age2))  <br>  <br>    t1.start()  <br>    t2.start()<br></code></pre></td></tr></table></figure><h2 id="3-2-数据共享"><a href="#3-2-数据共享" class="headerlink" title="3.2 数据共享"></a>3.2 数据共享</h2><p>多线程之间共用内存空间，数据是共享的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=write)  <br>t2 = threading.Thread(target=read)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><h2 id="3-3-守护线程"><a href="#3-3-守护线程" class="headerlink" title="3.3 守护线程"></a>3.3 守护线程</h2><p>和进程类似，主线程会等待所有子线程结束再结束，如果想要让子线程随主进程结束而结束，应该设置守护线程，<code>线程.daemon = True</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t = threading.Thread(target=work)  <br>  <br>    t.daemon = <span class="hljs-literal">True</span>  <br>    t.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-互斥锁"><a href="#3-4-互斥锁" class="headerlink" title="3.4 互斥锁"></a>3.4 互斥锁</h2><p>多线程中<strong>所有变量都由所有线程共享</strong>，最大的危险在于多个线程同时修改同一变量，内容就会出现紊乱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多次运行结果不同</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">add1函数中的num为1451039</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string">-----------------------</span><br><span class="hljs-string">add1函数中的num为1727878</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">import</span> threading, time  <br>  <br>num = <span class="hljs-number">0</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>在上述案例中，<code>num += 1</code>并不是原子操作，而是分为以下几步交由CPU执行：</p><ol><li>读取当前 <code>num</code> 的值到寄存器</li><li>将寄存器中的值加1</li><li>将结果写回 <code>num</code> 变量</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">时间点 | 线程1              | 线程2              | num的值<br>----------------------------------------------------------------<br>t1    | 读取 num=0         |                    | 0<br>t2    | 计算 0+1=1         |                    | 0  <br>t3    |                    | 读取 num=0         | 0<br>t4    |                    | 计算 0+1=1         | 0<br>t5    | 写入 num=1         |                    | 1<br>t6    |                    | 写入 num=1         | 1 ← 错误！应该是2<br></code></pre></td></tr></table></figure><hr><p>为了确保计算正确，就要给两个 <code>add()</code>函数<strong>上个锁</strong>，当某个线程获得了该锁，其他线程就不能同时执行，而要等待直到获得该锁的线程释放锁，并获得该锁。由于锁只有一个，同一时间只有一个线程可以持有该锁，就不会造成修改的冲突。</p><p>通过 <code>threading.Lock()</code>可以创建一个锁对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>  <br>num = <span class="hljs-number">0</span>  <br><span class="hljs-comment"># 创建一个锁对象</span><br>lock = threading.Lock()  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>当多个线程同时执行 <code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用 <code>try...finally</code>来确保锁一定会被释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 上述代码的全局变量改为 num = &#x27;0&#x27; 就会形成死线程，采用try...finally可以解决</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>            num += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>        lock.release()  <span class="hljs-comment"># 不管是否成功执行，一定要释放锁</span><br></code></pre></td></tr></table></figure><blockquote><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p></blockquote><h1 id="4-进程和线程的区别"><a href="#4-进程和线程的区别" class="headerlink" title="4 进程和线程的区别"></a>4 进程和线程的区别</h1><ol><li>线程是依附于进程的，<strong>没有进程就没有线程</strong></li><li>一个进程<strong>最少有一个线程</strong>，进程可以创建多个线程</li><li>进程之间<strong>数据隔离</strong>，线程之间<strong>共享全局变量</strong>（使用互斥锁解决资源竞争问题）</li><li>进程是<strong>操作系统分配资源</strong>的基本单位，线程是<strong>CPU调度</strong>的基本单位</li><li>进程更消耗资源，相对更稳定；线程更轻量级，相对更灵活</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Python函数式编程</title>
    <link href="/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1 高阶函数"></a>1 高阶函数</h1><p><strong>Python 中的函数是“一等函数”</strong>，所谓“一等函数”指的就是函数可以赋值给变量，函数可以作为函数的参数，函数也可以作为函数的返回值。把一个函数作为其他函数的参数或返回值的用法，我们通常称之为“高阶函数”。</p><p>在Python中，<code>func()</code>是函数调用，<code>func</code>是函数本身，可以把函数本身赋值给变量，也就是：<strong>变量指向函数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>)  <span class="hljs-comment"># &lt;built-in function abs&gt;</span><br><br>f = <span class="hljs-built_in">abs</span>  <span class="hljs-comment"># f指向了abs函数</span><br><span class="hljs-built_in">print</span>(f(-<span class="hljs-number">5</span>))  <span class="hljs-comment"># 5  现在f等价于abs</span><br></code></pre></td></tr></table></figure><p>其实函数名本身也是变量，函数名指向函数。<br><img src="/../../../ai_assets/Pasted%20image%2020250911095842.png"></p><hr><p>函数能接收变量，变量可以指向函数，所以函数可以接受函数，这时传递的不是数据，而是<strong>计算逻辑</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):  <br>    <span class="hljs-keyword">return</span> x + y  <br><br><br>func(add, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)  <br></code></pre></td></tr></table></figure><h2 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1.1 map()"></a>1.1 map()</h2><p><code>map()</code>接收两个参数，一个是函数，一个是可迭代对象 <code>Iterable</code>，<code>map()</code>将函数依次作用到可迭代对象的每个元素，并将结果作为一个新的迭代器对象 <code>Iterator</code>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br><span class="hljs-comment"># 将f作用到列表中的每一个元素</span><br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(r))<br></code></pre></td></tr></table></figure><p>上述代码中，由于 <code>map()</code>返回的是一个惰性序列 <code>Iterator</code>，所以通过 <code>list()</code>把整个序列算出来返回一个 <code>list</code>。</p><p>输入一行数据作为列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27; &#x27;</span>)))<br></code></pre></td></tr></table></figure><h2 id="1-2-reduce"><a href="#1-2-reduce" class="headerlink" title="1.2 reduce()"></a>1.2 reduce()</h2><p><code>reduce()</code>把一个函数作用到一个序列中，其中这个函数必须<strong>接收两个参数</strong>，<code>reduce()</code>将计算结果继续和下一个元素累计计算。<br>使用 <code>reduce()</code>需要导入 <code>from functools import reduce</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><br><span class="hljs-built_in">print</span>(reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))  <span class="hljs-comment"># 累加求和 55</span><br><br><span class="hljs-comment"># 使用lambda匿名函数</span><br><span class="hljs-built_in">print</span>(reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-3-filter"><a href="#1-3-filter" class="headerlink" title="1.3 filter()"></a>1.3 filter()</h2><p><code>filter</code>接收一个函数一个序列，把传入的函数作用到每一个元素上，根据返回值决定是否保留，<code>True</code>保留元素，<code>False</code>丢弃元素。最终结果作为 <code>Iterator</code>返回，也就是一个惰性序列，需要使用 <code>list()</code>获取所有计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 求出0~100的所有偶数</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(f, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br></code></pre></td></tr></table></figure><h2 id="1-4-sorted"><a href="#1-4-sorted" class="headerlink" title="1.4 sorted()"></a>1.4 sorted()</h2><p><code>sorted()</code>可以对序列进行排序，返回一个新的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">sorted</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>还可以接收一个 <code>key</code>函数实现自定义排序，<code>key</code>将指定函数作用到序列的每一个值上，并按照返回值进行排序。另外还可以使用 <code>reverse=True</code>表示逆序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><br><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br><br><span class="hljs-comment"># 按照第二个元素分数进行排序</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=f)<br><br><span class="hljs-comment"># 使用lambda并且逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h1 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2 匿名函数"></a>2 匿名函数</h1><ul><li><code>def</code> 关键字，可以定义带有名称的函数</li><li><code>lambda</code> 关键字，可以定义匿名函数（无名称）</li></ul><p>有名称的函数，可以基于名称重复使用。无名称的匿名函数，只可<strong>临时</strong>使用一次。<br>表达式内容自动成为返回值，不可使用 <code>return</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 传入参数: 函数体（一行代码）<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br><br><br><span class="hljs-comment"># 传入一个一次性的函数</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x * y, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h1 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3 闭包"></a>3 闭包</h1><h2 id="3-1-闭包的定义"><a href="#3-1-闭包的定义" class="headerlink" title="3.1 闭包的定义"></a>3.1 闭包的定义</h2><p>调用了外部函数变量的内部函数就称之为<strong>闭包（Closure）</strong>，闭包可以增强安全性，将原本的全局变量变为外部函数的参数，对于内层函数来说这个变量又是外部变量。</p><p>闭包的三个必要条件：</p><ol><li>有嵌套：函数嵌套</li><li>有引用：内部函数引用外部函数变量</li><li>有返回：外部函数返回内部函数名（对象）</li></ol><p>银行取款非闭包写法：这种写法余额 <code>initial_value</code>是全局变量，有被修改的风险。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">initial_value = <span class="hljs-number">10000</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>    <span class="hljs-keyword">if</span> flag:  <br>        initial_value += value  <br>    <span class="hljs-keyword">else</span>:  <br>        initial_value -= value  <br><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment">#  存款1000，变为11000</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款2000，变为9000</span><br></code></pre></td></tr></table></figure><p>闭包写法：<code>initial_value</code>变成了外部函数 <code>count()</code>的参数，外部无法访问。想在内部函数引用外部变量需要使用 <code>nonlocal</code>声明，否则会被认为是内部函数局部变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">initial_value=<span class="hljs-number">0</span></span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>        <span class="hljs-keyword">nonlocal</span> initial_value  <span class="hljs-comment"># 声明为外部变量</span><br>        <span class="hljs-keyword">if</span> flag:  <br>            initial_value += value  <br>        <span class="hljs-keyword">else</span>:  <br>            initial_value -= value  <br>  <br>    <span class="hljs-keyword">return</span> atm  <br>  <br><br><span class="hljs-comment"># 现在 fn 存储的是 atm() 函数，并且保存了 initial_value = 10000 的状态</span><br>fn = count(<span class="hljs-number">10000</span>)  <br><br><span class="hljs-comment"># 使用 fn 可以调用 atm() 函数</span><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 存款</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款</span><br></code></pre></td></tr></table></figure><h2 id="3-2-闭包的原理"><a href="#3-2-闭包的原理" class="headerlink" title="3.2 闭包的原理"></a>3.2 闭包的原理</h2><p>闭包有点类的思想，外层函数中的参数像类的元素一样被保留了下来。实际上在Python的函数对象中存储了一些属性：</p><ul><li><code>__code__</code>：保存函数的字节码。</li><li><code>__globals__</code>：保存全局作用域引用。</li><li><code>__closure__</code>：保存了被捕获的自由变量（也就是闭包变量）。</li></ul><p>在上述案例中 <code>fn = count(10000)</code>执行后，<code>fn</code>是 <code>atm</code>这个函数对象。所以 <code>initial_value=10000</code> 这个变量其实是保存在 <code>fn.__closure__</code> 里的，Python会把它包装为一个<strong>cell object</strong>（细胞对象），用来存活并保持可变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">可以访问到 initial_value 的值</span><br><span class="hljs-string">fn.__closure__ 是一个元组，里面的元素就是 cell 对象</span><br><span class="hljs-string">cell_contents 就是捕获到的变量值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(fn.__closure__[<span class="hljs-number">0</span>].cell_contents)  <span class="hljs-comment"># 10000</span><br></code></pre></td></tr></table></figure><h1 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4 装饰器"></a>4 装饰器</h1><h2 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h2><p><strong>装饰器（Decorator）</strong> 就是创建一个闭包函数，在闭包函数内调用目标函数，可以达到不改变目标函数的同时，增加额外的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我开始了&#x27;</span>)  <span class="hljs-comment"># 执行前扩展</span><br>        func()  <span class="hljs-comment"># 原函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我结束了&#x27;</span>)  <span class="hljs-comment"># 执行后扩展</span><br><br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 将 demo 函数对象传入 outer()，fn 现在是保存了 func 状态的 inner 函数对象</span><br>fn = outer(demo)<br><br>fn()  <span class="hljs-comment"># 其实执行的就是 inner() 函数的内容</span><br></code></pre></td></tr></table></figure><p>上述写法还不够优雅，可以使用 <code>@函数名</code>的方式，也叫语法糖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># @outer 放在函数定义处相当于执行了 demo = outer(demo)</span><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 此时执行 demo() 已经是扩展之后的功能了</span><br>demo()<br></code></pre></td></tr></table></figure><blockquote><p>原来的 <code>demo()</code>函数仍然存在，只是同名 <code>demo</code>变量指向了新的函数，于是调用 <code>demo()</code>会执行扩展后的函数，其实就是保存了 <code>func</code> 状态的 <code>inner()</code>函数。</p></blockquote><h2 id="4-2-带参有返回值"><a href="#4-2-带参有返回值" class="headerlink" title="4.2 带参有返回值"></a>4.2 带参有返回值</h2><p>要被装饰的原函数带参有返回值，并且原函数接收不定长参数，有一些细节需要注意。</p><ul><li><code>fn(args, kwargs)</code>是位置参数：相当于 <code>get_sum((1,2,3,4), &#123;&#39;math&#39;:18&#125;)</code></li><li><code>fn(*args, **kwargs)</code>是不定长参数：相当于 <code>get_sum(1,2,3,4, math=18)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):  <span class="hljs-comment"># 接收过来 args 已经是元组， kwargs 是字典  </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始计算...&#x27;</span>)  <br>        <span class="hljs-comment"># return fn (args, kwargs)  # 这种写法是错误的，被当做位置参数了</span><br>        <span class="hljs-keyword">return</span> fn(*args, **kwargs)  <span class="hljs-comment"># 现成的容器传入不定长需要 * 和 **  </span><br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sum</span>(<span class="hljs-params">*args, **kwargs</span>):  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(args) + <span class="hljs-built_in">sum</span>(kwargs.values())  <br>  <br>  <br>a = get_sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, math=<span class="hljs-number">10</span>, eng=<span class="hljs-number">30</span>)  <br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">开始计算...</span><br><span class="hljs-string">50</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="4-3-多个装饰器"><a href="#4-3-多个装饰器" class="headerlink" title="4.3 多个装饰器"></a>4.3 多个装饰器</h2><p>多个装饰器一层一层进入函数，再一层一层返回，装饰器的应用顺序是：<strong>自下而上，依次包裹</strong>。</p><ul><li>执行顺序是由外到内（先进入 <code>outer1</code>，再进入 <code>outer2</code>，再执行原函数）</li><li>返回顺序是由内到外（先从 <code>outer2</code> 返回，再从 <code>outer2</code> 返回）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer1</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer2</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer1  </span><br><span class="hljs-meta">@outer2  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是猪猪侠&#x27;</span>)  <br>  <br>  <br>hello()<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">装饰器1开始</span><br><span class="hljs-string">装饰器2开始</span><br><span class="hljs-string">测试函数</span><br><span class="hljs-string">装饰器2结束</span><br><span class="hljs-string">装饰器1结束</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码的两个装饰器相当于 <code>hello = outer1(outer2(hello))</code>。</p><ol><li><code>hello</code>先被 <code>outer2</code>装饰，返回一个新函数</li><li>这个新函数再被 <code>outer1</code>装饰，又得到一个新函数</li></ol><blockquote><p>多个装饰器有点递归或者栈调用的感觉，只不过多个装饰器是采用多层函数嵌套，并没有无限调用自己，只是采用了类似的套娃结构。</p><p>如果说递归是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……<br>递归是：无限重复的同一个壳。</p><p>那么多个装饰器是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有条河，河里有条船，船上有个老船员，正在给小船员讲故事！故事是……<br>多个装饰器是：多层不同的外壳。</p></blockquote><h2 id="4-4-带参装饰器"><a href="#4-4-带参装饰器" class="headerlink" title="4.4 带参装饰器"></a>4.4 带参装饰器</h2><p>在普通装饰器中 <code>@outer 相当于 demo = outer(demo)</code>，默认接收一个被装饰的函数参数，这里所说的带参装饰器是在 <code>@outer</code>的参数，语法糖的格式<strong>只允许接收一个参数</strong>，所以要使用三层函数嵌套来进行额外的传参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">name</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">msg</span>):   <span class="hljs-comment"># 可以接收参数</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我开始执行了&#x27;</span>)<br>            fn(msg)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我执行结束了&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:测试返回值&#x27;</span>   <span class="hljs-comment"># 可以返回值</span><br>        <span class="hljs-keyword">return</span> inner<br>    <span class="hljs-keyword">return</span> outer<br><br><br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&#x27;猪猪侠&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-built_in">print</span>(msg)<br><br><br>hello(<span class="hljs-string">&#x27;大家好啊&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">大家好</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(hello(<span class="hljs-string">&#x27;hhh&#x27;</span>))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">hhh</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">猪猪侠:测试返回值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>在上述代码中，<code>@deco(&#39;猪猪侠&#39;)</code>相当于 <code>hello = deco(&#39;猪猪侠&#39;)(hello)</code>，<code>hello</code>实际是一个指向 <code>inner</code>函数的变量。</p><ul><li>第一次调用 <code>deco(&#39;猪猪侠&#39;)</code>，返回一个真正的装饰器函数，也就是 <code>outer</code>函数</li><li>第二次相当于是 <code>outer(hello)</code>，和之前的普通装饰器一样</li></ul><blockquote><p>如果使用传统格式，而不使用语法糖，也可以直接在外层函数传参，而不需要三层函数，用法为 <code>hello = outer(hello, name)</code>。</p></blockquote><h1 id="5-偏函数"><a href="#5-偏函数" class="headerlink" title="5 偏函数"></a>5 偏函数</h1><p>Python的 <code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。<br>偏函数可以<strong>固定函数的某些参数</strong>，生成一个新的函数，在调用时可以减少重复参数的输入，降低调用难度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int()默认将字符串按照10进制进行转换，可以通过base设置进制</span><br><span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;152&#x27;</span>, base=<span class="hljs-number">8</span>)<br><br><span class="hljs-comment"># 固定base参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int2</span>(<span class="hljs-params">x, base=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x, base)<br><br><span class="hljs-comment"># functools.partial可以很方便地构造偏函数</span><br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Python生成器和迭代器</title>
    <link href="/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1 迭代"></a>1 迭代</h1><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 可迭代对象:<br>代码块<br></code></pre></td></tr></table></figure><h1 id="2-推导式（生成式）"><a href="#2-推导式（生成式）" class="headerlink" title="2 推导式（生成式）"></a>2 推导式（生成式）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h1 id="3-生成器"><a href="#3-生成器" class="headerlink" title="3 生成器"></a>3 生成器</h1><p>受到内存限制，列表的容量是有限的，存储大量数据要占用大量的空间。</p><p>生成器解决了这个问题，<strong>生成器（generator）允许按需生成值，而不是一次性在内存中创建并存储整个序列。</strong><br>在每次请求时（使用 <code>next()</code> 或在 <code>for</code> 循环中）才计算并返回一个值。计算完一个值后，它会“暂停”执行，保存当前的状态（包括局部变量），直到下一次请求到来时再“唤醒”并从暂停的地方继续执行。这种方式被称为<strong>惰性求值</strong>。</p><h2 id="3-1-生成器表达式"><a href="#3-1-生成器表达式" class="headerlink" title="3.1 生成器表达式"></a>3.1 生成器表达式</h2><p>生成器表达式在语法上类似于列表推导式，把 <code>[]</code>改成 <code>()</code>就创建了一个 <code>generator</code>。</p><ul><li><strong>列表推导式</strong>：立即生成所有元素，并存储在内存中。</li><li><strong>生成器表达式</strong>：返回一个生成器对象，按需生成元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br><span class="hljs-built_in">print</span>(g)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x00000280B9CA04A0&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(g))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-生成器函数"><a href="#3-2-生成器函数" class="headerlink" title="3.2 生成器函数"></a>3.2 生成器函数</h2><p>推导算法复杂的时候可以使用函数实现，这是最常见的方法，写法和普通函数类似，不过使用 <code>yield</code> 语句而不是 <code>return</code> 语句来返回值。</p><ul><li><code>return</code>：函数遇到 <code>return</code> 会立即终止，并返回一个值。每次调用函数都会从第一行代码重新开始执行。</li><li><code>yield</code>：函数遇到 <code>yield</code> 会暂停执行，将值返回给调用者，并<strong>记住函数当前的所有状态</strong>。下次调用时，函数会从上次返回的 <code>yield</code>语句继续执行。</li></ul><p>如果一个函数定义中包含 <code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个 <code>generator</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无限序列生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> count<br>        count += <span class="hljs-number">1</span><br><br>f = counter() <br><span class="hljs-built_in">print</span>(f)  <span class="hljs-comment"># &lt;generator object counter at 0x0000018E4602B610&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>generator</code>函数会创建一个 <code>generator</code>对象，多次调用 <code>generator</code>函数会创建多个相互独立的 <code>generator</code>，所以正确做法是创建一个 <code>generator</code>对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">f = counter()  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0  创建了新的generator对象</span><br></code></pre></td></tr></table></figure><h2 id="3-3-生成器的访问"><a href="#3-3-生成器的访问" class="headerlink" title="3.3 生成器的访问"></a>3.3 生成器的访问</h2><p>如果要访问生成器，可以使用 <code>next()</code>函数。<code>generator</code>保存的是算法，每次调用 <code>next()</code>就计算 <code>g</code>的下一个值，直到计算到最后一个元素，没有更多的元素时，抛出 <code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>不过一般不会使用 <code>next()</code>，由于 <code>generator</code>也是可迭代对象，可以通过 <code>for</code>循环去迭代它，并且不用担心相关 <code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代generator对象</span><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:<br><span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4 迭代器"></a>4 迭代器</h1><h2 id="4-1-可迭代对象"><a href="#4-1-可迭代对象" class="headerlink" title="4.1 可迭代对象"></a>4.1 可迭代对象</h2><p>可以直接作用于 <code>for</code>循环的对象统称为<strong>可迭代对象（Iterable）</strong>，包括：</p><ul><li>集合数据类型（都是 <code>Iterable</code>，但不是 <code>Iterator</code>，可以使用 <code>iter()</code>函数转化为迭代器）<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器（都是 <code>Iterable</code>，又是 <code>Iterator</code>）<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>可以使用 <code>isinstance</code>方法判断是否为<strong>可迭代对象</strong> <code>Iterable</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure><h2 id="4-2-迭代器对象"><a href="#4-2-迭代器对象" class="headerlink" title="4.2 迭代器对象"></a>4.2 迭代器对象</h2><p>生成器不但可以作用于 <code>for</code>循环，还可以被 <code>next()</code>函数不断调用并返回下一个值，直到最后抛出 <code>StopIteration</code>错误表示无法继续返回下一个值了。<br>迭代器是一个实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象，可以被 <code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器（Iterator）</strong>。</p><p>也可以使用 <code>isinstance</code>方法判断是否为<strong>迭代器对象</strong> <code>Iterator</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>((i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator))  <span class="hljs-comment"># True，迭代器</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>([], Iterator))  <span class="hljs-comment"># False，列表不是迭代器</span><br></code></pre></td></tr></table></figure><p>生成器都是 <code>Iterator</code>对象，但 <code>list</code>、<code>dict</code>、<code>str</code>虽然是 <code>Iterable</code>，却不是 <code>Iterator</code>。<br>把 <code>list</code>、<code>dict</code>、<code>str</code>等 <code>Iterable</code>变成 <code>Iterator</code>可以使用 <code>iter()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]  <br>ls = <span class="hljs-built_in">iter</span>(ls)  <span class="hljs-comment"># 转换为了Iterator</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(ls, Iterator))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><ul><li>凡是可作用于 <code>for</code>循环的对象都是 <code>Iterable</code>类型</li><li>凡是可作用于 <code>next()</code>函数的对象都是 <code>Iterator</code>类型，它们表示一个惰性计算的序列</li></ul><blockquote><p>为什么 <code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是 <code>Iterator</code>？<br>这是因为Python的 <code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被 <code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出 <code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 <code>next()</code>函数实现按需计算下一个数据，所以 <code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p></blockquote><p>Python的 <code>for</code>循环本质上就是通过不断调用 <code>next()</code>函数实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面两种方式完全等价</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 首先获得Iterator对象: </span><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <br><span class="hljs-comment"># 循环: </span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <br><span class="hljs-keyword">try</span>:       <br><span class="hljs-comment"># 获得下一个值:       </span><br>x = <span class="hljs-built_in">next</span>(it)   <br><span class="hljs-keyword">except</span> StopIteration:      <br><span class="hljs-comment"># 遇到StopIteration就退出循环       </span><br><span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Python赋值与深浅拷贝</title>
    <link href="/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-可变对象和不可变对象"><a href="#1-可变对象和不可变对象" class="headerlink" title="1 可变对象和不可变对象"></a>1 可变对象和不可变对象</h1><p>可变对象和不可变对象的划分依据：<strong>在不改变地址的前提下，元素值能否修改</strong>。</p><ul><li>可变对象：该对象所指内存的值可以被改变<ul><li>列表 <code>list</code></li><li>集合 <code>set</code></li><li>字典 <code>dict</code></li><li>自定义对象</li></ul></li><li>不可变对象：该对象所指向的内存中的值不能被改变，一旦创建就<strong>不可修改</strong>，想要修改对象的值，需要复制一份后再改变，会返回一个新地址<ul><li>数字 <code>int</code> <code>float</code></li><li>字符串 <code>str</code></li><li>元组 <code>tuple</code></li><li>布尔 <code>bool</code></li></ul></li></ul><p>可以通过 <code>id()</code>查看对象的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不可变对象：改变元素值本质是创建了一个新的对象，指向了新的对象</span><br>a = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202913808</span><br>a = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202914128，内容修改，地址也变了</span><br><br><span class="hljs-comment"># 可变对象：</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536</span><br>ls[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536，内容修改，地址不变</span><br></code></pre></td></tr></table></figure><h1 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2 赋值"></a>2 赋值</h1><p>与C++不同，Python的赋值 <code>=</code>属于<strong>引用赋值</strong>，只是了创建对象的另一个<strong>引用（别名）</strong>，新旧变量指向同一个内存对象，通过任一引用修改对象（需要可变），其他引用都会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引用赋值，a和b都指向同一内存空间</span><br>a = <span class="hljs-number">10</span><br>b = a<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 1437435953680</span><br><br><span class="hljs-comment"># c和d也指向同一内存空间</span><br>c = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>d = c<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 2028769177536</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(d))  <span class="hljs-comment"># 2028769177536</span><br></code></pre></td></tr></table></figure><p>Python解释器在执行 <code>a = 10</code>赋值时做以下操作：</p><ol><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p>把一个变量 <code>a</code>赋值给另一个变量 <code>b</code>，这个操作实际上是把变量 <code>b</code>指向变量 <code>a</code>所指向的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br>b = a<br>a = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250909100211.png"></p><h1 id="3-浅拷贝"><a href="#3-浅拷贝" class="headerlink" title="3 浅拷贝"></a>3 浅拷贝</h1><p>浅拷贝和深拷贝使用需要导入 <code>import copy</code>模块，它们的区别是拷贝层级不同，都可以操作可变对象和不可变对象，但是一般不会操作不可变对象。</p><blockquote><p>不论是深拷贝还是浅拷贝，针对不可变类型的拷贝，都不会开辟新的空间，而是拷贝对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b = copy.copy(a)<br>c = copy.deepcopy(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 1553475958912</span><br></code></pre></td></tr></table></figure></blockquote><p>浅拷贝 <code>copy.copy()</code>会创建新对象，<strong>复制最外层的数据</strong>，但内部容器仍然是引用。</p><ul><li>外层独立：外层修改互不影响</li><li>共享内层：嵌套对象的修改会影响所有拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]<br>b = copy.copy(a)  <span class="hljs-comment"># 实际拷贝了 [1, 2, 3, 地址]</span><br><br><span class="hljs-comment"># 外层在新的对象中</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 2785582893824</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 2785582894016</span><br><br><span class="hljs-comment"># 内层还是原来的引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [66, 5, 6]]，外层独立，内层仍然是旧引用</span><br></code></pre></td></tr></table></figure><p>在最外层只暴露了深层的引用，浅拷贝只会拷贝这个地址，而不会拷贝深层数据。<br><img src="/../../../ai_assets/Pasted%20image%2020250906180358.png"></p><h1 id="4-深拷贝"><a href="#4-深拷贝" class="headerlink" title="4 深拷贝"></a>4 深拷贝</h1><p>深拷贝 <code>copy.deepcopy()</code>会创建新的对象，并且<strong>完全独立</strong>的，会递归复制所有嵌套对象。</p><ul><li>完全隔离：任何修改都不会影响其他拷贝</li><li>内存开销：需要更多内存，因为创建所有对象的副本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy  <br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]  <br>b = copy.deepcopy(a)  <br><br><span class="hljs-comment"># 外层是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1823162354432</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1823162354624</span><br><br><span class="hljs-comment"># 内层也是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357568</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357952</span><br>  <br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 6]]，完全独立，不受影响</span><br></code></pre></td></tr></table></figure><h1 id="5-总结区分"><a href="#5-总结区分" class="headerlink" title="5 总结区分"></a>5 总结区分</h1><p><strong>普通赋值和浅拷贝：</strong><br><img src="/../../../ai_assets/Pasted%20image%2020250906194615.png"></p><p><strong>浅拷贝和深拷贝：</strong></p><ul><li>浅拷贝只拷贝第一层中的数据并开辟空间存储</li><li>深拷贝拷贝所有的数据并开辟对应的空间存储</li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250906201908.png"></p><p><strong>拷贝不可变类型：</strong><br>深浅拷贝对于不可变类型来说，非常类似普通的赋值，只是复制了引用。<br><img src="/../../../ai_assets/Pasted%20image%2020250906202301.png"></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Python面向对象</title>
    <link href="/2024/07/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/07/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象就是老板思想，需要什么工作就派给什么职位（类）的员工，对于相同的职位都有相同的特征，每一种职位都有很多不同的人（对象）在岗位上，而每一个人又有自己的特点（属性）和技能（方法）。</p><h1 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1 类和对象"></a>1 类和对象</h1><ul><li>类：<strong>抽象的模板</strong>，是对一群有相同特征或行为的事物的统称，不能直接使用。（比如学生类）<ul><li><strong>属性</strong>：这类事物具有什么样的<strong>特征</strong></li><li><strong>方法</strong>：这类事物具有什么样的<strong>行为</strong></li></ul></li><li>对象：<strong>具体的实体</strong>，是由类创建出来的一个具体存在，可以直接使用。（比如张三）</li></ul><h2 id="1-1-定义类和创建对象"><a href="#1-1-定义类和创建对象" class="headerlink" title="1.1 定义类和创建对象"></a>1.1 定义类和创建对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义类，类名一般使用大驼峰</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">方法名</span>:<br>...<br>...<br><br><span class="hljs-comment"># 如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 创建对象</span><br>对象名 = 类名()<br><br><span class="hljs-comment"># 通过对象名调用内部方法</span><br>对象名.方法名()<br></code></pre></td></tr></table></figure><blockquote><p>在Python中，<strong>函数</strong>是独立的代码块，可以在任何地方定义和调用。<strong>方法</strong>是定义在类内部的函数，通常用于操作类的实例或类本身。</p></blockquote><p><code>self</code>关键字：类似Java的 <code>this</code><br>为了在类的内部区分是哪个对象调用了类的方法，哪一个对象调用的方法，<code>self</code>就是哪一个对象的引用。调用方法时，不需要传递 <code>self</code>参数。在方法内部：</p><ul><li>通过 <code>self.</code>访问对象的属性</li><li>通过 <code>self.</code>调用对象的其他方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 谁调用就是谁</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;self是<span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)  <br>  <br>  <br>car = Car()  <br>car.run()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;car对象<span class="hljs-subst">&#123;car&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>实例方法的第一个参数必须为 <code>self</code>！</p></blockquote><h2 id="1-2-属性的增加与访问"><a href="#1-2-属性的增加与访问" class="headerlink" title="1.2 属性的增加与访问"></a>1.2 属性的增加与访问</h2><p>与Java不同的是，Python可以在类的外面直接添加属性，但<strong>不推荐</strong>这种方式，属性应该封装到类的内部，参考下一节的 <code>__init__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 增加属性</span><br>对象名.属性名 = 属性值<br></code></pre></td></tr></table></figure><blockquote><p>由于这种方法的存在，和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，同一个类的不同实例，拥有的变量名称可能不同</p></blockquote><p>属性的访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类外部访问</span><br>对象名.属性名<br><br><span class="hljs-comment"># 类内部访问</span><br><span class="hljs-variable language_">self</span>.属性名<br></code></pre></td></tr></table></figure><h2 id="1-3-获取对象信息"><a href="#1-3-获取对象信息" class="headerlink" title="1.3 获取对象信息"></a>1.3 获取对象信息</h2><p><code>dir(对象)</code>可以查看该对象有哪些属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>使用 <code>dir()</code>只能把属性和方法列出来，搭配 <code>getattr()</code>、<code>setattr()</code>以及 <code>hasattr()</code>可以改变对象的属性和方法。</p><ul><li><code>hasattr()</code>查看是否有指定属性</li><li><code>getattr()</code>获取指定属性</li><li><code>setattr()</code>设置指定属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看是否有name属性，返回True和False</span><br><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br><br><span class="hljs-comment"># 获取指定属性，如果没有则抛出AttributeError的错误</span><br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">404</span>)  <span class="hljs-comment"># 如果属性不存在返回指定值，自行设定</span><br><br><span class="hljs-comment"># 设置指定属性值，可以是之前没有的</span><br><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><blockquote><p>只有在不知道对象信息的时候，我们才会去获取对象信息，否则直接使用 <code>对象.属性</code>即可。</p></blockquote><h2 id="1-4-身份运算符is、is-not"><a href="#1-4-身份运算符is、is-not" class="headerlink" title="1.4 身份运算符is、is not"></a>1.4 身份运算符is、is not</h2><p>身份运算符 <code>is</code>、<code>is not</code>用于<strong>比较两个对象的内存地址</strong>是否一致——是否是对同一个对象的引用。</p><ul><li><code>is</code>用于判断两个变量<strong>引用对象</strong>是否为同一个</li><li><code>==</code>用于判断<strong>引用变量的值</strong>是否相等</li></ul><blockquote><p>针对 <code>None</code>的比较，建议使用 <code>is</code>。</p></blockquote><h1 id="2-魔法方法"><a href="#2-魔法方法" class="headerlink" title="2 魔法方法"></a>2 魔法方法</h1><p>魔法方法使用 <code>__xx__</code>双下划线包围，在特殊情况下会自动调用。</p><h2 id="2-1-init-方法"><a href="#2-1-init-方法" class="headerlink" title="2.1 __init__方法"></a>2.1 <code>__init__</code>方法</h2><p><code>__init__</code>就是Python的<strong>构造方法</strong>，也用来声明<strong>实例属性</strong>，创建对象时自动触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><br><br><span class="hljs-comment"># 有参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><span class="hljs-variable language_">self</span>.age = age<br></code></pre></td></tr></table></figure><h2 id="2-2-str-方法"><a href="#2-2-str-方法" class="headerlink" title="2.2 __str__方法"></a>2.2 <code>__str__</code>方法</h2><p>使用 <code>print()</code>打印对象时，默认是打印对象的内存地址，如果不想要输出内存地址，就需要定义 <code>__str__</code>方法。<code>__str__</code>方法的<strong>返回值必须是字符串</strong>，打印时将会打印其返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;name: <span class="hljs-subst">&#123;self.name&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-repr-方法"><a href="#2-3-repr-方法" class="headerlink" title="2.3 __repr__方法"></a>2.3 <code>__repr__</code>方法</h2><ul><li><code>__str__</code>：面向<strong>用户</strong>，强调可读性，在print时会调用</li><li><code>__repr__</code>：面向<strong>开发者</strong>，强调更准确、更标准的对象表示形式，通常是调试用的，交互式解释器中会调用</li></ul><p>如果只写 <code>__repr__</code> 而没写 <code>__str__</code>，那 <code>print(obj)</code> 也会退回调用 <code>__repr__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.item = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack(top-&gt; &quot;</span> + <span class="hljs-string">&quot;, &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.item[::-<span class="hljs-number">1</span>])) + <span class="hljs-string">&quot;)&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Stack(<span class="hljs-subst">&#123;self.item!r&#125;</span>)&quot;</span><br><br><br><span class="hljs-built_in">print</span>(st)     <span class="hljs-comment"># 调用 __str__，输出：Stack(top-&gt; 3, 2, 1)</span><br>st            <span class="hljs-comment"># 调用 __repr__，输出：Stack([1, 2, 3])</span><br></code></pre></td></tr></table></figure><h2 id="2-4-del-方法"><a href="#2-4-del-方法" class="headerlink" title="2.4 __del__方法"></a>2.4 <code>__del__</code>方法</h2><p>  当删除对象时，会自动调用 <code>__del__</code>方法，让对象在销毁前做一些事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span>被销毁了&#x27;</span>)<br><br>stu = Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>)<br><br><span class="hljs-comment"># 使用del手动删除对象，执行__del__方法，否则在对象自然销毁时执行</span><br><span class="hljs-keyword">del</span> stu<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-5-len-方法"><a href="#2-5-len-方法" class="headerlink" title="2.5 __len__方法"></a>2.5 <code>__len__</code>方法</h2><p>定义调用 <code>len(对象)</code>函数时，返回的长度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br></code></pre></td></tr></table></figure><h2 id="2-6-iter-方法"><a href="#2-6-iter-方法" class="headerlink" title="2.6 __iter__方法"></a>2.6 <code>__iter__</code>方法</h2><p>通过实现 <code>__iter__</code>方法，使用 <code>yield</code>关键字，可以使自定义类成为可迭代对象，方便使用 <code>for</code>循环进行遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <br>        current = <span class="hljs-variable language_">self</span>.head  <br>        <span class="hljs-keyword">while</span> current:  <br>            <span class="hljs-keyword">yield</span> current.data  <br>            current = current.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="3-封装"><a href="#3-封装" class="headerlink" title="3 封装"></a>3 封装</h1><p>根据职责将属性和方法封装到一个抽象的类中，外界使用类创建对象，让对象使用属性、调用方法，<strong>对象方法的细节都被封装在类的内部</strong>。</p><p>私有属性和私有方法只能在类的内部使用，在类的外部使用需要通过公共接口。</p><h2 id="3-1-私有属性"><a href="#3-1-私有属性" class="headerlink" title="3.1 私有属性"></a>3.1 私有属性</h2><p>格式：在属性名前面加两个下划线 <code>__</code>。<br>用法：和Java一样，定义公有方法 <code>get_xxx</code>获取私有属性、<code>set_xxx</code>设置私有属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__属性名<br></code></pre></td></tr></table></figure><h2 id="3-2-私有方法"><a href="#3-2-私有方法" class="headerlink" title="3.2 私有方法"></a>3.2 私有方法</h2><p>格式：在方法名前面加两个下划线 <code>__</code>。<br>用法：定义公有方法调用私有方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__方法名</span>():<br>...<br></code></pre></td></tr></table></figure><blockquote><p>了解：其实Python中没有真正的私有，在外部使用 <code>类名.__属性</code>、<code>类名.__方法</code>也可以访问，但<strong>不要这样做</strong>。<br>实际上Python内部只是将私有成员改了一个名，<code>__属性</code>变成了 <code>_类名__属性</code>，<code>__方法</code>变成了 <code>_类名__方法</code>。</p></blockquote><h2 id="3-3-dict-属性"><a href="#3-3-dict-属性" class="headerlink" title="3.3 __dict__属性"></a>3.3 <code>__dict__</code>属性</h2><p><code>___dict___</code> 是 Python 中的一个特殊属性，用于存储对象的所有属性及其对应的值。它以字典形式呈现，键为属性名，值为属性值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.gender = gender<br><br><br>p = Person(<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;男&#x27;</span>)  <br><span class="hljs-built_in">print</span>(p.__dict__)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;猪猪侠&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>在文件写入中可以使用 <code>__dict__</code>将对象转为字典，再将字典转为字符串进行写入。</p><h1 id="4-继承"><a href="#4-继承" class="headerlink" title="4 继承"></a>4 继承</h1><h2 id="4-1-继承的定义"><a href="#4-1-继承的定义" class="headerlink" title="4.1 继承的定义"></a>4.1 继承的定义</h2><ul><li>父类：也叫作基类</li><li>子类：也叫作派生类或扩展类</li></ul><p>子类默认继承父类所有的属性和方法，Python 的子类<strong>不会直接继承</strong>父类的私有属性和私有方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">父类名</span>):<br>...<br><br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(父类名<span class="hljs-number">1</span>, 父类名<span class="hljs-number">2</span>):<br>...<br></code></pre></td></tr></table></figure><p>当多个父类中存在相同名字的属性或方法，默认使用第一个父类的同名属性和方法，可以使用 <code>__mro__</code>属性或 <code>mro()</code>方法查看先后顺序。<br>MRO(Method Resolution Order)：方法解析顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(类名.__mro__)<br><span class="hljs-built_in">print</span>(类名.mro())<br></code></pre></td></tr></table></figure><p>在Python中，<code>object</code>是所有类的基类，即所有Python对象的根源。如果没有指定父类，会默认使用 <code>object</code>作为该类的基类（可以使用 <code>dir</code>函数查看）。</p><h2 id="4-2-重写"><a href="#4-2-重写" class="headerlink" title="4.2 重写"></a>4.2 重写</h2><p>父类方法不满足子类需求时，可以<strong>重写（override）</strong>，直接在子类中使用和父类相同名字的属性和方法即可进行重写。重写之后会调用子类的方法，而不是父类的。</p><h3 id="4-2-1-“覆盖”父类"><a href="#4-2-1-“覆盖”父类" class="headerlink" title="4.2.1 “覆盖”父类"></a>4.2.1 “覆盖”父类</h3><p>子类方法和父类方法完全不同，在子类中写一个和父类同名的方法实现即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工作&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CowHorse</span>(<span class="hljs-title class_ inherited__">Person</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 当牛马就行了</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当牛马&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-2-2-“扩展”父类"><a href="#4-2-2-“扩展”父类" class="headerlink" title="4.2.2 “扩展”父类"></a>4.2.2 “扩展”父类</h3><p>方式一：<code>父类名.父类方法(self)</code></p><p>这种方法可以精准访问指定的父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        School.__init__(<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># 将当前实例传给父类的__init__方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>煎饼果子&#x27;</span>)  <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 现代煎饼果子</span><br></code></pre></td></tr></table></figure><p>方式二：<code>super().父类方法()</code>（更常用）</p><p><code>super()</code> 实际上返回的是一个 <strong>代理对象（super object）</strong>。这个代理对象知道两件事：</p><ol><li>当前是哪个类（<code>__class__</code>）</li><li>当前实例的 MRO 是什么</li></ol><p>只能访问最近的父类，有就用，没有就往后找，找不到再报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从当前类的 MRO 中，从当前类的下一个开始，依次查找 __init__ 方法 ，并调用第一个</span><br><span class="hljs-built_in">super</span>().__init__()<br></code></pre></td></tr></table></figure><p><code>super()</code>零参数时，Python 解释器会自动填充两个参数：</p><ul><li><code>__class__</code>：当前正在定义的类。</li><li><code>self</code>：当前实例。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 会自动填充当前实例的self和当前类</span><br>        <span class="hljs-built_in">super</span>().make() <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 古法Master煎饼果子</span><br></code></pre></td></tr></table></figure><blockquote><p>在Python中 <code>super</code>是一个特殊的类，<code>super()</code>是使用 <code>super</code>类创建出来的对象。使⽤<code>super() </code>可以⾃动查找⽗类，适合单继承使⽤，多继承不建议使用。</p></blockquote><h1 id="5-多态"><a href="#5-多态" class="headerlink" title="5 多态"></a>5 多态</h1><h2 id="5-1-多态的定义"><a href="#5-1-多态的定义" class="headerlink" title="5.1 多态的定义"></a>5.1 多态的定义</h2><p>当我们定义一个 <code>class</code>的时候，我们实际上就定义了一种数据类型，判断一个变量是否是某个类型可以用 <code>isinstance()</code>判断。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(dog, Dog)  <span class="hljs-comment"># True，Dog类型</span><br><span class="hljs-built_in">isinstance</span>(cat, Cat)  <span class="hljs-comment"># True，Cat类型</span><br><span class="hljs-built_in">isinstance</span>(dog, Animal)  <span class="hljs-comment"># True，既是Dog类型，又是Animal类型</span><br></code></pre></td></tr></table></figure><p>多态指的是<strong>同一函数对于传入的不同对象做出不同的响应</strong>。多态的好处在于，当我们需要传入 <code>Dog</code>、<code>Cat</code>等等时，我们只需要接收 <code>Animal</code>这个父类类型就可以，并且原有的函数对于新增的 <code>Animal</code>子类也生效，这就是多态的含义。</p><p>实现多态的条件：</p><ol><li>有继承（子类继承父类）</li><li>有方法重写（子类重写父类方法）</li><li>父类引用指向子类对象（子类对象传给父类对象调用者）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;动物叫&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;汪汪汪&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;喵喵喵&#x27;</span>  <br>  <br>    <span class="hljs-comment"># 注意没有继承Animal  </span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>  <br>  <br>  <br><span class="hljs-comment"># 这个函数不关心传入的是什么类型，只关心是否有 speak 方法  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br><span class="hljs-comment"># 显式写出类型，但实际没有作用  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal: Animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br>dog = Dog()  <br>cat = Cat()  <br>car = Car()  <br>sound(dog)  <br>sound(cat)  <br>  <br><span class="hljs-comment"># 鸭子类型的体现，car虽然不是Animal，但是有speak方法  </span><br><span class="hljs-comment"># 注意这个不叫多态，因为多态的条件是有继承有重写  </span><br>sound(car)<br></code></pre></td></tr></table></figure><p>对于静态语言Java来说，多态需要继承同一父类或接口，在刚刚的例子中必须是 <code>Animal</code>或其子类。而在Python中，<strong>不关心对象的类型，只关心对象的行为</strong>（即它有什么方法）。只要一个对象具有所需的方法和属性，它就可以被当作预期的类型来使用，在刚刚的例子中比如一个 <code>Car</code>类，只要有 <code>speak</code>方法，就可以实现多态。</p><p>Python的多态最大的特点是：<strong>鸭子类型（Duck Typing）</strong>。“如果它走起路来像鸭子，叫起来像鸭子，那么它就是鸭子。”</p><h2 id="5-2-多态的应用"><a href="#5-2-多态的应用" class="headerlink" title="5.2 多态的应用"></a>5.2 多态的应用</h2><h3 id="5-2-1-方法重写（最常见的形式）"><a href="#5-2-1-方法重写（最常见的形式）" class="headerlink" title="5.2.1 方法重写（最常见的形式）"></a>5.2.1 方法重写（最常见的形式）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">pass</span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):  <br>        <span class="hljs-variable language_">self</span>.width = width  <br>        <span class="hljs-variable language_">self</span>.height = height  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.width * <span class="hljs-variable language_">self</span>.height  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):  <br>        <span class="hljs-variable language_">self</span>.radius = radius  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>  <br>  <br>  <br><span class="hljs-comment"># 多态的体现  </span><br>shapes = [Square(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>), Circle(<span class="hljs-number">3</span>), Square(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)]  <br>  <br><span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;面积: <span class="hljs-subst">&#123;shape.area()&#125;</span>&quot;</span>)  <span class="hljs-comment"># 同样的方法调用，不同的结果</span><br></code></pre></td></tr></table></figure><h3 id="5-2-2-运算符重载"><a href="#5-2-2-运算符重载" class="headerlink" title="5.2.2 运算符重载"></a>5.2.2 运算符重载</h3><p>相同的运算符（如 <code>+</code>, <code>*</code>）对不同类型的对象有不同的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># + 运算符的多态</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)        <span class="hljs-comment"># 数字加法: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; World&quot;</span>)  <span class="hljs-comment"># 字符串拼接: Hello World</span><br><span class="hljs-built_in">print</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])     <span class="hljs-comment"># 列表合并: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="5-2-3-内置函数的多态"><a href="#5-2-3-内置函数的多态" class="headerlink" title="5.2.3 内置函数的多态"></a>5.2.3 内置函数的多态</h3><p>像 <code>len()</code> 这样的函数可以对多种类型的对象工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello&quot;</span>))     <span class="hljs-comment"># 字符串长度: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))   <span class="hljs-comment"># 列表元素个数: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;))  <span class="hljs-comment"># 字典键值对数量: 2</span><br></code></pre></td></tr></table></figure><h2 id="5-3-抽象类（接口）"><a href="#5-3-抽象类（接口）" class="headerlink" title="5.3 抽象类（接口）"></a>5.3 抽象类（接口）</h2><p>在Python中，抽象类和接口是一个东西，方法体是<strong>空实现的</strong>（<code>pass</code>）称之为<strong>抽象方法</strong>，<strong>含有抽象方法的类</strong>称之为<strong>抽象类</strong>。</p><ul><li>父类用来确定有哪些方法（<strong>父类制定接口标准</strong>）</li><li>具体的方法实现有子类来实现（<strong>子类实现接口标准</strong>）</li></ul><p>在Python中，抽象类的子类并不是必须要实现所有的抽象方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&#x27;&#x27;&#x27;吃&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&#x27;&#x27;&#x27;工作&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># Person的子类要去实现eat和work两个方法</span><br></code></pre></td></tr></table></figure><h1 id="6-其他特性"><a href="#6-其他特性" class="headerlink" title="6 其他特性"></a>6 其他特性</h1><h2 id="6-1-实例属性和实例方法"><a href="#6-1-实例属性和实例方法" class="headerlink" title="6.1 实例属性和实例方法"></a>6.1 实例属性和实例方法</h2><p>使用 <code>类名()</code>创建对象，创建对象的动作有两步：</p><ol><li>在内存中为对象分配空间</li><li>调用初始化方法 <code>__init__</code>为对象初始化</li></ol><p>对象创建后，内存中就有了一个对象的实实在在的存在——<strong>实例</strong>。</p><ul><li>创建出来的对象叫做<strong>类的实例</strong>，创建对象的动作叫做<strong>实例化</strong></li><li>对象的属性叫做<strong>实例属性</strong>，对象的方法叫做<strong>实例方法</strong></li></ul><p>对象各自拥有自己的实例属性，可以通过 <code>self.</code>  访问自己的属性、调用自己的方法。</p><blockquote><p>每一个对象都有自己<strong>独立的内存空间，保存各自不同的属性</strong>。<br>多个对象的方法，在内存中只有一份，调用方法时，需要把对象的引用传递到方法的内部。</p></blockquote><h2 id="6-2-类属性和类方法"><a href="#6-2-类属性和类方法" class="headerlink" title="6.2 类属性和类方法"></a>6.2 类属性和类方法</h2><ul><li>在程序运行时，类同样会被加载到内存，在Python中，类是一个特殊的对象——<strong>类对象</strong>。</li><li>在程序运行时，类对象在内存中<strong>只有一份</strong>，使用一个类可以创建出<strong>很多个对象的实例</strong>。</li></ul><p>除了封装<strong>实例的属性和方法</strong>外，类对象还可以拥有<strong>自己的属性和方法</strong>——<strong>类属性、类方法</strong>。</p><ul><li>类属性：给类对象定义的属性，与具体对象无关，用来记录<strong>类对象的相关特征</strong></li><li>类方法：给类对象定义的方法，可以访问类对象或调用其他类方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-comment"># 定义类属性，描述学生数量</span><br>count = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 定义类方法，使用@classmethod标识</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>(<span class="hljs-params">cls</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;学生的数量为<span class="hljs-subst">&#123;cls.count&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>类方法第一个参数必须为类对象，通常用 <code>cls</code>表示，类似实例方法中的 <code>self</code>，不需要传值。<br>在类方法中，哪个类调用的方法，<code>cls</code>就是哪个类的引用，可以通过 <code>cls.</code>访问类属性或调用类方法。</p></blockquote><p><img src="/../../../ai_assets/Pasted%20image%2020250904191238.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问类属性</span><br>类名.类属性  <span class="hljs-comment"># 推荐</span><br>对象名.类属性 <br><br><span class="hljs-comment"># 调用类方法   </span><br>类名.类方法  <span class="hljs-comment"># 推荐</span><br>对象名.类方法<br></code></pre></td></tr></table></figure><h2 id="6-3-静态方法"><a href="#6-3-静态方法" class="headerlink" title="6.3 静态方法"></a>6.3 静态方法</h2><p>既不需要访问实例属性和实例方法，又不需要访问类属性和类方法，就可以使用<strong>静态方法</strong>，使用装饰器 <code>@staticmethod</code>来标识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>():  <span class="hljs-comment"># 不需要self</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>)<br><br><span class="hljs-comment"># 调用静态方法</span><br>类.静态方法()   <span class="hljs-comment"># 推荐</span><br>对象.静态方法()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Python异常与模块</title>
    <link href="/2024/07/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/07/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1 异常处理"></a>1 异常处理</h1><h2 id="1-1-异常的捕获"><a href="#1-1-异常的捕获" class="headerlink" title="1.1 异常的捕获"></a>1.1 异常的捕获</h2><p>世界上没有完美的程序，程序运行都可能出现异常，出现异常有下面两种情况：</p><ol><li>整个程序因为一个BUG停止运行</li><li>对BUG进行提醒，整个程序继续运行</li></ol><p>实际开发更多是第2种情况，就需要<strong>捕获异常</strong>，它的作用在于：提前假设某处会出现异常，提前做好准备，当真的出现异常的时候，可以有后续手段，一般 <code>try</code> 下方只放一行尝试执行的代码。</p><ul><li><code>try</code>：只有在 <code>try</code> 内部的代码，才会被捕获异常</li><li><code>except</code>：匹配机制，用来匹配特定异常</li><li><code>else</code>：没有异常的时候执行</li><li><code>finally</code>：有没有异常都会执行</li></ul><p>用 <code>try</code>来运行可能出错的代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至 <code>except</code>语句块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">else</span>:<br>    没有异常的处理代码<br><span class="hljs-keyword">finally</span>:<br>    有没有异常都会执行的代码<br></code></pre></td></tr></table></figure><hr><p>捕获常规异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span>:<br>出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获指定异常：如果异常类型和要捕获的异常类型不一致，则无法捕获异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 变量:<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获多个异常：在except后使用元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> (异常类型<span class="hljs-number">1</span>, 异常类型<span class="hljs-number">2</span>):<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获异常并输出描述信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> e:<br>pirnt(e)<br></code></pre></td></tr></table></figure><p>捕获所有异常：<code>Exception</code> 是所有异常的父类，任何异常都可以用 <code>Exception</code> 抓住</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>pirnt(e)<br></code></pre></td></tr></table></figure><p><code>except</code>不仅会捕获指定异常，还会将其子类一网打尽，常见错误类型和继承关系：<br><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><h2 id="1-2-异常的记录与抛出"><a href="#1-2-异常的记录与抛出" class="headerlink" title="1.2 异常的记录与抛出"></a>1.2 异常的记录与抛出</h2><p>记录错误，使用Python内置的 <code>logging</code>模块可以很方便的记录异常信息，打印完错误信息程序还会继续正常执行。通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    logging.exception(e)<br></code></pre></td></tr></table></figure><p>异常本质上也是一个 <code>class</code>，捕获异常就是捕获该类的一个实例。异常不是凭空产生的，而是有意创造的并抛出的。必要时我们可以定义一个异常 <code>class</code>，并选择好合适的继承关系，用 <code>raise</code>进行抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):  <br>    <span class="hljs-keyword">pass</span>  <br><br><br>a = <span class="hljs-number">10</span>  <br>b = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">&#x27;分母为0&#x27;</span>)  <br><span class="hljs-built_in">print</span>(a / b)<br></code></pre></td></tr></table></figure><h1 id="2-异常的传递"><a href="#2-异常的传递" class="headerlink" title="2  异常的传递"></a>2  异常的传递</h1><p>当函数 <code>func01</code> 中发生异常, 并且没有捕获处理这个异常的时候, 异常会传递到函数 <code>func02</code>, 当 <code>func02</code> 也没有捕获处理这个异常的时候，<code>main</code> 函数会捕获这个异常,  这就是异常的传递性。<br><strong>当所有函数都没有捕获异常的时候, 程序就会报错</strong>。</p><p><img src="/../../../ai_assets/Pasted%20image%2020250901212333.png"></p><blockquote><p>利用异常具有传递性的特点，当我们想要保证程序不会因为异常崩溃的时候，就可以在 <code>main</code> 函数中设置异常捕获，由于无论在整个程序哪里发生异常, 最终都会传递到 <code>main</code> 函数中，这样就可以确保所有的异常都会被捕获。</p></blockquote><h1 id="3-模块与包"><a href="#3-模块与包" class="headerlink" title="3 模块与包"></a>3 模块与包</h1><h2 id="3-1-模块基本用法"><a href="#3-1-模块基本用法" class="headerlink" title="3.1 模块基本用法"></a>3.1 模块基本用法</h2><p>模块就是一个Python文件，里面有类、函数、变量等，可以导入模块去使用，类似C++的头文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">from</span> 包|模块] <span class="hljs-keyword">import</span> 包|模块|函数|变量|类... [<span class="hljs-keyword">as</span> 别名]<br></code></pre></td></tr></table></figure><p>实例：<br>代码文件 <code>B.py</code> 中有函数：<code>B1</code> <code>B2</code> <code>B3</code>，在代码文件A中使用，可以有如下写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法一</span><br><span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 别名</span><br><span class="hljs-keyword">import</span> B <span class="hljs-keyword">as</span> b<br>b.B1()<br>b.B2()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法二</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> B1, B2<br>B1()<br>B2()<br><span class="hljs-comment"># B3没有导入，不能使用</span><br><br><span class="hljs-comment"># 导入B中所有函数，但不推荐，因为没有方法一可读性强，归属关系不清楚</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br>B3()<br></code></pre></td></tr></table></figure><h2 id="3-2-Python内置变量"><a href="#3-2-Python内置变量" class="headerlink" title="3.2 Python内置变量"></a>3.2 Python内置变量</h2><p><code>__name__</code>变量：<br>任何一个Python代码中，都隐式附带这个变量。</p><ul><li>当这个代码文件直接执行的时候，此变量记录值是：<code>__main__</code></li><li>当这个代码文件，作为模块被其它代码文件导入的时候，此变量记录值是：<code>代码文件名本身</code></li></ul><p>基于这个特性，我们可以区分这个文件是执行了还是被导入了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ...       <span class="hljs-comment"># 在测试的时候，可以避免其他文件导入时该文件时，都执行测试代码</span><br></code></pre></td></tr></table></figure><p><code>__all__</code>变量：<br>表示的是如果文件被 <code>from 模块 import *</code>导入，则内部的哪些函数可以被 <code>*</code>导入。<br>默认是全部导入，如果不想要全部的话，可以手动赋值此变量。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># B3不会被其他文件导入</span><br>__all__ = [<span class="hljs-string">&quot;B1&quot;</span>, <span class="hljs-string">&quot;B2&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B1</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B2</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B3</span>():<br>    ...<br></code></pre></td></tr></table></figure><h2 id="3-3-包"><a href="#3-3-包" class="headerlink" title="3.3 包"></a>3.3 包</h2><p>概念：Python的包是一个特殊文件夹，这个文件夹内包含：</p><ol><li><code>__init__.py</code>的文件（用来控制模块的导入行为）</li><li>其它模块（<code>.py</code>）文件</li></ol><p>包可以帮助我们<strong>管理模块</strong>, 包的作用就是包含多个模块，但包的本质依然是模块。<br><img src="/../../../ai_assets/Pasted%20image%2020250902103509.png"></p><p>实例：<br>文件夹 <code>my_package</code>内有：</p><ul><li><code>__init__.py</code>文件</li><li>有 <code>A.py</code> <code>C.py</code> 模块文件</li><li>有 <code>B.py</code> 模块文件，这个模块内提供 <code>B1</code> <code>B2</code> <code>B3</code> 三个函数</li></ul><p>方式一：不受 <code>__init__.py</code>控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不推荐，不好写</span><br><span class="hljs-keyword">import</span> my_package.B<br>my_package.B.B1()<br>my_package.B.B2()<br></code></pre></td></tr></table></figure><p>方式二：受到 <code>__init__.py</code>控制<br>在 <code>__init__.py</code> 文件内写上：<code>__all__ = [&quot;A&quot;, &quot;B&quot;]</code> ，则可以使用A和B两个模块，无法用C这个模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> *<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> B1<br>B1()    <span class="hljs-comment"># 无法使用B2和B3</span><br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br></code></pre></td></tr></table></figure><h2 id="3-4-安装第三方包"><a href="#3-4-安装第三方包" class="headerlink" title="3.4 安装第三方包"></a>3.4 安装第三方包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install 包名称<br></code></pre></td></tr></table></figure><p>如果网络不好可以用清华镜像，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称<br></code></pre></td></tr></table></figure><p>在Pycharm直接安装<br><img src="/../../../ai_assets/Pasted%20image%2020250902110216.png"></p><h2 id="3-5-Anaconda"><a href="#3-5-Anaconda" class="headerlink" title="3.5 Anaconda"></a>3.5 Anaconda</h2><p>Anaconda内置了非常多的第三方库，可以用来管理Python模块。<br>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在 <code>sys</code>模块的 <code>path</code>变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习\\试学班&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_display&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\python310.zip&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\DLLs&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib\\site-packages&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_matplotlib_backend&#x27;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>可以设置环境变量 <code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。</p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Python文件操作</title>
    <link href="/2024/07/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/07/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件打开"><a href="#1-文件打开" class="headerlink" title="1 文件打开"></a>1 文件打开</h1><p><code>open</code>函数，可以打开已存在的文件，或创建一个新文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(name, mode, encoding)<br></code></pre></td></tr></table></figure><ul><li><code>name</code>：文件路径</li><li><code>mode</code>：工作模式：只读、写入、追加等</li><li><code>encoding</code>：编码格式（推荐UTF-8）</li></ul><p>工作模式：</p><ul><li><code>r</code> ：只读（默认）</li><li><code>rb</code>：读取非文本文件（内部是01），否则会被默认按UTF-8编码）</li><li><code>wb</code>：写入非文本文件（01）</li><li><code>w</code> ：覆盖写入，原有内容会被删除</li><li><code>a</code> ：追加写入，在原有内容后追加</li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250901145332.png"></p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于encoding的位置不是第三个，所以要用关键字参数显式指明</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;python.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment"># 此时f是open函数的文件对象，拥有属性和方法</span><br></code></pre></td></tr></table></figure><h1 id="2-文件关闭"><a href="#2-文件关闭" class="headerlink" title="2 文件关闭"></a>2 文件关闭</h1><p><code>close()</code>关闭文件对象，和打开文件是配套操作。如果不关闭，文件会被Python一直占用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.close()  <span class="hljs-comment"># 同时会自动调用 文件对象.flush() </span><br></code></pre></td></tr></table></figure><h1 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3 文件读取"></a>3 文件读取</h1><p>文件读取的前置要求是文件要先打开。</p><p><code>read()</code>方法：<br>读取文件，返回一个<strong>字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.read(num)<br><span class="hljs-comment"># num表示读取的长度（单位字节），没有传入num默认读取文件所有数据</span><br></code></pre></td></tr></table></figure><p><code>readlines()</code>方法：<br>读取整个文件，按照行进行切分，返回一个<strong>列表</strong>，每一行数据作为一个元素，末尾添加 <code>\n</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readlines()<br></code></pre></td></tr></table></figure><p><code>readline()</code>方法：<br>调用一次读取一行内容，返回<strong>字符串</strong>，末尾带有 <code>\n</code>。如需读取多行，需要多次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readline()<br></code></pre></td></tr></table></figure><blockquote><p>读取文件有指针标记位置，使用 <code>f.seek(0)</code>回拨指针到开头。</p></blockquote><p>循环读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象:<br>...     <span class="hljs-comment"># line是每一行的字符串</span><br><br><span class="hljs-comment"># 方式二</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象.readlines():<br>...     <span class="hljs-comment"># line是每一行的字符串</span><br></code></pre></td></tr></table></figure><p><code>with open</code>：<br>这是一种包含打开、操作、关闭的快捷操作方式，在 <code>with open</code>的语句块中完成文件操作，操作完成后自动关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(...) <span class="hljs-keyword">as</span> 文件对象:<br>文件对象.read()<br>...<br><br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>ls = f.readlines()<br><span class="hljs-built_in">print</span>(ls)<br></code></pre></td></tr></table></figure><h1 id="4-文件写入"><a href="#4-文件写入" class="headerlink" title="4 文件写入"></a>4 文件写入</h1><p>覆盖写入：</p><ul><li>调用 <code>write</code>时内容并未真正写入文件，而是会积攒在程序的内存中，称之为<strong>缓冲区</strong></li><li>当调用 <code>flush</code> 的时候，内容才会真正写入文件</li><li>这样做可以避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写入磁盘）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-comment"># 2、覆盖写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入文件，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure><p>追加写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-comment"># 2、追加写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入目的地，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Python基础语法</title>
    <link href="/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h1><ul><li>单行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br></code></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>Python不区分单双引号，都可以。</p></blockquote><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><p>Python的变量与C++不同，<strong>变量本身没有类型</strong>，但存储的数据本身是有类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;哈哈哈&#x27;</span><br>name = <span class="hljs-number">666</span><br><span class="hljs-built_in">print</span>(name)  <span class="hljs-comment"># name 内的值变成了666</span><br></code></pre></td></tr></table></figure><blockquote><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，例如Java和C++。</p></blockquote><p>Python变量一般不使用驼峰命名法，而是使用<strong>全小写加下划线</strong>。<br>变量命名规则：</p><ol><li>字母、数字、下划线组成</li><li>不能以数字开头</li><li>区分大小写</li><li>不能使用关键字</li></ol><p>Python中可以把任何数据都看成一个“对象”，而变量就是在程序中用来<strong>指向这些数据对象</strong>的，对变量赋值就是把数据和变量给关联起来。</p><p>Python解释器在执行 <code>a = 10</code>赋值时做以下操作：</p><ol><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p><img src="/../../../ai_assets/Pasted%20image%2020250909101046.png"></p><h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250831105835.png"></p><p>可以使用 <code>type()</code>查看变量内存储的是什么类型。</p><p>数据类型转换：</p><ul><li><code>int()</code>转换为整数</li><li><code>float()</code>转换为浮点数</li><li><code>str()</code>转换为字符串</li><li><code>bool</code>转化为布尔</li><li><code>list()</code>转换为列表</li><li>…</li></ul><p>字符处理相关：</p><ul><li><code>ord()</code>获取字符的整数表示</li><li><code>chr()</code>把编码转换为对应的字符</li></ul><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4 运算符"></a>4 运算符</h1><p><strong>算术运算符</strong></p><ul><li><code>+</code> 加法</li><li><code>-</code> 减法</li><li><code>*</code> 乘法</li><li><code>/</code> 除法</li><li><code>//</code> 整除</li><li><code>%</code> 取余</li><li><code>**</code> 乘方</li></ul><p><strong>赋值运算符</strong></p><ul><li><code>=</code> 将右侧结果赋予左侧变量</li></ul><p><strong>复合赋值运算符</strong></p><ul><li><code>a?=b</code> 相当于：<code>a = a?b</code> ，这个 <code>?</code> 可以是任何的算术运算符</li></ul><p><strong>比较运算符</strong></p><ul><li><code>==</code> 相等</li><li><code>!=</code> 不相等</li><li><code>&gt;</code> 大于</li><li><code>&lt;</code> 小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li></ul><p><strong>逻辑运算符</strong></p><ul><li><code>and</code> 全真为真</li><li><code>or</code> 全假为假</li><li><code>not</code> 取反</li></ul><h1 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5 输入输出"></a>5 输入输出</h1><h2 id="5-1-print输出"><a href="#5-1-print输出" class="headerlink" title="5.1 print输出"></a>5.1 print输出</h2><p><code>print()</code> 语句（函数）可以向屏幕内一次性输出多份内容，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以空格分隔，内容可以是：字面量、变量、表达式。</span><br><span class="hljs-built_in">print</span>(内容<span class="hljs-number">1</span>, 内容<span class="hljs-number">2</span>, ... ,..., 内容N)<br><br><span class="hljs-comment"># 默认以回车结束，可以使用end设置</span><br><span class="hljs-built_in">print</span>(内容, end = <span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>格式化输出：</strong><br>两种方法变量的位置都可以填写表达式，Python会先计算再填入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5-2-input输入"><a href="#5-2-input输入" class="headerlink" title="5.2 input输入"></a>5.2 input输入</h2><p><code>input()</code> 可以获取用户的键盘录入数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>()  <span class="hljs-comment"># 从键盘输入内容，赋值给name变量  </span><br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)  <span class="hljs-comment"># 输入前会输出指定的提示</span><br></code></pre></td></tr></table></figure><p>注意：<code>input</code> 输入的内容会自动转换为<strong>字符串</strong>类型，如果需要输入数字类型，要自行转换类型。</p><p><strong>在同一行输入多个内容：</strong><br><code>map()</code> 的作用是：将一个函数应用到可迭代对象（如列表、元组等）的每一个元素上，并返回一个包含所有结果的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原理：input()输入进来是字符串，split()默认按照空格分割，返回一个字符串列表</span><br><span class="hljs-comment"># map将int()函数应用到列表里的每一个元素，返回一个迭代器，可以使用变量分别接收</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>name, pwd = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure><p><strong>一行内输入列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将map返回的迭代器转换为列表</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure><p><strong>连续输入多行数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：逐行读取</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = []  <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>    row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))  <br>    mp.append(row)<br><br><span class="hljs-comment"># 特殊的字符矩阵</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>mp = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())  <span class="hljs-comment"># 将输入的字符串处理空行换行之后转为列表</span><br>mp.append(row)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：列表推导式</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><h1 id="6-分支语句"><a href="#6-分支语句" class="headerlink" title="6 分支语句"></a>6 分支语句</h1><h2 id="6-1-if-elif-else"><a href="#6-1-if-elif-else" class="headerlink" title="6.1 if-elif-else"></a>6.1 if-elif-else</h2><p><code>else if</code> 可以简写为 <code>elif</code>。<br>特殊地，Python不同于C++，<code>a &gt; 1 and a &lt; 100</code>可以简写为 <code>1 &lt; a &lt; 100</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件<span class="hljs-number">1</span>:<br>代码块<span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">2</span>:<br>代码块<span class="hljs-number">2</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">3</span>:<br>代码块<span class="hljs-number">3</span><br><span class="hljs-keyword">else</span>:<br>代码块<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>Python通过缩进区分代码块，缩进需要严格准确。缩进可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，Python对缩进极其依赖，<strong>不要使用制表键（Tab键）来缩进代码</strong>，可以在编辑器中设置Tab为4个空格。</p></blockquote><p>Python中为了简化 <code>if-else</code>结构，也引入了三元运算符，结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">真值结果 <span class="hljs-keyword">if</span> 条件 <span class="hljs-keyword">else</span> 假值结果<br>num = <span class="hljs-number">10</span><br>res = <span class="hljs-string">&#x27;偶数&#x27;</span> <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;奇数&#x27;</span><br><span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 偶数</span><br></code></pre></td></tr></table></figure><h2 id="6-2-match-case"><a href="#6-2-match-case" class="headerlink" title="6.2 match-case"></a>6.2 match-case</h2><p>类似C++的 <code>switch-case</code>，但有所差别，不像C++遇到 <code>break</code>才停止，而是只执行匹配条件的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">alp = <span class="hljs-string">&#x27;a&#x27;</span>  <br>  <br><span class="hljs-keyword">match</span> alp:  <br>    <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= x &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:  <span class="hljs-comment"># 使用条件，并且返回匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;小写字母<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写A&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span> | <span class="hljs-string">&#x27;C&#x27;</span> | <span class="hljs-string">&#x27;D&#x27;</span>:  <span class="hljs-comment"># 多个匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写B C D&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> _:  <span class="hljs-comment"># _ 代表其他情况，类似C++的default</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;其他情况&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="7-循环语句"><a href="#7-循环语句" class="headerlink" title="7 循环语句"></a>7 循环语句</h1><h2 id="7-1-while循环"><a href="#7-1-while循环" class="headerlink" title="7.1 while循环"></a>7.1 while循环</h2><p>与C++不同的是，Python有独特的 <code>循环-else</code>结构：</p><ul><li><code>else</code> 子句只在循环正常完成时执行</li><li>如果循环被 <code>break</code> 中断，<code>else</code> 部分不会执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 条件:<br>代码块<br><span class="hljs-keyword">else</span>:<br>代码块<br></code></pre></td></tr></table></figure><h2 id="7-2-for循环"><a href="#7-2-for循环" class="headerlink" title="7.2 for循环"></a>7.2 for循环</h2><p><code>for</code>循环与C++有所不同，从待处理数据集中，挨个取出内容，将其赋给临时变量，然后执行循环语句，循环往复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 待处理数据集:<br>代码块<br><span class="hljs-keyword">else</span>:<br>代码块<br></code></pre></td></tr></table></figure><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>，上述语法的待处理数据集，本质上应当是：<strong>可迭代对象</strong>，可以使用 <code>isinstance</code>方法判断是否为可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure><p>可迭代对象（类型）：<strong>其内容可以一个个依次取出的一种类型</strong>，包括：</p><ul><li>集合数据类型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>和C++相同，Python可以使用 <code>continue</code>跳过本轮循环，使用 <code>break</code>中断整个循环。</p><blockquote><p>在Python中，变量作用域有些特殊，在for循环的外部访问临时变量，<strong>实际上可以访问到，但在编程规范上不建议这样做。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br><span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>在规范中，Python通过 <code>:</code>和缩进控制作用域，实现C++中 <code>&#123;&#125;</code>的作用。</p></blockquote><hr><p><code>range()</code>可以生成数字序列，生成的数字序列是<strong>可迭代对象</strong>，与列表类似，但不是列表类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成从0开始，到num结束（但不包括num），也就是 [0, num)</span><br><span class="hljs-built_in">range</span>(num) <br><br><span class="hljs-comment"># 从num1开始，到num2结束（不包括num2），为[num1, num2)</span><br><span class="hljs-built_in">range</span>(num1, num2)<br><br><span class="hljs-comment"># 和上一个范围一样，但步长由step决定</span><br><span class="hljs-built_in">range</span>(num1, num2, step)<br></code></pre></td></tr></table></figure><p><code>range()</code>可以和 <code>for</code>循环进行搭配，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br><span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-comment"># 等价于以下C++代码</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>另外Python还可以使用 <code>zip</code>将多个可迭代对象放在一个循环内进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]<br><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(x, y):<br>    <span class="hljs-built_in">print</span>(i, j)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1 10</span><br><span class="hljs-string">2 11</span><br><span class="hljs-string">3 12</span><br><span class="hljs-string">4 13</span><br><span class="hljs-string">5 14</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8 函数"></a>8 函数</h1><h2 id="8-1-语法格式"><a href="#8-1-语法格式" class="headerlink" title="8.1 语法格式"></a>8.1 语法格式</h2><p>参数和返回值可以省略，函数必须先定义再调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">[形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2.</span>..]</span>):<br>函数内容<br>[<span class="hljs-keyword">return</span> 返回值]<br><span class="hljs-comment"># Python PEP8规范：函数定义的前后分别空两行</span><br><br><span class="hljs-comment"># 调用函数</span><br>函数名([实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2.</span>..])<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br><span class="hljs-keyword">return</span> a + b + c<br><br><span class="hljs-built_in">sum</span> = add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 形参和实参一一对应，与C++不同的是，实参的传入类型不受限制。</span><br>add(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在Python中函数可以有多个返回值，并且可以是不同类型，按照返回值顺序，用多个变量接收即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>   <span class="hljs-comment"># 本质是返回了一个元组 (&quot;zhangsan&quot;, 18)</span><br><br>name, age = test()          <span class="hljs-comment"># 等同于 name, age = (&quot;zhangsan&quot;, 18)</span><br></code></pre></td></tr></table></figure><p>Python是动态强类型语言，函数中可以显式声明接收的数据类型，但是没有实际作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 规定num接收int类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(func(<span class="hljs-string">&#x27;哈哈哈&#x27;</span>))  <span class="hljs-comment"># 甚至可以传字符串</span><br></code></pre></td></tr></table></figure><h3 id="8-1-1-位置参数"><a href="#8-1-1-位置参数" class="headerlink" title="8.1.1 位置参数"></a>8.1.1 位置参数</h3><p>就是C++最普通的函数传值方式， 传递的参数和定义的参数<strong>一一对应</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>...<br><br><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 数量一致，顺序一致，一一对应</span><br></code></pre></td></tr></table></figure><h3 id="8-1-2-关键字参数"><a href="#8-1-2-关键字参数" class="headerlink" title="8.1.2 关键字参数"></a>8.1.2 关键字参数</h3><p>通过<strong>键值对形式</strong>显式指明形参的名称，由于会自动匹配，所以可以不按照顺序进行传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>...<br><br><br>func(x=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>, y=<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 和位置参数混用的时候，关键字传参必须在位置参数的后面，否则无法对应</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, z=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="8-1-3-默认参数"><a href="#8-1-3-默认参数" class="headerlink" title="8.1.3 默认参数"></a>8.1.3 默认参数</h3><p>默认参数也叫缺省参数，在定义函数时<strong>提供默认值</strong>，调用该函数时如果不传该参数则使用默认参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意有默认值的参数要在无默认值参数的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name, age=<span class="hljs-number">18</span></span>):<br>...<br><br><br>func(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>func(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：缺省参数必须指向不可变对象！因为可变对象在函数内部可能会被修改，而导致和默认值不同。</p></blockquote><h3 id="8-1-4-不定长参数"><a href="#8-1-4-不定长参数" class="headerlink" title="8.1.4 不定长参数"></a>8.1.4 不定长参数</h3><p>不定长参数也叫可变参数，用于在调用时<strong>参数数量不确定</strong>，可以使用元组接收或字典接收。</p><ul><li>使用元组接收：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以传入元组或列表，但args都接收为元组类型，在函数内不可变</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, *args</span>):<br>...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个元组，接收3, 4, 5, 6</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 已经有现成元组或列表，传入时可以加上 * 变成不定长参数</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, *ls)  <span class="hljs-comment"># x接收1，y接收2，args接收列表内的元素</span><br></code></pre></td></tr></table></figure><ul><li>使用字典接收：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, **kwargs</span>):<br>...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个字典，内部有三个键值对</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 已经有现成字典，传入时可以加上 ** 变成不定长参数</span><br>d = &#123;name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, age: <span class="hljs-number">18</span>&#125;<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, **d)  <span class="hljs-comment"># x接收1，y接收2，kwargs接收字典内的元素</span><br><br><span class="hljs-comment"># kwargs只是d的拷贝，在函数内修改kwargs不会影响d的内容</span><br></code></pre></td></tr></table></figure><h2 id="8-2-None"><a href="#8-2-None" class="headerlink" title="8.2 None"></a>8.2 None</h2><p>在Python中有一个数据类型：<code>NoneType</code> ，它只有一个字面量：<code>None</code>，并且不可变。<br>函数如果没有写 <code>return</code>，则默认返回值是 <code>None</code>，或者也可以显式写 <code>return None</code>。</p><p>作用：</p><ul><li>用在 <code>if</code> 判断中， <code>None</code> 等同于 <code>False</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">score</span>):<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;good&#x27;</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 本行也可以省略</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(<span class="hljs-number">59</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不及格&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>用在变量声明时，暂不需要初始值可以使用 <code>None</code> 代替</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>  age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-comment"># 为了避免作用域问题，age需要在for循环外部定义</span><br><span class="hljs-comment"># for循环外定义的时候，不需要初始值，可以以None代替</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最后一个同学的年龄是：%d &quot;</span> % age)<br></code></pre></td></tr></table></figure><ul><li>用于函数无返回值时</li></ul><h2 id="8-3-函数规范注释"><a href="#8-3-函数规范注释" class="headerlink" title="8.3 函数规范注释"></a>8.3 函数规范注释</h2><p>使用多行注释，在函数体之前为函数进行说明解释，在Pycharm中调用函数时通过鼠标悬停可以显示函数的说明文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    函数说明文本</span><br><span class="hljs-string">    :param 参数1: 参数1的说明</span><br><span class="hljs-string">    :param 参数2: 参数2的说明</span><br><span class="hljs-string">    :return: 返回值的说明</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    函数体<br>    <span class="hljs-keyword">return</span> ...<br></code></pre></td></tr></table></figure><h2 id="8-4-变量作用域"><a href="#8-4-变量作用域" class="headerlink" title="8.4 变量作用域"></a>8.4 变量作用域</h2><p>局部变量：写在函数内部的是局部变量，其作用范围只在函数内部有效。<br>全局变量：写在函数外部的是全局变量，其作用范围在函数内外都生效。</p><p><code>global</code>关键字：可以<strong>在函数内部将局部变量声明为全局变量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():  <br>    <span class="hljs-keyword">global</span> a  <br>    a = <span class="hljs-number">100</span>  <span class="hljs-comment"># 使用global声明后，可以在函数内部修改全局变量</span><br>  <br>  <br>fun()  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出为100</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Python数据容器</title>
    <link href="/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-列表-list"><a href="#1-列表-list" class="headerlink" title="1 列表(list)"></a>1 列表(list)</h1><h2 id="1-1-列表的创建与访问"><a href="#1-1-列表的创建与访问" class="headerlink" title="1.1 列表的创建与访问"></a>1.1 列表的创建与访问</h2><p>列表类似C++的数组，不过列表中的数据可以为<strong>不同的数据类型</strong>，并且可以嵌套，嵌套时类似C++的多维数组。<br>列表定义用 <code>[]</code>包围，以 <code>,</code>分割，正向下标从0开始，有<strong>反向索引</strong>，从-1开始，从后往前，依次递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = []   <span class="hljs-comment"># 空列表</span><br><br>demo_list = [<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;哈哈&#x27;</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>]]<br><span class="hljs-comment"># 正向索引    0      1     2       3 </span><br><span class="hljs-comment"># 反向索引   -4     -3    -2      -1</span><br><br>demo[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 得到 &#x27;哈哈&#x27;</span><br>demo[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 得到 1</span><br></code></pre></td></tr></table></figure><p>列表可以使用 <code>+</code>拼接或使用 <code>*</code>实现重复计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ls1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] * <span class="hljs-number">2</span><br>ls2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-built_in">print</span>(ls1)  <span class="hljs-comment"># [1, 2, 1, 2]</span><br><span class="hljs-built_in">print</span>(ls1 + ls2)  <span class="hljs-comment"># [1, 2, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="1-2-列表生成式"><a href="#1-2-列表生成式" class="headerlink" title="1.2 列表生成式"></a>1.2 列表生成式</h2><p>列表生成式的效率很高，<strong>强烈建议使用列表生成式来创建列表</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h2 id="1-3-列表的遍历"><a href="#1-3-列表的遍历" class="headerlink" title="1.3 列表的遍历"></a>1.3 列表的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># while方式</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(my_list):<br><span class="hljs-built_in">print</span>(my_list[i])<br>i++<br><br><span class="hljs-comment"># for方式</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250904170517.png"></p><h1 id="2-元组-tuple"><a href="#2-元组-tuple" class="headerlink" title="2 元组(tuple)"></a>2 元组(tuple)</h1><h2 id="2-1-元组的创建与访问"><a href="#2-1-元组的创建与访问" class="headerlink" title="2.1 元组的创建与访问"></a>2.1 元组的创建与访问</h2><p>元组与列表类似，不同之处在于元组的元素<strong>不能修改</strong>，元组使用 <code>()</code>，列表使用 <code>[]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = ()    <span class="hljs-comment"># 空元组</span><br><br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 元组内只有一个元素时，需要有逗号在内，否则小括号会识别为运算符</span><br>nums = (<span class="hljs-number">1</span>,)  √<br>nums = (<span class="hljs-number">1</span>)   ×<br><br><span class="hljs-comment"># 元组的访问和列表完全一样，通过下标访问，支持反向下标</span><br>nums[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-2-元组的“可变”"><a href="#2-2-元组的“可变”" class="headerlink" title="2.2 元组的“可变”"></a>2.2 元组的“可变”</h2><p>元组内有 <code>list</code>的时候，元组依然遵循元素不可变，但 <code>list</code>内的元素可以修改。这是因为元组存储的时候本质上存的是 <code>list</code>的地址，只要地址不变，元组元素就没有修改，而所指内容是否变化和元组无关。正因为如此，替换为别的 <code>list</code>也是不被允许的，因为地址发生了改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, 地址)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250909114917.png"></p><h2 id="2-3-打包和解包"><a href="#2-3-打包和解包" class="headerlink" title="2.3 打包和解包"></a>2.3 打包和解包</h2><p>当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打包操作</span><br>a = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 解包操作</span><br>i, j, k = a<br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 10 100</span><br></code></pre></td></tr></table></figure><blockquote><p>解包操作对所有序列的成立，包括列表、元组、字符串、<code>range</code>都可以使用解包操作。</p></blockquote><p>解包时元素个数和变量个数不匹配会引发 <code>ValueError</code>异常，不过我们可以使用星号表达式解决变量少于元素个数的情况，让一个变量接收多个值。</p><ol><li>星号修饰的变量会变成一个列表，可以存放0个或多个元素</li><li>解包语法中，只能有一个型号表达式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  <br><br><span class="hljs-comment"># 可以改变型号表达式的位置，会自动匹配</span><br>i, j, *k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 2 [3, 4, 5, 6]</span><br>  <br>*i, j, k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># [1, 2, 3, 4] 5 6</span><br></code></pre></td></tr></table></figure><blockquote><p><code>a, b = b, a</code>和 <code>a, b, c = b, c, a</code>实际并没有用到打包解包语法，而是有特定的字节码指令实现这两个操作，效率非常高，在三个以上的变量交换时需要使用打包解包。</p></blockquote><h2 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250831194646.png"></p><h1 id="3-字符串-str"><a href="#3-字符串-str" class="headerlink" title="3 字符串(str)"></a>3 字符串(str)</h1><h2 id="3-1-字符串的创建和访问"><a href="#3-1-字符串的创建和访问" class="headerlink" title="3.1 字符串的创建和访问"></a>3.1 字符串的创建和访问</h2><p>字符串同列表、元组一样，可以通过下标和反向下标进行访问。不过和C++非常不同的一点是，字符串是<strong>无法修改</strong>的容器。也就是说如果要完成修改操作，只能得到一个新的字符串，旧的字符串是无法修改的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字符串可以使用单引号、双引号、三引号进行定义，使用三引号时可以跨行。</span><br><br>s = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment"># 空字符串</span><br><br>s = <span class="hljs-string">&#x27;hhh&#x27;</span><br>s = <span class="hljs-string">&quot;hhh&quot;</span><br>s = <span class="hljs-string">&quot;&quot;&quot;hhh</span><br><span class="hljs-string">hhhh</span><br><span class="hljs-string">hh</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 单引号里面可以包双引号，双引号里面可以包单引号</span><br>s = <span class="hljs-string">&quot;人工&#x27;智&#x27;能&quot;</span><br>s = <span class="hljs-string">&#x27;人工&quot;智&quot;能&#x27;</span><br><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><ul><li>字符串内部使用 <code>\</code>进行转义，比如 <code>\n</code>换行、<code>\t</code>缩进，又或者转义 <code>\ &#39; &quot;</code>这些特殊字符</li><li>Python中以 <code>r</code>或 <code>R</code>开头的字符串叫做原始字符串，字符串内都是本来的含义，没有所谓转义字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 很多字符需要转义需要很多\，可以使用r&#x27;&#x27;或R&#x27;&#x27;表示内部字符串默认不转义</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)  <span class="hljs-comment"># \\</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>) <span class="hljs-comment"># \\\t\\</span><br></code></pre></td></tr></table></figure><h2 id="3-2-字符串的运算"><a href="#3-2-字符串的运算" class="headerlink" title="3.2 字符串的运算"></a>3.2 字符串的运算</h2><ul><li>字符串比较时按照字典序从前往后，只要其中一位大，后面就不用比较了</li><li>可以使用 <code>+</code>进行拼接，还可以使用 <code>*</code>将字符串重复</li></ul><h2 id="3-3-字符串的格式化"><a href="#3-3-字符串的格式化" class="headerlink" title="3.3 字符串的格式化"></a>3.3 字符串的格式化</h2><p>两种方法变量的位置都可以填写表达式，Python会先计算再填入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-4-常用方法"><a href="#3-4-常用方法" class="headerlink" title="3.4 常用方法"></a>3.4 常用方法</h2><p>由于字符串<strong>不可变</strong>，所以使用字符串的方法并不会改变原来的字符串，而是产生新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 转大写</span><br>su = s.upper()<br><br><span class="hljs-comment"># 转小写</span><br>sl = s.lower()<br><br><span class="hljs-comment"># replace用法，生成新的字符串，原字符串不变</span><br>s = <span class="hljs-string">&quot;Python好玩真好玩&quot;</span><br>new_s = s.replace(<span class="hljs-string">&quot;好玩&quot;</span>, <span class="hljs-string">&quot;有趣&quot;</span>)<br><span class="hljs-built_in">print</span>(s)      <span class="hljs-comment"># 结果还是  Python好玩真好玩</span><br><span class="hljs-built_in">print</span>(new_s)  <span class="hljs-comment"># 修改后的  Python有趣真有趣</span><br><br><span class="hljs-comment"># split用法，原字符串不变，生成一个新列表</span><br>name = <span class="hljs-string">&quot;Python-Java-C++&quot;</span><br>name_list = name.split(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-built_in">print</span>(name)        <span class="hljs-comment"># Python-Java-C++</span><br><span class="hljs-built_in">print</span>(name_list)   <span class="hljs-comment"># [&#x27;Python&#x27;, &#x27;Java&#x27;, &#x27;C++&#x27;]</span><br><br><span class="hljs-comment"># strip用法，去除前后指定字符串</span><br>demo = <span class="hljs-string">&quot;   hhhh  &quot;</span><br>new1 = demo.strip()       <span class="hljs-comment"># 默认去除前后空格和换行符</span><br>demo = <span class="hljs-string">&quot;1211哈哈哈21121&quot;</span><br>new2 = demo.strip(<span class="hljs-string">&quot;12&quot;</span>)   <span class="hljs-comment"># 按照单个字符，&#x27;1&#x27;和&#x27;2&#x27;都会删除</span><br><span class="hljs-built_in">print</span>(new2)    <span class="hljs-comment"># 哈哈哈</span><br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250831200302.png"></p><h1 id="4-序列的切片"><a href="#4-序列的切片" class="headerlink" title="4 序列的切片"></a>4 序列的切片</h1><p>序列是指：<strong>内容连续、有序，可使用下标索引</strong>的一类数据容器。<br>上述的列表、元组、字符串都是序列。序列支持切片操作，切片就是从原序列中取出一个子序列。</p><p>语法：<code>序列[起始下标:结束下标:步长]</code>（类似 <code>range</code>序列，<code>[起始,结束)</code>范围内指定步长）<br>表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。</p><ul><li>起始下标表示从何处开始，可以留空，留空视作从头开始</li><li>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾</li><li>步长表示依次取元素的间隔（可以为负，反向走，起始下标也要在结束下标右边）</li></ul><p><strong>注意，此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</strong></p><h1 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5 字典(dict)"></a>5 字典(dict)</h1><h2 id="5-1-字典的创建和访问"><a href="#5-1-字典的创建和访问" class="headerlink" title="5.1 字典的创建和访问"></a>5.1 字典的创建和访问</h2><p>字典使用 <code>&#123;&#125;</code>包围，存储的元素是<strong>键值对</strong> <code>key:value</code>，并且 <code>key</code>不可重复，重复会覆盖原有数据。</p><ul><li><code>key</code> 数据类型<strong>必须为不可变类型</strong>，不可为字典、列表，一般类型用：字符串、整数</li><li><code>value</code> 数据类型随意，不限制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;&#125;      <span class="hljs-comment"># 空字典</span><br>d = <span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># 空字典</span><br><br>d = &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&quot;lisi&quot;</span>:<span class="hljs-number">59</span>&#125;<br><br><span class="hljs-comment"># 集合不可用下标进行访问，但可以使用key来取得对应的value</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&quot;zhangsan&quot;</span>])  <span class="hljs-comment"># 结果为100</span><br></code></pre></td></tr></table></figure><p>字典访问到不存在的 <code>key</code>会报错，可以使用 <code>in</code>或 <code>字典.get(键, 返回值)</code>来检验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 in 检验</span><br>d = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span> <span class="hljs-keyword">in</span> d:  <span class="hljs-comment"># 相反还有 not in</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在字典&#x27;</span>)<br><br><span class="hljs-comment"># 使用 字典.get(键, 返回值) 方法</span><br><span class="hljs-comment"># 键存在则返回值，键不存在默认返回 None，也可以指定返回值</span><br><span class="hljs-keyword">if</span> d.get(<span class="hljs-string">&#x27;lisi&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># d.get(&#x27;lisi&#x27;, 1) == 1 作用一样  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不在字典&#x27;</span>)<br><br><span class="hljs-comment"># 可以用get()很方便地统计出现次数</span><br>s = <span class="hljs-built_in">input</span>()  <br>counter = &#123;&#125;  <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:  <br>    <span class="hljs-keyword">if</span> c.isalpha():  <br>        counter[c] = counter.get(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 存在返回已有值，不存在返回0</span><br></code></pre></td></tr></table></figure><blockquote><p>字典通过哈希算法计算 <code>key</code>的位置，所以字典的<strong>查找和插入操作极快</strong>。由于要保证hash的正确性，作为 <code>key</code>的对象就不能变。在Python中，字符串和整数都不可变，可以放心用作 <code>key</code>，<code>list</code>可变不能作为 <code>key</code>。</p></blockquote><h2 id="5-2-字典的遍历"><a href="#5-2-字典的遍历" class="headerlink" title="5.2 字典的遍历"></a>5.2 字典的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代字典的键</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d.keys():  <span class="hljs-comment"># 等同于 for i in d:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;k&#125;</span> 分数：<span class="hljs-subst">&#123;d[k]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 迭代字典的值</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> d.values():<br><span class="hljs-built_in">print</span>(v)<br><br><span class="hljs-comment"># 迭代字典的键值对</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>: <span class="hljs-subst">&#123;v&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-3-常用方法"><a href="#5-3-常用方法" class="headerlink" title="5.3 常用方法"></a>5.3 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250901085204.png"></p><h1 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6 集合(set)"></a>6 集合(set)</h1><h2 id="6-1-集合的创建"><a href="#6-1-集合的创建" class="headerlink" title="6.1 集合的创建"></a>6.1 集合的创建</h2><p><code>set</code>和 <code>dict</code>类似也是一组 <code>key</code>的集合，但不存储 <code>value</code>，由于 <code>key</code>不能重复，所以在 <code>set</code>中没有重复的 <code>key</code>。集合内部是<strong>去重并且无序</strong>的，使用 <code>&#123;&#125;</code>包围。因为无序，所以集合不可用下标进行访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 空集合，s = &#123;&#125; 不是空集合，而是空字典</span><br><br>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <br></code></pre></td></tr></table></figure><p><code>set</code>和 <code>dict</code>底层原理一样，唯一的区别仅仅在于没有存储 <code>value</code>，<code>key</code>是唯一的保证了 <code>set</code>内部不会有重复元素，由于无法判断两个可变对象是否相等，所以<strong>不能存放可变对象</strong>。</p><blockquote><p>注意与C++非常不同的是，<strong>集合不会自动排序</strong>，<code>dict</code> 和 <code>set</code> 的底层哈希表会让它看起来好像有顺序，但这不是排序，只是哈希存储的结果，顺序不稳定）</p></blockquote><h2 id="6-2-集合的运算"><a href="#6-2-集合的运算" class="headerlink" title="6.2 集合的运算"></a>6.2 集合的运算</h2><p><code>set</code>之间有很方便的取交集 <code>&amp;</code>和取并集 <code>|</code>运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>s2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-built_in">print</span>(s1 &amp; s2)  <span class="hljs-comment"># 交集 &#123;1, 2&#125;</span><br><span class="hljs-built_in">print</span>(s1 | s2)  <span class="hljs-comment"># 并集 &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-3-集合的遍历"><a href="#6-3-集合的遍历" class="headerlink" title="6.3 集合的遍历"></a>6.3 集合的遍历</h2><p>由于集合不支持下标访问，所以不能使用 <code>while</code>循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="6-4-常用操作"><a href="#6-4-常用操作" class="headerlink" title="6.4 常用操作"></a>6.4 常用操作</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250901084030.png"></p><h1 id="7-容器对比"><a href="#7-容器对比" class="headerlink" title="7 容器对比"></a>7 容器对比</h1><p>列表、元组字符串为序列类型，集合、字典为非序列类型。</p><ul><li>是否支持下标索引<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否支持重复元素：<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否可以修改<ul><li>支持：列表、集合、字典</li><li>不支持：元组、字符串</li></ul></li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250901090126.png"></p><h1 id="8-容器通用操作"><a href="#8-容器通用操作" class="headerlink" title="8 容器通用操作"></a>8 容器通用操作</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250901090833.png"></p><ul><li><code>sorted</code>：接收任意可迭代对象（<code>list、tuple、set、dict、str</code>等），返回一个<strong>新的列表</strong>（不修改原对象）。</li><li><code>.sort()</code>：<code>list</code>专属方法，<strong>直接在原列表上排序</strong>，不会返回新列表（返回 <code>None</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>tp_ls = <span class="hljs-built_in">sorted</span>(tp)  <span class="hljs-comment"># 返回值为列表</span><br><br>ls = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br>ls.sort()  <span class="hljs-comment"># 直接对ls本身进行排序</span><br></code></pre></td></tr></table></figure><p><code>sorted</code>有类似C++中的 <code>cmp</code>函数，可以自定义排序规则，并且支持 <code>lambda</code>匿名函数，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以第一个元素作为依据进行排序</span><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br>ls = <span class="hljs-built_in">sorted</span>(ls)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># x 是需要排序容器的一个元素，sorted 会把每个元素传入自定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">x</span>):<br><span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 自定义排序规则</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=cmp)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;bob&#x27;, 70), (&#x27;alice&#x27;, 80), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># lambda函数＋逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;carl&#x27;, 100), (&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70)]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
