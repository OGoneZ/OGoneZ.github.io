<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>概率论常见术语</title>
    <link href="/2024/07/26/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/00%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/"/>
    <url>/2024/07/26/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/00%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><p>概率（Probability）<br />概率是指某个事件发生的可能性，通常用0到1之间的数字来表示：</p><ul><li>0 表示事件不可能发生</li><li>1 表示事件必然发生</li></ul></li><li><p>条件概率（Conditional Probability）<br />条件概率是指在知道事件 <span class="math inline"><em>A</em></span>已经发生的情况下，另一个事件 <span class="math inline"><em>B</em></span>发生的概率，记作 <spanclass="math inline"><em>P</em>(<em>B</em>|<em>A</em>)</span>。它的计算公式为：<br /><span class="math display">$$ P(B|A) = \frac{P(A \cap B)}{P(A)}$$</span><br />其中，<spanclass="math inline"><em>P</em>(<em>A</em> ∩ <em>B</em>)</span> 是事件<span class="math inline"><em>A</em></span> 和 <spanclass="math inline"><em>B</em></span> 同时发生的概率。</p></li><li><p>联合概率（Joint Probability）<br />联合概率是指事件 <span class="math inline"><em>A</em></span> 和事件<span class="math inline"><em>B</em></span> 同时发生的概率，记作 <spanclass="math inline"><em>P</em>(<em>A</em>, <em>B</em>)</span> 或 <spanclass="math inline"><em>P</em>(<em>A</em> ∩ <em>B</em>)</span>。</p></li><li><p>全概率（Total Probability）<br />全概率用于计算多个互斥事件下某个事件的总概率。例如，已知事件 <spanclass="math inline"><em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, …, <em>A</em><sub><em>n</em></sub></span>是一组互斥且完备的事件，那么事件 <spanclass="math inline"><em>B</em></span> 的全概率为：<br /><span class="math display">$$ P(B) = \sum_{i=1}^{n} P(B|A_i) \cdotP(A_i) $$</span></p></li><li><p>贝叶斯定理（Bayes’ Theorem）<br />贝叶斯定理是一个重要的公式，用于计算后验概率。其表述为：<br /><span class="math display">$$ P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}$$</span><br />这里：</p><ul><li><span class="math inline"><em>P</em>(<em>A</em>|<em>B</em>)</span>是在事件 <span class="math inline"><em>B</em></span>已发生的情况下，事件 <span class="math inline"><em>A</em></span>发生的后验概率。</li><li><span class="math inline"><em>P</em>(<em>B</em>|<em>A</em>)</span>是在事件 <span class="math inline"><em>A</em></span> 发生的情况下，事件<span class="math inline"><em>B</em></span> 发生的条件概率。</li><li><span class="math inline"><em>P</em>(<em>A</em>)</span> 是事件 <spanclass="math inline"><em>A</em></span> 的先验概率。</li><li><span class="math inline"><em>P</em>(<em>B</em>)</span> 是事件 <spanclass="math inline"><em>B</em></span> 的总概率。</li></ul></li><li><p>先验概率（Prior Probability）<br />先验概率是指在获得任何新信息之前对一个事件发生的概率的估计，记作 <spanclass="math inline"><em>P</em>(<em>A</em>)</span>。</p></li><li><p>后验概率（Posterior Probability）<br />后验概率是指在获得新信息（比如事件 <spanclass="math inline"><em>B</em></span>发生）后，对一个事件发生的概率的更新，记作 <spanclass="math inline"><em>P</em>(<em>A</em>|<em>B</em>)</span>。</p></li><li><p>似然（Likelihood）<br />似然通常指在给定模型参数的情况下，观察到数据的概率。在贝叶斯分类器中，似然反映了特征数据在给定类别下的分布。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学文章汇总</title>
    <link href="/2024/07/26/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/00%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
    <url>/2024/07/26/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/00%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术（上）</a></p><p><ahref="https://zhuanlan.zhihu.com/p/24863977">矩阵求导术（下）</a></p><p><ahref="https://zhuanlan.zhihu.com/p/595273755">统计思维：解读数据</a></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_感知机</title>
    <link href="/2024/07/25/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2024/07/25/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>感知机（Perceptron）是二分类模型， 接收多个信号，输出一个信号。感知机的信号只有 0、1 两种取值。 <img src="10_perceptron.png" /></p><p><span class="math inline"><em>𝑥</em><sub>1</sub></span>、<spanclass="math inline"><em>𝑥</em><sub>2</sub></span> 是输入信号，<spanclass="math inline"><em>𝑦</em></span> 是输出信号，<spanclass="math inline"><em>𝑤</em><sub>1</sub></span>、<spanclass="math inline"><em>𝑤</em><sub>2</sub></span> 是权重，<spanclass="math inline">○</span>称为神经元或节点。只有当输入信号和权重计算之后超过阈值 <spanclass="math inline"><em>θ</em></span> 时才会输出1，也称之为神经元被激活。 <span class="math display">$$y=\begin{cases}0 &amp; (w_1x_1+w_2x_2\leq\theta) \\1 &amp; (w_1x_1+w_2x_2&gt;\theta) &amp;\end{cases}$$</span></p><h1 id="简单逻辑电路">2 简单逻辑电路</h1><h2 id="与门and-gate">2.1 与门(AND gate)</h2><p>使用感知机实现简单逻辑电路，满足条件的参数有无数个，如 <spanclass="math inline">(<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, <em>θ</em>) = (0.5, 0.5, 0.7)</span>。<span class="math display">$$\begin{array}{|cc|c|}\hlinex_{1} &amp; x_{2} &amp; y \\\hline0 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 1 \\\hline\end{array}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">AND</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="与非门nand-gate">2.2 与非门(NAND gate)</h2><p>与非门颠倒了与门的输出，满足条件的参数也有无数个，只要把与门的参数值取反即可，比如<spanclass="math inline">(<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, <em>θ</em>) = (−0.5, −0.5, −0.7)</span>。<span class="math display">$$\begin{array}{|cc|c|}\hlinex_{1} &amp; x_{2} &amp; y \\\hline0 &amp; 0 &amp; 1 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 \\\hline\end{array}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">NAND</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="或门or-gate">2.3 或门(OR gate)</h2><p>实现或门的参数也有无数种，比如 <spanclass="math inline">(<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, <em>θ</em>) = (0.5, 0.5, 0.4)</span>。<span class="math display">$$\begin{array}{|cc|c|}\hlinex_{1} &amp; x_{2} &amp; y \\\hline0 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1 \\\hline\end{array}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">OR</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.4</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="扩展形式">2.4 扩展形式</h2><p>考虑到以后的事情，这里将 <span class="math inline"><em>θ</em></span>改为 <span class="math inline">−<em>b</em></span>，其中 <spanclass="math inline"><em>𝑏</em></span> 为偏置，<spanclass="math inline"><em>𝑤</em>1</span>,<spanclass="math inline"><em>𝑤</em>2</span>为权重。权重控制输入信号的重要性，偏置调整神经元被激活的容易程度。<span class="math display">$$y=\begin{cases}0 &amp; (b+w_1x_1+w_2x_2\leq0) \\1 &amp; (b+w_1x_1+w_2x_2&gt;0) &amp;\end{cases}$$</span></p><p>再来使用这种形式实现一个与门： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AND</span>(<span class="hljs-params">x1, x2</span>):<br>    x = np.array([x1, x2])<br>    w = np.array([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>    b = -<span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>(w * x) + b &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p><h1 id="多层感知机">3 多层感知机</h1><p>感知机的局限性在于它只能表示由一条直线划分的空间，使用之前的简单感知机，无法实现异或门（XORgate）。 <span class="math display">$$\begin{array}{|cc|c|}\hlinex_{1} &amp; x_{2} &amp; y \\\hline0 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 \\\hline\end{array}$$</span></p><p>无法使用一条直线将 0 和 1 分开。 <img src="10_split01.png" /></p><p>可以考虑使用与门、与非门、或门组合来构成异或门。 <spanclass="math display">$$\begin{array}{|cc|cc|c|}\hlinex_{1} &amp; x_{2} &amp; s_{1} &amp; s_{2} &amp; y \\\hline0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\\hline\end{array}$$</span></p><p><img src="10_XOR.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">XOR</span>(<span class="hljs-params">x1, x2</span>):<br>    s1 = NAND(x1, x2)<br>    s2 = OR(x1, x2)<br>    <span class="hljs-keyword">return</span> AND(s1, s2)<br></code></pre></td></tr></table></figure><p>使用感知机的表示方法来表示这个异或门。 <imgsrc="10_multi_preceptron.png" /></p><p>这就是多层感知机结构，第 0层的两个神经元接收输入信号，并将信号发送给第 1 层的神经元。 第 1层的神经元将信号发送给第 2 层的神经元。第 2层的神经元输出结果。通过叠加层，感知机能进行更加灵活的表示。</p><p>这就是神经网络的基础。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>感知机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_K-means聚类</title>
    <link href="/2024/07/23/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09_K-means%E8%81%9A%E7%B1%BB/09_K-means%E8%81%9A%E7%B1%BB/"/>
    <url>/2024/07/23/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09_K-means%E8%81%9A%E7%B1%BB/09_K-means%E8%81%9A%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>聚类是一种<strong>无监督学习</strong>，不需要预先定义的标签，只是根据数据特征去学习，通过度量特相似度或者距离，然后把已知的数据集划分成若干个不同的类别。与分类不同，聚类任务的标是发现数据内在的结构。</p><p>聚类分为两类：</p><ul><li>硬聚类：每个数据点仅属于一个聚类</li><li>软聚类：每个数据点被赋予属于每个已识别聚类的概率</li></ul><p>聚类算法大体上可以分为：</p><ul><li>基于质心的聚类</li><li>基于密度的聚类</li><li>层次聚类</li><li>谱聚类</li></ul><h1 id="算法流程">2 算法流程</h1><p>K-Means是一种基于质心迭代的聚类算法，根据质心之间的距离将数据集划分为 K个相似的簇，并使每个簇内的数据点尽可能相似。</p><p>K-Means 实现步骤：</p><ol type="1"><li>初始化 K 个 质心：使用随机选择或初始质心采样方法</li><li>分配质心：将每个样本分配到距离最近的质心</li><li>更新质心：计算每个簇所有样本的均值，作为新的质心</li><li>重复2、3步骤，直到质心位置收敛或达到最大迭代次数</li></ol><p><ahref="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">聚类可视化</a></p><h1 id="api-实现">3 API 实现</h1><p>使用 <code>make_blobs</code> 生成数据。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<br><br>X, y = make_blobs(<br>    n_samples=<span class="hljs-number">1000</span>,  <span class="hljs-comment"># 样本数</span><br>    n_features=<span class="hljs-number">2</span>,  <span class="hljs-comment"># 特征数</span><br>    centers=[[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]],  <span class="hljs-comment"># 中心点</span><br>    cluster_std=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>]  <span class="hljs-comment"># 数据标准差</span><br>)<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<br><br>model = KMeans()<br>model.fit(X)<br><br><span class="hljs-comment"># 模型的预测值为簇的编号，并不是分类标签</span><br>ret = model.predict(X) <br><span class="hljs-comment"># 可以将训练和预测合为一步 model.fit_predict(X)</span><br><br><span class="hljs-comment"># 也可以直接使用 labels_ 查看 X 的聚类结果</span><br>model.labels_<br></code></pre></td></tr></table></figure><ul><li><code>n_clusters</code>：指定聚类的簇数，即 <spanclass="math inline">$\small{K}$</span> 值，默认值为<code>8</code>。</li><li><code>max_iter</code>：最大迭代次数，默认值为<code>300</code>，控制每次初始化中 K-Means 迭代的最大步数。</li><li><code>init</code>：初始化质心的方法，默认值为<code>'k-means++'</code>，表示从数据中多次随机选取 K个质心，每次都计算这一次选中的中心点之间的距离，然后取距离最大的一组作为初始化中心点，推荐使用这个值；如果设置为<code>'random'</code>则随机选择初始质心。</li><li><code>n_init</code>：和上面的参数配合，指定算法运行的初始化次数，默认值为<code>10</code>。</li><li><code>algorithm</code>：K-Means 的计算算法，默认值为<code>'lloyd'</code>。还有一个可选的值为<code>'elkan'</code>，表示基于三角不等式的优化算法，适用于 K值较大的情况，计算效率较高。</li><li><code>tol</code>：容忍度，控制算法的收敛精度，默认值为<code>1e-4</code>。如果数据集较大时，可适当增大此值以加快收敛速度。</li></ul><p>可视化聚类结果： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], c=model.labels_)<br></code></pre></td></tr></table></figure> <img src="09_kmeans.png" /></p><h1 id="模型评估">4 模型评估</h1><h2 id="簇内平方和wcss">4.1 簇内平方和(WCSS)</h2><p>簇内平方和（Within-cluster Sum of Squares, WSS）和误差平方和（Sum ofSquaredErrors，SSE）是同一概念的不同叫法。衡量每个<strong>簇内样本点到簇中心的距离的平方和</strong>，WCSS越小，聚类效果越好。 <spanclass="math display">$$WCSS=\sum_{i=1}^\mathrm{k}\sum_{p\inC_i}\left|p-m_i\right|^2$$</span> <spanclass="math inline"><em>C</em><sub><em>i</em></sub></span> 表示簇，<spanclass="math inline"><em>k</em></span> 表示聚类中心的个数，<spanclass="math inline"><em>p</em></span> 表示某个簇内的样本，<spanclass="math inline"><em>m</em></span> 表示质心点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以直接查看 WCSS 参数</span><br>model.inertia_<br></code></pre></td></tr></table></figure><p><img src="09_sse.png" /></p><p>肘部法：下降率突然变缓时即认为是最佳 n_clusters 值。 <imgsrc="09_elbow.png" /></p><h2 id="sc-轮廓系数">4.2 SC 轮廓系数</h2><p>轮廓系数（轮廓系数 (SilhouetteCoefficient）衡量每个样本与其<strong>所在簇的的内聚程度(Cohesion)</strong>，以及与<strong>其他簇的分离程度(Separation)</strong>。轮廓系数范围为<code>[-1, 1]</code>，值越高聚类效果越好。<spanclass="math display">$$SC_i=\frac{b_i-a_i}{\max(a_i,b_i)}$$</span></p><ul><li><span class="math inline"><em>b</em><sub><em>i</em></sub></span>为第 <span class="math inline"><em>i</em></span>个样本到最近簇所有样本的平均距离</li><li><span class="math inline"><em>a</em><sub><em>i</em></sub></span>为第 <span class="math inline"><em>i</em></span>个样本到同簇其他样本的平均距离</li><li>除掉 <spanclass="math inline">max (<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>i</em></sub>)</span>体现了规范化(normalization)的思想，将两者的差缩放到可比较的范围</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> silhouette_score<br><br>silhouette_score(X, model.labels_)<br></code></pre></td></tr></table></figure><p><img src="09_sc.png" /></p><h2 id="ch-指数">4.3 CH 指数</h2><p>CH 指数（Calinski-HarabaszIndex）衡量簇间方差与簇内方差的比值，考虑簇内的内聚程度、簇外的离散程度、质心的个数。CH指数越大聚类效果越好。 <span class="math display">$$\begin{aligned}&amp; \mathrm{CH}(\mathrm{k})=\frac{SSB}{SSW}·\frac{m-k}{k-1} \\&amp; SSW=\sum_{i=1}^m\left\|x_i-C_{pi}\right\|^2 \\&amp; SSB=\sum_{j=1}^kn_j\left\|C_j-\bar{X}\right\|^2\end{aligned}$$</span></p><ul><li><spanclass="math inline"><em>S</em><em>S</em><em>W</em></span>：相当于WCSS，簇内每个样本点到质心的距离平方和，衡量簇内距离</li><li><spanclass="math inline"><em>S</em><em>S</em><em>B</em></span>：质心到质心均值的距离平方和，衡量簇间距离</li><li> <span class="math inline"><em>m</em></span> 代表总样本数，<spanclass="math inline"><em>k</em></span> 代表簇的数量，<spanclass="math inline">$\frac{m-k}{k-1}$</span>可以看作是一个正则化项，使得在考虑簇之间的分离时，也要考虑到簇的数量以及每个簇的样本量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> calinski_harabasz_score<br><br>calinski_harabasz_score(X, model.labels_)<br></code></pre></td></tr></table></figure><p><img src="09_ch.png" /></p><h1 id="算法优缺点">5 算法优缺点</h1><p>K-Means 是一种经典的聚类算法</p><ul><li>优点：实现简单，算法收敛速度快</li><li>缺点：结果不稳定（跟初始值设定有关），无法解决样本不均衡的问题，容易收敛到局部最优解，受噪声数据影响较大</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>K-means</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_集成学习</title>
    <link href="/2024/07/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>集成学习（EnsembleLearning）并不是一种具体的算法，而是一种思想：<strong>将多个单模型组合成一个综合模型</strong>，从而克服单一模型可能存在的局限性，提高准确性和稳定性，获得比单一模型更好的泛化能力。</p><h2 id="术语说明">1.1 术语说明</h2><p>基学习器 (base learner)、基模型(base model)、基估计器 (baseestimator)，指的是集成学习中的单个模型。 进一步将基学习器分为弱学习器(weak learner)和强学习器(strong learner)，弱学习器是表现略优于随机猜测的学习器。对于二元分类问题，弱分类器定义为准确率约为50%的分类器；强学习器则是实现了出色的预测性能，在二元分类问题中准确率大于等于80%。</p><blockquote><p>注意：很多资料将基学习器和弱学习器混为一谈，因为集成学习（尤其是串行方法）可以有效地将弱学习器提升为强学习器。</p></blockquote><h2 id="why-集成学习">1.2 Why 集成学习</h2><h3 id="偏差-方差均衡">1.2.1 偏差-方差均衡</h3><p>为了减少测试误差而增加训练误差的做法被称为<strong>偏差-方差权衡</strong>，也是许多正则化技术背后的驱动原则。</p><ul><li><strong>偏差（Bias）</strong>衡量的是预测值与真实值之间的平均差异。偏差越大，模型在训练集上的预测准确率就越低。高偏差是指训练过程中的误差较大，优化意味着尝试降低偏差。</li><li><strong>方差（Variance）</strong>衡量的是给定模型在不同实现之间的预测差异。方差越大，模型对未知数据的预测准确率越低。高方差是指测试和验证过程中的误差较大，泛化是指试图降低方差。</li></ul><p>偏差和方差分别反向代表了模型在训练集和测试集上的准确率，我们希望同时降低模型偏差和方差，但同时降低两者并不总是可行的，因此需要进行正则化。正则化会降低模型方差，但代价是增加偏差。</p><p>模型总误差由偏差、方差和数据集随机性导致的不可约误差构成： <spanclass="math display"><em>E</em><em>r</em><em>r</em><em>o</em><em>r</em> = <em>B</em><em>i</em><em>a</em><em>s</em><sup>2</sup> + <em>V</em><em>a</em><em>r</em><em>i</em><em>a</em><em>n</em><em>c</em><em>e</em> + <em>I</em><em>r</em><em>r</em><em>e</em><em>d</em><em>u</em><em>c</em><em>i</em><em>b</em><em>l</em><em>e</em> <em>E</em><em>r</em><em>r</em><em>o</em><em>r</em></span></p><h3 id="多模型优势">1.2.1 多模型优势</h3><p>任何一种模型都包含众多变量，例如训练数据、超参数等，这些变量会影响最终模型的总误差。因此，即使是单一训练算法也可能产生不同的模型，每个模型都有各自的偏差、方差和不可约误差。通过组合多个不同的模型，集成算法可以降低总体误差，保留每个模型自身的复杂性和优势，例如对特定数据子集的低偏差。</p><p>一般来说，组合模型之间的<strong>多样性越大</strong>，最终的集成模型就越准确。由多种欠正则化模型，即与训练数据过拟合的模型，组成的集成模型性能优于单一正则化模型（集成森林中的决策树不需要剪枝）。集成学习还可以帮助解决高维数据引发的问题，有效替代降维方法。</p><h1 id="算法分类">2 算法分类</h1><p>集成学习主要分为并行和串行两种方法：</p><ul><li>并行方法会将每个基学习器与其他基学习器分开单独训练</li><li>串行方法训练一个新的基础学习器，使其能够最小化前一步训练的模型所犯的错误</li></ul><p><img src="08_parallel_sequential.png" /></p><p>并行方法进一步分为同质学习器和异质学习器，而串行方法通常使用同质学习器。</p><ul><li>同质（Homogeneous）：使用相同的基础学习算法来生成基学习器</li><li>异质（Heterogeneous）：使用不同的基础学习算法来生成基学习器</li></ul><p>目前最流行的三种集成学习技术是 Bagging、Boosting 和 Stacking。</p><h2 id="bagging">2.1 Bagging</h2><p>Bagging（BootstrapAggregating，自助聚合）通过自助采样（bootstrap）构建多个基学习器，然后将这些基学习器的预测结果进行组合（分类问题采用投票法，回归问题采用平均法）</p><p>特点：Bagging旨在<strong>减少方差</strong>，尤其在基学习器存在较大方差时效果显著。</p><p>典型算法：</p><ul><li>随机森林（RandomForest）：通过构建大量决策树并进行投票来提高分类性能。</li></ul><p><img src="08_bagging.png" /></p><h2 id="boosting">2.2 Boosting</h2><p>Boosting（提升）是一种迭代方法，模型是按顺序训练的，每个新模型都试图纠正先前模型的错误，最后通过对所有模型的预测进行加权平均。</p><p>特点：Boosting旨在<strong>减少偏差</strong>，通过逐步改进模型提高预测的准确性，常常应用于简单的基学习器（如决策树桩）。</p><p>典型算法：</p><ul><li>AdaBoost (AdaptiveBoosting)：为每个训练样本分配一个权重，并在每次迭代中调整这些权重。</li><li>Gradient Boosting Machine (GBM)：GBM 是一种更通用的 Boosting算法，它使用梯度下降来优化损失函数。</li><li>XGBoost (Extreme Gradient Boosting)：GBM的一种优化版本，在效率、精度上都有很大的提升。</li><li>LightGBM (Light Gradient Boosting Machine)：另一种 GBM的优化版本，它使用基于直方图的算法来加速训练过程，并减少内存使用，特别适用于处理大规模数据集。</li></ul><p><img src="08_boosting.png" /></p><h2 id="stacking">2.3 Stacking</h2><p>Stacking（堆叠）是将多个基模型的预测结果作为新的特征输入到元学习器（MetaLearner）中进行训练，元学习器的目标是学习如何最好地组合基学习器的预测结果。</p><p>特点：利用不同模型的优势，获得比单个模型更好的性能。</p><p><img src="08_stacking.png" /></p><h1 id="随机森林">3 随机森林</h1><p>随机森林是 Bagging 的一个变体，在以决策树为基学习器构建 Bagging集成的基础上，进一步在决策树训练过程中引入了<strong>随机特征选择</strong>，更加增强了模型的多样性。</p><ol type="1"><li>Bootstrap采样： 从原始数据集中使用 Bootstrap有放回抽样，形成多个子集，每个子集用于训练一颗决策树</li><li>构建决策树：每棵树进行节点分裂时，不必考虑所有特征，而是随机选取一部分特征进行分裂</li><li>集成学习：分类任务采用投票法，回归任务采用平均法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><br>model = RandomForestClassifier()<br></code></pre></td></tr></table></figure><ul><li><code>n_estimators</code>： 决策树数量，（default = 10）</li><li><code>Criterion</code>： entropy、 或者 gini, (default = gini)</li><li><code>max_depth</code>：指定树的最大深度， （default = None表示树会尽可能的生长）</li><li><code>max_features</code>=“auto”，决策树构建时使用的最大特征数量<ul><li>“auto”：<code>max _ features=sqrt(n _ features)</code></li><li>“sqrt”： <code>max _ features=sqrt (n_ features)</code> (same as“auto”)</li><li>“log2”：<code>max _features=log2(n_features)</code></li><li>None：<code>max _ features=n_features</code></li></ul></li><li><code>bootstrap</code>：是否采用有放回抽样，如果为 False将会使用全部训练样本，（default = True）</li></ul><p>随机森林通过集成多个决策树提高了泛化能力且对噪声数据不敏感，适合解决复杂问题。</p><h1 id="boosting-1">4 Boosting</h1><h2 id="adaboost">4.1 AdaBoost</h2><p>Adaptive Boosting（自适应提升）是基于 Boosting思想实现集成学习算法，自适应体现在根据前一轮模型的错误调整样本的权重。主要有两个特点：</p><ol type="1"><li>提高上一轮被弱学习器分类错误的样本权重</li><li>对弱学习器进行线性组合，提高分类效果好的弱学习器权重</li></ol><p>AdaBoost 训练过程：</p><ol type="1"><li><p><strong>初始化样本权重</strong>：给每个样本分配一个相等的初始权重，对于<span class="math inline"><em>N</em></span> 个样本，初始权重为： <spanclass="math display">$$w_i^{(1)}=\frac{1}{N}$$</span></p></li><li><p><strong>训练弱学习器</strong>：根据当前样本权重训练一个弱学习器，目标是最小化加权误差，第<span class="math inline"><em>t</em></span> 轮得到的弱学习器加权误差为：<span class="math display">$$\varepsilon_{t} = \sum_{i=1}^{N}w_{i}^{(t)} \cdot I(y_{i} \neq h_{t}(x_{i}))$$</span></p></li></ol><ul><li><span class="math inline"><em>ε</em><sub><em>t</em></sub></span>: 第<span class="math inline"><em>t</em></span>轮弱分类器的加权错误率。</li><li><span class="math inline"><em>N</em></span>: 训练样本的总数。</li><li><spanclass="math inline"><em>w</em><sub><em>i</em></sub><sup>(<em>t</em>)</sup></span>:第 <span class="math inline"><em>t</em></span> 轮中第 <spanclass="math inline"><em>i</em></span>个样本的权重。权重在每轮迭代中都会根据前一轮的表现进行调整（分错的样本权重增加，分对的样本权重减少）。</li><li><span class="math inline"><em>I</em>(⋅)</span>: 指示函数 (IndicatorFunction)。<ul><li>如果括号内的条件 (<spanclass="math inline"><em>y</em><sub><em>i</em></sub> ≠ <em>h</em><sub><em>t</em></sub>(<em>x</em><sub><em>i</em></sub>)</span>)为真（即弱分类器 <spanclass="math inline"><em>h</em><sub><em>t</em></sub></span> 分错了样本<spanclass="math inline"><em>x</em><sub><em>i</em></sub></span>），则函数值为<span class="math inline">1</span>。</li><li>如果条件为假（即弱分类器 <spanclass="math inline"><em>h</em><sub><em>t</em></sub></span> 分对了样本<spanclass="math inline"><em>x</em><sub><em>i</em></sub></span>），则函数值为<span class="math inline">0</span>。</li></ul></li><li><span class="math inline"><em>y</em><sub><em>i</em></sub></span>: 第<span class="math inline"><em>i</em></span> 个样本的真实标签。</li><li><spanclass="math inline"><em>h</em><sub><em>t</em></sub>(<em>x</em><sub><em>i</em></sub>)</span>:第 <span class="math inline"><em>t</em></span> 轮弱分类器对第 <spanclass="math inline"><em>i</em></span> 个样本的预测结果。</li></ul><ol start="3" type="1"><li><p><strong>更新学习器权重</strong>：计算第 <spanclass="math inline"><em>t</em></span>轮弱学习器的权重，该弱学习器误差越小，权重越大，第 <spanclass="math inline"><em>t</em></span> 轮的弱学习器 <spanclass="math inline"><em>α</em><sub><em>t</em></sub></span> 的权重为：<span class="math display">$$\alpha_{t} = \frac{1}{2} ln \left( \frac{1- \varepsilon_{t}}{\varepsilon_{t}} \right)$$</span></p></li><li><p><strong>更新样本权重</strong>：根据当前学习器的表现，更新样本权重，误分类样本的权重会增加，正确分类样本的权重会降低，权重更新公式为：<spanclass="math display"><em>w</em><sub><em>i</em></sub><sup>(<em>t</em> + 1)</sup> = <em>w</em><sub><em>i</em></sub><sup>(<em>t</em>)</sup> ⋅ <em>e</em><sup>−<em>α</em><sub><em>t</em></sub><em>y</em><sub><em>i</em></sub><em>h</em><sub><em>t</em></sub>(<em>x</em><sub><em>i</em></sub>)</sup></span></p></li><li><p><strong>归一化权重</strong>：对所有样本的权重进行归一化，使所有样本权重和为1。</p></li><li><p><strong>构建强学习器</strong>：对所有弱学习器进行加权组合，预测时通过加权投票确定最终类别。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> AdaBoostClassifier, AdaBoostRegressor<br></code></pre></td></tr></table></figure><p>AdaBoost 简单易实现，但是对异常值敏感，容易过拟合。</p><h2 id="gbdt">4.2 GBDT</h2><p>GBDT（Gradient Boosting DecisionTrees）梯度提升树使用<strong>梯度提升</strong>的思想，通过迭代训练一系列决策树（通常是CART树），每次训练时通过减少前一个模型的误差（拟合残差）来提升模型的性能。</p><p>GBDT使用梯度下降的方式来最小化损失函数。回归任务通常是均方误差（MSE），分类任务通常是对数损失（LogLoss）。</p><ol type="1"><li><p><strong>初始化</strong>：初始化一个弱学习器，通常是一个常数（训练集的平均标签值）<spanclass="math display">$$\hat{y}_0=\frac{1}{n}\sum_{i=1}^ny_i$$</span></p></li><li><p><strong>计算负梯度（残差）</strong>：计算损失函数在当前模型预测值处的负梯度，作为残差的近似值</p></li><li><p><strong>训练决策树</strong>：构建一颗新的决策树，新决策树并不是拟合真实标签，而是尽可能地拟合残差</p></li><li><p><strong>更新模型</strong>：将新树的预测结果乘以学习率 <spanclass="math inline"><em>η</em></span> 后加入到现有模型中 <spanclass="math display"><em>F</em><sub><em>m</em> + 1</sub>(<em>x</em>) = <em>F</em><sub><em>m</em></sub>(<em>x</em>) + <em>η</em><em>h</em><sub><em>m</em></sub>(<em>x</em>)</span></p></li><li><p><strong>得到强学习器</strong>：最终将所有树的预测值求和得到最终结果</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier, GradientBoostingRegressor<br></code></pre></td></tr></table></figure><h2 id="xgboost">4.3 XGBoost</h2><p>XGBoost 算法是 GBDT 算法的一种改进和优化，由陈天奇在其论文<ahref="https://arxiv.org/pdf/1603.02754">《<em>XGBoost: A Scalable TreeBoosting System</em>》</a>中提出。</p><p>XGBoost 的算法流程与 GBDT 类似，但做了一些改进：</p><ol type="1"><li>损失函数：引入正则化项，可以防止过拟合</li><li>梯度提升：使用二阶泰勒展开近似损失函数，可以更精确地计算梯度和残差</li><li>分裂点查找：实现了精确贪心算法和近似贪心算法，可以高效地查找最佳分裂点</li><li>缺失值处理：可以自动学习缺失值的分裂方向</li><li>运行速度：使用了加权分位数 sketch和稀疏感知算法，通过缓存优化和模型并行来提高算法速度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgb<br><br><span class="hljs-comment"># 将数据处理成数据集格式DMatrix格式</span><br><span class="hljs-comment"># DMatrix数据结构 支持缺失值，优化存储和计算，，并且可以加速训练</span><br>dm_train = xgb.DMatrix(X_train, y_train)<br>dm_test = xgb.DMatrix(X_test)<br><br><span class="hljs-comment"># 设置模型参数</span><br>params = &#123;<br>    <span class="hljs-string">&#x27;booster&#x27;</span>: <span class="hljs-string">&#x27;gbtree&#x27;</span>,           <span class="hljs-comment"># 用于训练的基学习器类型</span><br>    <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;multi:softmax&#x27;</span>,  <span class="hljs-comment"># 指定模型的损失函数</span><br>    <span class="hljs-string">&#x27;num_class&#x27;</span>: <span class="hljs-number">3</span>,                <span class="hljs-comment"># 类别的数量</span><br>    <span class="hljs-string">&#x27;gamma&#x27;</span>: <span class="hljs-number">0.1</span>,                  <span class="hljs-comment"># 控制每次分裂的最小损失函数减少量</span><br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">6</span>,                <span class="hljs-comment"># 决策树最大深度</span><br>    <span class="hljs-string">&#x27;lambda&#x27;</span>: <span class="hljs-number">2</span>,                   <span class="hljs-comment"># L2正则化权重</span><br>    <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.8</span>,              <span class="hljs-comment"># 控制每棵树训练时随机选取的样本比例</span><br>    <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.8</span>,       <span class="hljs-comment"># 用于控制每棵树或每个节点的特征选择比例</span><br>    <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.001</span>,                  <span class="hljs-comment"># 学习率</span><br>    <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">10</span>,                    <span class="hljs-comment"># 设置随机数生成器的种子</span><br>    <span class="hljs-string">&#x27;nthread&#x27;</span>: <span class="hljs-number">16</span>,                 <span class="hljs-comment"># 指定了训练时并行使用的线程数</span><br>&#125;<br><br><span class="hljs-comment"># num_boost_round 代表 boosting 过程的迭代次数，也就是弱学习器的数量</span><br>model = xgb.train(params, dm_train, num_boost_round=<span class="hljs-number">200</span>)<br><br><span class="hljs-comment"># 模型预测</span><br>y_pred = model.predict(dm_test)<br></code></pre></td></tr></table></figure><p><code>params</code>的参数：</p><ol type="1"><li><code>booster</code>：指定用于训练的基学习器类型，默认值为<code>'gbtree'</code>，表示使用传统的决策树作为基学习器；其他的选项包括<code>'gblinear'</code>和<code>'dart'</code>，前者表示使用线性回归或逻辑回归，后者也是基于决策树的模型，但具有丢弃树的机制，降低过拟合风险。通常<code>'gbtree'</code>适用于大多数问题，尤其涉及到非线性关系；<code>'dart'</code>适用于复杂数据集，尤其是在出现过拟合时。如果数据集较小或线性关系较强，可以尝试使用<code>'gblinear'</code>。</li><li><code>objective</code>：指定模型的损失函数（优化目标），常见的选项包括：<ul><li><code>'reg:squarederror'</code>：回归任务中的均方误差（MSE），用于回归任务。</li><li><code>'reg:logistic'</code>：回归任务中的逻辑回归，通常用于二分类任务。</li><li><code>'binary:logistic'</code>：二分类任务中的逻辑回归，输出概率值。</li><li><code>'binary:logitraw'</code>：二分类任务中的逻辑回归，输出未经过Sigmoid 处理的原始值。</li><li><code>'multi:softmax'</code>：多分类任务，输出为每个类别的最大概率。</li><li><code>'multi:softprob'</code>：多分类任务，输出为每个类别的概率分布。</li></ul></li><li><code>eta</code>/<code>learning_rate</code>：XGBoost中的学习率，默认值为 0.3，推荐将初始值设置为 0.01 到 0.1。</li><li><code>alpha</code>和 <code>lambda</code>：前者控制 L1正则化项（Lasso）的强度，默认为 <code>0</code>；后者控制 L2正则化项（Ridge）的强度，默认为 <code>1</code>。</li><li><code>scale_pos_weight</code>：用于处理类别不平衡问题，尤其是二分类问题。在类别严重不平衡的情况下，通过调整这个参数来加大少数类的权重，使得模型更关注少数类样本，默认值为1。</li><li><code>gamma</code>：用来控制每次分裂的最小损失函数减少量，该参数控制树的生长，越大的<code>gamma</code> 会使得树更小，减小过拟合的风险，默认值为0，意味着模型不会受到分裂的限制，树会尽可能深，直到节点中没有足够的样本。</li><li><code>num_class</code>：用于多分类任务的参数，表示类别的数量。对于二分类任务，无需设置该参数。</li><li><code>colsample_bytree</code> / <code>colsample_bylevel</code> /<code>colsample_bynode</code>：控制在每棵树、每一层、每个节点上采样特征的比例。这些参数用于控制模型的复杂度。较小的值会增加模型的随机性，从而防止过拟合；较大的值则意味着每棵树使用更多的特征，可能导致过拟合。<ul><li><code>colsample_bytree</code>：每棵树使用的特征比例（默认为1.0）。</li><li><code>colsample_bylevel</code>：每一层使用的特征比例（默认为1.0）。</li><li><code>colsample_bynode</code>：每个节点使用的特征比例（默认为1.0）。</li></ul></li></ol><p>除了<code>param</code>字典提供的模型参数外，<code>train</code>函数也有一些超参数：</p><ol type="1"><li><code>num_boost_round</code>：树的训练轮数，设置较小的<code>learning_rate</code>并增加训练轮数可以提高模型的稳定性。</li><li><code>early_stopping_rounds</code>：用于实现早期停止机制。当指定轮次的训练中，验证集上的损失函数不再减少时，训练会自动停止，避免过拟合。</li><li><code>feval</code>：设置用户自定义的评估函数，这种方式允许用户灵活地使用任何适合特定任务的评估指标，需要注意的是评估函数有两个参数，一个表示模型预测值（NumPy的 <code>ndarray</code>对象），一个是训练数据（XGBoost 的<code>DMatrix</code>对象）；函数返回一个二元组<code>(name, value)</code>，其中 <code>name</code>是评估指标的名称，<code>value</code> 是指标的值。</li><li><code>obj</code>：设置用户自定义的目标函数，目标函数用于计算每一步的梯度和二阶导数，从而指导模型的优化过程，有兴趣的读者可以自行研究。</li><li><code>evals</code>：用于指定一个或多个验证集，其值是包含一个或多个<code>(data, label)</code>元组的列表，每个元组代表一个评估数据集，数据集需要是<code>DMatrix</code>对象。在训练过程中，XGBoost会在每一轮迭代后评估验证集上的性能，通常用于监控训练过程中的过拟合或调整超参数。</li><li><code>eval_results</code>：存储在训练过程中计算的所有评估结果，通常传入一个字典。</li><li><code>verbose_eval</code>：控制训练过程中评估结果的输出频率，可以设置为一个整数，表示多少轮迭代输出一次评估结果，也可以设置为<code>True</code>或<code>False</code>，表示每轮都输出或不输出任何评估结果。</li><li><code>xgb_model</code>：用于加载之前训练好的模型，以便从中断点继续训练。你可以指定一个<code>xgb_model</code> 文件或者传入一个 <code>Booster</code> 对象。</li><li><code>callbacks</code>：在训练过程中添加自定义的回调函数，回调函数可以在每一轮迭代时提供额外的控制，如自动停止训练、调整学习。</li></ol><p>可以通过 <code>plot_importance</code> 查看每个特征的重要性。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, ax = plt.subplots(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>))<br><br><span class="hljs-comment"># ax 可以指定坐标系，此外还可以设置 max_num_features 限制特征数量</span><br>xgb.plot_importance(model, ax=ax)<br></code></pre></td></tr></table></figure> <img src="08_xgb_plot_importance.png" /></p><h2 id="lightbgm">4.4 LightBGM</h2><p>LightGBM（Light Gradient BoostingMachine）是由微软开发的梯度提升算法，相较于GBDT，有更快的训练速度，更低的内存消耗，更高的准确率，支持大规模数据和并行学习。</p><p>核心技术：</p><ol type="1"><li><strong>基于直方图的算法 (Histogram-based Algorithm)</strong><ul><li><strong>基本思想：</strong> 将连续的特征值离散化成若干个 bins(桶)，然后使用这些 bins来构建直方图。在寻找最佳分裂点时，只需遍历直方图中的bins，而不需要遍历所有的数据点。</li><li><strong>优点：</strong><ul><li>减少了寻找最佳分裂点的计算量，提高了训练速度。</li><li>降低了内存消耗，因为只需要存储直方图，而不需要存储原始的特征值。</li></ul></li><li><strong>缺点：</strong><ul><li>离散化可能会损失一些信息，但通常情况下，这种损失可以忽略不计。</li></ul></li></ul></li><li><strong>Leaf-wise 的生长策略 (Leaf-wise Tree Growth)</strong><ul><li><strong>基本思想：</strong> 每次从当前所有的叶子节点中，选择分裂收益最大的节点进行分裂，而不是像level-wise 那样，每次分裂所有的叶子节点。</li><li><strong>优点：</strong><ul><li>可以生成更复杂的树模型，因为 leaf-wise每次只分裂一个节点，可以更精细地拟合数据。</li><li>通常情况下，leaf-wise 的准确率比 level-wise 更高。</li></ul></li><li><strong>缺点：</strong><ul><li>容易过拟合，特别是当数据集较小的时候。可以通过设置 <code>max_depth</code> 参数来限制树的深度，防止过拟合。</li></ul></li></ul></li><li><strong>直接支持类别特征 (Direct Support for CategoricalFeatures)</strong><ul><li><strong>基本思想：</strong> LightGBM可以直接处理类别特征，不需要进行 one-hot 编码。</li><li><strong>优点：</strong><ul><li>节省了内存空间，因为不需要存储大量的 one-hot 编码。</li><li>提高了训练速度，因为不需要对类别特征进行额外的处理。</li></ul></li></ul></li><li><strong>Gradient-based One-Side Sampling (GOSS)</strong><ul><li><strong>基本思想：</strong> 在每次迭代中，LightGBM不是使用所有的样本来计算梯度，而是只使用一部分样本。GOSS算法选择梯度绝对值较大的样本（这些样本的梯度比较重要），并随机选择梯度绝对值较小的样本。</li><li><strong>优点：</strong><ul><li>减少了计算梯度的样本数量，提高了训练速度。</li></ul></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><br><span class="hljs-comment"># 将数据转化为 LightGBM 的数据格式</span><br>train_data = lgb.Dataset(X_train, y_train)<br>test_data = lgb.Dataset(X_test, y_test, reference=train_data)<br><br><span class="hljs-comment"># 设置模型参数</span><br>params = &#123;<br>    <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;multiclass&#x27;</span>,   <span class="hljs-comment"># 多分类问题</span><br>    <span class="hljs-string">&#x27;num_class&#x27;</span>: <span class="hljs-number">3</span>,              <span class="hljs-comment"># 类别数量</span><br>    <span class="hljs-string">&#x27;metric&#x27;</span>: <span class="hljs-string">&#x27;multi_logloss&#x27;</span>,   <span class="hljs-comment"># 多分类对数损失函数</span><br>    <span class="hljs-string">&#x27;boosting_type&#x27;</span>: <span class="hljs-string">&#x27;gbdt&#x27;</span>,     <span class="hljs-comment"># 使用梯度提升树算法</span><br>    <span class="hljs-string">&#x27;num_leaves&#x27;</span>: <span class="hljs-number">31</span>,            <span class="hljs-comment"># 叶子节点数</span><br>    <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.05</span>,       <span class="hljs-comment"># 学习率</span><br>    <span class="hljs-string">&#x27;feature_fraction&#x27;</span>: <span class="hljs-number">0.75</span>,    <span class="hljs-comment"># 每次训练时随机选择特征的比例</span><br>    <span class="hljs-string">&#x27;early_stopping_rounds&#x27;</span>: <span class="hljs-number">10</span>  <span class="hljs-comment"># 连续多少论没有性能提升就停止迭代</span><br>&#125;<br><span class="hljs-comment"># 模型训练</span><br>model = lgb.train(params=params, train_set=train_data, num_boost_round=<span class="hljs-number">200</span>, valid_sets=[test_data])<br><br><span class="hljs-comment"># 模型预测，结果为各标签的概率值，类似 sklearn 的 predict_proba</span><br>y_proba = model.predict(X_test, num_iteration=model.best_iteration)<br><br><span class="hljs-comment"># 将预测结果处理成标签</span><br>y_pred= np.argmax(y_proba, axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li><code>objective</code>：设置优化目标函数（损失函数），可选值有：<ul><li><code>'regression'</code>：回归任务。</li><li><code>'binary'</code>：二分类任务。</li><li><code>'multiclass'</code>：多分类任务。</li><li><code>'multiclassova'</code>：多分类任务，使用一对多的策略。</li><li><code>'rank_xendcg'</code>、<code>'lambdarank'</code>：排名任务。</li></ul></li><li><code>metric</code>：评估模型性能的指标，可选值有：<ul><li><code>'l2'</code>、<code>'mean_squared_error'</code>：回归任务中的均方误差。</li><li><code>'binary_error'</code>：二分类错误率。</li><li><code>'multi_logloss'</code>：多分类对数损失。</li><li><code>'auc'</code>：二分类任务中的 AUC。</li><li><code>'precision'</code>、<code>'recall'</code>、<code>'f1'</code>：精度、召回率、F1分数。</li></ul></li><li><code>boosting_type</code>：设置提升类型，可选值有：<ul><li><code>'gbdt'</code>：传统的梯度提升树。</li><li><code>'dart'</code>：具有随机丢弃树机制来防止过拟合的决策树。</li><li><code>'goss'</code>：通过单边梯度抽样来加速训练。</li><li><code>'rf'</code>：随机森林。</li></ul></li><li><code>num_leaves</code>/<code>max_depth</code>：决策树的叶子节点数 /决策树的最大深度，控制树的复杂度。</li><li><code>lambda_l1</code>/<code>lambda_l2</code>：L1 和 L2正则化参数，用于控制模型的复杂度，防止过拟合。</li><li><code>max_bin</code>：用于分割连续特征（数据分箱）的最大箱子数。</li><li><code>feature_fraction</code>：每次训练时随机选择特征的比例。</li><li><code>early_stopping_rounds</code>：设置评估指标在连续多少轮迭代中没有改进时，训练会提前停止。</li><li><code>learning_rate</code>：学习率。</li><li><code>n_estimators</code>：弱学习器的数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>集成学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_朴素贝叶斯</title>
    <link href="/2024/07/19/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <url>/2024/07/19/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><h2 id="贝叶斯定理">1.1 贝叶斯定理</h2><p>贝叶斯定理是概率论中的一个重要定理，它描述了如何从主观经验或已知事实出发，通过收集到的样本数据（证据）来更新对事件发生概率的认知（信念）。贝叶斯定理的数学表达式为：<span class="math display">$$P(A \mid B) = \frac{P(B \mid A)}{P(B)}\cdot P(A)$$</span></p><ul><li><span class="math inline"><em>P</em>(<em>A</em>)</span> 是事件 <spanclass="math inline"><em>A</em></span>发生的<strong>先验概率</strong>，我们可以理解为已知事实或主观经验（<strong>主观概率</strong>）</li><li><span class="math inline"><em>P</em>(<em>B</em> ∣ <em>A</em>)</span>是在事件 <span class="math inline"><em>A</em></span> 发生的条件下事件<span class="math inline"><em>B</em></span>发生的<strong>条件概率</strong>，通常也称之为<strong>似然性</strong>（likelihood）</li><li><span class="math inline"><em>P</em>(<em>B</em>)</span> 是事件 <spanclass="math inline"><em>B</em></span> 发生的（全）概率，和 <spanclass="math inline"><em>P</em>(<em>B</em> ∣ <em>A</em>)</span>可以通过收集到的样本数据（证据）获取</li><li><span class="math inline"><em>P</em>(<em>A</em> ∣ <em>B</em>)</span>是在事件 <span class="math inline"><em>B</em></span> 发生的条件下事件<span class="math inline"><em>A</em></span>发生的条件概率，即收集到样本数据后对事件 <spanclass="math inline"><em>A</em></span>发生概率的重新认知，称之为<strong>后验概率</strong>。</li></ul><p>贝叶斯定理告诉我们一个重要的事实：可以从已知的事实或主观经验出发，通过收集到的证据来更新我们对某个事件发生概率的认知，也就是<strong>可以通过已知的事实和收集的证据来推断出未知的真相</strong>。</p><h2 id="朴素贝叶斯">1.2 朴素贝叶斯</h2><p>朴素贝叶斯算法是基于贝叶斯定理和特征条件独立性假设的分类算法，因其简单高效而受到广泛应用。朴素贝叶斯算法的关键在于“<strong>朴素</strong>”二字，也就是刚才所说的<strong>特征条件独立性</strong>假设，即用于分类的特征在类确定的条件下都是独立的，该假设使得朴素贝叶斯的学习成为可能。</p><p>假设我们有一个特征集合 <spanclass="math inline"><em>X</em> = {<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub>}</span>和一个类别 <span class="math inline"><em>C</em></span>，朴素贝叶斯算法假设： <spanclass="math display"><em>P</em>(<em>X</em>|<em>C</em>) = <em>P</em>(<em>x</em><sub>1</sub>|<em>C</em>) ⋅ <em>P</em>(<em>x</em><sub>2</sub>|<em>C</em>) ⋅ … ⋅ <em>P</em>(<em>x</em><sub><em>n</em></sub>|<em>C</em>)</span>这个假设使得我们无需考虑特征之间复杂的依赖关系，极大简化了条件概率的计算。</p><h1 id="算法流程">2 算法流程</h1><h2 id="训练阶段">2.1 训练阶段</h2><p>首先计算每个类别的先验概率和每个特征在各个类别下的条件概率。</p><ol type="1"><li><p>计算先验概率： <span class="math display">$$P(C_{i}) = \frac{n_{i}}{n}$$</span> <spanclass="math inline"><em>C</em><sub><em>i</em></sub></span> 表示类别，<span class="math inline"><em>n</em><sub><em>i</em></sub></span> 是类别<span class="math inline"><em>C</em><sub><em>i</em></sub></span>的样本数量， <span class="math inline"><em>n</em></span>是总的样本容量。</p></li><li><p>计算条件概率： <span class="math display">$$P(x_{j} \vert C_{i}) = \frac{n_{i,j}}{n_{i}}$$</span> <spanclass="math inline"><em>n</em><sub><em>i</em>, <em>j</em></sub></span>是在类别 <spanclass="math inline"><em>C</em><sub><em>i</em></sub></span> 中，特征<span class="math inline"><em>x</em><sub><em>j</em></sub></span>出现的次数。</p></li></ol><h2 id="预测阶段">2.2 预测阶段</h2><p>给定一个待分类样本 <span class="math inline">$\small{X}$</span>，朴素贝叶斯算法通过以下步骤来计算其属于每个类别的后验概率： <spanclass="math display">$$P(C_{i} \vert X) = \frac{P(X \vert C_{i})}{P(X)} \cdot P(C_{i})$$</span> 上面的公式中， <span class="math inline">$\small{P(X)}$</span>对应到每个类别都是一个常量，可以忽略掉它，再结合独立性假设有： <spanclass="math display"><em>P</em>(<em>C</em><sub><em>i</em></sub>|<em>X</em>) ∝ <em>P</em>(<em>C</em><sub><em>i</em></sub>) ⋅ <em>P</em>(<em>x</em><sub>1</sub>|<em>C</em><sub><em>i</em></sub>) ⋅ <em>P</em>(<em>x</em><sub>2</sub>|<em>C</em><sub><em>i</em></sub>) ⋅ … ⋅ <em>P</em>(<em>x</em><sub><em>n</em></sub>|<em>C</em><sub><em>i</em></sub>)</span>然后选择具有最高后验概率的类别作为预测结果。</p><h1 id="api-使用">3 API 使用</h1><p>在 <code>sklearn.navie_bayes</code>模块下有五个朴素贝叶斯算法的变体，每种变体针对不同类型的数据和特征分。</p><table><thead><tr><th>分类器</th><th>特征类型</th><th>主要假设</th></tr></thead><tbody><tr><td><code>BernoulliNB</code></td><td>二元特征</td><td>特征服从 Bernoulli 分布</td></tr><tr><td><code>CategoricalNB</code></td><td>类别特征</td><td>特征服从多项式分布，常用于处理类别数据</td></tr><tr><td><code>ComplementNB</code></td><td>计数特征</td><td>利用补集概率，常用于处理不平衡数据集</td></tr><tr><td><code>GaussianNB</code></td><td>连续特征</td><td>特征服从高斯分布</td></tr><tr><td><code>MultinomialNB</code></td><td>计数特征</td><td>特征服从多项式分布，常用于文本分类</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br><br>model = GaussianNB()<br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 分类结果</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 分类概率，为了方便观看，保留两位小数</span><br>y_proba = model.predict_proba(X_test).<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="算法优缺点">4 算法优缺点</h1><p>优点：</p><ol type="1"><li>逻辑简单容易实现，适合大规模数据集。</li><li>运算开销较小。预测需要用到的概率在训练阶段都已经准好了，当新数据来了之后，只需要获取对应的概率值并进行简单的运算就能获得预测的结果。</li><li>受噪声和无关属性影响小。</li></ol><p>缺点：由于引入了“特征相互独立”这个假设，缺点也相当明显，因为在实际应用中，特征之间很难做到完全独立，尤其是维度很高的数据，如果特征之间的相关性较大，那么分类的效果就会变得很差。</p><p>为了解决朴素贝叶斯的缺点，在其基础上又衍生出了一些新的方法，包括：半朴素贝叶斯（OneDependent Estimator）、AODE（Averaged One Dependent Estimator）、K依赖朴素贝叶斯、朴素贝叶斯网络、高斯混合朴素贝叶斯等。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>朴素贝叶斯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_决策树</title>
    <link href="/2024/07/18/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E5%86%B3%E7%AD%96%E6%A0%91/06_%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2024/07/18/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E5%86%B3%E7%AD%96%E6%A0%91/06_%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>决策树（DecisionTree）是一种基于树形结构的算法，根据一系列条件判断逐步划分数据，缩小范围，最终得出预测结果。决策树由4 部分组成：</p><ul><li>根节点：树的节点，包含所有数据</li><li>内部节点：表示特征上的判断条件</li><li>分支：根据判断条件分出的路径</li><li>叶子节点：最终分类或回归的结果</li></ul><p>决策树适用于需要规则化、可解释性和快速决策的场景，尤其在数据特征明确、样本量适中的情况下表现良好。在复杂任务中，它常作为基模型，与集成学习结合（如随机森林、梯度提升树）以提升性能。<img src="06_tree_direct.png" /></p><h1 id="决策树工作流程">2 决策树工作流程</h1><p>训练决策树模型有三个核心的步骤：特征选择、决策树构建和决策树剪枝。</p><p>递归选择最优特征，并根据该特征对训练数据进行划分，使得对各个子数据集有一个最好的分类。</p><ol type="1"><li>首先构建根结点，将所有训练数据都放在根结点。</li><li>选择一个最优特征，按照这一特征将训练数据集划分成子集，使得各个子集有一个在当前条件下最好的分类。</li><li>如果这些子集已经能够被基本正确分类，那么构建叶结点，并将这些子集分到所对应的叶结点中去；如果还有子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行划分并构建相应的结点。</li><li>如此递归直至所有训练数据子集被基本正确分类，或者没有合适的特征为止。</li></ol><p>最后每个子集都被分到叶结点有了明确的类，这就生成了一棵决策树。这样生成的决策树对训练数据有很好的分类能力，但可能发生过拟合现象。因此需要对已生成的树进行剪枝，将树变得更简单，从而使它具有更好的泛化能力。</p><h2 id="特征选择">2.1 特征选择</h2><p>特征选择在于选取对训练数据具有分类能力的特征，这样可以提高决策树学习的效率。如果一个特征能够使得分类后的分支结点尽可能属于同一类别，即该结点有着较高的<strong>纯度</strong>（purity），那么该特征对数据集而言就具备较强的分类能力。</p><p>通常选择的准则有信息增益、信息增益率和基尼指数</p><h3 id="信息增益与-id3">2.1.1 信息增益与 ID3</h3><p>信息熵（entropy）是度量样本集合“纯度”的一个指标，当前样本集合 <spanclass="math inline"><em>D</em></span> 中共有 <spanclass="math inline"><em>k</em></span> 种类别，第 <spanclass="math inline"><em>i</em></span>类样本样本的比例（也就是出现概率）为 <spanclass="math inline"><em>p</em><sub><em>k</em></sub></span>，则 <spanclass="math inline"><em>D</em></span> 的<strong>信息熵</strong>定义为：<span class="math display">$$Ent(D) = -\sum_{i = 1}^{k}p_i\,log_2\,p_i$$</span> 不难发现，信息熵越小，<spanclass="math inline"><em>D</em></span> 的纯度越大。可以得出，<spanclass="math inline"><em>E</em><em>n</em><em>t</em>(<em>D</em>)</span>的最小值为0，最大值为 <spanclass="math inline"><em>l</em><em>o</em><em>g</em><sub>2</sub><em>k</em></span>。</p><p>直接以信息熵为基础，计算当前划分对信息熵所造成的变化，也就是<strong>信息增益（informationgain）</strong>，衡量的是当前划分对信息的不确定性减少的贡献程度。公式为<strong>划分前的信息熵 - 划分后的信息熵</strong>。 <spanclass="math display">$$\mathrm{Gain}(D,A)=\mathrm{Ent}(D)-\sum_{v=1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</span>可以看出， 划分后的信息熵表达的是在给定特征 <spanclass="math inline"><em>A</em></span> 的条件下，数据集 <spanclass="math inline"><em>D</em></span>的不确定性，称为<strong>条件熵</strong>： <spanclass="math display">$$Ent(D|A)=\sum_{v=1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</span></p><ul><li>特征 <span class="math inline"><em>A</em></span> 的取值：<spanclass="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ...<em>a</em><sub><em>v</em></sub></span>，共有V 个</li><li><spanclass="math inline"><em>D</em><sub><em>v</em></sub></span>：<spanclass="math inline"><em>D</em></span> 在特征 <spanclass="math inline"><em>A</em></span> 上取值为 <spanclass="math inline"><em>a</em><sub><em>v</em></sub></span>的样本子集</li><li><span class="math inline">$\frac{|D_v|}{D}$</span>：取值为 <spanclass="math inline"><em>a</em><sub><em>v</em></sub></span>的样本比例，第 <span class="math inline"><em>v</em></span>个分支的权重，样本越多越重要</li><li><spanclass="math inline"><em>E</em><em>n</em><em>t</em>(<em>D</em><sub><em>v</em></sub>)</span>：子集<span class="math inline"><em>D</em><sub><em>v</em></sub></span>的信息熵</li></ul><p>ID3 算法就是基于信息增益进行特征选择的。</p><h3 id="信息增益率与-c4.5">2.1.2 信息增益率与 C4.5</h3><p>信息增益作为划分准则时，倾向于筛选性强的特征，极端来看每个特征值只对应一个结果，那么结果就够纯，所以<strong>信息增益会倾向于选择取值较多的特征</strong>。</p><p><strong>信息增益率（information gain ratio）</strong>可以对这一问题进行校正： <spanclass="math display">$$\mathrm{Gain_ratio}(D,A)=\frac{\mathrm{Gain}(D,A)}{\mathrm{IV}(A)}$$</span>其中 <span class="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>为： <spanclass="math display">$${IV}(A)=-\sum_{v=1}^{V}\frac{|D_{v}|}{|D|}\log_{2}\frac{|D_{v}|}{|D|}$$</span><span class="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>表述的基本思想是特征 <span class="math inline"><em>A</em></span>的取值信息熵，取值数目越多，则 <spanclass="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>取值越大。</p><p>信息增益率希望选择的是：</p><ol type="1"><li>信息增益尽可能大</li><li>特征取值尽可能少</li></ol><p>C4.5算法就是基于信息增益比进行特征选择的，但不是仅仅参考信息增益比，而是采用了<strong>启发式方法</strong>，会在避免取值较多的特征 和 避免信息增益过小 之间找到平衡。</p><h3 id="基尼指数与-cart">2.1.3 基尼指数与 CART</h3><p>样本 <span class="math inline"><em>D</em></span> 有 <spanclass="math inline"><em>k</em></span> 种类别，样本属于第 <spanclass="math inline"><em>k</em></span> 种类别的概率为 <spanclass="math inline"><em>p</em><sub><em>k</em></sub></span>，那么两次抽到的是同一类别的概率为<spanclass="math inline"><em>p</em><sub><em>k</em></sub><sup>2</sup></span>，一共<span class="math inline"><em>k</em></span>种类别求和得到抽到任一同样类别的概率，用 1减去这个概率，反映的是<strong>从样本 D中任取两个样本，其类别标签不一致的概率</strong>。 <spanclass="math display">$$Gini(D) = 1 - \sum_{k=1}^{n}{p_{k}}^{2}$$</span>该值称为<strong>基尼指数（Giniindex）</strong>，基尼指数越大样本集合的不确定性也越大，这与信息熵相似。</p><p>属性 A 的基尼指数为： <span class="math display">$$Gini\_index(D, A)= \sum_{v=1}^{V}\frac{\lvert D_{v} \rvert}{\lvert D\rvert}Gini(D_{v})$$</span> 和特征熵类似，根据特征 A的取值，将数据集分为 V 个子集，分别计算每个子集的基尼指数，按照权重（占比）进行求和。</p><p>CART 算法就是基于基尼指数进行特征选择的，CART既可以生成分类树，也可以生成回归树。</p><blockquote><p>在回归问题中面对的特征是连续值，可以通过遍历特征所有可能的取值，找到切分点<span class="math inline">$\small{x}$</span>让切分后的子集在信息增益比或基尼指数方面达到最优，在数据分裂时以 <spanclass="math inline">$\small{x}$</span> 为分界点将数据划分为 <spanclass="math inline">$\small{D_{1}}$</span> 和 <spanclass="math inline">$\small{D_{2}}$</span> 两个子集，其中 <spanclass="math inline">$\small{D_{1}}$</span> 包含特征值小于等于 <spanclass="math inline">$\small{x}$</span> 的样本， <spanclass="math inline">$\small{D_{2}}$</span> 包含特征值大于 <spanclass="math inline">$\small{x}$</span> 的样本。</p></blockquote><h2 id="数据分裂">2.2 数据分裂</h2><p>通过上述准则选定特征后就要进行数据分裂，根据选定特征将数据集分成两个或多个子集，每个子集对应于特征的不同取值。递归对每个子集重复特征选择和数据分裂的动作，直到满足停止条件。</p><p>常见的停止条件：</p><ol type="1"><li>树达到预设的深度</li><li>当前结点的样本数量少于预设的阈值</li><li>结点上所有样本属于同一个类别</li><li>信息增益或 Gini 指数的变动低于某个阈值</li></ol><h2 id="决策树剪枝">2.3 决策树剪枝</h2><p>剪枝可以减少树结构的复杂性，避免过拟合的风险，提升泛化能力。</p><ul><li><strong>预剪枝</strong>（pre-pruning）：在构建决策树的过程中设置一些限制条件（上一节中罗列了常见停止条件）提前停止树的生长，避免生成过于复杂的树，但是可能存在欠拟合的风险，因为过早停止分裂可能会遗漏潜在的重要决策规则。</li><li><strong>后剪枝</strong>（post-pruning）：后剪枝是在决策树构建完成后，通过评估和移除一些不必要的分支来简化树结构。在减少过拟合风险的同时，还能较好的保留对数据的拟合能力，但是计算量较大，而且如果没有合适的验证集，剪枝效果就会受到影响。</li></ul><h1 id="api-使用">3 API 使用</h1><p>sklearn 中的基于 CART 算法分别实现了<code>DecisionTreeClassifier</code> 和<code>DecisionTreeRegressor</code> 来分别解决分类和回归问题。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier, DecisionTreeRegressor<br><br>model1 = DecisionTreeClassifier()<br>model2 = DecisionTreeRegressor()<br></code></pre></td></tr></table></figure></p><ul><li><code>criterion</code>：特征选择（数据分裂质量评估）的标准，可以选择<code>'gini'</code>或<code>'entropy'</code>，前者代表基尼指数，也是默认值，后者代表信息增益。</li><li><code>max_depth</code>：树的最大深度，默认值为<code>None</code>，如果不设置该参数，会存在过拟合风险。</li><li><code>min_samples_split</code>：一个内部结点再次分裂所需的最小样本数，默认值为<code>2</code>。这个参数可以设置为整数表示最小样本数，也可以设置为浮点数，表示占总样本数的比例。</li><li><code>min_samples_leaf</code>：叶结点所需的最小样本数，默认值为<code>1</code>。将该参数设置为较大的值可以平滑模型，降低过拟合风险。这个参数也可以设置为整数或浮点数，道理同上。</li><li><code>max_features</code>：用于最佳分裂的特征数，默认值为<code>None</code>。这个参数可以设置为整数，表示选择固定数量的特征；可以设置为浮点数，表示选择特征的比例；可以设置为字符串，<code>'auto'</code>和<code>'sqrt'</code>表示将总的特征数量求平方根，用平方根的值作为选择特征的数量，<code>'log2'</code>表示将总的特征数量求对数，用对数值作为选择特征的数量。</li><li><code>class_weight</code>：指定类别的权重，用于处理类别不平衡问题，默认值为<code>None</code>。可以用字典的方式手动设置每个类别的权重，也可以使用<code>'balanced'</code>让模型自动调整。</li><li><code>splitter</code>：选择分裂结点的策略，默认值为<code>'best'</code>，表示最佳分裂，还有一个取值是<code>'random'</code>，表示随机分裂。</li><li><code>max_leaf_nodes</code>：限制叶结点的最大数量，可以防止树结构过于复杂。</li><li><code>min_impurity_decrease</code>：结点分裂所需的最小不纯度降低值，任何结点只有在不纯度减少超过此值时才会进行分裂。</li><li><code>ccp_alpha</code>：成本复杂度剪枝中的<spanclass="math inline">$\small{\alpha}$</span>参数值。这个参数用于控制后剪枝中成本复杂度计算公式中<spanclass="math inline">$\small{\alpha}$</span>的值。较小的<spanclass="math inline">$\small{\alpha}$</span>值允许更复杂的树，而较大的<spanclass="math inline">$\small{\alpha}$</span>值倾向于选择更简单的树。通过调整<spanclass="math inline">$\small{\alpha}$</span>，可以找到一个最佳的复杂度和误差之间的平衡点。</li></ul><p>通过以下代码可以可视化决策树： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> plot_tree<br><br>plot_tree(<br>    decision_tree=model,               <span class="hljs-comment"># 决策树模型</span><br>    feature_names=iris.feature_names,  <span class="hljs-comment"># 特征的名称</span><br>    class_names=iris.target_names,     <span class="hljs-comment"># 标签的名称</span><br>    filled=<span class="hljs-literal">True</span>                        <span class="hljs-comment"># 用颜色填充</span><br>)<br></code></pre></td></tr></table></figure> <imgsrc="06_decision_tree_plot.png" alt="06_decision_tree_plot" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>决策树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_逻辑回归</title>
    <link href="/2024/07/16/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/07/16/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>逻辑回归（LogisticRegression）尽管名字中含有“回归”，但逻辑回归实际上是一种分类算法，用于处理二分类问题。逻辑回归通过<strong>将线性回归的输出作为输入，映射到[0,1]区间</strong>，来表示某个类别的概率。</p><p>常用的映射函数是 sigmoid 函数：<spanclass="math inline">$𝑓(𝑥)=\frac{1}{1+𝑒^{−𝑥}}$</span>，将线性回归的输出作为输入会得到{0, 1} 的输出。 <span class="math display">$$𝑃(𝑦=1∣x)=\frac{1}{1+e^{-(w^Tx+b)}}$$</span> <spanclass="math inline"><em>𝑃</em>(<em>𝑦</em> = 1 ∣ <em>x</em>)</span>表示输出为1类的概率，根据逻辑回归结果和阈值来确认最终预测结果，若逻辑回归结果大于阈值则输出为1类，反之输出为 0 类。 <span class="math display">$$\begin{aligned}&amp;\begin{bmatrix}0.5 &amp; 0 &amp; 0.7 \\0.5 &amp; 0.5 &amp; 0.9 \\0.1 &amp; 1 &amp; 0.6 \\0.6 &amp; 0.1 &amp; 0\end{bmatrix}\begin{bmatrix}-1 \\2 \\0.5\end{bmatrix}=\quad\begin{bmatrix}-0.15 \\0.95 \\2.2 \\-0.4\end{bmatrix}\quad\xrightarrow{\mathrm{sigmoid}}\begin{bmatrix}0.46257015 \\0.72111518 \\0.90024951 \\0.40131234\end{bmatrix}\xrightarrow{\text{与阈值 }0.5\text{ 比较}}\quad\begin{bmatrix}0 \\1 \\1 \\0\end{bmatrix}\end{aligned}$$</span> <img src="05_sigmoid.png" /></p><blockquote><p>实际逻辑回归是一个翻译错误，Logistic并没有回归的意思，而是来自统计学中的 logodds（对数几率），后来发明了一个词 Logit来描述，实际应为对数几率回归，或对率回归。</p></blockquote><h1 id="损失函数">2 损失函数</h1><p>逻辑回归的损失函数通常使用对数损失（LogLoss），也称为二元交叉熵损失（Binary Cross-Entropy Loss） ，用于衡量模型输出的概率分布与真实标签之间的差距。逻辑回归的损失函数来源于最大似然估计（MLE）。 对数似然： <spanclass="math display">$$\logL({y,F(X)})=\sum_{i=1}^ny_i\mathrm{log}\,p_{x_i}+(1-y_i)\mathrm{log}\,(1-p_{x_i})$$</span><span class="math inline"><em>y</em><sub><em>i</em></sub></span> 是第<span class="math inline"><em>i</em></span> 个样本的真实值(0 或1)，<spanclass="math inline"><em>p</em><sub><em>x</em><sub><em>i</em></sub></sub></span>是第 <span class="math inline"><em>i</em></span> 个样本属于类别 1的概率。当 <spanclass="math inline"><em>y</em><sub><em>i</em></sub></span> 为 1时，右边消掉，当 <spanclass="math inline"><em>y</em><sub><em>i</em></sub></span> 为 0时，左边消掉，概率越低，把握越小，则 log值越小，当似然函数最大时，损失最小。</p><p>拟合就是求似然函数的最大值，为了方便优化，令损失函数为： <spanclass="math display">$$Loss=-\frac{1}{n}\sum_{i=1}^ny_i\mathrm{log}\,p_{x_i}+(1-y_i)\mathrm{log}\,(1-p_{x_i})$$</span>加上负号，求解损失函数的最小值即可，<spanclass="math inline">$\frac{1}{n}$</span> 则类似均方误差中的平均。</p><h1 id="api-使用">3 API 使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression()<br><br>model.fit(X_train, X_test)<br></code></pre></td></tr></table></figure><ul><li><code>penalty</code>：指定正则化类型，用于控制模型复杂度，防止过拟合，默认值为<code>l2</code>。</li><li><code>C</code>：正则化强度的倒数，默认值为 <code>1.0</code>。较小的<code>C</code> 值会加强正则化（更多限制模型复杂度），较大的<code>C</code> 值会减弱正则化（更注重拟合训练数据）。</li><li><code>solver</code>：指定优化算法，默认值为<code>lbfgs</code>，可选值包括：<ul><li><code>'lbfgs'</code>: 拟牛顿法（默认），仅支持 L2正则化</li><li><code>'newton-cg'</code>: 牛顿法，仅支持 L2正则化</li><li><code>'liblinear'</code>: 坐标下降法，适用于小数据集，支持 L1和L2正则化</li><li><code>'sag'</code>: 随机平均梯度下降，适用于大规模数据集，仅支持L2正则化</li><li><code>'saga'</code>: 改进的随机梯度下降，适用于大规模数据，支持L1、L2和 ElasticNet正则化</li></ul></li><li><code>multi_class</code>：指定多分类问题的处理方式，默认值为<code>'auto'</code>，根据数据选择 <code>'ovr'</code> 或<code>'multinomial'</code>，前者表示一对多策略，适合二分类或多分类的基础情况，后者表示多项式回归策略，适用于多分类问题，需与<code>'lbfgs'</code>、<code>'sag'</code> 或 <code>'saga'</code>搭配使用。</li><li><code>fit_intercept</code>：是否计算截距（偏置项），默认值为<code>True</code>。</li><li><code>class_weight</code>：类别权重，处理类别不平衡问题，默认值为<code>None</code>，设置为<code>'balanced'</code>可以根据类别频率自动调整权重。</li></ul><h1 id="多分类">4 多分类</h1><p>逻辑回归通常用于二分类问题，但可以通过一对多（One-vs-Rest，OvR）、一对一（One-vs-One,OvO）以及 Softmax 回归（Multinomial LogisticRegression，多项逻辑回归）来扩展到多分类任务。</p><h2 id="ovo-ovr">4.1 OvO OvR</h2><ul><li>OvO 存储开销和测试时间大，训练时间短</li><li>OvR 存储开销和测试时间小，训练时间长</li></ul><p><img src="05_ovo_ovr.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression(<br>    multi_class=<span class="hljs-string">&#x27;ovr&#x27;</span>  <span class="hljs-comment"># 设置 ovr 或者 ovo</span><br>)<br></code></pre></td></tr></table></figure><p><code>multi_class</code>在后续版本中将会被废弃，取而代之的是一个新的类来实现OvO、OvR。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.multiclass <span class="hljs-keyword">import</span> OneVsOneClassifier, OneVsRestClassifier<br><br>model1 = OneVsOneClassifier(estimator=LogisticRegression())<br>model2 = OneVsRestClassifier(estimator=LogisticRegression())<br></code></pre></td></tr></table></figure></p><h2 id="softmax-回归">4.2 Softmax 回归</h2><p>Softmax 回归（多项逻辑回归）直接扩展逻辑回归到多分类问题，使用Softmax 函数将模型输出转化为概率分布。 对于类别 c： <spanclass="math display">$$P(y=c|x)=\frac{e^{\beta_{c}^{T}x}}{\sum_{j=1}^{C}e^{\beta_{j}^{T}x}}$$</span>损失函数： <spanclass="math display">$$Loss=-\frac{1}{n}\sum_{i=1}^{n}\sum_{c=1}^{C}I(y_{i}=c)\mathrm{log}P(y_{i}=c|x_{i})$$</span>其中 <spanclass="math inline"><em>𝐼</em>(<em>𝑦</em><sub><em>𝑖</em></sub> = <em>c</em>)</span>为示性函数，当 <spanclass="math inline"><em>𝑦</em><sub><em>𝑖</em></sub> = <em>c</em></span>时值为 1，反之值为 0。</p><ul><li>优点：只训练 1 个模型，计算高效，分类一致性更好。</li><li>缺点：计算 Softmax 需要对所有类别求指数，计算量较高。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression(multi_class=<span class="hljs-string">&quot;multinomial&quot;</span>)<br></code></pre></td></tr></table></figure><p>对于多分类问题，LogisticRegression 会自动使用<code>multinomial</code>，因此 <code>multi_class</code>参数可省略。整体来看，大多数情况 Softmax 更加优秀，这也是为什么要把<code>multi_class</code> 移除。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>逻辑回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_线性回归</title>
    <link href="/2024/07/14/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/07/14/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>回归模型是机器学习和统计学中的一种基本模型，用于预测连续型输出变量。简单的说，给定一组输入变量（自变量）和对应的输出变量（因变量），回归模型旨在找到输入变量和输出变量之间的映射关系。</p><p>线性回归分类：</p><ul><li><p><strong>一元线性回归</strong>：建立一个因变量与单个自变量之间线性关系的模型，也就是只有一个特征。<spanclass="math display"><em>y</em> = <em>w</em><strong>x</strong> + <em>b</em></span><span class="math inline">$\small{y}$</span> 是目标变量（因变量），<span class="math inline"><strong>x</strong></span>是输入变量（自变量）， <span class="math inline"><em>b</em></span>是偏置（截距,intercept），<spanclass="math inline"><em>w</em></span>是权重（回归系数, regressioncoefficients）</p></li><li><p><strong>多元线性回归</strong>：建立一个因变量与多个自变量之间线性关系的模型，模型具有多个特征。<spanclass="math display"><em>y</em> = <em>w</em><sub>1</sub><em>x</em><sub>1</sub> + <em>w</em><sub>2</sub><em>x</em><sub>2</sub> + <em>w</em><sub>3</sub><em>x</em><sub>3</sub> + ⋯ + <em>w</em><sub><em>n</em></sub><em>x</em><sub><em>n</em></sub> + <em>b</em></span>可以用向量简化为：<spanclass="math inline"><em>y</em> = <strong>w</strong><sup><strong>T</strong></sup><strong>x</strong> + <em>b</em></span>或 <spanclass="math display"><em>y</em> = <strong>w</strong><sup><strong>T</strong></sup><strong>x</strong></span>其中， <spanclass="math inline"><strong>x</strong> <strong>=</strong> <strong>[</strong><strong>1</strong><strong>,</strong> <strong>x</strong><sub><strong>1</strong></sub><strong>,</strong> <strong>x</strong><sub><strong>2</strong></sub><strong>,</strong> <strong>…</strong><strong>,</strong> <strong>x</strong><sub><strong>n</strong></sub><strong>]</strong></span>是包含截距的输入向量， <spanclass="math inline"><strong>w</strong> <strong>=</strong> <strong>[</strong><strong>w</strong><sub><strong>0</strong></sub><strong>,</strong> <strong>w</strong><sub><strong>1</strong></sub><strong>,</strong> <strong>w</strong><sub><strong>2</strong></sub><strong>,</strong> <strong>…</strong><strong>,</strong> <strong>w</strong><sub><strong>n</strong></sub><strong>]</strong><sup><strong>T</strong></sup></span>是模型参数（包括截距 <span class="math inline"><em>b</em></span>和回归系数 <spanclass="math inline"><strong>w</strong><sub><strong>1</strong></sub><strong>,</strong> <strong>w</strong><sub><strong>2</strong></sub><strong>,</strong> <strong>⋯</strong><strong>,</strong> <strong>w</strong><sub><strong>n</strong></sub></span>）</p></li></ul><h1 id="线性回归求解">2 线性回归求解</h1><h2 id="损失函数">2.1 损失函数</h2><p>建立回归模型的目的是为了找到最佳的回归系数 <spanclass="math inline"><strong>w</strong></span> 和截距 <spanclass="math inline"><em>b</em></span> ，能够使预测值 <spanclass="math inline">${\hat{y_{i}}}$</span> 与实际观测值 <spanclass="math inline"><em>y</em><sub><em>i</em></sub></span>之间差异最小化。 <strong>损失函数（LossFunction）</strong>，也称为代价函数（Cost Function），定义损失函数为：<span class="math display">$$L(w)=\sum_{i=1}^{m}(\hat{y_i}-y_i)^2$$</span></p><blockquote><p>很多时候损失函数和代价函数两个术语存在混用，严谨来说： -损失函数：单个训练样本的误差，通常用 <spanclass="math inline"><em>L</em>(<em>w</em>)</span>, <spanclass="math inline"><em>L</em>(<em>w</em>, <em>b</em>)</span> -代价函数：整个训练集的平均误差，损失函数的平均，通常用 <spanclass="math inline"><em>J</em>(<em>θ</em>)</span></p></blockquote><p>损失函数 <span class="math inline"><em>L</em>(<em>w</em>)</span>最小化时便找到了最佳参数，这为优化参数指明了方向。</p><p><img src="04_loss.png" /></p><h2 id="正规方程法">2.2 正规方程法</h2><p><strong>正规方程法（Normal Equation）</strong>是一种直接计算线性回归模型参数（权重和偏置）的方法，它不需要像梯度下降那样的迭代过程。<img src="04_loss_matrix.png" /></p><p>整理后得出多元线性回归方程的解析解为： <spanclass="math display"><strong>w</strong> = (<strong>X</strong><sup><em>T</em></sup><strong>X</strong>)<sup>−1</sup><strong>X</strong><sup><em>T</em></sup><strong>y</strong></span></p><p><span class="math inline"><strong>X</strong></span>为特征值矩阵，<span class="math inline"><strong>y</strong></span>为目标值向量，<span class="math inline"><strong>w</strong></span>为参数向量，<span class="math inline"><em>w</em><sub>0</sub></span>为偏置。若 <spanclass="math inline"><em>X</em><sup><em>T</em></sup><em>X</em></span>不满秩，可以解出多个 <spanclass="math inline"><em>w</em></span>，此时需要设定归纳偏好，或引入正则化(regularization)。</p><p><span class="math display">$$X = \begin{bmatrix} 1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp;x_{1n} \\ 1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2n} \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp;x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{mn} \end{bmatrix}\;\;\;\;\;\;\;\;\;\;\;\;\;y = \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ y_m \end{bmatrix}\;\;\;\;\;\;\;\;\;\;\;\;\;w = \begin{bmatrix} w_0 \\ w_1 \\ \vdots \\ w_n \end{bmatrix}$$</span></p><h2 id="梯度下降法">2.3 梯度下降法</h2><h3 id="梯度下降思想">2.3.1 梯度下降思想</h3><p>梯度下降（GradientDescent）是一种优化算法，广泛应用于机器学习和深度学习中，用于找到最小化模型损失函数的参数。</p><p>梯度下降是一个迭代过程，不断重复以下步骤直到模型收敛，即损失不再明显减少：</p><ol type="1"><li><p><strong>初始化参数：</strong> 随机设定模型的初始参数<spanclass="math inline"><strong>w</strong></span>（包含权重和偏置）。</p></li><li><p><strong>计算损失：</strong> 使用当前的参数计算模型的损失函数<strong><spanclass="math inline"><em>J</em>(<strong>w</strong>)</span></strong>。</p></li><li><p><strong>计算梯度：</strong> 对损失函数 <strong><spanclass="math inline"><em>J</em>(<strong>w</strong>)</span></strong>计算偏导数，得到当前位置的梯度 <spanclass="math inline">∇<em>J</em>(<strong>w</strong>)</span>，得到损失函数变化最快的方向。<span class="math display">$$\nabla J(\mathbf{w}) = \left[\frac{\partial{J}}{\partial{w_{1}}},  \frac{\partial{J}}{\partial{w_{2}}},\cdots,  \frac{\partial{J}}{\partial{w_{n}}} \right]$$</span></p></li><li><p><strong>更新参数：</strong> 沿着梯度的反方向，根据学习率(learningrate) <span class="math inline"><em>α</em></span> 更新参数。 <spanclass="math display"><em>θ</em> = <em>θ</em> − <em>α</em> ⋅ ∇<em>J</em>(<strong>w</strong>)​</span></p></li><li><p><strong>重复：</strong> 返回到第 2步，用新的参数重复计算和更新，直到达到某一停止条件</p><ol type="1"><li>达到最大迭代次数</li><li>损失变化小于某个阈值。</li></ol></li></ol><h3 id="学习率的选择">2.3.2 学习率的选择</h3><ul><li>学习率过小：收敛速度慢，易陷入局部最优解</li><li>学习率过大：可能导致跳过最优解，甚至发散</li></ul><p><img src="04_learning_rate.png" /></p><p>自适应学习率：高级优化器（如Adam、Adagrad）动态调整学习率以提升性能</p><h3 id="梯度下降常见分类">2.3.3 梯度下降常见分类</h3><ol type="1"><li>批量梯度下降(Batch GradientDescent，BGD)：每次迭代使用<strong>全部训练数据</strong>计算梯度。<ul><li>优点：梯度方向稳定，更新平滑，收敛过程较稳定。</li><li>缺点：每次都计算整个训练集，计算量大，对大数据集效率低。</li></ul></li><li>随机梯度下降(Stochastic GradientDescent，SGD)：每次迭代随机选取<strong>一个样本</strong>计算梯度。<ul><li>优点：快速迭代，每次只用一个样本计算梯度；由于引入了随机性，有助于跳出局部最优解。</li><li>缺点：每次更新方向不确定，收敛过程波动很大，甚至难以收敛，在最小值附近震荡。</li></ul></li><li>小批量梯度下降(Mini-batch GradientDescent，MBGD)：每次迭代使用<strong>一小批样本</strong>(如32、64个)计算梯度。<ul><li>优点：计算成本相对 BGD 较低，又比 SGD 稳定，兼具 BGD 的稳定和 SGD的速度。</li><li>缺点：合适的 batch size 需要实验。</li></ul></li></ol><p><ahref="https://www.jeremyjordan.me/gradient-descent/">梯度下降优化扩展内容</a></p><h3 id="梯度下降常见问题">2.3.4 梯度下降常见问题</h3><p>特征缩放：通常需要提前对特征进行缩放（如标准化或归一化），以加快收敛速度。</p><p>局部最优解、鞍点问题：可能陷入局部最优解，或遇到鞍点（梯度为零但非极值点）。解决方案：使用动量（Momentum）、自适应优化器（如Adam）或二阶方法（如牛顿法）。</p><h2 id="正规方程和梯度下降对比">2.4 正规方程和梯度下降对比</h2><p>正规方程法：</p><ul><li>一次运算得出</li><li>不需要学习率</li><li>计算量大、容易受到噪声、特征强相关性的影响；如果数据不是线性的，无法使用或效果不好</li><li>应用场景：小数据量场景</li></ul><p>梯度下降法：</p><ul><li>需要迭代求解</li><li>需要选择学习率</li><li>应用场景：更加普适，适合于嘈杂、大数据场景，在各种损失函数中大量使用。在深度学习中模型参数轻松过亿，只能通过迭代求解</li></ul><h1 id="api-使用">3 API 使用</h1><h2 id="正规方程">3.1 正规方程</h2><p><code>LinearRegression</code>使用最小二乘法计算回归模型的参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><br>model = LinearRegression(<br>    fit_intercept=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 是否计算偏置</span><br>)<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure></p><h2 id="梯度下降">3.2 梯度下降</h2><p><code>SGDRegressor</code>使用随机梯度下降求解，随机梯度下降对特征的尺度非常敏感，通常需要在训练之前对特征进行标准化或归一化处理。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">form sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br><br>model = SGDRegressor(<br>    loss=<span class="hljs-string">&quot;squared_error&quot;</span>,  <span class="hljs-comment"># 损失函数，默认为均方误差</span><br>    penalty=<span class="hljs-string">&quot;l2&quot;</span>,  <span class="hljs-comment"># 正则化项，默认为 L2 正则</span><br>    fit_intercept=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 是否计算偏置</span><br>    learning_rate=<span class="hljs-string">&quot;constant&quot;</span>, <span class="hljs-comment"># 学习率策略</span><br>    eta0=<span class="hljs-number">0.1</span>, <span class="hljs-comment"># 初始学习率</span><br>    max_iter=<span class="hljs-number">1000</span>, <span class="hljs-comment"># 最大迭代次数</span><br>    tol=<span class="hljs-number">1e-8</span>, <span class="hljs-comment"># 损失值变化量小于 tol 时停止迭代</span><br>)<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure></p><ul><li><code>loss</code>：指定优化目标（损失函数），默认值为<code>'squared_error'</code>（最小二乘法），其他可以选择的值有：<code>'huber'</code>、<code>'epsilon_insensitive'</code>和 <code>'squared_epsilon_insensitive'</code>，其中<code>'huber'</code>适用于对异常值更鲁棒的回归模型。</li><li><code>penalty</code>：指定正则化方法，用于防止过拟合，默认为<code>'l2'</code>（L2正则化），其他可以选择的值有：<code>'l1'</code>（L1正则化）、<code>'elasticnet'</code>（弹性网络，L1和 L2 的组合）、<code>None</code>（不使用正则化）。</li><li><code>alpha</code>：正则化强度的系数，控制正则化项的权重，默认值为<code>0.0001</code>。较大的 <code>alpha</code>值会加重正则化的影响，从而限制模型复杂度；较小的值会让模型更关注训练数据的拟合。</li><li><code>l1_ratio</code>：当 <code>penalty='elasticnet'</code> 时，控制L1 和 L2 正则化之间的权重，默认值为 <code>0.15</code>，取值范围为<code>[0, 1]</code>（<code>0</code> 表示完全使用 L2，<code>1</code>表示完全使用 L1）。</li><li><code>tol</code>：优化算法的容差，即判断收敛的阈值，默认值为<code>1e-3</code>。当目标函数的改变量小于 <code>tol</code>时，训练会提前终止；如果希望训练更加精确，可以适当降低<code>tol</code>。</li><li><code>learning_rate</code>：指定学习率的调节策略，默认值为<code>'constant'</code>，表示使用固定学习率，具体的值由<code>eta0</code> 指定；其他可选项包括：<ul><li><code>'optimal'</code>：基于公式<code>eta = 1.0 / (alpha * (t + t0))</code>自动调整。</li><li><code>'invscaling'</code>：按<code>eta = eta0 / pow(t, power_t)</code> 缩放学习率。</li><li><code>'adaptive'</code>：动态调整，误差减少时保持当前学习率，否则减小学习率。</li></ul></li><li><code>eta0</code>：初始学习率，默认值为 <code>0.01</code>，当<code>learning_rate='constant'</code>或其他策略使用时，<code>eta0</code> 决定了初始更新步长。</li><li><code>power_t</code>：当 <code>learning_rate='invscaling'</code>时，控制学习率衰减速度，默认值为<code>0.25</code>。较小的值会让学习率下降得更慢，从而更长时间地关注全局优化。</li><li><code>early_stopping</code>：是否启用早停机制，默认值为<code>False</code>。如果设置为<code>True</code>，模型会根据验证集性能自动停止训练，防止过拟合。</li><li><code>validation_fraction</code>：指定用作验证集的训练数据比例，默认值为<code>0.1</code>。当 <code>early_stopping=True</code>时，该参数会起作用。</li><li><code>max_iter</code>：训练的最大迭代次数，默认值为<code>1000</code>。当数据较大或学习率较小时，可能需要增加迭代次数以保证收敛。</li><li><code>shuffle</code>：是否在每个迭代轮次开始时打乱训练数据，默认值为<code>True</code>，表示打乱数据。打乱数据有助于提高模型的泛化能力。</li><li><code>warm_start</code>：是否使用上次训练的参数继续训练，默认值为<code>False</code>。当设置为 <code>True</code>时，可以在已有模型的基础上进一步优化。</li><li><code>verbose</code>：控制训练过程的日志输出，默认值为<code>0</code>，可以设置为更高值以观察训练进度。</li></ul><h2 id="lasso-回归">3.3 Lasso 回归</h2><p>拉索（Lasso）回归在线性回归基础上引入 <spanclass="math inline">$\small{L1}$</span>正则化项，不仅防止过拟合，还具有特征选择的功能，特别适用于高维数据。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br><br>model = Lasso()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure></p><h2 id="ridge-回归">3.4 Ridge 回归</h2><p>岭（Ridge）回归在线性回归的基础上引入 <spanclass="math inline">$\small{L2}$</span>正则化项，目的是防止模型过拟合，尤其是当特征数较多或特征之间存在共线性时。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br><br>model = Ridge()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure></p><h2 id="elasticnet-回归">3.5 ElasticNet 回归</h2><p>弹性网络（ElasticNet）回归结合了岭回归和套索回归的优点，通过同时引入<span class="math inline">$\small{L1}$</span> 和 <spanclass="math inline">$\small{L2}$</span>正则化项，适用于高维数据且特征之间存在相关的情况。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> ElasticNet<br><br>model = ElasticNet()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_KNN算法</title>
    <link href="/2024/07/13/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_KNN%E7%AE%97%E6%B3%95/03_KNN%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/13/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_KNN%E7%AE%97%E6%B3%95/03_KNN%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>K近邻算法（k-nearest neighbors,KNN）是一种用于分类和回归的非参数统计方法。KNN算法的原理是<strong>从历史数据中找到 <spanclass="math inline">$\small{k}$</span>个跟新输入的实例最邻近的实例</strong>，根据它们中的多数所属的类别来对新实例进行分类或者输出新实例的目标值。K近邻算法没有显式的学习训练过程，它用的是“<strong>近朱者赤，近墨者黑</strong>”这样一种简单朴素的思想来实现分类或回归。</p><ul><li>分类问题：在K个最近邻的标签中取众数（由于可能平票，所以通常取奇数K）</li><li>回归问题：在K个最近邻的标签中取平均数</li></ul><h1 id="关键参数">2 关键参数</h1><h2 id="k值的选择">2.1 K值的选择</h2><ul><li>K值过小：在较小范围的训练实例中进行预测，容易受到异常值的影响，发生<strong>过拟合</strong></li><li>K值过大：在较大范围的训练实例中进行预测，容易受到均衡值的影响，发生<strong>欠拟合</strong></li></ul><h2 id="距离的度量">2.2 距离的度量</h2><h3 id="闵可夫斯基距离">2.2.1 闵可夫斯基距离</h3><p>我们可以用距离（distance）来衡量特征空间中两个实例之间的相似度，闵氏距离全称闵可夫斯基距离（MinkowskiDistance），对于两个 <span class="math inline">$\small{n}$</span> 维向量<span class="math inline">$\small{\mathbf{x}=(x_{1}, x_{2}, \cdots,x_{n})}$</span> 和 <span class="math inline">$\small{\mathbf{y}=(y_{1},y_{2}, \cdots, y_{n})}$</span> ，它们之间的距离可以定义为： <spanclass="math display">$$d(\mathbf{x}, \mathbf{y}) = (\sum_{i=1}^{n}{\vert x_{i} - y_{i}\rvert}^{p})^{\frac{1}{p}}$$</span></p><h3 id="曼哈顿距离">2.2.2 曼哈顿距离</h3><p>当 <span class="math inline"><em>p</em> = 1</span>时，闵式距离即曼哈顿距离（Manhattandistance），也就是线段对轴产生的投影的距离总和，特点是横平竖直。 <spanclass="math display">$$d(\mathbf{x}, \mathbf{y}) = \sum_{i=1}^{n} \lvert x_{i} - y_{i} \rvert$$</span> <img src="03_manhattan.png" /></p><h3 id="欧几里得距离">2.2.3 欧几里得距离</h3><p>当 <span class="math inline"><em>p</em> = 2</span>时，闵式距离即欧几里得距离（Euclideandistance），也就是现实意义上两点之间的距离。 <spanclass="math display">$$d(\mathbf{x}, \mathbf{y}) = \sqrt{\sum_{i=1}^{n}(x_{i} - y_{i})^{2}}$$</span> <img src="03_oujilide.png" /></p><h3 id="切比雪夫距离">2.2.4 切比雪夫距离</h3><p>当 <span class="math inline"><em>p</em> → ∞</span>时，闵式距离即切比雪夫距离，即每个轴上投影的最大值。 <spanclass="math display">$$d(\mathbf{x}, \mathbf{y}) = \underset{i}{max}(\lvert x_{i} - y_{i}\rvert)$$</span></p><p><img src="03_chebyshev.png" /></p><h1 id="特征预处理">3 特征预处理</h1><p>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响（支配）目标结果，使得一些模型（算法）无法学习到其它的特征。</p><h2 id="smote-过采样">3.1 SMOTE 过采样</h2><p>在垃圾邮件过滤时，正常邮件远多于垃圾邮件。如果直接用这种不平衡的数据去训练模型，模型会倾向于偷懒，因为它只要把所有样本都预测为多数类，就能获得很高的准确率。</p><p><strong>SMOTE</strong> 就是为了解决分类任务中<strong>数据类别不平衡</strong>问题的算法，通过人工合成新的少数类样本来平衡数据集，从而帮助机器学习模型更好地学习少数类的特征。</p><p>SMOTE 工作原理：</p><ol type="1"><li>选择少数样本：随机选择一个少数样本 A</li><li>找到 K 近邻：在所有少数样本中，找到 K 个 A 的最近邻，假设K=3，找到了 B,C,D</li><li>选择近邻：从 K 个最近邻中随机选择一个，比如选到了 C</li><li>生成新样本：在 A 和 C 的连线上随机选择一个点作为新样本</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install imbalanced-learn<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> imblearn.over_sampling <span class="hljs-keyword">import</span> SMOTE<br><br>smote = SMOTE(random_state=<span class="hljs-number">42</span>)<br>X_resampled, y_resampled = smote.fit_resample(X, y)<br></code></pre></td></tr></table></figure><h2 id="归一化">3.2 归一化</h2><p><strong>归一化 (Normalization)</strong>将数据缩放到一个固定的范围<code>[mi, mx]</code>，最常见的是 <strong>[0,1]</strong> 之间。 常用方法：Min-Max Scaling (最小-最大缩放)</p><ol type="1"><li><p>缩放到<code>[0, 1]</code>（把<spanclass="math inline"><em>x</em></span>到<spanclass="math inline"><em>m</em><em>i</em><em>n</em></span>的距离映射到整个范围<spanclass="math inline"><em>m</em><em>a</em><em>x</em> − <em>m</em><em>i</em><em>n</em></span>内）<span class="math display">$$X'=\frac{x-min}{max-min}$$</span></p></li><li><p>映射到<code>[mi, mx]</code>范围内（把<spanclass="math inline"><em>X</em><sup>′</sup></span>放缩<spanclass="math inline"><em>m</em><em>x</em> − <em>m</em><em>i</em></span>倍，再偏移<spanclass="math inline"><em>m</em><em>i</em></span>） <spanclass="math display"><em>X</em><sup>″</sup> = <em>X</em><sup>′</sup> · (<em>m</em><em>x</em> − <em>m</em><em>i</em>) + <em>m</em><em>i</em></span></p></li></ol><p>API实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><br><span class="hljs-comment"># 创建归一化对象，feature_range控制范围[mi, mx]</span><br>mms = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 对数据进行归一化</span><br><span class="hljs-comment"># fit_transform: 通常用于训练集，同时完成transform()和fit()</span><br><span class="hljs-comment"># transform: 通常用于测试集或新数据，使用之前训练集的参数直接transform()</span><br>X_train = mms.fit_transform(X_train)<br>X_test = mms.transform(X_test)<br></code></pre></td></tr></table></figure></p><ul><li>优点：保留了数据的原始分布</li><li>缺点：对异常值非常敏感，如果存在极端值，会使大部分数据压缩到很小的范围内</li></ul><h2 id="标准化">3.3 标准化</h2><p><strong>标准化 (Standardization)</strong>是将数据缩放成<strong>均值为 0，标准差为 1</strong>的分布。 <spanclass="math display">$$X'=\frac{X-μ}{σ}$$</span></p><p>其中<span class="math inline"><em>μ</em></span>为均值(mean)，<spanclass="math inline"><em>σ</em></span>为标准差(std)，先减掉均值变为均值为0，再除掉标准差放缩到标准差为1。</p><p>API实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br><span class="hljs-comment"># 创建标准化对象</span><br>ss = StandardScaler()<br><br><span class="hljs-comment"># 对数据进行标准化</span><br><span class="hljs-comment"># fit_transform: 通常用于训练集，同时完成transform()和fit()</span><br><span class="hljs-comment"># transform: 通常用于测试集或新数据，使用之前训练集的参数直接transform()</span><br>X_train  = ss.fit_transform(X_train)<br>X_test = ss.transform(X_test)<br><br><span class="hljs-comment"># 查看原始数据均值、标准差和方差</span><br><span class="hljs-built_in">print</span>(ss.mean_)<br><span class="hljs-built_in">print</span>(ss.scale_)<br><span class="hljs-built_in">print</span>(ss.var_)<br></code></pre></td></tr></table></figure></p><ul><li>优点：对异常值没那么敏感</li><li>缺点：标准化假设数据服从或近似服从正态分布。如果数据分布与正态分布相差较大，标准化后的效果可能不理想，甚至会适得其反，改变了数据的原始分布</li></ul><h2 id="独热编码">3.4 独热编码</h2><p>对于类别型（category）特征，整数编码会被视为有序数值，导致距离的错误计算，比如红色=1，黄色=2，绿色=3，红色和绿色直接的距离并不比红色和黄色之间远，它们之间都是平等的类别。使用<strong>独热编码（One-Hot Encoding）</strong>可将类别特征转换为二元向量，消除虚假的顺序关系。</p><table><thead><tr><th style="text-align: center;">颜色_红色</th><th style="text-align: center;">颜色_黄色</th><th style="text-align: center;">颜色_绿色</th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><br><span class="hljs-comment"># 创建独热编码对象，删除转换后的第一列</span><br>onehot = OneHotEncoder(drop_first=<span class="hljs-literal">True</span>)<br><br>X_train = onehot.fit_transform(X_train)<br>X_test = onehot.transform(X_test)<br></code></pre></td></tr></table></figure><p><strong>多重共线性</strong>是指特征之间存在高度线性相关关系的现象，上述例子中：<spanclass="math display"><em>颜</em><em>色</em>_<em>红</em><em>色</em> + <em>颜</em><em>色</em>_<em>黄</em><em>色</em> + <em>颜</em><em>色</em>_<em>绿</em><em>色</em> = 1</span>这种完全线性相关关系会导致特征矩阵的列之间存在完美共线性，模型参数估计会变得不稳定（矩阵不可逆或接近奇异），导致系数估计值方差增大、模型可解释性下降、过拟合等问题。</p><p>使用 <code>drop="first"</code>删掉第一列不仅能打破这种多重共线性，还能减少冗余特征，提升计算效率。</p><p>也可以使用 <code>pd.get_dummies(df)</code> 实现独热编码，返回DataFrame，可读性更强。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.get_dummies(df, drop_first=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><h2 id="标签编码">3.5 标签编码</h2><p><strong>标签编码器（LabelEncoder）</strong>将类别特征中的每个类别映射为一个唯一数字，比如将 “红色”、“绿色”、“蓝色”分别编码为 0、1、2。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder<br><br>X_train = [<span class="hljs-string">&#x27;蓝色&#x27;</span>, <span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-string">&#x27;黄色&#x27;</span>, <span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-string">&#x27;蓝色&#x27;</span>]<br><br>le = LabelEncoder()<br>X_train = le.fit_transform(X_train)<br>X_test = le.transform(X_test)<br><br>X_train<br><span class="hljs-comment"># array([1, 0, 2, 0, 1])</span><br></code></pre></td></tr></table></figure></p><h2 id="列转换器">3.6 列转换器</h2><p><strong>列转换器 (ColumnTransformer)</strong>可以在同一个数据集中，对不同类型的列（例如数值型、类别型、文本型）应用不同的预处理方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.compose <span class="hljs-keyword">import</span> ColumnTransformer<br><br>numerical_features = [<span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;收入&#x27;</span>]<br>categorical_features = [<span class="hljs-string">&#x27;职业&#x27;</span>, <span class="hljs-string">&#x27;婚姻状况&#x27;</span>]<br><br><span class="hljs-comment"># 创建列转换器</span><br>ct = ColumnTransformer(<br>    transformers=[<br>        <span class="hljs-comment"># 对数值型列进行标准化</span><br>        (<span class="hljs-string">&#x27;num&#x27;</span>, StandardScaler(), numerical_features),  <br>        <span class="hljs-comment"># 对类别型列进行独热编码</span><br>        (<span class="hljs-string">&#x27;cat&#x27;</span>, OneHotEncoder(drop_first=<span class="hljs-literal">True</span>), categorical_features) <br>    ],<br>    remainder=<span class="hljs-string">&#x27;passthrough&#x27;</span>  <span class="hljs-comment"># 其余列不进行处理</span><br>)<br><br>X_train = ct.fit_transform(X_train)<br>X_test = ct.transform(X_test)<br></code></pre></td></tr></table></figure></p><h1 id="模型训练">4 模型训练</h1><h2 id="数据集的加载">4.1 数据集的加载</h2><p>首先从<code>scikit-learn</code>加载鸢尾花数据集。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><br><span class="hljs-comment"># 加载数据集</span><br>iris = load_iris()<br><br><span class="hljs-comment"># 特征（150行4列的二维数组，分别是花萼长、花萼宽、花瓣长、花瓣宽）</span><br>X = iris[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-comment"># 标签（150个元素的一维数组，包含0、1、2三个值分别代表三种鸢尾花）</span><br>y = iris[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure></p><h2 id="数据集的划分">4.2 数据集的划分</h2><p>通过<code>scikit-learn</code>的封装好的函数<code>train_test_split</code>可以很方便地划分训练集和测试集，函数返回一个四元组，分别代表训练特征、测试特征、训练标签、测试标签。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-comment"># random_state 可以设定随机种子，生成相同的随机划分</span><br><span class="hljs-comment"># stratify 可以分层抽样，保持原有分布</span><br>X_train, X_test, y_train, y_test =<br>train_test_split(X, y, train_size=<span class="hljs-number">0.8</span>, random_state=<span class="hljs-number">18</span>, stratify=y)<br></code></pre></td></tr></table></figure></p><h2 id="分类实现">4.3 分类实现</h2><p>若样本类别不均衡，可设置<code>weights='distance'</code>以降低稀有类样本的误判风险。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br><span class="hljs-comment"># 创建模型</span><br>model = KNeighborsClassifier()<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 模型预测</span><br>y_pred = model.predict(X_test)<br></code></pre></td></tr></table></figure></p><h2 id="回归实现">4.4 回归实现</h2><p>KNN通常用来解决分类任务，不过也可以解决回归任务，通过计算k近邻的平均或加权平均值，来获得新实例目标值的预测。</p><p>KNN回归模型计算复杂度较高，而且对噪声数据非常敏感，在很多时候它并不是一个很好的选择，KNN回归通常适用于非线性关系明显且数据量不大的情况。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><br><span class="hljs-comment"># 创建模型</span><br>model = KNeighborsRegressor()<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 模型预测</span><br>y_pred = model.predict(X_test)<br></code></pre></td></tr></table></figure></p><blockquote><p>即便只有一个特征，也要将X处理为二维数组，因为<code>fit</code>不能接收一维数组作为第一个参数，可以使用<code>reshape(-1, 1)</code>将一维数组转化为n行1列的二维数组，其中<code>-1</code>表示自动计算。</p></blockquote><h1 id="模型评估">5 模型评估</h1><h2 id="准确率accuracy">5.1 准确率(accuracy)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.score(X_test, y_test)<br></code></pre></td></tr></table></figure><p>不能仅凭准确率判断模型好坏，因为类别不平衡的时候会干扰判断，此外还有查准率(精确率,Precision)、查全率(召回率, Recall)、F1-score等指标。</p><h2 id="混淆矩阵">5.2 混淆矩阵</h2><p>多分类问题中，混淆矩阵的行数和列数都等于类别数，也就是<spanclass="math inline"><em>n</em> × <em>n</em></span>的方阵，行表示真实标签，列表示预测标签。</p><ul><li><code>confusion_matrix</code>：生成分类模型混淆矩阵</li><li><code>classification_report</code>：生成分类模型评估报告<ul><li><strong>precision</strong>: 精确率</li><li><strong>recall</strong>: 召回率</li><li><strong>f1-score</strong>: F1度量</li><li><strong>support</strong>: 样本支持数</li><li><strong>accuracy</strong>: 准确率</li><li><strong>macro avg</strong>: 宏平均，每个类别的性能平均值</li><li><strong>weighted avg</strong>:加权平均，根据每个标签的比例进行加权平均</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix, classification_report<br><br><span class="hljs-comment"># 混淆矩阵</span><br><span class="hljs-built_in">print</span>(confusion_matrix(y_test, y_pred))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">array([[ 8, 0, 0], </span><br><span class="hljs-string">       [ 0, 11, 0], </span><br><span class="hljs-string">       [ 0, 1, 10]])</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 评估报告</span><br><span class="hljs-built_in">print</span>(classification_report(y_test, y_pred))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">             precision    recall    f1-score    support </span><br><span class="hljs-string">        0.0     1.00       1.00       1.00         8 </span><br><span class="hljs-string">        1.0     0.92       1.00       0.96        11 </span><br><span class="hljs-string">        2.0     1.00       0.91       0.95        11 </span><br><span class="hljs-string">          </span><br><span class="hljs-string">accuracy                              0.97        30 </span><br><span class="hljs-string">macro avg       0.97       0.97       0.97        30 </span><br><span class="hljs-string">weighted avg    0.97       0.97       0.97        30</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>使用热力图可视化混淆矩阵：</p><ul><li><code>confusion_matrix()</code>：计算混淆矩阵</li><li><code>heatmap()</code>：绘制热力图<ul><li><code>annot</code>：每个单元格显示数值</li><li><code>cmap</code>：热力图颜色</li><li><code>xticklabels</code>/<code>yticklabels</code>：坐标轴标签<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix<br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>]<br><br>cm = confusion_matrix(y_test, y_pred)<br><br>sns.heatmap(cm, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">&#x27;Blues&#x27;</span>,<br>            xticklabels=iris[<span class="hljs-string">&#x27;target_names&#x27;</span>], <br>            yticklabels=iris[<span class="hljs-string">&#x27;target_names&#x27;</span>])<br>            <br>plt.title(<span class="hljs-string">&#x27;混淆矩阵热力图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;预测标签&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;实际标签&#x27;</span>)<br></code></pre></td></tr></table></figure> <img src="03_heatmap.png" /></li></ul></li></ul><h1 id="参数调优">6 参数调优</h1><p>使用<code>scikit-learn</code>的<code>KNeighborsClassfier</code>创建分类器模型时，可以对模型的超参数进行设定，主要有以下几个参数：</p><ol type="1"><li><code>n_neighbors</code>：近邻的数量，就是 KNN 算法中 K 的值。</li><li><code>weights</code>：可以选择 <code>uniform</code>或<code>distance</code>，前者表示所有样本的权重相同，后者表示距离越近权重越高，默认值是<code>uniform</code>。当然，我们也可以通过传入自定义的函数来确定每个样本的权重。</li><li><code>algorithm</code>：有<code>auto</code>、<code>ball_tree</code>、<code>kd_tree</code>、<code>brute</code>四个选项，默认值为<code>auto</code>。其中<code>ball_tree</code>是一种树形结构，基于球体划分的方法将数据点分配到层次化的树结构中，在高维数据和稀疏数据场景下有较好的性能；<code>kd_tree</code>也是一种树形结构，通过选择一个维度将空间划分为若干个子区域再进行搜索，从而避免跟所有的邻居进行比较，对于低维度和空间分布均匀的数据，后者有较好的效果，在高维空间中会遇到的维度灾难问题；<code>auto</code>选项是根据输入数据的维度自动选择<code>ball_tree</code>或<code>kd_tree</code>；<code>brute</code>选项则是使用暴力搜索算法（穷举法），再处理小数据集时，它是一个简单且有效的选择。</li><li><code>leaf_size</code>：使用 <code>ball_tree</code>或<code>kd_tree</code>算法时，该参数用于限制树结构叶子节点最大样本数量，默认值为<code>30</code>，该参数会影响树的构建和节点查找的性能。</li><li><code>p</code>：闵可夫斯基距离公式中的<code>p</code>，默认值为2，计算欧氏距离。</li></ol><h2 id="网格搜索">6.1 网格搜索</h2><p>手动调整费时费力，可以使用 <strong>网格搜索(Grid Search) 和交叉验证(Cross Validation)</strong> 对模型的超参数进行调整。</p><ul><li>网格搜索：通过穷举法遍历给定的超参数空间</li><li>交叉验证：通常使用K-foldCV，划分K折，每次使用1折做测试集，重复K次</li></ul><p><img src="03_kfold.png" /></p><p>API实现：</p><ul><li><code>GridSearchCV</code>：<ul><li><code>estimator</code>：要优化的模型</li><li><code>param_grid</code>：超参数搜索空间，是字典，键为超参数，值为超参数取值列表</li><li><code>cv</code>：交叉验证的折数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br><span class="hljs-comment"># 网格搜索交叉验证</span><br>gs = GridSearchCV(<br>    estimator=KNeighborsClassifier(),<br>    param_grid=&#123;<br>        <span class="hljs-string">&quot;n_neighbors&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>],<br>        <span class="hljs-string">&quot;weights&quot;</span>: [<span class="hljs-string">&#x27;uniform&#x27;</span>, <span class="hljs-string">&#x27;distance&#x27;</span>],<br>        <span class="hljs-string">&#x27;p&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>    &#125;,<br>    cv=<span class="hljs-number">5</span><br>)<br><br><span class="hljs-comment"># 在训练集上进行网格搜索</span><br>gs.fit(X_train, y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最佳参数：&#x27;</span>, gs.best_params_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最佳得分：&#x27;</span>, gs.best_score_)<br><br><span class="hljs-comment"># 最佳模型</span><br>best_model = gs.best_estimator_<br><br><span class="hljs-comment"># 直接使用最佳模型进行预测</span><br>gs.predict(X_test)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="optuna">6.2 Optuna</h2><p>Optuna是一个自动化超参数优化框架，设计用于简化超参数调优过程并提高模型性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> optuna<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 定义目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">objective</span>(<span class="hljs-params">trial</span>):<br>    <span class="hljs-comment"># 在目标函数中定义超参数的搜索范围</span><br>    n_estimators = trial.suggest_int(<span class="hljs-string">&quot;n_estimators&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 树的数量</span><br>    max_depth = trial.suggest_int(<span class="hljs-string">&quot;max_depth&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 树的最大深度</span><br><br>    <span class="hljs-comment"># 创建并训练模型</span><br>    model = RandomForestClassifier(n_estimators=n_estimators, <br>                                   max_depth=max_depth,<br>                                   random_state=<span class="hljs-number">42</span>)<br>    model.fit(X_train, y_train)<br>    <br>    <span class="hljs-comment"># 进行预测</span><br>    preds = model.predict(X_test)<br>    <br>    <span class="hljs-comment"># 计算准确率</span><br>    accuracy = accuracy_score(y_test, preds)<br>    <span class="hljs-keyword">return</span> accuracy  <span class="hljs-comment"># 返回目标函数值</span><br><br><span class="hljs-comment"># 创建一个 Study 对象并进行优化</span><br>study = optuna.create_study(direction=<span class="hljs-string">&quot;maximize&quot;</span>)  <span class="hljs-comment"># 目标是最大化准确率</span><br>study.optimize(objective, n_trials=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 进行 50 次优化</span><br><br><span class="hljs-comment"># 打印最优结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best accuracy: &quot;</span>, study.best_value)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best parameters: &quot;</span>, study.best_params)<br></code></pre></td></tr></table></figure><h1 id="模型保存和加载">7 模型保存和加载</h1><p>保存： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> joblib<br><br>joblib.dump(model, <span class="hljs-string">&#x27;model/model_name.pkl&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>加载： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = joblib.load(<span class="hljs-string">&#x27;model/model_name.pkl&#x27;</span>)<br></code></pre></td></tr></table></figure></p><h1 id="手撕knn">8 手撕KNN</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-comment"># 1.数据加载</span><br><br>iris = load_iris()<br><span class="hljs-comment"># 特征（150行4列的二维数组，分别是花萼长、花萼宽、花瓣长、花瓣宽）</span><br>X = iris[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-comment"># 标签（150个元素的一维数组，包含0、1、2三个值分别代表三种鸢尾花）</span><br>y = iris[<span class="hljs-string">&#x27;target&#x27;</span>]<br><span class="hljs-comment"># 拼接为一个数组</span><br>data = np.hstack([X, y.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2.数据集划分</span><br><br><span class="hljs-comment"># 在原数组内随机打乱</span><br>np.random.shuffle(data)<br><br><span class="hljs-comment"># 设定训练集大小</span><br>train_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(X) * <span class="hljs-number">0.8</span>)<br><br><span class="hljs-comment"># 索引切片划分训练集和测试集</span><br>X_train, X_test = data[:train_size, :-<span class="hljs-number">1</span>], data[train_size:, :-<span class="hljs-number">1</span>]<br>y_train, y_test = data[:train_size, -<span class="hljs-number">1</span>], data[train_size:, -<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3.计算欧氏距离函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_distance</span>(<span class="hljs-params">u, v</span>):    <br>    <span class="hljs-string">&quot;&quot;&quot;计算n维向量的欧氏距离&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> np.sqrt(np.<span class="hljs-built_in">sum</span>((u - v) ** <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.预测单个向量的标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_label</span>(<span class="hljs-params">X_train, y_train, X_one, k</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据历史数据的k个最近邻生成标签</span><br><span class="hljs-string">    param:</span><br><span class="hljs-string">        X_train: 训练集特征</span><br><span class="hljs-string">        y_train: 训练集标签</span><br><span class="hljs-string">        X_one: 待预测的样本特征</span><br><span class="hljs-string">        k: k个最近邻</span><br><span class="hljs-string">    return: 为待预测样本生成的特征</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 遍历求解每个训练集与待测样本的距离</span><br>    dis = [get_distance(X, X_one) <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> X_train]<br><br>    <span class="hljs-comment"># 求解前k个最近邻的标签</span><br>    labels = y_train[np.argpartition(dis, k)[:k]]<br><br>    <span class="hljs-comment"># 返回k个最近邻标签的众数</span><br>    <span class="hljs-keyword">return</span> stats.mode(labels).mode<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 5.预测输入数据集的标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X_train, y_train, X_in, k=<span class="hljs-number">5</span></span>):<br>    <span class="hljs-keyword">return</span> [make_label(X_train, y_train, X, k) <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> X_in]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>KNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_机器学习基本理论</title>
    <link href="/2024/07/12/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/"/>
    <url>/2024/07/12/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习三要素">1 机器学习三要素</h1><p><strong>机器学习方法 = 模型 + 策略 + 算法</strong></p><ul><li>模型(model)：总结数据的内在规律，用数学语言描述的参数系统</li><li>策略(strategy)：选取最优模型的评价准则</li><li>算法(algorithm)：选取最优模型的具体方法</li></ul><h1 id="机器学习方法分类">2 机器学习方法分类</h1><p><img src="02_algorithm_sum.png" /></p><h1 id="建模流程">3 建模流程</h1><ol type="1"><li><strong>收集数据</strong>：收集用于训练和测试的数据集，确保数据代表实际问题的不同方面</li><li><strong>数据清洗</strong>：对数据进行清洗，去除掉脏数据和不可用的数据</li><li><strong>特征工程</strong>：对数据进行转换和格式化，确保适合用于机器学习模型训练</li><li><strong>选择算法</strong>：选择适合任务类型(分类、回归、聚类等)和数据特征的机器学习算法</li><li><strong>模型训练</strong>：使用训练集数据训练模型，让模型从数据中学习规律</li><li><strong>模型评估</strong>：使用测试集评估模型性能，确认是否达到预期效果</li><li><strong>模型优化</strong>：确保模型有较好性能的基础上进一步提高模型效果</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境，实时监控其表现</li></ol><h1 id="特征工程">4 特征工程</h1><h2 id="特征工程概述">4.1 特征工程概述</h2><p>特征工程 (FeatureEngineering)是机器学习过程中非常重要的一步，通过对原始数据的处理、转换和构造，生成新的特征或选择有效的特征，从而提高模型的性能。优秀的特征工程可以显著提高模型的表现，忽视特征工程可能导致模型性能欠佳。</p><blockquote><p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</p></blockquote><h2 id="特征工程内容">4.2 特征工程内容</h2><h3 id="特征选择">4.2.1 特征选择</h3><p>从原始特征中挑选出<strong>与目标变量关系最密切的特征</strong>，剔除冗余、无关或噪声特征。减少模型的复杂度、加速训练过程、并减少过拟合的风险。</p><p>特征选择不会创建新特征，也不会改变数据结构。</p><ul><li>过滤法(FilterMethod)：基于统计测试(如卡方检验、相关系数、信息增益等)来评估特征与目标变量之间的关系，选择最相关的特征。</li><li>包裹法(Wrapper Method)：使用模型(如递归特征消除RFE)来评估特征的重要性，并根据模型的表现进行特征选择。</li><li>嵌入法(EmbeddedMethod)：使用模型本身的特征选择机制(如决策树的特征重要性，L1正则化的特征选择)来选择最重要的特征。</li></ul><h3 id="特征转换">4.2.2 特征转换</h3><p>对数据进行数学或统计处理，使其变得更加适合模型的输入要求。</p><ul><li><strong>归一化(Normalization)</strong>：将特征缩放到特定的范围(通常是0 到 1 之间)。适用于对尺度敏感的模型(如 KNN、SVM)。</li><li><strong>标准化(Standardization)</strong>：通过减去均值并除以标准差，使特征的分布具有均值0，标准差 1。</li><li><strong>对数变换</strong>：对于有偏态的分布(如收入、价格等)，对数变换可以将其转化为更接近正态分布的形式。</li><li>类别(category)变量的编码<ul><li><strong>独热编码 (One-Hot Encoding)</strong>：将类别型变量转换为二进制列，常用于无序类别特征，如红色、绿色、蓝色。</li><li><strong>标签编码(LabelEncoding)</strong>：将类别型变量映射为整数，常用于有序类别特征，如高、中、低。</li><li><strong>目标编码(TargetEncoding)</strong>：将类别变量的每个类别替换为其对应目标变量的平均值或其他统计量。</li><li><strong>频率编码(FrequencyEncoding)</strong>：将类别变量的每个类别替换为该类别在数据集中的出现频率。</li></ul></li></ul><h3 id="特征构造">4.2.3 特征构造</h3><p>特征构造是基于现有的特征创造出新的、更有代表性的特征。通过组合、转换、或者聚合现有的特征，形成能够更好反映数据规律的特征。</p><ul><li><p><strong>交互特征</strong>：将两个特征组合起来，形成新的特征。例如，两个特征的乘积、和或差等。例如，将年龄与收入结合创建新的特征，可能能更好地反映某些模式。</p></li><li><p><strong>统计特征</strong>：从原始特征中提取统计值，例如求某个时间窗口的平均值、最大值、最小值、标准差等。例如，在时间序列数据中，从原始数据中提取每个小时、每日的平均值。</p></li><li><p><strong>日期和时间特征</strong>：从日期时间数据中提取如星期几、月份、年份、季度等特征。例如，将“2000-01-01”转换为“星期几”、“是否节假日”、“月初或月末”等特征。</p></li></ul><h3 id="特征降维">4.2.4 特征降维</h3><p>当数据集的特征数量非常大时，特征降维可以帮助减少计算复杂度并避免过拟合。通过降维方法，可以在保持数据本质的情况下减少特征的数量。</p><ul><li><strong>主成分分析(PCA)</strong>：通过线性变换将原始特征映射到一个新的空间，使得新的特征(主成分)尽可能地保留数据的方差。</li><li><strong>线性判别分析(LDA)</strong>：一种监督学习的降维方法，通过最大化类间距离与类内距离的比率来降维。</li><li><strong>t 分布随机近邻嵌入(t-Distributed Stochastic NeighborEmbedding，t-SNE)</strong>：一种非线性的降维技术，特别适合可视化高维数据。</li><li><strong>自编码器(AutoEncoder)</strong>：一种神经网络模型，通过压缩编码器来实现数据的降维。</li></ul><h2 id="常用方法">4.3 常用方法</h2><p>对于一个模型来说，有些特征可能很关键，而有些特征可能用处不大。因此<strong>特征选择</strong>是最基本的操作。有时也会遇到维度灾难，即特征数量过多，在确保不丢失重要特征的前提下减少维度的数量，经常会用到<strong>特征降维</strong>。</p><h3 id="低方差过滤法">4.3.1 低方差过滤法</h3><p>低方差意味着该特征的样本值几乎都一样，对预测影响很小，可以直接去掉。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold<br><br><span class="hljs-comment"># 过滤掉方差低于 0.1 的特征</span><br>var_thresh = VarianceThreshold(threshold=<span class="hljs-number">0.1</span>)<br>X_filtered = var_thresh.fit_transform(X)<br></code></pre></td></tr></table></figure></p><h3 id="相关系数法">4.3.2 相关系数法</h3><p>通过计算特征与目标变量或特征之间的相关性，筛选出高相关性特征(与目标相关)或剔除冗余特征(特征间高度相关)。</p><ol type="1"><li><strong>皮尔逊相关系数 (PearsonCorrelation)</strong>：用于衡量两个变量的<strong>线性相关性</strong>，考察的是变量之间沿着一条直线的相似程度。</li></ol><p><span class="math display">$$r=\frac{\sum_{i=1}^n(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\sum_{i=1}^n(x_i-\bar{x})^2}\sqrt{\sum_{i=1}^n(y_i-\bar{y})^2}}$$</span></p><p>适用于<strong>连续变量</strong>，且这些变量近似服从<strong>正态分布</strong>。如果数据不符合正态分布，或者关系不是线性的，皮尔逊相关系数可能无法准确反映变量间的关系。</p><p>取值范围[-1, 1]：</p><ul><li>+1 表示完全正相关(一个变量增加，另一个也增加)</li><li>-1 表示完全负相关(一个变量增加，另一个减少)</li><li>0 表示没有线性相关性</li></ul><p>使用<code>pandas.DataFrame.corrwith(method="pearson")</code>可以计算各个特征与标签间的皮尔逊相关系数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">X.corrwith(y, method=<span class="hljs-string">&#x27;pearson&#x27;</span>)<br><span class="hljs-comment"># sepal length (cm) 0.798078 </span><br><span class="hljs-comment"># sepal width (cm) -0.440290 </span><br><span class="hljs-comment"># petal length (cm) 0.935431 </span><br><span class="hljs-comment"># petal width (cm) 0.938179 </span><br><span class="hljs-comment"># dtype: float64</span><br></code></pre></td></tr></table></figure></p><p>使用 <code>pandas.DataFrame.corr(method="pearson")</code>计算皮尔逊相关系数矩阵。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">corr_matrix = X.corr(method=<span class="hljs-string">&#x27;pearson&#x27;</span>)<br></code></pre></td></tr></table></figure></p><table style="width:100%;"><thead><tr><th></th><th>sepal length (cm)</th><th>sepal width (cm)</th><th>petal length (cm)</th><th>petal width (cm)</th><th>label</th></tr></thead><tbody><tr><td>sepal length (cm)</td><td>1.000000</td><td>-0.117570</td><td>0.871754</td><td>0.817941</td><td>0.782561</td></tr><tr><td>sepal width (cm)</td><td>-0.117570</td><td>1.000000</td><td>-0.428440</td><td>-0.366126</td><td>-0.426658</td></tr><tr><td>petal length (cm)</td><td>0.871754</td><td>-0.428440</td><td>1.000000</td><td>0.962865</td><td>0.949035</td></tr><tr><td>petal width (cm)</td><td>0.817941</td><td>-0.366126</td><td>0.962865</td><td>1.000000</td><td>0.956547</td></tr><tr><td>label</td><td>0.782561</td><td>-0.426658</td><td>0.949035</td><td>0.956547</td><td>1.000000</td></tr></tbody></table><p>使用热力图将皮尔逊矩阵可视化。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.heatmap(corr_matrix, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;.2f)</span><br></code></pre></td></tr></table></figure></p><p><img src="02_heatmap.png" /></p><ol start="2" type="1"><li><strong>斯皮尔曼相关系数(Spearman’s Rank CorrelationCoefficient)</strong>：用于衡量两个变量之间的<strong>单调关系</strong>，考察的是一个变量增加时，另一个变量也倾向于增加或减少的程度，不一定是线性关系。其中 <spanclass="math inline"><em>d</em><sub><em>i</em></sub></span>是两个变量在排名时的差异，<spanclass="math inline"><em>n</em></span> 是样本大小。 <spanclass="math display">$$ρ=1−\frac{6\sum_{i=1}^n​d_i^2​}{n(n^2−1)}​$$</span></li></ol><p>取值范围 [-1, 1]：</p><ul><li>+1 表示完全单调递增关系</li><li>-1 表示完全单调递减关系</li><li>0 表示没有单调关系</li></ul><p>适用于<strong>连续变量或离散变量</strong>。对数据的分布没有严格要求，即使数据不服从正态分布也可以使用。特别适合于处理顺序数据(例如，排名)。</p><p>使用 <code>pandas.DataFrame.corrwith(method="spearman")</code>计算斯皮尔曼相关系数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">X.corrwith(y, method=<span class="hljs-string">&#x27;spearman&#x27;</span>)<br><span class="hljs-comment"># sepal length (cm)    0.798078</span><br><span class="hljs-comment"># sepal width (cm)    -0.440290</span><br><span class="hljs-comment"># petal length (cm)    0.935431</span><br><span class="hljs-comment"># petal width (cm)     0.938179</span><br><span class="hljs-comment"># dtype: float64</span><br></code></pre></td></tr></table></figure></p><p>同样可以使用 <code>pandas.DataFrame.corr(method="spearman")</code>来计算斯皮尔曼相关系数矩阵。</p><h3 id="主成分分析pca">4.3.3 主成分分析(PCA)</h3><p>主成分分析(Principal Component Analysis，PCA)是一种常用的降维技术，通过线性变换将高维数据投影到低维空间，同时保留数据的主要变化模式。</p><p>使用 <code>sklearn.decomposition.PCA(n_components=2)</code>进行主成分分析。 参数<code>n_components</code> ：</p><ul><li>小数：表示保留多少比例的信息</li><li>整数：表示保留多少个维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><br><span class="hljs-comment"># 保留两个维度的特征</span><br>pca = PCA(n_components=<span class="hljs-number">2</span>)<br>X_pca = pca.fit_transform(X)<br></code></pre></td></tr></table></figure><p>可视化： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># 转换前的三维可视化</span><br>ax1 = fig.add_subplot(<span class="hljs-number">121</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>ax1.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], X[:, <span class="hljs-number">2</span>])<br>ax1.set_title(<span class="hljs-string">&#x27;Before PCA(3D)&#x27;</span>)<br>ax1.set_xlabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&quot;Feature 2&quot;</span>)<br>ax1.set_zlabel(<span class="hljs-string">&quot;Feature 3&quot;</span>)<br><br><span class="hljs-comment"># 转换后的二维可视化</span><br>ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>ax2.scatter(X_pca[:, <span class="hljs-number">0</span>], X_pca[:, <span class="hljs-number">1</span>])<br>ax2.set_title(<span class="hljs-string">&#x27;After PCA(2D)&#x27;</span>)<br>ax2.set_xlabel(<span class="hljs-string">&quot;Principal Component 1&quot;</span>)<br>ax2.set_ylabel(<span class="hljs-string">&quot;Principal Component 2&quot;</span>)<br></code></pre></td></tr></table></figure> <img src="02_pca.png" /></p><h1 id="模型评估和选择">5 模型评估和选择</h1><h2 id="损失函数">5.1 损失函数</h2><p>预测结果 <span class="math inline"><em>f</em>(<em>X</em>)</span>和真实值 <span class="math inline"><em>y</em></span>之间的存在偏差，我们使用损失函数(lossfunction)来度量预测偏差的程度，记作 <spanclass="math inline"><em>L</em>(<em>y</em>, <em>f</em>(<em>X</em>))</span>，损失函数是非负实值函数，损失函数值越小，模型越好。</p><p>常见损失函数：</p><ul><li><p>0-1损失函数 <span class="math display">$$L(y,f(X))=\begin{cases} 1,\quad y≠f(X) \\ 0,\quad y=f(X) )\end{cases}$$</span></p></li><li><p>平方损失函数 <spanclass="math display"><em>L</em>(<em>y</em>, <em>f</em>(<em>X</em>)) = (<em>y</em> − <em>f</em>(<em>X</em>))<sup>2</sup></span></p></li><li><p>绝对损失函数 <spanclass="math display"><em>L</em>(<em>y</em>, <em>f</em>(<em>X</em>)) = |<em>y</em> − <em>f</em>(<em>X</em>)|</span></p></li><li><p>对数似然损失函数 <spanclass="math display"><em>L</em>(<em>y</em>, <em>F</em>(<em>X</em>)) = −[<em>y</em> log  <em>p</em><sub><em>x</em></sub> + (1 − <em>y</em>) log  (1 − <em>p</em><sub><em>x</em></sub>)]</span><span class="math inline"><em>y</em></span> 是实际标签（ <spanclass="math inline"><em>y</em> ∈ {0, 1}</span> ，表示类别 0 或 1），<span class="math inline"><em>p</em><sub><em>x</em></sub></span>是模型预测的样本 <span class="math inline"><em>x</em></span> 属于类别 1的概率。</p></li></ul><h2 id="经验误差">5.2 经验误差</h2><p>根据选取的损失函数，就可以计算出模型 <spanclass="math inline"><em>f</em>(<em>X</em>)</span>在训练集上的平均误差，称为训练误差，也被称作 <strong>经验误差(empiricalerror)</strong> 或 经验风险(empirical risk)。 <spanclass="math display">$$R_{emp}= \frac{1}{n}\sum _{i=1}^nL(y_i, f(x_i))$$</span> 类似地，在测试集上的平均误差，被称为测试误差或者<strong>泛化误差 (generalization error)</strong>。</p><p>一般情况下对模型评估的策略，就是考察经验误差；当经验风险最小时，就认为取到了最优的模型。这种策略被称为<strong>经验风险最小化(empirical risk minimization，ERM)</strong>。</p><h2 id="欠拟合和过拟合">5.3 欠拟合和过拟合</h2><p>拟合(Fitting)是指机器学习模型在训练数据上学习到规律并生成预测结果的过程。<img src="02_fitting_model.png" /></p><p><strong>过拟合(overfitting)</strong>：模型在训练集上学得太好，甚至记住了噪声或偶然特征，导致在训练集表现好、测试集表现差。<strong>欠拟合(underfitting)</strong>：模型对训练数据学习不足，连训练集都拟合不好，模型太简单、能力不够，无法捕捉数据中的真实规律。</p><p>欠拟合通过增加模型复杂度、增加特征或改进特征工程、增加训练时间、减少正则化强度即可，一般来说更容易遇到、并且不易解决的问题是过拟合。</p><ul><li>过拟合产生原因：<ul><li>模型复杂度过高：模型过于复杂，参数过多</li><li>训练数据不足：数据集太小，模型学到的细节无法泛化到新数据</li><li>特征过多：模型记住了数据的噪声，而不是规律</li><li>训练时间过长：模型学会了数据中的噪声，而不是规律</li></ul></li><li>过拟合解决方案：<ul><li>减少模型复杂度：降低模型参数数量，使用简化的模型或降维</li><li>增加训练数据：收集更多数据增强数据多样性</li><li><strong>使用正则化：引入 L1 、L2 正则化</strong></li><li>早停：模型验证损失不再下降时，提前停止训练</li></ul></li></ul><h2 id="正则化">5.4 正则化</h2><p>正则化(Regularization)通过在损失函数中添加额外项，<strong>惩罚过大的参数</strong>，进而限制模型复杂度、避免过拟合，提高模型泛化能力。</p><p>如在平方损失函数中加入正则化： <span class="math display">$$Loss=\frac{1}{n}{\left(\sum_{i=1}^n(f(x_i)-y_i)^2+\lambda\sum_{i=1}^k{w_i}^2\right)}$$</span> 𝜆是<strong>正则化系数</strong>，用来表示<strong>惩罚项的权重</strong>。正则化系数需在模型训练开始之前手动设置，是“超参数”。</p><ul><li>𝜆 过大：可能使模型太简单，导致欠拟合</li><li>𝜆 过小：可能使模型太复杂，导致过拟合</li></ul><p>原损失函数和正则化项相互平衡，在模型的拟合能力和复杂度之间找到最佳折中。</p><ul><li>原损失函数的目的：更好的拟合数据集</li><li>正则化项的目的：减小参数的大小，从而降低模型复杂度</li></ul><p>常见的正则化技术有 L1 正则化和 L2 正则化。</p><h3 id="l1-正则化lasso回归">5.4.1 L1 正则化(Lasso回归)</h3><p>L1 正则化在损失函数中加入参数的绝对值之和： <spanclass="math display">$$Loss_{L1}=\text{原}Loss+\lambda\sum_{i=1}^k|w_i|$$</span>L1 正则化通过惩罚模型参数的绝对值，使得部分权重<strong>趋近 0 甚至变为0</strong>。这会导致<strong>特</strong><strong>征选择</strong>，即模型会自动“丢弃”一些不重要的特征。</p><blockquote><p>在解决回归问题时，使用 L1 正则化也被称为“Lasso 回归”。</p></blockquote><h3 id="l2-正则化ridge回归">5.4.2 L2 正则化(Ridge回归)</h3><p>L2 正则化在损失函数中加入参数的平方之和： <spanclass="math display">$$Loss_{L2}=\text{原}Loss+\lambda\sum_{i=1}^kw_i{}^2$$</span>L2正则化通过惩罚模型参数的平方，使得所有参数都变得更小，但不会将参数强行压缩为 0。它会使得模型<strong>尽量平滑</strong>，从而防止过拟合。</p><p>由于 L2 正则化平方的存在，虽然在 <spanclass="math inline"><em>w</em><sub><em>i</em></sub></span> 绝对值大于 1时，惩罚力度更大，但是当 <spanclass="math inline"><em>w</em><sub><em>i</em></sub></span> 绝对值小于 1时，惩罚力度变小，所以即使某个特征对模型影响很小，也不会将其权重压缩为0。 <img src="02_L1_L2.png" /></p><blockquote><p>在解决回归问题时，使用 L2 正则化也被称为“岭回归”。</p></blockquote><h3 id="elasticnet-正则化弹性网格回归">5.4.3 ElasticNet正则化(弹性网格回归)</h3><p>ElasticNet 正则化结合了 L1 和 L2正则化，通过调整两个正则化项的比例来取得平衡，从而同时具备稀疏性和稳定性的优点。<span class="math display">$$Loss_{ElasticNet}=\text{原}Loss+\lambda\left(\alpha\sum_{i=1}^n|\omega_i|+(1-\alpha)\sum_{i=1}^n\omega_i^2\right)$$</span> 其中 <span class="math inline"><em>α</em></span> 是控制 L1 和L2 正则化的比例。</p><h2 id="评估方法">5.5 评估方法</h2><h3 id="留出法hold-out">5.5.1 留出法(Hold-Out)</h3><p>留出法(Hold-Out Validation)将数据划分为训练集、验证集和测试集(如70%训练，30%测试)。结果受单次划分影响较大，可能高估或低估模型性能。</p><h3 id="k-折交叉验证k-fold-cv">5.5.2 k 折交叉验证(k-Fold CV)</h3><p>交叉验证(Cross-Validation)是一种评估模型泛化能力的方法，通过将数据集划分为多个子集，反复进行训练和验证，以减少因单次数据划分带来的随机性误差。</p><p>k 折交叉验证(k-Fold Cross-Validation)将数据均匀分为 k个子集(称为“折”)，每次用 k−1 折训练，剩余 1 折验证，重复 k次后取平均性能。充分利用数据，结果更稳定。k 一般取 10、5。 <imgsrc="02_kfold.png" /></p><h3 id="留一法leave-one-out">5.5.3 留一法(Leave-One-Out)</h3><p>留一法(Leave-One-Out, LOO) 是 k-Fold的特殊形式，每次仅留一个样本作为验证集，其余全部用于训练，重复直到所有样本都被验证一次。适用于小数据集，计算成本极高。</p><h1 id="模型求解算法">6 模型求解算法</h1><p>模型求解其实就是寻找最优参数，让增加了正则化之后的损失函数最小化，称为结构风险最小化(StructuralRisk Minimization，SRM)。 <spanclass="math display">$$\min\frac{1}{n}(\sum_{i=1}^nL(y_i,f(x_i))+\lambdaJ(\theta))$$</span> 这其实就是求解一个<strong>最优化问题</strong>。代入训练集所有数据(𝑥𝑖,𝑦𝑖)，要求最小值的目标函数就是模型中参数 𝜃 的函数。</p><p>具体求解的算法，可以利用数学公式直接计算解析解，也可以使用<strong>迭代算法</strong>。</p><h2 id="解析解">6.1 解析解</h2><p>通过数学公式进行严格推导得到解析解，那么就直接得到了最优模型的全部参数，这种方法称作解析法。</p><ul><li>优点：直接通过计算得到最优值，精确迅速</li><li>缺点：适用条件苛刻，目标函数必须可导，且导数方程有解析解；特征维度较大时，计算复杂度极高</li></ul><p>例如线性回归问题：通过最小二乘法得到解析解 <spanclass="math display">$$\begin{gathered}Loss_{MSE}=\frac{1}{n}(X\beta-y)^T(X\beta-y) \\\nabla Loss_{MSE}=\frac{2}{n}X^T(X\beta-y)=0 \\\boldsymbol{\beta}=(\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}\end{gathered}$$</span></p><h2 id="梯度下降法">6.2 梯度下降法</h2><h3 id="梯度下降思想">6.2.1 梯度下降思想</h3><p>梯度下降法(gradientdescent)是迭代算法，基本思路就是先选取一个适当的初始值 <spanclass="math inline"><em>𝜃</em><sub>0</sub></span>，然后沿着负梯度方向，不停地更新参数，最终取到极小值。</p><p>(1)初始化参数：随机选择初始参数(2)计算梯度：在当前参数下，计算损失函数的梯度(3)更新参数：沿负梯度方向调整参数(4)重复迭代：直到满足停止条件(如梯度接近零、达到最大迭代次数等)</p><ul><li>梯度方向：函数变化增长最快的方向(变量沿此方向变化时函数增长最快)</li><li>负梯度方向：函数变化减少最快的方向(变量沿此方向变化时函数减少最快)</li></ul><p>沿着损失函数的负梯度方向变化，此时损失函数减少最快，能够以最快速度下降到极小值。<spanclass="math display"><em>θ</em><sub><em>k</em> + 1</sub> = <em>θ</em><sub><em>k</em></sub> − <em>α</em> ⋅ ∇<em>L</em>(<em>θ</em><sub><em>k</em></sub>)</span><span class="math inline">$\nabla𝐿(𝜃_𝑘)$</span>是参数取值为 <spanclass="math inline"><em>𝜃</em><sub><em>𝑘</em></sub></span> 时损失函数 𝐿的梯度； 𝛼 是每次迭代的步长，被称为<strong>学习率(learningrate)</strong>，是一个常见的超参数，设置过小训练迭代过慢，设置过大不易收敛。</p><blockquote><p>注意每次更新的是“x”，而不是“y”，每次“x”沿着负梯度方向移动一段距离。</p></blockquote><p>梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。</p><ul><li>优点：适用性广，计算简单</li><li>缺点：收敛速度慢，可能陷入局部最优解</li></ul><h3 id="梯度下降分类">6.2.2 梯度下降分类</h3><ol type="1"><li>批量梯度下降(Batch GradientDescent，BGD)：每次迭代使用<strong>全部训练数据</strong>计算梯度。<ul><li>优点：梯度方向稳定，更新平滑，收敛过程较稳定。</li><li>缺点：每次都计算整个训练集，计算量大，对大数据集效率低。</li></ul></li><li>随机梯度下降(Stochastic GradientDescent，SGD)：每次迭代随机选取<strong>一个样本</strong>计算梯度。<ul><li>优点：快速迭代，每次只用一个样本计算梯度；由于引入了随机性，有助于跳出局部最优解。</li><li>缺点：每次更新方向不确定，收敛过程波动很大，甚至难以收敛，在最小值附近震荡。</li></ul></li><li>小批量梯度下降(Mini-batch GradientDescent，MBGD)：每次迭代使用<strong>一小批样本</strong>(如32、64个)计算梯度。<ul><li>优点：计算成本相对 BGD 较低，又比 SGD 稳定，兼具 BGD 的稳定和 SGD的速度。</li><li>缺点：合适的 batch size 需要实验。</li></ul></li></ol><p><ahref="https://www.jeremyjordan.me/gradient-descent/">梯度下降优化扩展内容</a></p><h2 id="牛顿法和拟牛顿法">6.3 牛顿法和拟牛顿法</h2><p>牛顿法也是求解无约束最优化问题的常用方法，核心思想是利用目标函数的二阶导数信息（不需要手动指定学习率了），通过迭代逐渐逼近极值点。<spanclass="math display"><em>θ</em><sub><em>k</em> + 1</sub> = <em>θ</em><sub><em>k</em></sub> − <em>H</em><sup>−1</sup>(<em>θ</em><sub><em>k</em></sub>) ⋅ ∇<em>L</em>(<em>θ</em><sub><em>k</em></sub>)</span><spanclass="math inline"><em>𝐻</em><sup>−1</sup>(<em>𝜃</em><sub><em>𝑘</em></sub>)</span>表示损失函数 <span class="math inline"><em>L</em></span>黑塞矩阵的逆在点 <spanclass="math inline"><em>𝜃</em><sub><em>𝑘</em></sub></span> 的取值。</p><ul><li>优点：收敛速度快，精度高。</li><li>缺点：计算非常复杂，可能发散。</li></ul><p>由于牛顿法中需要计算黑塞矩阵的逆 <spanclass="math inline"><em>𝐻</em><sup>−1</sup>(<em>𝜃</em><sub><em>𝑘</em></sub>)</span>，这一步比较复杂，所以可以考虑用一个 <span class="math inline"><em>n</em></span>阶正定矩阵来近似代替它，这种方法称为“拟牛顿法”。</p><p>牛顿法和拟牛顿法一般用于解决中小规模的凸优化问题。</p><h1 id="模型评估指标">7 模型评估指标</h1><p>模型的评估指标用于衡量模型在训练集或测试集上的性能，评估结果反映了模型预测的准确性和泛化能力。</p><h2 id="回归模型">7.1 回归模型</h2><h3 id="均方误差mse">7.1.1 均方误差(MSE)</h3><p>均方误差(Mean Squared Error,MSE)：每个样本的<strong>预测值与真实值之差的平方</strong>的平均值。<span class="math display">$${MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2$$</span></p><p>MSE对误差进行平方，因此对<strong>异常值非常敏感</strong>。MSE的值越小，说明模型的预测越精准，性能越好。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br>mean_squared_error(y_true, y_test)<br></code></pre></td></tr></table></figure></p><h3 id="均方根误差rmse">7.1.2 均方根误差(RMSE)</h3><p>均方根误差(Root Mean Squared Error,RMSE)：均方根误差是均方误差的平方根。 <span class="math display">$$RMSE=\sqrt{MSE}=\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i−\hat{y}_i)^2}$$</span></p><p>RMSE 同样对<strong>大误差</strong>敏感，因为它是在 MSE的基础上计算得到的，优势在于与目标的量纲一致。如果一味地降低RMSE，可能会导致模型对异常值也拟合度很高，容易过拟合。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> root_mean_squared_error<br><br>root_mean_squared_error(y_true, y_test)<br></code></pre></td></tr></table></figure></p><h3 id="平均绝对误差mae">7.1.3 平均绝对误差(MAE)</h3><p>平均绝对误差(Mean Absolute Error,MAE)：预测值与真实值差的绝对值的平均值。 <span class="math display">$$MAE=\frac{1}{n}\sum_{i=1}^{n}|y_i-\hat{y}_i|$$</span></p><p>MAE对所有误差都给予相同的权重，因此对<strong>异常值</strong>不敏感，并且和目标量纲一致。</p><blockquote><p>如果希望模型对异常值更加敏感，可以选择 MSE 或 RMSE。RMSE 比 MSE更易于解释。 如果希望模型对异常值不敏感，可以选择 MAE。在实际应用中，通常会同时考虑这三个指标，以便更全面地评估模型的性能。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br><br>mean_absolute_error(y_true, y_test)<br></code></pre></td></tr></table></figure><h3 id="r2-决定系数">7.1.4 <spanclass="math inline"><em>R</em><sup>2</sup></span> 决定系数</h3><p><span class="math inline"><em>R</em><sup>2</sup></span>决定系数：衡量模型对目标变量的解释能力，越接近 1越好。由于分母是均方误差，所以对异常值也敏感。 <spanclass="math display">$$R^2=1-\frac{MSE}{Var}=1-\frac{\sum_{i=1}^n(f(x_i)-y_i)^2}{\sum_{i=1}^n(y_i-\bar{y})^2}$$</span>决定系数右侧的所减项实际为均方误差与方差的比值。</p><ul><li>均方误差越接近 0，整体越接近 1。</li><li>方差越大，说明真实数据本身规律越弱，允许的误差范围越大，整体也会越接近1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> r2_score<br><br>r2_score(y_true, y_test)<br></code></pre></td></tr></table></figure><h2 id="分类模型">7.2 分类模型</h2><h3 id="混淆矩阵confusion-matrix">7.2.1 混淆矩阵(Confusion Matrix)</h3><p>正类为 Positive (P)，负类为 Negative (N)，总样本数 <spanclass="math inline"><em>n</em> = <em>T</em><em>P</em> + <em>T</em><em>N</em> + <em>F</em><em>P</em> + <em>F</em><em>N</em></span>。展示了模型预测结果与实际标签的对比情况，n分类问题的混淆矩阵为 <spanclass="math inline"><em>n</em> × <em>n</em></span>。</p><table><thead><tr><th>真实类别</th><th>预测为正例</th><th>预测为反例</th></tr></thead><tbody><tr><td><b>正例 (P)</b></td><td>真正例(True Positive, TP)</td><td>假反例(False Negative, FN)</td></tr><tr><td><b>反例 (N)</b></td><td>假正例(False Positive, FP)</td><td>真反例(True Negative, TN)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-comment"># 查看混淆矩阵</span><br>cm = confusion_matrix(y_ture, y_pred)<br><br><span class="hljs-comment"># 热力图可视化</span><br>sns.heatmap(cm, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;.2f&#x27;</span>, cmap=<span class="hljs-string">&#x27;warmcool&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="精度accuracy">7.2.2 精度(Accuracy)</h3><p>预测正确的比例。 <span class="math display">$$Accuracy=\frac{TP+TN}{n}​$$</span></p><table><thead><tr><th>真实类别</th><th>预测为正例</th><th>预测为反例</th></tr></thead><tbody><tr><td><b>正例 (P)</b></td><td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td><td style="background-color:#F8CECC;">假反例(False Negative, FN)</td></tr><tr><td><b>反例 (N)</b></td><td style="background-color:#F8CECC;">假正例(False Positive, FP)</td><td style="background-color:#D5E8D4;">真反例(True Negative, TN)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 方式一</span><br>accuracy_score(y_true, y_pred)<br><br><span class="hljs-comment"># 方式二</span><br>model.score(X_test, y_test)<br></code></pre></td></tr></table></figure><p>错误率(Error)：预测错误的比例。 <span class="math display">$$Error=\frac{FP+FN}{n}=1−Accuracy$$</span></p><h3 id="查准率precision">7.2.3 查准率(Precision)</h3><p>预测为正例的样本中，真正为正的比例，衡量模型预测的准不准。 <spanclass="math display">$$Precision=\frac{TP}{TP+FP}​$$</span></p><table><thead><tr><th>真实类别</th><th>预测为正例</th><th>预测为反例</th></tr></thead><tbody><tr><td><b>正例 (P)</b></td><td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td><td>假反例(False Negative, FN)</td></tr><tr><td><b>反例 (N)</b></td><td style="background-color:#F8CECC;">假正例(False Positive, FP)</td><td>真反例(True Negative, TN)</td></tr></tbody></table><p>核心特点：宁缺毋滥。查准率高，意味着模型在说一个样本是正例时，有很高的可信度。<strong>误报代价高</strong>时更关心，比如垃圾邮件检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score<br><br>precision_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><h3 id="查全率召回率recall">7.2.4 查全率/召回率(Recall)</h3><p>真正的正例中，被模型判正的比例，衡量模型找得全不全。 <spanclass="math display">$$Recall=\frac{TP}{TP+FN}$$</span></p><table><thead><tr><th>真实类别</th><th>预测为正例</th><th>预测为反例</th></tr></thead><tbody><tr><td><b>正例 (P)</b></td><td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td><td style="background-color:#F8CECC;">假反例(False Negative, FN)</td></tr><tr><td><b>反例 (N)</b></td><td>假正例(False Positive, FP)</td><td>真反例(True Negative, TN)</td></tr></tbody></table><p>核心特点：宁多报不漏报。查全率高，意味着模型能够把绝大多数的正例都找出来，很少漏掉。<strong>漏报代价高</strong>时更关心，比如病毒检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> recall_score<br><br>recall_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><h3 id="f1度量f1-score">7.2.5 F1度量(F1-score)</h3><p>查准率和查全率是相互制约的，需要一个综合性的指标来平衡它们，F1度量就是它们的调和平均数，同时兼顾了查准率和查全率。<span class="math display">$$\frac{1}{F_1}=\frac{1}{2}·(\frac{1}{Precision}+\frac{1}{Recall})$$</span> 得=&gt; <span class="math display">$$F_1​=2\cdot\frac{Precision\cdot Recall}{Precision+Recall}$$</span></p><ul><li><p><strong>F-beta度量</strong>：不平衡场景可用加权的 <spanclass="math inline"><em>F</em><sub><em>β</em></sub></span>​ 强调召回或查准。<span class="math display">$$F_β=(1+β^2)⋅\frac{PR}{β^2P+R}​$$</span></p></li><li><p>当 <spanclass="math inline"><em>β</em> &gt; 1</span> 时，更看重Recall（如 <spanclass="math inline"><em>F</em><sub>2</sub>​</span> 度量）</p></li><li><p>当 <spanclass="math inline"><em>β</em> &lt; 1</span> 时，更看重Precision（如 <spanclass="math inline"><em>F</em><sub>0.5</sub></span> 度量）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br><br>f1_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><hr /><p>使用 <code>sklearn</code> 中的 <code>classification_report</code>可以生成分类任务的评估报告， 可以很方便地查看精确率、召回率、F1分数等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">classification_report(y_true, y_pred)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">             precision    recall    f1-score    support </span><br><span class="hljs-string">        0.0     1.00       1.00       1.00         8 </span><br><span class="hljs-string">        1.0     0.92       1.00       0.96        11 </span><br><span class="hljs-string">        2.0     1.00       0.91       0.95        11 </span><br><span class="hljs-string">          </span><br><span class="hljs-string">accuracy                              0.97        30 </span><br><span class="hljs-string">macro avg       0.97       0.97       0.97        30 </span><br><span class="hljs-string">weighted avg    0.97       0.97       0.97        30</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="roc曲线">7.2.6 ROC曲线</h3><ul><li>真正例率（TPR）：实际为正例，被预测为正例的比例，即召回率。(第一行)</li><li>假正例率（FPR）：实际为负例，被预测为正例的比例。（第二行）</li><li>阈值（Threshold）：根据阈值将概率（一般是正例概率）转换为类别标签。</li></ul><p><spanclass="math display">$$TPR=\frac{TP}{\textit{实际正例数}}=\frac{TP}{TP+FN}\qquadFPR=\frac{FP}{\textit{实际负例数}}=\frac{FP}{FP+TN}$$</span></p><table><thead><tr><th>真实类别</th><th>预测为正例</th><th>预测为反例</th></tr></thead><tbody><tr><td><b>正例 (P)</b></td><td>真正例(True Positive, TP)</td><td>假反例(False Negative, FN)</td></tr><tr><td><b>反例 (N)</b></td><td>假正例(False Positive, FP)</td><td>真反例(True Negative, TN)</td></tr></tbody></table><p>ROC 曲线（Receiver Operating CharacteristicCurve，受试者工作特征）是评估二分类模型性能的工具，以假正例率（FPR）为横轴，以真正例率（TPR）为纵轴，展示不同阈值下模型的表现。绘制ROC 曲线时，从高到低调整阈值，计算每个阈值的 TPR 和 FPR并绘制所有阈值的点，形成 ROC 曲线。 <img src="02_roc.png" /></p><p>中间的红色虚线是随机猜测概率，只要 ROC曲线在虚线上方就有预测价值，当然如果在虚线下方说明能够反向预测正确，反转输出也有预测价值。</p><blockquote><p>在左下角时，阈值被设定的很高（比如0.999才预测为正例），那么模型将所有样本都预测为负例，不预测为正例就不会出错，所以TPR 和 FPR 都很低。 阈值稍微降低，由于此时正例概率很大，TPR提升很快，有预测就有失误，FPR 随之提升，但没有 TPR提升快，曲线向上凸起。当阈值继续降低，正例概率变低，将会导致更多的预测失误，FPR 增长速度超越TPR，曲线开始向下弯曲。右上角是另一种极端，阈值设定很低，所有样本都预测为正例，TPR 和 FPR都很高。</p></blockquote><h3 id="auc值">7.2.7 AUC值</h3><p>AUC 值代表 ROC 曲线下的面积，用于量化模型性能。AUC值越大，模型区分正负类的能力越强，模型性能越好。AUC 值=0.5表示模型接近随机猜测，AUC 值=1 代表完美模型。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_auc_score<br><br><span class="hljs-comment"># 获取正类预测概率值</span><br>y_proba = model.predict_proba(X_test)[:, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 计算 auc 值</span><br>roc_auc_score(y_test, y_proba)<br></code></pre></td></tr></table></figure></p><p>绘制 ROC 曲线： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve, roc_auc_score<br><span class="hljs-keyword">import</span> matplotplib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 获取正类预测概率值</span><br>y_proba = model.predict_proba(X_test)[:, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 返回 FPR, TPR, 阈值 数组</span><br>fpr, tpr, threshold = roc_curve(y_test, y_proba)<br><br><span class="hljs-comment"># 计算 AUC 值</span><br>roc_auc = roc_auc_score(y_test, y_proba)<br><br><span class="hljs-comment"># 绘制 ROC 曲线</span><br>plt.plot(fpr, tpr, label=<span class="hljs-string">f&#x27;ROC curve(roc_auc=<span class="hljs-subst">&#123;roc_auc:<span class="hljs-number">.2</span>f&#125;</span>)&#x27;</span>)<br>plt.plot([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], linestyle=<span class="hljs-string">&#x27;--&#x27;</span>)<br>plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>plt.ylim(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;False Positive Rate&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;True Positive Rate&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;ROC Curve&#x27;</span>)<br>plt.legend(loc=<span class="hljs-string">&#x27;lower right&#x27;</span>)<br></code></pre></td></tr></table></figure> <img src="02_roc_curve.png" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_机器学习概览</title>
    <link href="/2024/07/09/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/"/>
    <url>/2024/07/09/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论">1 绪论</h1><h2 id="引言">1.1 引言</h2><p><strong>机器学习</strong>：利用经验改善系统自身的性能。</p><blockquote><p>任何经验在计算机内都以数据形式存在。</p></blockquote><p><img src="01_ml.png" /></p><p>计算问题分类：</p><ul><li>P问题：可以在多项式时间（合理时间）内求解</li><li>NP问题：在多项式时间内求不出答案，但可以验证一个解</li></ul><p>在计算学习理论当中，有一个很重要的理论模型<strong>PAC模型</strong>。</p><p>如果对于任意小的：</p><ul><li>误差上限 <spanclass="math inline"><em>ε</em> &gt; 0</span>（表示学得多接近真理）</li><li>置信下限 <spanclass="math inline">1 − <em>δ</em></span>（表示学得多可靠）</li></ul><p>存在一个多项式时间算法，能从有限样本中学到一个假设 <spanclass="math inline"><em>h</em></span>，满足： <spanclass="math display"><em>P</em>(<em>e</em><em>r</em><em>r</em><em>o</em><em>r</em>(<em>h</em>) ≤ <em>ε</em>) ≥ 1 − <em>δ</em></span>也就是说：以至少 <span class="math inline">1 − <em>δ</em></span>的概率，学到的模型错误率不超过 <spanclass="math inline"><em>ε</em></span>。</p><p>机器学习面对的很多问题，既不是P问题也不是NP问题，这些问题通常是可验证的优化问题，只能从数据中学到<strong>近似最优解</strong>（高概率正确）。</p><h2 id="基本术语">1.2 基本术语</h2><h3 id="数据基本概念">1.2.1 数据基本概念</h3><ul><li><strong>标签(label)/目标(target)</strong>：模型要预测的结果</li><li><strong>特征(feature)/属性(attribute)</strong>：从数据中抽取出来的，对结果预测有用的信息</li><li><strong>示例(instance)</strong>：一个具体的输入对象，即一行特征数据，不包含标签。</li><li><strong>样例(example)</strong>：带有标签的一行数据</li><li><strong>样本(sample)</strong>：一行或几行，或整个数据集都可以叫样本</li></ul><p><img src="01_sample.png" /></p><h3 id="数据集与空间映射">1.2.2 数据集与空间映射</h3><ul><li><strong>参数(parameter)</strong>：模型通过训练自动学习得到的数值，用于描述模型本身</li><li><strong>超参数(hyperparameter)</strong>：训练开始前人为设定的参数，控制模型的学习过程或结构，不会在训练中自动学习</li><li>数据集：<ul><li><strong>训练集(training set)</strong>：用来训练模型的数据</li><li><strong>验证集(validation set)</strong>：用于调参或选择模型</li><li><strong>测试集(testing set)</strong>：用来测试模型的数据</li></ul></li><li>机器学习的目标就是<strong>学习一个映射函数<spanclass="math inline"><em>f</em> : 𝒳 → 𝒴</span></strong>，逼近真实映射函数<spanclass="math inline"><em>f</em><sup>*</sup> : 𝒳 → 𝒴</span><ul><li>属性空间/特征空间/输入空间：输入特征的所有可能取值集合<spanclass="math inline">𝒳</span></li><li>标签空间/目标空间/输出空间：输出结果的所有可能取值集合<spanclass="math inline">𝒴</span></li></ul></li><li><strong>特征向量(featurevector)</strong>：所有特征表示为向量形式，示例在属性空间中的一个点</li></ul><h3 id="模型相关">1.2.3 模型相关</h3><p>机器学习就是：学习器(learner)基于已标注数据(groundtruth)，在假设空间中寻找最优假设(hypothesis)，使其在未知样本上尽可能逼近真实规律(truefunction)。</p><ul><li><strong>真相函数(truefunction)</strong>：世界的真实规律，不可知</li><li><strong>真值(groundtruth)</strong>：我们已知的、标注好的真实标签</li><li><strong>学习器(learner)</strong>：训练算法，从数据中学习规律，寻找最优假设</li><li><strong>假设(hypothesis)</strong>：学习器学出来的近似函数，用来逼近真值</li><li><strong>模型(Model)</strong>：一个机器学习算法与训练后的参数集合，用于进行预测或分类</li></ul><h3 id="任务类型">1.2.4 任务类型</h3><ul><li><strong>分类(classification)</strong>：根据输入特征，预测离散的类别标签<ul><li>二分类：判断样本属于两种类别中的哪一种，如猫/狗<ul><li>正类：我们关注的目标类，通常用标签1表示，如患病</li><li>反类：与正类相对的非目标类，通常用标签0表示，如健康</li><li>正/反类是人为定义的，没有绝对好坏，根据视角不同，可以调换</li></ul></li><li>多分类：判断样本属于多个类别中的哪一种，如猫/狗/鸟</li></ul></li><li><strong>回归(regression)</strong>：根据输入特征，预测一个连续数值，如预测房价</li></ul><h3 id="监督范式">1.2.5 监督范式</h3><ul><li><strong>监督学习(SupervisedLearning)</strong>：用带标签的数据来训练模型，学习输入与输出的映射，常用于<strong>分类</strong>和<strong>回归</strong>任务</li><li><strong>无监督学习(UnsupervisedLearning)</strong>：数据没有标签，模型要自己发现规律或结构，常用于<strong>聚类</strong>和<strong>降维</strong>任务</li><li><strong>半监督学习(Semi-supervisedLearning)</strong>：只有少量样本带标签，通过少量监督信息引导整体学习</li><li><strong>强化学习(ReinforcementLearning)</strong>：模型通过与环境交互、不断试错，根据奖励信号优化策略，以获得最大奖励</li></ul><h3 id="理论基础与泛化">1.2.6 理论基础与泛化</h3><ul><li>独立同分布(i.i.d.)：大多数机器学习理论的基本假设<ol type="1"><li>独立 (independent)：每个样本的生成不依赖其他样本</li><li>同分布 (identically distributed)：所有样本都来自同一个概率分布</li></ol></li><li>未见样本(unseen instance)：模型在训练时没有见过的样本</li><li>未知分布：训练集和测试集都是从这个分布抽样的，机器学习的目标就是学习到一个模型，使它对这个未知分布的整体表现尽可能好</li><li><strong>泛化(generalization)</strong>：模型在未见样本上的表现能力</li></ul><h3 id="学习理论">1.2.7 学习理论</h3><ul><li>归纳偏好：学习器在多种可能假设中倾向选择某一类假设的偏好，是学习的前提</li><li><strong>无免费午餐定理(No Free Lunch,NFL)</strong>：对所有可能的数据分布而言，没有任何算法在所有任务上都优于其他算法，如果一个算法在某些任务上表现好，那它必然在其他任务上表现差</li></ul><blockquote><p>NFL定理的前提是所有问题出现的机会相同，或所有问题同样重要。脱离具体问题，空谈什么算法好没有意义。</p></blockquote><h1 id="模型评估与选择">2 模型评估与选择</h1><p>奥卡姆剃刀原则主张在有多个同样有效的解释时，应选择最简单的那个解释。核心理念是“如无必要，勿增实体”。但判断什么样的模型算简单这个问题并不简单。</p><h2 id="误差和过拟合">2.1 误差和过拟合</h2><p>经验误差并不是越低越好，如果太低可能会导致过拟合，使泛化误差升高。</p><ul><li>经验误差：在训练集上的误差</li><li>泛化误差：在未来样本上的误差</li></ul><p><strong>过拟合(overfitting)</strong>：模型在训练集上学得太好，甚至记住了噪声或偶然特征，导致在训练集表现好、测试集表现差。<strong>欠拟合(underfitting)</strong>：模型对训练数据学习不足，连训练集都拟合不好，模型太简单、能力不够，无法捕捉数据中的真实规律。<img src="01_fitting.png" /></p><p>如何获得测试结果？评估方法 如何评估性能优劣？性能度量如何判断实质差别？比较检验</p><h2 id="评估方法">2.2 评估方法</h2><p>模型训练流程：</p><ol type="1"><li>初始划分：将原始数据划分为训练集 + 验证集 + 测试集。</li><li>模型训练阶段：在<strong>训练集</strong>上训练模型，在<strong>验证集</strong>上调参、选择最优模型结构，训练过程中验证集不参与梯度更新，只是用来评估。</li><li>模型选择阶段：使用验证集表现最好的参数，重新用<strong>训练集 +验证集</strong>合并训练一次，得到最终模型。</li><li>模型评估阶段：用<strong>测试集</strong>测试模型性能，测试集只用于一次性、最终评估，不能再回头调参。</li><li>模型部署阶段：最终确认算法后，可以用全量数据（<strong>训练+验证+测试</strong>）重新训练一个生产模型，使模型能利用所有可用数据进行学习。</li></ol><h3 id="留出法hold-out">2.2.1 留出法(Hold-out)</h3><p><strong>核心思想</strong>：将数据随机分成多个部分，一部分用于训练模型，另一部分用于验证和测试模型。它既可用于模型评估，也可用于模型选择。</p><p><strong>优点</strong>：简单、计算量小，适合大数据集。<strong>缺点</strong>：对数据划分方式敏感，数据量少时，训练集和测试集都可能不足。</p><p>注意：</p><ul><li>保证数据分布一致性，例如使用分层采样</li><li>多次重复划分，例如100次随机划分</li><li>测试集要适中，太大影响模型训练效果，太小影响模型测试效果</li></ul><blockquote><p>常见比例： - 训练集 : 测试集 = 7 : 3 或 8 : 2 - 三划分时：训练6，验证 2，测试 2</p></blockquote><p>模型评估： <img src="01_holdout_test.png" /></p><p>模型选择： <img src="01_holdout_validation.png" /></p><h3 id="交叉验证法cross-validation-cv">2.2.2 交叉验证法(CrossValidation, CV)</h3><p><strong>核心思想</strong>：将数据划分为 K 个折（fold），每次用 K−1 折训练、剩下1 折测试，循环K次，<strong>每个子集都做一次测试集</strong>，取平均度量作为性能估计。</p><p>常见形式：</p><ul><li><strong>K折交叉验证(K-FoldCV)</strong>：最常见，K一般取10，还有5、20等</li><li><strong>留一法(Leave-One-Out, LOO)</strong>：K = 样本数，每次只留 1个样本作验证</li></ul><p><strong>优点</strong>：每个样本都参与训练与验证，充分利用数据，评估结果稳定可靠<strong>缺点</strong>：计算成本高</p><p><img src="01_kfold.png" /></p><h3 id="自助法bootstrap">2.2.3 自助法(Bootstrap)</h3><p>当数据集非常小，以至于划分训练/测试集都感觉很奢侈时，自助法就派上用场了。</p><p><strong>核心思想</strong>：从原始数据集中进行<strong>有放回采样</strong>，形成与原数据等大小的训练集。从未被采样过的样本称为袋外(out-of-bag,OOB)测试集，每次自主采样约有 36.8% 成为 OOB。</p><p><strong>优点</strong>：在数据集较小、难以有效划分训练/测试集时非常有用<strong>缺点</strong>：有放回采样，改变了原始数据集的分布</p><p><img src="01_bootstrap.png" /></p><h2 id="性能度量">2.3 性能度量</h2><h3 id="回归任务regression">2.3.1 回归任务(Regression)</h3><ul><li><strong>均方误差 (Mean Squared Error,MSE)</strong>：每个样本的<strong>预测值与真实值之差的平方</strong>的平均值。<span class="math display">$${MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2$$</span></li></ul><p>MSE对误差进行平方，因此对<strong>异常值非常敏感</strong>。MSE的值越小，说明模型的预测越精准，性能越好。</p><ul><li><strong>均方根误差(Root Mean Squared Error,RMSE)</strong>：均方根误差是均方误差的平方根。 <spanclass="math display">$$RMSE=\sqrt{MSE}=\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i−\hat{y}_i)^2}$$</span></li></ul><p>RMSE 同样对<strong>大误差</strong>敏感，因为它是在 MSE的基础上计算得到的，优势在于与目标的量纲一致。如果一味地降低RMSE，可能会导致模型对异常值也拟合度很高，容易过拟合。</p><ul><li><strong>平均绝对误差(Mean Absolute Error,MAE)</strong>：预测值与真实值差的绝对值的平均值。 <spanclass="math display">$$MAE=\frac{1}{n}\sum_{i=1}^{n}|y_i-\hat{y}_i|$$</span></li></ul><p>MAE对所有误差都给予相同的权重，因此对<strong>异常值</strong>不敏感，并且和目标量纲一致。</p><blockquote><p>如果希望模型对异常值更加敏感，可以选择 MSE 或 RMSE。RMSE 比 MSE更易于解释。 如果希望模型对异常值不敏感，可以选择 MAE。在实际应用中，通常会同时考虑这三个指标，以便更全面地评估模型的性能。</p></blockquote><h3 id="分类任务classification">2.3.2 分类任务(Classification)</h3><p><strong>混淆矩阵(Confusion Matrix)</strong>：正类为 Positive(P)，负类为 Negative (N)。 总样本数 <spanclass="math inline"><em>n</em> = <em>T</em><em>P</em> + <em>T</em><em>N</em> + <em>F</em><em>P</em> + <em>F</em><em>N</em></span>。</p><table><thead><tr><th style="text-align: left;">真实类别</th><th style="text-align: left;">预测为正例</th><th style="text-align: left;">预测为反例</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>正例 (P)</strong></td><td style="text-align: left;">真正例(True Positive, TP)</td><td style="text-align: left;">假反例(False Negative, FN)</td></tr><tr><td style="text-align: left;"><strong>反例 (N)</strong></td><td style="text-align: left;">假正例(False Positive, FP)</td><td style="text-align: left;">真反例(True Negative, TN)</td></tr></tbody></table><ul><li><p><strong>精度(Accuracy)</strong>：预测正确的比例。 <spanclass="math display">$$Accuracy=\frac{TP+TN}{n}​$$</span></p></li><li><p><strong>错误率(Error)</strong>：预测错误的比例。 <spanclass="math display">$$Error=\frac{FP+FN}{n}=1−Accuracy$$</span></p></li><li><p><strong>查准率(Precision)</strong>：预测为正例的样本中，真正为正的比例，衡量模型预测的准不准。<span class="math display">$$Precision=\frac{TP}{TP+FP}​$$</span></p></li></ul><p>核心特点：宁缺毋滥。查准率高，意味着模型在说一个样本是正例时，有很高的可信度。<strong>误报代价高</strong>时更关心，比如垃圾邮件检测。</p><ul><li><strong>查全率/召回率(Recall)</strong>：真正的正例中，被模型判正的比例，衡量模型找得全不全。<span class="math display">$$Recall=\frac{TP}{TP+FN}$$</span></li></ul><p>核心特点：宁多报不漏报。查全率高，意味着模型能够把绝大多数的正例都找出来，很少漏掉。<strong>漏报代价高</strong>时更关心，比如病毒检测。</p><ul><li><p><strong>F1度量(F1-score)</strong>：查准率和查全率是相互制约的，需要一个综合性的指标来平衡它们，F1度量就是它们的调和平均数，同时兼顾了查准率和查全率。<span class="math display">$$\frac{1}{F_1}=\frac{1}{2}·(\frac{1}{Precision}+\frac{1}{Recall})$$</span> 得=&gt; <span class="math display">$$F_1​=2\cdot\frac{Precision\cdot Recall}{Precision+Recall}$$</span></p></li><li><p><strong>F-beta度量</strong>：不平衡场景可用加权的 <spanclass="math inline"><em>F</em><sub><em>β</em></sub></span>​ 强调召回或查准。<span class="math display">$$F_\beta=(1+\beta^2)⋅\frac{PR}{\beta^2P+R}​$$</span></p></li><li><p>当 <spanclass="math inline"><em>β</em> &gt; 1</span> 时，更看重Recall（如 <spanclass="math inline"><em>F</em><sub>2</sub>​</span> 度量）</p></li><li><p>当 <spanclass="math inline"><em>β</em> &lt; 1</span> 时，更看重Precision（如 <spanclass="math inline"><em>F</em><sub>0.5</sub></span> 度量）</p></li></ul><h2 id="比较检验">2.4 比较检验</h2><p>McNemar检验 于交叉验证t检验</p><h1 id="线性模型">3 线性模型</h1><h2 id="一元线性回归">3.1 一元线性回归</h2><p>一元线性回归方程： <spanclass="math display"><em>y</em> = <em>w</em><strong>x</strong> + <em>b</em></span>定义损失函数： <span class="math display">$$L(w, b)=\sum_{i=1}^{m}(y_i-(wx+b))^2$$</span> 对损失函数进行最小二乘估计，分别对 <spanclass="math inline"><em>w</em></span> 和 <spanclass="math inline"><em>b</em></span> 求偏导，令导数等于0，得到闭式(closed-form)解： <span class="math display">$$w=\frac{\sum_{i=1}^{m}y_i(x_i-\bar{x})}{\sum_{i=1}^{m}x_i^2-\frac{1}{m}(\sum_{i=1}^{m}x_i)^2}\qquad\qquadb=\frac{1}{m}\sum_{i=1}^{m}(y_i-wx_i)$$</span></p><p>线性回归中，对于离散属性的处理：</p><ul><li>若有“序”，则连续化，如高、中、低，可以转为0，1，2</li><li>无“序”，则转为k维向量，如红、绿、蓝，转为三个特征，<code>[1, 0, 0] [0, 1, 0] [0, 0, 1]</code></li></ul><h2 id="多元线性回归">3.2 多元线性回归</h2><p>多元线性回归方程： <spanclass="math display"><em>y</em> = <em>w</em><sub>1</sub><em>x</em><sub>1</sub> + <em>w</em><sub>2</sub><em>x</em><sub>2</sub> + <em>w</em><sub>3</sub><em>x</em><sub>3</sub> + ⋯ + <em>w</em><sub><em>n</em></sub><em>x</em><sub><em>n</em></sub> + <em>b</em></span>可以用向量简化为：<spanclass="math inline"><em>y</em> = <strong>w</strong><sup><strong>T</strong></sup><strong>x</strong> + <em>b</em></span></p><p>其中<span class="math inline">$\boldsymbol{w}=\begin{pmatrix} w_1 \\w_2 \\ w_3 \\ ... \end{pmatrix}$</span>，<spanclass="math inline">$\boldsymbol{x} = \begin{pmatrix} x_1 \\ x_2 \\ x_3\\ ... \end{pmatrix}$</span>，将<spanclass="math inline"><strong>w</strong></span>进行转置后和<spanclass="math inline"><strong>x</strong></span>做矩阵乘法：<spanclass="math inline">$\boldsymbol{w^Tx}=\begin{pmatrix} w_1 , w_2 , w_3,... \end{pmatrix}×\begin{pmatrix} x_1 \\ x_2 \\ x_3 \\ ...\end{pmatrix}$</span></p><p>还可以将 <span class="math inline"><em>b</em></span> 吸收进去<spanclass="math inline">$\boldsymbol{w}=\begin{pmatrix}1 \\ w_1 \\ w_2 \\w_3 \\ ... \end{pmatrix}$</span>，<spanclass="math inline">$\boldsymbol{x} = \begin{pmatrix} b \\ x_1 \\ x_2 \\x_3 \\ ... \end{pmatrix}$</span>，简化书写为：<spanclass="math inline"><em>y</em> = <strong>w</strong><sup><strong>T</strong></sup><strong>x</strong></span></p><p>同样采用最小二乘求解，得到解析解为： <spanclass="math display"><strong>w</strong> = (<strong>X</strong><sup><em>T</em></sup><strong>X</strong>)<sup>−1</sup><strong>X</strong><sup><em>T</em></sup><strong>y</strong></span>若 <spanclass="math inline"><em>X</em><sup><em>T</em></sup><em>X</em></span>不满秩，可以解出多个 <spanclass="math inline"><em>w</em></span>，此时需要设定归纳偏好，或引入正则化(regularization)。</p><blockquote><p>矩阵的转置与矩阵相乘等于 <spanclass="math inline"><em>L</em><sub>2</sub></span> 范数 <spanclass="math inline">||<em>x</em>||<sub>2</sub></span> 的平方：<spanclass="math inline"><strong>x</strong><sup><em>T</em></sup><strong>x</strong> = ||<em>x</em>||<sub>2</sub><sup>2</sup></span></p></blockquote><h2 id="广义线性回归">3.3 广义线性回归</h2><p>令预测值稍作变换便可得到 <span class="math inline"><em>y</em></span>的衍生物。 <spanclass="math display"><em>l</em><em>n</em> <em>y</em> = <em>w</em><sup><em>T</em></sup><em>x</em> + <em>b</em></span>上述变换得到了对数线性回归(log-linear regression)，实际是用 <spanclass="math inline"><em>e</em><sup><em>w</em><sup><em>T</em></sup><em>x</em> + <em>b</em></sup></span>逼近<span class="math inline"><em>y</em></span>。</p><p>推广得到广义线性模型的一般形式，将线性回归的输出作为输入传入 <spanclass="math inline"><em>g</em><sup>−1</sup></span> 函数： <spanclass="math display"><em>y</em> = <em>g</em><sup>−1</sup>(<em>w</em><sup><em>T</em></sup><em>x</em> + <em>b</em>)</span></p><p>其中 <span class="math inline"><em>g</em></span> 称为联系函数(linkfunction)，是单调可微的，令 <spanclass="math inline"><em>g</em>(·) = <em>l</em><em>n</em>(·)</span>则得到对数线性回归。</p><h2 id="对数几率回归逻辑回归">3.4 对数几率回归（逻辑回归）</h2><p>对数几率回归（逻辑回归， LogisticRegression），也称对率回归，是解决分类问题的算法。</p><p>线性回归模型 <spanclass="math inline"><em>z</em> = <em>w</em><sup><em>T</em></sup><em>x</em> + <em>b</em></span>产生实值输出，我们期望输出 <spanclass="math inline"><em>y</em> ∈ {0, 1}</span>来解决分类问题，根据上一节的描述，我们需要找到一个 <spanclass="math inline"><em>z</em></span> 和 <spanclass="math inline"><em>y</em></span> 的联系函数。</p><p>理想的单位阶跃函数(unit-step function)为： <spanclass="math display">$$y=\begin{cases}0, \qquad z&lt;0 \\ 0.5, \quad\; z=0 \\ 1,\qquadz&gt;0\end{cases}$$</span> 但是该函数分段，用不可导的点，性质不好，于是寻找替代函数：<span class="math display">$$y=\frac{1}{1+e^{-z}}$$</span> 该函数称为 <strong>sigmoid</strong> 函数，或<strong>logistics</strong> 函数，具有单调可微、任意阶可微可导的性质。<img src="01_sigmoid.png" /></p><p>将线性回归的输出作为输入会得到 {0, 1} 的输出。 <spanclass="math display">$$y=\frac{1}{1+e^{-(w^Tx+b)}}$$</span> 即： <span class="math display">$$ln\frac{y}{1-y}=w^Tx+b$$</span> 根据上一节的广义线性模型，相当于用右侧的线性模型去逼近左侧的<span class="math inline"><em>y</em></span> 衍生物。</p><p>其中 <span class="math inline">$\frac{y}{1-y}$</span> 中的 <spanclass="math inline"><em>y</em></span> 表示正例的可能性，<spanclass="math inline">1 − <em>y</em></span>为负例的可能性，整体在统计学上称为几率(odds)，反映了 <spanclass="math inline"><em>x</em></span> 作为正例的相对可能性，加上 <spanclass="math inline"><em>l</em><em>n</em></span> 称为对数几率(log odds,亦称为 <strong>logit</strong>)，在计算机学科当中通常使用<strong>logisticsregression</strong>，建议称为对数几率回归，简称<strong>对率回归</strong>。</p><blockquote><p>注意：由于历史原因，逻辑回归本身是一个错误的翻译，<strong>Logistic</strong>并没有逻辑的意思，而是源自<strong>Logit</strong>，不是<strong>Logic</strong>，<strong>Logit</strong>本身来自 <strong>Logodds</strong>，也就是对数几率。</p></blockquote><p>对率回归有几大优点：</p><ul><li>不同于很多模型，无需<strong>假设数据分布</strong>，这意味着用很强的普适性</li><li>可以得到类别的近似概率预测</li><li>可用现有数值优化算法求取最优解</li></ul><h2 id="多分类学习">3.5 多分类学习</h2><p>拆解法：将一个多分类任务转化为多个二分类任务，然后对多个二分类任务的结果进行举手表决。</p><ul><li>一对一(One-vs-One, OvO)：<ul><li>训练 <span class="math inline"><em>N</em>(<em>N</em> − 1)/2</span>个分类器，存储开销和测试时间大</li><li>训练只用两个类的样本，训练时间短</li></ul></li><li>一对其他(One-vs-Rest, OvR)：<ul><li>训练 <span class="math inline"><em>N</em></span>个分类器，存储开销和测试时间小</li><li>训练用到全部样例，训练时间长</li></ul></li></ul><p>实践中，逻辑回归、SVM、神经网络等模型均可通过OvR或OvO扩展至多分类任务。两者预测性能取决于具体的数据分布，大多数情况差不多。<img src="01_ovo_ovr.png" /></p><h1 id="决策树">4 决策树</h1><p>决策树是直接导致机器学习能够成为一个学科的模型，思想非常简单。</p><h2 id="决策树基本流程">4.1 决策树基本流程</h2><p>决策树基于树结构进行决策。</p><ul><li>每个“内部节点”对应某个特征上的“测试”（test）</li><li>某个分支对应该测试的某种可能结果，即该特征的某个取值</li><li>每个“叶子结点”对应一个“预测结果”</li></ul><p>学习过程：通过对训练样本的分析来确定“<strong>划分特征</strong>”，即内部结点所对应的特征。预测过程：将测试示例从根结点开始，沿着划分特征所构成的“判定测试序列”下行，直到叶子结点。</p><p>策略：分而治之（divide-and-conquer）自根至叶的递归过程，在每个中间节点寻找一个划分（split ortest）属性。</p><p>既然是递归，停止条件非常重要：</p><ol type="1"><li>当前节点的样本都属于同一类别，无需划分。</li><li>当前节点样本有不同类别，但是特征集为空，没有能够划分的特征了，或者其余特征值都相同。</li><li>当前节点包含的样本集合为空（有这个特征但是训练集中没有这种样本）</li></ol><p><img src="01_tree_process.png" /></p><h2 id="信息增益划分">4.2 信息增益划分</h2><p>信息熵（entropy）是度量样本集合“纯度”的一个指标，当前样本集合 <spanclass="math inline"><em>D</em></span> 中共有 <spanclass="math inline"><em>k</em></span> 种类别，第 <spanclass="math inline"><em>i</em></span>类样本样本的比例（也就是出现概率）为 <spanclass="math inline"><em>p</em><sub><em>k</em></sub></span>，则 <spanclass="math inline"><em>D</em></span> 的<strong>信息熵</strong>定义为：<span class="math display">$$Ent(D) = -\sum_{i = 1}^{k}p_i\,log_2\,p_i$$</span> 不难发现，信息熵越小，<spanclass="math inline"><em>D</em></span> 的纯度越大。可以得出，<spanclass="math inline"><em>E</em><em>n</em><em>t</em>(<em>D</em>)</span>的最小值为0，最大值为 <spanclass="math inline"><em>l</em><em>o</em><em>g</em><sub>2</sub><em>k</em></span>。</p><p>直接以信息熵为基础，计算当前划分对信息熵所造成的变化，也就是<strong>信息增益（informationgain）</strong>，衡量的是当前划分对信息的不确定性减少的贡献程度。公式为<strong>划分前的信息熵 - 划分后的信息熵</strong>。 <spanclass="math display">$$\mathrm{Gain}(D,A)=\mathrm{Ent}(D)-\sum_{v=1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</span>可以看出， 划分后的信息熵表达的是在给定特征 <spanclass="math inline"><em>A</em></span> 的条件下，数据集 <spanclass="math inline"><em>D</em></span>的不确定性，称为<strong>条件熵</strong>： <spanclass="math display">$$Ent(D|A)=\sum_{v=1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</span></p><ul><li>特征 <span class="math inline"><em>A</em></span> 的取值：<spanclass="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ...<em>a</em><sub><em>v</em></sub></span>，共有V 个</li><li><spanclass="math inline"><em>D</em><sub><em>v</em></sub></span>：<spanclass="math inline"><em>D</em></span> 在特征 <spanclass="math inline"><em>A</em></span> 上取值为 <spanclass="math inline"><em>a</em><sub><em>v</em></sub></span>的样本子集</li><li><span class="math inline">$\frac{|D_v|}{D}$</span>：取值为 <spanclass="math inline"><em>a</em><sub><em>v</em></sub></span>的样本比例，第 <span class="math inline"><em>v</em></span>个分支的权重，样本越多越重要</li><li><spanclass="math inline"><em>E</em><em>n</em><em>t</em>(<em>D</em><sub><em>v</em></sub>)</span>：子集<span class="math inline"><em>D</em><sub><em>v</em></sub></span>的信息熵</li></ul><p>其实就是按照特征 <span class="math inline"><em>A</em></span>的取值将样本划分为 <span class="math inline"><em>V</em></span>个子集，分别计算每个子集的信息熵 <spanclass="math inline"><em>E</em><em>n</em><em>t</em>(<em>D</em><sub><em>v</em></sub>)</span>，但是由于特征<span class="math inline"><em>A</em></span>的取值并不是均匀的，所以需要按比例划分权重 <spanclass="math inline">$\frac{|D_v|}{D}$</span>，每个子集的信息熵与权重相乘<spanclass="math inline">$\frac{|D_v|}{D}Ent(D_v)$</span>，最后再相加，至此得到了给定特征<span class="math inline"><em>A</em></span> 的信息熵，用划分前信息熵 -划分后信息熵，由此得到了一个差值，即信息增益。 <imgsrc="01_id3_split.png" /> &gt; 划分后的信息熵越小，说明特征 <spanclass="math inline"><em>A</em></span> 的选择性越强，每一个子集 <spanclass="math inline"><em>D</em><sub><em>v</em></sub></span>内部纯度越高。</p><p>ID3 树就是使用信息增益作为划分准则。</p><h2 id="信息增益率划分">4.3 信息增益率划分</h2><p>信息增益作为划分准则时，越大越好，即划分后的信息熵越小越好，也就是划分后的子集<span class="math inline"><em>D</em><sub><em>v</em></sub></span>内部越纯越好。如此便会导致一个问题，信息增益倾向于筛选性强，极端来看每个特征值只对应一个结果，那么结果就够纯，所以<strong>信息增益会倾向于选择取值较多的特征</strong>。</p><blockquote><p>比如按照每个人的手机号特征进行划分，由于结果绝对纯正，它的信息增益会很高，但是由此会造成这个树的泛化能力变得极差。</p></blockquote><p>由于信息增益的这个缺陷，引入了<strong>信息增益率（information gainratio）</strong>： <spanclass="math display">$$\mathrm{Gain_ratio}(D,A)=\frac{\mathrm{Gain}(D,A)}{\mathrm{IV}(A)}$$</span>其中 <span class="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>为： <spanclass="math display">$${IV}(A)=-\sum_{v=1}^{V}\frac{|D_{v}|}{|D|}\log_{2}\frac{|D_{v}|}{|D|}$$</span><span class="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>表述的基本思想是特征 <span class="math inline"><em>A</em></span>的取值信息熵，取值数目越多，则 <spanclass="math inline"><em>I</em><em>V</em>(<em>A</em>)</span>取值越大。</p><p>信息增益率希望选择的是：</p><ol type="1"><li>信息增益尽可能大</li><li>特征取值尽可能少</li></ol><blockquote><p>这种思想叫做<strong>规范化（normalization）</strong>，在 <spanclass="math inline"><em>R</em><sup>2</sup></span> 系数中也有体现。</p></blockquote><p>由此便解决了信息增益偏向选择取值较多的特征，但我们并不清楚怎样平衡信息增益和特征取值两者的重要性，所以在C4.5决策树中并不是单纯的使用信息增益率作为划分依据，而是采用了<strong>启发式方法</strong>。</p><p>算法会检查高信息增益率的特征是否也具有足够高的信息增益。如果一个特征的信息增益率很高，但其信息增益很低，那么它可能只是因为分裂信息非常小，而不是因为它真的能很好地划分数据。</p><p>C4.5 试图在以下两者之间找到平衡：</p><ul><li>避免选择具有大量值的属性 (信息增益率的作用)</li><li>避免选择分裂信息太小的属性 (启发式修正的作用)</li></ul><h2 id="基尼指数划分">4.4 基尼指数划分</h2><p>样本 <span class="math inline"><em>D</em></span> 有 <spanclass="math inline"><em>k</em></span> 种类别，样本属于第 <spanclass="math inline"><em>k</em></span> 种类别的概率为 <spanclass="math inline"><em>p</em><sub><em>k</em></sub></span>，那么两次抽到的是同一类别的概率为<spanclass="math inline"><em>p</em><sub><em>k</em></sub><sup>2</sup></span>，一共<span class="math inline"><em>k</em></span>种类别求和得到抽到任一同样类别的概率，用 1 减去这个概率，反映的是从样本D 中任取两个样本，其类别标签不一致的概率。 <spanclass="math display">$$Gini(D) = 1 - \sum_{k=1}^{n}{p_{k}}^{2}$$</span>该值称为<strong>基尼指数（Gini index）</strong>，值越小，纯度越高。</p><p>属性 A 的基尼指数为： <span class="math display">$$Gini\_index(D, A)= \sum_{v=1}^{V}\frac{\lvert D_{v} \rvert}{\lvert D\rvert}Gini(D_{v})$$</span> 和特征熵类似，根据特征 A的取值，将数据集分为 V 个子集，分别计算每个子集的基尼指数，按照权重（占比）进行求和。</p><p>CART树就是基于使用基尼指数作为划分依据，既可以做分类任务，又可以做回归任务，在候选特征集当中，选取基尼指数最小的特征。</p><h2 id="决策树剪枝">4.5 决策树剪枝</h2><p>不止是信息增益和基尼指数，只要有一个概念能够描述划分子集中的数据纯度，便可以产生一个决策树算法。然而研究表明：划分选择的各种准则虽然对决策树的尺寸有较大影响，但对泛化性能的影响很有限。例如信息增益与基尼指数产生的结果，仅在约2% 的情况下不同。</p><p>剪枝方法和程度对于决策树泛化性能的影响更为显著。</p><p>在整个机器学习中，最大的敌人是过拟合。决策树的目的是把子集划分的越来越纯，当树的深度很深的时候，就学到了不该学的数据，将数据划分过于精细，决策树的泛化性能下降。<strong>剪枝（pruning）</strong>主动去掉一些分支，之前能分干净的现在做不到了，训练数据的划分能力变弱，但整体的泛化能力变强，剪枝是决策树对付过拟合的主要手段。</p><p>基本策略：剪枝过程中通过划分测试集，评估剪枝前后树的优劣来决定是否剪枝。</p><ul><li>预剪枝（pre-pruning）：提前终止某些分支的生长（贪心的思想导致不顾及全局最优）<ul><li>划分前验证集精度与划分后相等，根据奥卡姆剃刀原则，预剪枝决策为不划分</li><li>测试时间开销降低，训练时间开销降低</li><li>过拟合风险降低，欠拟合风险增加</li></ul></li><li>后剪枝 （post-pruning）：生成一棵完整的树之后，再回头剪枝<ul><li>划分前验证集精度与划分后相等，根据奥卡姆剃刀原则，后剪枝决策为不剪枝</li><li>测试时间开销降低，训练时间开销增加</li><li>过拟合风险降低，欠拟合风险基本不变</li></ul></li><li>后剪枝泛化性能通常优于预剪枝</li></ul><blockquote><p>通常单个决策树一定要剪枝，而在集成学习中的弱学习器一般不剪枝。</p></blockquote><h1 id="支持向量机">5 支持向量机</h1><h2 id="支持向量机基本型">5.1 支持向量机基本型</h2><p>找到一个超平面方程 <spanclass="math inline"><em>w</em><sup><em>T</em></sup><em>x</em> + <em>b</em> = 1</span>，将空间划分为两类。直觉上看，分类的点离这个超平面越远越好，离这个超平面最近的这些点叫做<strong>支持向量(supportvector)</strong>，两个异类支持向量到超平面的距离之和称之为<strong>间隔(margin)</strong>。 <img src="01_svm.png" /></p><h2 id="求解方法">5.2 求解方法</h2><p>目标是寻找参数 <span class="math inline"><em>w</em></span> 和 <spanclass="math inline"><em>b</em></span>，使得 <spanclass="math inline"><em>γ</em></span> 最大，也就是最大化间隔。 <spanclass="math display">$$\begin{aligned}&amp; \arg \min _{\boldsymbol{w}, b} \frac{1}{2}\|\boldsymbol{w}\|^{2}\\&amp; \quad \text { s.t. } y_{i}\left(\boldsymbol{w}^{\top}\boldsymbol{x}_{i}+b\right) \geq 1, i=1,2, \ldots, m.\end{aligned}$$</span></p><p>如果明白凸优化理论，不难发现这是一个凸二次规划问题，能用优化计算包求解，但可以有更高效的办法——拉格朗日乘子法。</p><p>最终解为： <spanclass="math display">$$f(\boldsymbol{x})=\boldsymbol{w}^\top\boldsymbol{x}+b=\sum_{i=1}^m\alpha_iy_i\boldsymbol{x}_i^\top\boldsymbol{x}+b$$</span>在推导对偶问题时，引入的拉格朗日乘子存在约束条件，需要满足 KTT 条件：<span class="math display">$$\left.\left\{\begin{array}{ll}\alpha_i\geq0; &amp; \\1-y_if(\boldsymbol{x}_i)\leq0; &amp; \\\alpha_i\left(1-y_if(\boldsymbol{x}_i)\right)=0. &amp;\end{array}\right.\right.$$</span>解的稀疏性：训练完成后，<strong>最终模型仅与支持向量有关</strong>，<strong>支持向量机（SupportVector Machine, SVM）</strong> 因此而得名。</p><p>还有著名的 SMO 算法，是一个迭代更新的算法，先选取 KKT条件违背程度最大的变量，当变量固定后，原始问题具有闭式解。</p><h2 id="特征空间映射">5.3 特征空间映射</h2><p>若不存在一个能正确划分两类样本的超平面，怎么办？将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。<img src="01_svm_space.png" /> &gt;如果原始空间是有限维（特征数有限），那么一定存在一个高维特征空间使样本线性可分。</p><p>原始问题： <span class="math display">$$\begin{aligned}&amp; \min _{\boldsymbol{w}, b} \frac{1}{2}\|\boldsymbol{w}\|^{2} \\&amp; \text { s.t. } y_{i}\left(\boldsymbol{w}^{\top}\boldsymbol{\phi}\left(\boldsymbol{x}_{i}\right)+b\right) \geqslant 1,i=1,2, \ldots, m .\end{aligned}$$</span> 对偶问题： <spanclass="math display">$$\begin{aligned}&amp; \max _{\boldsymbol{\alpha}} \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}\boldsymbol{\phi}\left(\boldsymbol{x}_{i}\right)^{\top}\boldsymbol{\phi}\left(\boldsymbol{x}_{j}\right) \\&amp; \text { s.t. } \sum_{i=1}^{m} \alpha_{i} y_{i}=0, \quad \alpha_{i}\geqslant 0, \quad i=1,2, \ldots, m\end{aligned}$$</span> 预测： <spanclass="math display">$$f(\boldsymbol{x})=\boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})+b=\sum_{i=1}^{m} \alpha_{i} y_{i}\boldsymbol{\phi}\left(\boldsymbol{x}_{i}\right)^{\top}\boldsymbol{\phi}(\boldsymbol{x})+b$$</span></p><h2 id="核函数">5.4 核函数</h2><p>由于两个高维向量求内积是困难的，所以设计<strong>核函数 (KernelFunction)</strong>，它能绕过显式考虑特征映射、缓解计算高维内积的困难，并且直接在原始的特征空间计算。<spanclass="math display"><em>κ</em>(<em>x</em><sub><em>i</em></sub>, <em>x</em><sub><em>j</em></sub>) = <em>ϕ</em>(<em>x</em><sub><em>i</em></sub>)<sup>T</sup><em>ϕ</em>(<em>x</em><sub><em>j</em></sub>)</span></p><blockquote><p>Mercer定理：若一个对称函数所对应的核矩阵<strong>半正定</strong>，则它就能作为核函数来使用。</p></blockquote><p>任何一个核函数，都隐式地定义了一个 <strong>RKHS</strong>（Reproducing Kernel Hilbert Space，再生核希尔伯特空间）。</p><p><strong>核函数选择是决定支持向量机性能的关键！</strong></p><blockquote><p>在机器学习中，没有最优解，只有近似最优解。在支持向量机算法中，前面的每一步都经过了严格的数学推导，是确定的，只有核函数这一步是无法确定的。</p></blockquote><h1 id="神经网络">6 神经网络</h1><p>神经网络是由具有适应性的<strong>简单单元</strong>组成的广泛并行互连的<strong>网络</strong>，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。神经网络模型的两个最重要的要素是<strong>神经元模型</strong>和<strong>网络结构</strong>。</p><blockquote><p>神经网络是一个很大的学科领域，这里仅讨论神经网络与机器学习的交集，即“神经网络学习”，亦称“连接主义（connectionism）”学习。</p></blockquote><h2 id="神经网络模型">6.1 神经网络模型</h2><p>神经网络中的简单单元是<strong>神经元模型</strong>，目前应用最广泛的还是1943 年 McCulloch and Pitts 提出的M-P神经元模型。神经网络学得的知识蕴含在连接权重 <spanclass="math inline"><em>w</em></span> 与阈值 <spanclass="math inline"><em>θ</em></span> 中。 <imgsrc="01_neuron.png" /></p><p><strong>激活函数 (activationfunction)</strong>，也称响应函数、挤压函数，理想的激活函数是阶跃函数，0表示抑制神经元，而 1表示激活神经元，但阶跃函数具有不连续、不光滑等不好的性质，常用的是Sigmoid 函数，在对率回归中也有用到。（其实 Sigmoid 并不是指某一个函数，S型的函数都可以） <img src="01_activate_function.png" /></p><hr /><p>目前神经网络最常用的网络结构<strong>多层前馈网络</strong>。</p><ul><li>多层网络：包含隐层的网络</li><li>前馈网络：神经元之间不存在同层连接也不存在跨层连接</li></ul><p>隐层和输出层神经元亦称“功能单元”（Functional Unit）。 <imgsrc="01_neural_net.png" /></p><h2 id="万有逼近性">6.2 万有逼近性</h2><p>多层前馈网络有强大的表示能力，也就是<strong>万有逼近性</strong>。</p><p>仅需一个包含足够多神经元的隐层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数。</p><p>如何设置隐层神经元数是未决问题（Open Problem）。实际常用“试错法”。</p><blockquote><p>万有逼近性并不是神经网络独有的特性，<strong>具有万有逼近性是能够作为机器学习模型的一个前提</strong>，许多数学模型如傅立叶变换、泰勒展开式也具备这种性质。决策树在划分过程中有信息熵支撑最后一定能够划分很干净，支持向量机也有理论保障能够找到间隔满足要求的划分超平面。为什么这里强调神经网络具有万有逼近性？因为神经网络整个训练过程一塌糊涂，是一个黑盒，没有严格的理论支撑，所以原来大家都怀疑它有没有万有逼近性，事实证明它有这个能力。</p></blockquote><h2 id="缓解过拟合">6.3 缓解过拟合</h2><p>早停（early stopping）：</p><ul><li>若训练误差连续 a 轮的变化小于 b，则停止训练</li><li>使用验证集：若训练误差降低、验证误差升高，则停止训练</li></ul><p>正则化 （regularization）：</p><ul><li>在误差目标函数中增加一项描述网络复杂度</li><li>模型偏好比较小的连接权和阈值，使网络输出更“光滑”</li><li><spanclass="math display">$$E=\lambda\frac{1}{m}\sum_{k=1}^mE_k+(1-\lambda)\sum_iw_i^2$$</span></li></ul><p>深度学习并非“突然出现”的”颠覆性技术”，而是经过了长期发展、很多研究者做出贡献，“冷板凳”坐“热”的结果。</p><h1 id="贝叶斯分类器">7 贝叶斯分类器</h1><h2 id="贝叶斯决策论">7.1 贝叶斯决策论</h2><p>贝叶斯决策论（Bayesian DecisionTheory）是是概率框架下实施决策的基本理论。 给定 N 个类别，令 <spanclass="math inline"><em>λ</em><sub><em>i</em><em>j</em></sub></span>代表将第 <span class="math inline"><em>j</em></span> 类样本误分类为第<span class="math inline"><em>i</em></span>类所产生的损失，则基于后验概率将样本 <spanclass="math inline"><em>x</em></span> 分到第 <spanclass="math inline"><em>i</em></span> 类的条件风险为： <spanclass="math display">$$R(c_i\mid\boldsymbol{x})=\sum_{j=1}^N\lambda_{ij}P(c_j\mid\boldsymbol{x})$$</span>贝叶斯判定准则（Bayes decision rule）：在条件风险中选择最小的。 <spanclass="math display">$$h^*(\boldsymbol{x})=\underset{c\in\mathcal{Y}}{\operatorname*{\operatorname*{\arg\min}}}R(c\mid\boldsymbol{x})$$</span></p><ul><li><span class="math inline"><em>h</em><sup>*</sup></span>称为贝叶斯最优分类器（Bayes optimalclassifier），其总体风险称为贝叶斯风险（Bayes risk）</li><li><spanclass="math inline">1 − <em>R</em>(<em>h</em><sup>*</sup>)</span>反映了学习性能的理论上限</li></ul><h2 id="生成式和判别式模型">7.2 生成式和判别式模型</h2><p><span class="math inline"><em>P</em>(<em>c</em> ∣ <em>x</em>)</span>在现实中通常难以直接获得，从这个角度来看，机器学习所要实现的是基于有限的训练样本尽可能准确地估计出后验概率。</p><p>两种基本策略：</p><ul><li>判别式（Discriminative） 模型<ul><li>思路：直接对 <spanclass="math inline"><em>P</em>(<em>c</em> ∣ <em>x</em>)</span> 建模</li><li>代表：<ul><li>决策树</li><li>BP 神经网络</li><li>SVM</li></ul></li></ul></li><li>生成式（Generative）模型<ul><li><p>思路：先对联合概率分布 <spanclass="math inline"><em>P</em>(<em>x</em> ∣ <em>c</em>)</span>建模，再由此获得 <spanclass="math inline"><em>P</em>(<em>c</em> ∣ <em>x</em>)</span> <spanclass="math display">$$P(c\mid x)=\frac{P(x,c)}{P(x)}$$</span></p></li><li><p>代表：贝叶斯分类器</p></li></ul></li></ul><h2 id="贝叶斯定理">7.3 贝叶斯定理</h2><p>对于根据贝叶斯定理可以将上式 <spanclass="math inline"><em>P</em>(<em>c</em> ∣ <em>x</em>)</span> 转为：<span class="math display">$$P(c\mid x)=\frac{P(c)P(x\midc)}{P(x)}$$</span></p><ul><li><spanclass="math inline"><em>P</em>(<em>c</em>)</span>：先验概率（Prior），样本空间中各类样本所占的比例，可通过各类样本出现的频率估计（大数定律）</li><li><spanclass="math inline"><em>P</em>(<em>x</em>)</span>：证据（Evidence）因子，与类别无关</li><li><spanclass="math inline"><em>P</em>(<em>x</em> ∣ <em>c</em>)</span>：样本相对于类标记的类条件概率 (Class-ConditionalProbability)，亦称<strong>似然 (Likelihood)</strong></li></ul><p>主要困难在于估计似然。</p><h2 id="极大似然估计">7.4 极大似然估计</h2><p><strong>先假设某种概率分布形式（独立同分布），再基于训练样例对参数进行估计。</strong></p><p>假定 <spanclass="math inline"><em>P</em>(<em>x</em> ∣ <em>c</em>)</span>具有确定的概率分布形式，且被参数 <spanclass="math inline"><em>θ</em><sub><em>c</em></sub></span>唯一确定，则任务就是利用训练集 D 来估计参数 <spanclass="math inline"><em>θ</em><sub><em>c</em></sub></span>。</p><p><span class="math inline"><em>θ</em><sub><em>c</em></sub></span>对于训练集 D 中第 c 类样本组成的集合 <spanclass="math inline"><em>D</em><sub><em>c</em></sub></span>的似然（Likelihood）为：</p><p><spanclass="math display"><em>P</em>(<em>D</em><sub><em>c</em></sub> ∣ <em>θ</em><sub><em>c</em></sub>) = ∏<sub><em>c</em> ∈ <em>D</em></sub><em>P</em>(<em>x</em> ∣ <em>θ</em><sub><em>c</em></sub>)</span></p><p>概率都是小于 1的浮点数，连乘易造成下溢，因此通常使用对数似然（Log-Likelihood）：</p><p><spanclass="math display"><em>L</em><em>L</em>(<em>θ</em><sub><em>c</em></sub>) = log <em>P</em>(<em>D</em><sub><em>c</em></sub> ∣ <em>θ</em><sub><em>c</em></sub>) = ∑<sub><em>x</em> ∈ <em>D</em><sub><em>c</em></sub></sub>log <em>P</em>(<em>x</em> ∣ <em>θ</em><sub><em>c</em></sub>)</span></p><p>于是 <span class="math inline"><em>θ</em><sub><em>c</em></sub></span>的极大似然估计为 <spanclass="math inline"><em>θ̂</em><sub><em>c</em></sub> = arg max<sub><em>θ</em><sub><em>c</em></sub></sub><em>L</em><em>L</em>(<em>θ</em><sub><em>c</em></sub>)</span></p><h2 id="朴素贝叶斯分类器">7.5 朴素贝叶斯分类器</h2><p>朴素贝叶斯分类器（Naive Bayes Classifier）对于： <spanclass="math display">$$P(c\mid x)=\frac{P(c)P(x\midc)}{P(x)}$$</span></p><p>主要障碍是求解所有属性上的联合概率 <spanclass="math inline"><em>P</em>(<em>x</em> ∣ <em>c</em>)</span>，难以从有限训练样本估计获得，并且存在组合爆炸；样本稀疏的问题。</p><p>基本思路是假定所有特征是独立的。</p><ul><li>估计 <span class="math inline"><em>P</em>(<em>c</em>)</span>：<spanclass="math display">$$P(c)=\frac{|D_c|}{|D|}$$</span></li><li>估计 <spanclass="math inline"><em>P</em>(<em>c</em> ∣ <em>x</em>)</span>：<ul><li>离散属性：令 <spanclass="math inline"><em>D</em><sub><em>c</em><em>x</em><sub><em>i</em></sub></sub></span>表示 <span class="math inline"><em>D</em><sub><em>C</em></sub></span>中在第 i 个属性上取值为 <spanclass="math inline"><em>x</em><sub><em>i</em></sub></span>的样本组成的集合<span class="math display">$$P(x_i\midc)=\frac{|D_{c,x_i}|}{|D_c|}$$</span></li><li>连续属性：考虑概率密度函数，假定 <spanclass="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub> ∣ <em>c</em>) ∼ 𝒩(<em>μ</em><sub><em>c</em>, <em>i</em></sub>, <em>σ</em><sub><em>c</em>, <em>i</em></sub><sup>2</sup>)</span><span class="math display">$$p(x_i\midc)=\frac{1}{\sqrt{2\pi}\sigma_{c,i}}\exp\left(-\frac{(x_i-\mu_{c,i})^2}{2\sigma_{c,i}^2}\right)$$</span></li></ul></li></ul><h2 id="拉普拉斯修正">7.6 拉普拉斯修正</h2><p>在单纯的贝叶斯定理中，若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现问题，因概率连乘将“抹去”其他属性提供的信息。例如，若训练集中未出现过“敲声=清脆”的好瓜，则模型在遇到“敲声=清脆”的测试样本时，不论其他特征多么符合好瓜的“定义”，也会断定为好瓜的概率为0。</p><p><strong>拉普拉斯修正(Laplacian Correction)</strong>解决了这一问题，思路非常简单，初始时为所有可能的特征值添加 1 个初始值。<spanclass="math display">$$\hat{P}(c)=\frac{|D_c|+1}{|D|+N},\quad\hat{P}(x_i\midc)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$$</span></p><p>不过这里假设了特征值与类别的均匀分布，这是额外了引入的bias，因此要根据实际问题量身定制bias。比如好人比坏人多，给初始值的时候给好人多一些。</p><h1 id="集成学习">8 集成学习</h1><p>集成学习（EnsembleLearning）将多个个体学习器组合起来，显著提高整体的预测能力。只包含同种类型的个体学习器的集成称为同质集成，包含不同类型个体学习器的称为异质集成。</p><p>术语梳理：</p><ul><li>基学习器：是集成学习的基本组成部分，可以是弱学习器或强学习器。</li><li>个体学习器：广泛指单个模型，强调其与其他学习器的独立性。所有基学习器都是个体学习器。</li><li>弱学习器：专指那些表现略好于随机猜测的模型，通常在集成学习中（尤其是Boosting）用于组合成强学习器。</li><li>强学习器：性能很强、准确率高的学习器，可以是单个模型或由多个基学习器组合而成的模型（如随机森林）。</li></ul><p>集成学习分为两大类：</p><ul><li>序列化方法<ul><li>AdaBoost ［Freund &amp; Schapire, JCSS97］</li><li><strong>Gradient Boost</strong>［Friedman, AnnStat01］</li><li>LPBoost［Demiriz, Bennett, Shawe-Taylor, MLJ06］</li></ul></li><li>并行化方法<ul><li>Bagging［Breiman, MLJ96］</li><li><strong>Random Forest</strong>［Breiman, MLJ01］</li><li>Random Subspace［Ho, TPAMI98］</li></ul></li></ul><blockquote><p>Gradient Boost 早在 2001年便已提出，是一种框架性算法，后来华人学生陈天奇在 2014 年发布XGBoost，是 Gradient Boos的一种高效实现。它在算法的基础上引入了许多工程化的改进，使得模型训练更快、更稳健，并且在很多竞赛中表现出色。</p></blockquote><h2 id="boosting">8.1 Boosting</h2><p>由 AdaBoosting 发展而来的这一系列算法称为 Boosting，整体流程为：</p><ol type="1"><li>初始化权重：给每个训练样本分配一个初始权重，通常是相同的</li><li>迭代弱学习器：经过多轮迭代，每轮生成一个弱学习器<ol type="1"><li>训练弱学习器：使用带有权重的训练数据训练一个新的弱学习器，重点关注权重较高样本</li><li>更新样本权重：每轮的学习器根据评估结果赋予权重（如决策树可以直接处理权重）或采样（按比例抽取，如神经网络中无法处理权重），使错误样本在后续学习中得到更多关注</li></ol></li><li>组合多个弱学习器：将多个弱学习器的预测结果按照加权组合，得到最终结果</li></ol><p><img src="01_boosting.png" /></p><blockquote><p>由于都是前者学习器未能解决的问题，越往后的学习器需要攻克的问题越困难，一般来说准确率越低。</p></blockquote><h2 id="bagging">8.2 Bagging</h2><p>Bagging 的数据都来自原始数据集，怎样保证多样性？可以使用 Bootstrap采样，在不同的数据集上训练，得到的结果使用投票解决分类问题，使用平均解决回归问题。<img src="01_bagging.png" /></p><h2 id="好而不同">8.3 好而不同</h2><p>Bagging通过举手表决做出最终判断，如果个体学习器的表决都一样，那么整体的预测并不会有提升，如果个体学习器的错误率很高，整体可能更差。所以Bagging 的核心思想是个体学习器需要<strong>好而不同</strong>。 <imgsrc="01_ensemble.png" /></p><p>有一个式子描述“好而不同”，<strong>误差-分歧分解 （error-ambiguitydecomposition）</strong>： <img src="01_ensemble_diversity.png" /></p><p>然而多样性（diversity）是不易做到的，当多个个体学习器的准确率都达到很高，比如99%时，它们之间是高度相似的，此时就可以考虑舍弃一些准确率，从而来提升多样性。</p><blockquote><p>同质集成只需要使用同一种算法，实现方便，但是最大的麻烦是如何保持多样性。异质集成有天然的优点，具有多样性，但是不同算法的输出之间无法直接比较，需要做配准（alignment）。这件事非常困难，所以重点讨论的还是同质集成。</p></blockquote><h1 id="聚类">9 聚类</h1><h2 id="概述">9.1 概述</h2><p>监督学习：分类、回归 无监督学习：聚类、密度估计</p><p>聚类是无监督学习中研究最多、应用最广的。</p><p>目标：将数据样本划分为若干个通常不相交的簇（cluster）。</p><p>既可以作为一个单独过程用于找寻数据内在的分布结构，也可以作为分类等其他学习任务的前驱过程。比如：在没有先验知识的前提下对客户进行分组，提供个性化策略。 <imgsrc="01_kmeans.png" /></p><h2 id="聚类性能指标">9.2 聚类性能指标</h2><p>聚类性能度量，也称为<strong>有效性指标</strong>（validityindex）。</p><ul><li>外部指标（externalindex）：将聚类结果与参考模型（referencemodel）进行比较。但参考模型并不意味着标准，可以有很多种聚法。如Jaccard 系数，FM 指数，Rand 指数。</li><li>内部指标（internal index）：直接考察聚类结果而不参考模型。如 DB指数、Dunn指数。基本想法是簇内尽可能紧密，簇间尽可能远离：<ul><li>簇内相似度高</li><li>簇间相似度低</li></ul></li></ul><h2 id="距离度量">9.3 距离度量</h2><p>上一节中提到簇内尽可能紧密，既然谈到紧密，就一定涉及某种距离度量。</p><p>距离度量（distance metric）需满足的性质： <spanclass="math display">$$\begin{aligned}&amp;\operatorname{\text{非负性:dist}}(\boldsymbol{x}_{i},\boldsymbol{x}_{j})\geqslant0;\\&amp; \text{同一性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j)=0\text{当且仅当 }\boldsymbol{x}_i=\boldsymbol{x}_j\mathrm{~;} \\&amp;\text{对称性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j)=\mathrm{dist}(\boldsymbol{x}_j,\boldsymbol{x}_i);\\&amp; \text{直递性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j)\leqslant\operatorname{dist}(\boldsymbol{x}_i,\boldsymbol{x}_k)+\operatorname{dist}(\boldsymbol{x}_k,\boldsymbol{x}_j).\end{aligned}$$</span>尽管大部分距离满足上述四个条件，然而某些情况第四条直递性不满足，需要使用非距离度量（Non-metricdistance）。在图像识别等领域还有相似度（Similaring），也有非距离度量的理念。</p><p>常用距离形式-闵可夫斯基距离： <spanclass="math display">$$\operatorname{dist}_{\operatorname{mk}}(\boldsymbol{x}_i,\boldsymbol{x}_j)=\left(\sum_{u=1}^n|x_{iu}-x_{ju}|^p\right)^{\frac{1}{p}}$$</span></p><p>对于无序（non-ordinal）属性，可使用 VDM(Value DifferenceMetric)，令<spanclass="math inline"><em>m</em><sub><em>u</em>, <em>a</em></sub></span>表示属性<spanclass="math inline"><em>u</em></span>上取值为<spanclass="math inline"><em>a</em></span>的样本数，<spanclass="math inline"><em>m</em><sub><em>u</em>, <em>a</em>, <em>i</em></sub></span>表示在第<spanclass="math inline"><em>i</em></span>个样本簇中在属性<spanclass="math inline"><em>u</em></span>上取值为<spanclass="math inline"><em>a</em></span>的样本数，<spanclass="math inline"><em>k</em></span>为样本簇数，则属性<spanclass="math inline"><em>u</em></span>上两个离散值<spanclass="math inline"><em>a</em></span>与<spanclass="math inline"><em>b</em></span>之间的 VDM 距离为： <spanclass="math display">$$\begin{aligned}VDM_p(a,b)=\sum_{i=1}^k\left|\frac{m_{u,a,i}}{m_{u,a}}-\frac{m_{u,b,i}}{m_{u,b}}\right|^p\end{aligned}$$</span></p><p>对于混合属性，可以使用 MinkovDM： <spanclass="math display">$$\mathrm{MinkovDM}_p(x_i,x_j)=\left(\sum_{u=1}^{n_c}|x_{iu}-x_{ju}|^p+\sum_{u=n_c+1}^n\mathrm{VDM}_p(x_{iu},x_{ju})\right)^{\frac{1}{p}}$$</span></p><h2 id="聚类方法概述">9.4 聚类方法概述</h2><p>聚类的好坏没有绝对标准，可以将人们按男女聚类，也可以按照是否近视聚类。</p><blockquote><p>聚类的故事： 老师拿来苹果和梨，让小朋友分成两份。小明把大苹果大梨放一起，小个头的放一起，老师点头，恩，体量感。小芳把红苹果挑出来，剩下的放一起，老师点头，颜色感。小武的结果？不明白。小武掏出眼镜：最新款，能看到水果里有几个籽，左边这堆单数，右边双数。老师很高兴：新的聚类算法诞生了。</p></blockquote><p>聚类也许是机器学习中“新算法”出现最多、最快的领域总能找到一个新的“标准”，使以往算法对它无能为力。</p><ul><li>原型聚类<ul><li>亦称“基于原型的聚类” （prototype-based clustering）</li><li>假设：聚类结构能通过一组原型刻画</li><li>过程：先对原型初始化，然后对原型进行迭代更新求解</li><li>代表：<strong>k均值聚类</strong>，学习向量量化（LVQ），高斯混合聚类</li></ul></li><li>密度聚类<ul><li>亦称“基于密度的聚类”（density-based clustering）</li><li>假设：聚类结构能通过样本分布的紧密程度确定</li><li>过程：从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇</li><li>代表：<strong>DBSCAN</strong>, OPTICS, DENCLUE</li></ul></li><li>层次聚类 （hierarchical clustering）<ul><li>假设：能够产生不同粒度的聚类结果</li><li>过程：在不同层次对数据集进行划分，从而形成树形的聚类结构</li><li>代表：<strong>AGNES</strong>（自底向上），DIANA（自顶向下）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Seaborn基本图表</title>
    <link href="/2024/06/30/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/"/>
    <url>/2024/06/30/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Seaborn 是对 Matplotlib 进行了更高级的封装，而且也能和 Pandas无缝整合，可以用更少的代码构建出更好的统计图表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 联网加载官方的小费数据集</span><br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> ssl<br><br>ssl._create_default_https_context = ssl._create_unverified_context<br><br>tips_df = sns.load_dataset(<span class="hljs-string">&#x27;tips&#x27;</span>)<br>tips_df.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 244 entries, 0 to 243Data columns (total 7 columns): #   Column      Non-Null Count  Dtype   ---  ------      --------------  -----    0   total_bill  244 non-null    float64  1   tip         244 non-null    float64  2   sex         244 non-null    category 3   smoker      244 non-null    category 4   day         244 non-null    category 5   time        244 non-null    category 6   size        244 non-null    int64   dtypes: category(4), float64(2), int64(1)memory usage: 7.4 KB</code></pre><p>首先设置主题更好看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.set_theme()<br></code></pre></td></tr></table></figure><h1 id="直方图">1 直方图</h1><p>Seaborn中的方法非常统一，基本上都可以直接给数据集，通过<code>x</code>/<code>y</code>设置坐标轴数据来源，大多数也可以使用<code>hue</code>参数对某一字段进行分组聚合，通过<code>palette</code>参数设置颜色搭配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, palette=<span class="hljs-string">&#x27;Dark2&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><figure><img src="09_01.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>直方图设置<code>kde=True</code>参数可以得到核密度估计图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, kde=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><figure><img src="09_02.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="核密度图">2 核密度图</h1><p>核密度估计图（KDE，Kernel Density EstimatePlot）是一种用于显示数据分布的统计图表，它通过平滑直方图的方法来估计数据的概率密度函数，使得分布图看起来更加连续和平滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.kdeplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Density&#39;&gt;</code></pre><figure><img src="09_03.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="散点图">3 散点图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.scatterplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><figure><img src="09_04.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>通过<code>regplot()</code>函数绘制散点图，同时会拟合回归曲线，这个函数不支持使用<code>hue</code>进行分组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.regplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><figure><img src="09_05.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>可以通过<code>lmplot()</code>函数绘制分组回归曲线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.lmplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.FacetGrid at 0x169a85210&gt;</code></pre><figure><img src="09_06.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>通过<code>jointplot()</code>函数绘制在每个轴上包含单个变量的散点图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.jointplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.JointGrid at 0x16b18afe0&gt;</code></pre><figure><img src="09_07.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="箱线图">4 箱线图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.boxplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;total_bill&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;total_bill&#39;&gt;</code></pre><figure><img src="09_08.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="小提琴图">5 小提琴图</h1><p>相较于箱线图，小提琴图没有标注异常点而是显示了数据的整个范围，另一方面，小提琴图很好的展示了数据的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><figure><img src="09_09.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>按性别分组统计使用颜色区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, split=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><figure><img src="09_10.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="成对关系图">6 成对关系图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.pairplot(data=tips_df, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.PairGrid at 0x175b91570&gt;</code></pre><figure><img src="09_11.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="自定义颜色">7 自定义颜色</h1><p>使用Seaborn自带的调色板设置颜色，上述的绘图函数都可以设置<code>palette</code>参数进行设置。</p><figure><img src="09_12.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Seaborn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Matplotlib数据可视化</title>
    <link href="/2024/06/28/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2024/06/28/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="绘图流程">1 绘图流程</h1><ol type="1"><li>创建画布<code>plt.figure()</code></li><li>绘制图像<code>plt.plot(x, y)</code>等</li><li>显示图像<code>plt.show()</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_01.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><p>使用以下魔法方法可以在画图的时候生成矢量图，图片更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">%config InlineBackend.figure_format=<span class="hljs-string">&#x27;svg&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="常用图形">2 常用图形</h1><h2 id="折线图">2.1 折线图</h2><p>绘制连续数据的折线图，适用于显示随时间或序列变化的趋势。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>/<code>y</code>：横纵坐标数据</li><li><code>linestyle</code>：线的样式<ul><li><code>'-'</code></li><li><code>'--'</code></li><li><code>'-.'</code></li><li><code>':'</code></li></ul></li><li><code>marker</code>：标记点的样式<ul><li><code>'o'</code></li><li><code>'s'</code></li><li><code>'^'</code></li></ul></li><li><code>color</code>：线的颜色</li><li><code>label</code>：图例标签（配合<code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br><br>plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_02.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="柱形图">2.2 柱形图</h2><p>绘制垂直的柱状图，用于比较不同类别的数量或数值大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.bar(x, height, width=<span class="hljs-number">0.8</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>：柱子横坐标</li><li><code>height</code>：柱子的高度</li><li><code>width</code>：柱子宽度（0~1）</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合<code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br>height = [<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>]<br><br>plt.bar(x, height, color=<span class="hljs-string">&#x27;b&#x27;</span>, width=<span class="hljs-number">0.5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_03.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="条形图">2.3 条形图</h2><p>绘制横向的柱状图，在类别名称较长时更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.barh(y, width, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>y</code>: 柱子的纵坐标</li><li><code>width</code>: 柱子的长度</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合<code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">y = [<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>]<br>width = [<span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">50</span>]<br><br>plt.barh(y, width)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_04.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="直方图">2.4 直方图</h2><p>用于展示数据的分布情况，将数据分成若干个区间(bin)，并统计每个区间内的数据数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.hist(data, bins=<span class="hljs-number">10</span>, color=<span class="hljs-string">&#x27;purple&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>data</code>：一维数据集</li><li><code>bins</code>：分组数量</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合<code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>data = np.random.randn(<span class="hljs-number">1000</span>)<br><br>plt.hist(data, bins=<span class="hljs-number">20</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_05.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="饼图">2.5 饼图</h2><p>用于展示不同类别在总体中所占的比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.pie(sizes, labels=labels, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>, explode=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>sizes</code>：各部分的数值</li><li><code>labels</code>：各部分的名称</li><li><code>autopct</code>：显示百分比的格式字符串</li><li><code>explode</code>：突出显示指定扇形，控制凸起程度</li><li><code>pctdistance</code>：百分比离圆心的距离，单位为半径</li><li><code>labeldistance</code>：标签离圆心的距离，单位为半径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lan = [<span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C#&#x27;</span>, <span class="hljs-string">&#x27;Others&#x27;</span>]<br>rate = [<span class="hljs-number">8.84</span>, <span class="hljs-number">24.45</span>, <span class="hljs-number">8.35</span>, <span class="hljs-number">1.92</span>, <span class="hljs-number">1.38</span>, <span class="hljs-number">9.29</span>, <span class="hljs-number">6.94</span>, <span class="hljs-number">38.83</span>]<br>ex = [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>plt.pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_06.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="散点图">2.6 散点图</h2><p>用于展示两个变量之间的关系，每个数据点在图上表示为一个点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, s=<span class="hljs-number">50</span>, alpha=<span class="hljs-number">0.6</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>/<code>y</code>：横纵坐标</li><li><code>color</code>：点的颜色（只能指定一个）</li><li><code>c</code>：可以使用颜色列表</li><li><code>s</code>：点的大小</li><li><code>alpha</code>：点的透明度</li><li><code>label</code>：图例</li><li><code>cmap</code>: 颜色映射，将数值映射到颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">sx = np.random.rand(<span class="hljs-number">100</span>)<br>sy = np.random.rand(<span class="hljs-number">100</span>)<br>colors = np.random.rand(<span class="hljs-number">100</span>)<br>sizes = <span class="hljs-number">100</span> * np.random.rand(<span class="hljs-number">100</span>)<br><br>plt.scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="08_07.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="箱线图">2.7 箱线图</h2><p>箱线图又叫箱型图或盒须图，是一种用于展示一组数据分散情况的统计图表。</p><ul><li><p>箱子中间线：中位数（Median）</p></li><li><p>箱子上边界：上四分位（Q3）</p></li><li><p>箱子下边界：下四分位（Q1）</p></li><li><p>箱子的长度：四分位距离（IQR）</p></li><li><p>“最大值”：其实是上须（upperwhisker），不被离群值影响的范围，Q3+1.5*IQR</p></li><li><p>“最小值”：下须（lower whisker），Q1-1.5*IQR</p></li><li><p>离群值：异常值，超出须的点</p></li></ul><p><img src="08_08.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">box_data = &#123;  <br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">82</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">70</span>, <span class="hljs-number">90</span>, <span class="hljs-number">76</span>, <span class="hljs-number">84</span>, <span class="hljs-number">83</span>, <span class="hljs-number">95</span>],  <br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">79</span>, <span class="hljs-number">93</span>, <span class="hljs-number">88</span>, <span class="hljs-number">82</span>, <span class="hljs-number">87</span>, <span class="hljs-number">89</span>, <span class="hljs-number">92</span>],  <br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">72</span>, <span class="hljs-number">68</span>, <span class="hljs-number">65</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>]  <br>&#125;  <br>​  <br>plt.boxplot(box_data.values(), tick_labels=box_data.keys())  <br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="08_09.png" /></p><h1 id="图表元素">3 图表元素</h1><h2 id="中文问题">3.1 中文问题</h2><p>Matplotlib中文兼容有问题，可以使用SimSun（宋体），SimHei（黑体），Kaiti（楷体）等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># plt.rcParams[&#x27;font.family&#x27;] = [&#x27;Microsoft YaHei&#x27;]  # Windows正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># Mac正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 正常显示负号</span><br></code></pre></td></tr></table></figure><h2 id="图表标题与网格线">3.2 图表标题与网格线</h2><ul><li><code>plt.title()</code>：设置图表标题<ul><li><code>fontdict</code>：设置字体</li><li><code>loc</code>：设置标题位置</li></ul></li><li><code>plt.grid()</code>：设置网格线<ul><li><code>axis</code>：控制轴向，有<code>x</code>、<code>y</code>、<code>both</code></li><li><code>linestyle</code>：线的样式，<code>:</code>、<code>--</code>、<code>-.</code>、<code>-</code></li><li><code>linewidth</code>：线的粗细</li><li><code>alpha</code>：透明度</li><li><code>color</code>：颜色</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.title(<span class="hljs-string">&#x27;趋势图&#x27;</span>, loc=<span class="hljs-string">&#x27;left&#x27;</span>)<br>plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><figure><img src="08_10.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="坐标轴相关">3.3 坐标轴相关</h2><ul><li><code>plt.xlabel()</code>：设置x轴标题</li><li><code>plt.ylabel()</code>：设置y轴标题</li><li><code>plt.xlim()</code>：设置x轴范围</li><li><code>plt.ylim()</code>：设置y轴范围</li><li><code>plt.xticks('刻度位置（数值）', '显示值')</code>：设置x轴显示的刻度值</li><li><code>plt.yticks('刻度位置', '显示值')</code>：设置y轴显示的刻度值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xlabel(<span class="hljs-string">&#x27;月份&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;销售额&#x27;</span>)<br><br>idx = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br>mon = [<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;月&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br><br>plt.xticks(idx, mon)<br>plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">13</span>)<br>plt.ylim(<span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(10000.0, 100000.0)</code></pre><figure><img src="08_11.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h2 id="显示图例">3.4 显示图例</h2><p>设置完<code>label</code>参数之后，使用<code>plt.legend()</code>才能显示图例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成数据</span><br>x1 = np.arange(-<span class="hljs-number">1</span>*np.pi, np.pi, <span class="hljs-number">0.05</span>)<br>y1 = np.sin(x1)<br>y2 = np.cos(x1)<br><br><span class="hljs-comment"># 设置x轴刻度</span><br>plt.xticks([-<span class="hljs-number">1</span>*np.pi, -<span class="hljs-number">0.5</span>*np.pi, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>*np.pi, np.pi],<br>           [<span class="hljs-string">&#x27;-π&#x27;</span>, <span class="hljs-string">&#x27;-1/2π&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1/2π&#x27;</span>, <span class="hljs-string">&#x27;π&#x27;</span>])<br><br><span class="hljs-comment"># 作图</span><br>plt.plot(x1, y1, label=<span class="hljs-string">&#x27;y1=sin(x)&#x27;</span>)<br>plt.plot(x1, y2, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>,label=<span class="hljs-string">&#x27;y2=cos(x)&#x27;</span>)<br><br>plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x1e60c67bf70&gt;</code></pre><figure><img src="08_12.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><h1 id="一图多表">4 一图多表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, figsize=(width, height))<br></code></pre></td></tr></table></figure><ul><li>nrows：子图的行数</li><li>ncols：子图的列数</li><li>figsize：画布的大小</li><li>fig：返回的画布对象，用于调整整体的属性</li><li>axs：返回的子图数组，用于绘制各个子图，是一个Numpy数组，可以通过<code>axs[0, 1]</code>访问特定子图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><figure><img src="08_13.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><p>上一章的图形依次放入子图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].barh(y, width)<br>axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].hist(data, bins=<span class="hljs-number">20</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.collections.PathCollection at 0x1e60cec4880&gt;</code></pre><p>为了精确地控制子图，使用对象式写法<code>axs.set_方法名</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;语言占比图&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;语言占比图&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig<br></code></pre></td></tr></table></figure><figure><img src="08_14.png" alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Pandas数据操作和清洗</title>
    <link href="/2024/06/25/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/"/>
    <url>/2024/06/25/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据操作">1 基本数据操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df1 = pd.read_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(df1)<br>df2 = pd.DataFrame(data=&#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;钱七&#x27;</span>], <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">66</span>], <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">99</span>], <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">77</span>]&#125;)<br><span class="hljs-built_in">print</span>(df2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60   姓名  语文  数学  英语0  赵六  50  88  201  钱七  66  99  77</code></pre><h2 id="新增列行">1.1 新增列/行</h2><p>增加列使用<code>df['新列名'] = 新列值</code>，会在原数据上直接添加，如果列名已存在则会覆盖原列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;历史&#x27;</span>] = [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td></tr></tbody></table></div><p>使用<code>df.loc['新索引'] = 新行值</code>，会在原数据上直接添加，如果索引已存在则会覆盖原索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[<span class="hljs-number">1001</span>] = [<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">199</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">66</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td></tr></tbody></table></div><p>使用<code>assign()</code>方法实现列的新增，返回一个新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(<br>    新列<span class="hljs-number">1</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">111</span>,<span class="hljs-number">1111</span>],<br>    新列<span class="hljs-number">2</span>=[<span class="hljs-number">6</span>, <span class="hljs-number">66</span>, <span class="hljs-number">666</span>, <span class="hljs-number">6666</span>]  <br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th><th>新列1</th><th>新列2</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td><td>1</td><td>6</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>50</td><td>11</td><td>66</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td><td>111</td><td>666</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td><td>1111</td><td>6666</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(加权分=<span class="hljs-keyword">lambda</span> x: df1[<span class="hljs-string">&#x27;语文&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;数学&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;英语&#x27;</span>]*<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>50</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td><td>84.0</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td><td>129.6</td></tr></tbody></table></div><h2 id="删除列行">1.2 删除列/行</h2><p>使用 <code>drop</code>函数删除，默认沿着0轴，也就是行进行删除，使用<code>axis=1</code>表示对列操作，返回新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-string">&#x27;历史&#x27;</span>, axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-number">1001</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td></tr></tbody></table></div><h2 id="修改元素值">1.3 修改元素值</h2><h3 id="直接修改">1.3.1 直接修改</h3><p>通过索引操作会直接修改原表的值，一般不建议在原表直接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[df1[<span class="hljs-string">&#x27;姓名&#x27;</span>] == <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>] = <span class="hljs-number">666</span><br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>666</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td></tr></tbody></table></div><h3 id="replace函数">1.3.2 replace函数</h3><p><code>replace()</code>：替换指定值（任意类型都可以），返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.replace(val, new_val, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.replace(<span class="hljs-number">80</span>, <span class="hljs-number">999</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>999</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>666</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>999</td><td>100</td><td>60</td><td>70</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td></tr></tbody></table></div><p>Pandas字符串和Python原生字符串的操作几乎一致，只需要在操作前加上一个<code>.str</code>即可。</p><p><code>str.replace()</code>：替换指定字符串，只能是字符串，返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.<span class="hljs-built_in">str</span>.replace(<span class="hljs-built_in">str</span>, new_str, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;姓名&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;朱八八&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0        张三1       朱八八2        王五1001    猪猪侠Name: 姓名, dtype: object</code></pre><blockquote><p><code>str</code>中只包含文本对象，而<code>object</code>中什么类型（数字、文本、布尔）都能往里装，实际应用中当做字符串处理即可</p></blockquote><h2 id="选取数据">1.4 选取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>666</td><td>52</td><td>50</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66</td></tr></tbody></table></div><h3 id="使用索引">1.4.1 使用索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>88</td><td>90</td></tr><tr><th>1</th><td>82</td><td>52</td></tr><tr><th>2</th><td>80</td><td>60</td></tr><tr><th>1001</th><td>199</td><td>50</td></tr></tbody></table></div><h3 id="有条件筛选">1.4.2 有条件筛选</h3><p>使用 <code>loc</code>筛选出语文大于80并且数学比最低分高的人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[(df1[<span class="hljs-string">&#x27;语文&#x27;</span>] &gt; <span class="hljs-number">80</span>) &amp; (df1[<span class="hljs-string">&#x27;数学&#x27;</span>] &gt; df1[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>1</th><td>李四</td><td>82</td><td>666</td><td>52</td><td>50</td></tr></tbody></table></div><h1 id="合并与连接">2 合并与连接</h1><h2 id="纵向连接">2.1 纵向连接</h2><p><code>concat()</code>：多表连接，默认按照列字段连接，类似SQL中的UNION。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span>, 表<span class="hljs-number">3</span>], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&#x27;outer&#x27;</span>, ignore_index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认纵向连接</li><li>join：对不齐的标签如何处理<ul><li><code>'outer'</code>：默认值，取并集</li><li><code>'inner'</code>：取交集</li></ul></li><li>ignore_index：是否重建索引，默认False，不重建可能有重复索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([df1, df2])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>历史</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>80.0</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>666</td><td>52</td><td>50.0</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>70.0</td></tr><tr><th>1001</th><td>猪猪侠</td><td>199</td><td>100</td><td>50</td><td>66.0</td></tr><tr><th>0</th><td>赵六</td><td>50</td><td>88</td><td>20</td><td>NaN</td></tr><tr><th>1</th><td>钱七</td><td>66</td><td>99</td><td>77</td><td>NaN</td></tr></tbody></table></div><h2 id="横向连接">2.2 横向连接</h2><p><code>merge()</code>：类似SQL的JOIN，需要指定连接依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">merge(left, right, how=<span class="hljs-string">&#x27;inner&#x27;</span>, on=<span class="hljs-literal">None</span>, left_on=<span class="hljs-literal">None</span>, right_on=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>left/right：要连接的左表和右表</li><li>how：连接方式<ul><li><code>'inner'</code>：内连接（默认）</li><li><code>'left'</code>：左连接</li><li><code>'right'</code>：右连接</li><li><code>'outer'</code>：外连接</li></ul></li><li>on：两边都有的列名，作为连接键</li><li>left_on/right_on：两表列名不一样时使用</li><li>left_index/right_index：都设置为True，使用索引作为连接键</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>,<span class="hljs-number">58</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>,<span class="hljs-number">70</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>,<span class="hljs-number">88</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>,<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>])<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">76</span>],<span class="hljs-string">&#x27;舞蹈&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>,<span class="hljs-string">&#x27;刘强&#x27;</span>])<br>display(df1)<br>display(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>李华</th><td>93</td><td>87</td></tr><tr><th>王明</th><td>80</td><td>99</td></tr><tr><th>铁蛋</th><td>85</td><td>95</td></tr><tr><th>刘强</th><td>76</td><td>85</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 内连接</span><br>pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;inner&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93</td><td>87</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80</td><td>99</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85</td><td>95</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 左连接</span><br>df3 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全连接</span><br>df4 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;outer&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>刘强</th><td>NaN</td><td>NaN</td><td>NaN</td><td>76.0</td><td>85.0</td></tr><tr><th>李华</th><td>85.0</td><td>95.0</td><td>97.0</td><td>93.0</td><td>87.0</td></tr><tr><th>李雷</th><td>80.0</td><td>99.0</td><td>85.0</td><td>NaN</td><td>NaN</td></tr><tr><th>王明</th><td>85.0</td><td>85.0</td><td>65.0</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58.0</td><td>70.0</td><td>88.0</td><td>85.0</td><td>95.0</td></tr><tr><th>韩梅梅</th><td>93.0</td><td>87.0</td><td>80.0</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h1 id="排序与top-n">3 排序与TOP-N</h1><h2 id="索引排序与值排序">3.1 索引排序与值排序</h2><p><code>sort_index()</code>：按照索引排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp_df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>]&#125;,<br>                        index = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Cathy&#x27;</span>, <span class="hljs-string">&#x27;David&#x27;</span>])<br>display(tmp_df)<br>display(tmp_df.sort_index())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>Bob</th><td>93</td><td>87</td><td>80</td></tr><tr><th>Alice</th><td>80</td><td>99</td><td>85</td></tr><tr><th>Cathy</th><td>85</td><td>95</td><td>97</td></tr><tr><th>David</th><td>85</td><td>85</td><td>65</td></tr></tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>Alice</th><td>80</td><td>99</td><td>85</td></tr><tr><th>Bob</th><td>93</td><td>87</td><td>80</td></tr><tr><th>Cathy</th><td>85</td><td>95</td><td>97</td></tr><tr><th>David</th><td>85</td><td>85</td><td>65</td></tr></tbody></table></div><p><code>sort_values()</code>：按每一列或多列的值进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.sort_values(by, ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>by：列名或列名列表</li><li>ascending：排序规则<ul><li><code>True</code>：升序排序（默认）</li><li><code>False</code>：降序排序</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文升序排序，语文相同按照数学降序排序</span><br>sort_df3 = df3.sort_values([<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>], ascending=[<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])<br>sort_df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h2 id="top-n问题">3.2 TOP-N问题</h2><p>排序之后使用 <code>head(n)</code>可以完成TOP-N问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sort_df3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr></tbody></table></div><p>解决TOP-N问题时，并不需要对所有数据进行排序，使用<code>nlargest()</code>和 <code>nsmallest()</code>更加高效：</p><ul><li><code>nlargest(n, 列)</code>：返回指定列最大的前n项</li><li><code>nsmallest(n, 列)</code>：返回指定列最小的前n项</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nlargest(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nsmallest(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;语文&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr></tbody></table></div><h2 id="rank函数">3.3 rank函数</h2><p>类似MySQL的开窗函数，用于新增一列排名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank = pd.concat([df1, df1])<br>df_rank<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td></tr><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank[<span class="hljs-string">&#x27;排名&#x27;</span>] = df_rank.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).rank(method=<span class="hljs-string">&#x27;min&#x27;</span>)<br>df_rank.sort_values(<span class="hljs-string">&#x27;排名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>排名</th></tr></thead><tbody><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>1.0</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>1.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>3.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>3.0</td></tr><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>5.0</td></tr><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>5.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>7.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>7.0</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>9.0</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>9.0</td></tr></tbody></table></div><h1 id="特殊值处理">4 特殊值处理</h1><h2 id="缺失值处理">4.1 缺失值处理</h2><h3 id="识别缺失值">4.1.1 识别缺失值</h3><p><code>isna()</code>：返回布尔值，标记缺失值位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.isna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>刘强</th><td>True</td><td>True</td><td>True</td><td>False</td><td>False</td></tr><tr><th>李华</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>李雷</th><td>False</td><td>False</td><td>False</td><td>True</td><td>True</td></tr><tr><th>王明</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>铁蛋</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>韩梅梅</th><td>False</td><td>False</td><td>False</td><td>True</td><td>True</td></tr></tbody></table></div><h3 id="删除缺失值">4.1.2 删除缺失值</h3><p><code>dropna()</code>：删除缺失值所在行或列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.dropna(axis=<span class="hljs-number">0</span>, how=<span class="hljs-string">&#x27;any&#x27;</span>, subset=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认为0删除行，1表示删除列</li><li>how：<ul><li><code>'any'</code>：只要有一个NaN就删除（默认）</li><li><code>'all'</code>：全部为NaN才删除</li></ul></li><li>subset：指定在哪些列上检查是否为NaN，多列需要使用<code>[]</code></li><li>inplace：是否在原表修改，默认为False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>刘强</th><td>NaN</td><td>NaN</td><td>NaN</td><td>76.0</td><td>85.0</td></tr><tr><th>李华</th><td>85.0</td><td>95.0</td><td>97.0</td><td>93.0</td><td>87.0</td></tr><tr><th>李雷</th><td>80.0</td><td>99.0</td><td>85.0</td><td>NaN</td><td>NaN</td></tr><tr><th>王明</th><td>85.0</td><td>85.0</td><td>65.0</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58.0</td><td>70.0</td><td>88.0</td><td>85.0</td><td>95.0</td></tr><tr><th>韩梅梅</th><td>93.0</td><td>87.0</td><td>80.0</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><p>返回新对象，如需修改原数据需设置 <code>inplace</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除所有出现空值的行</span><br>df4.dropna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>李华</th><td>85.0</td><td>95.0</td><td>97.0</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85.0</td><td>85.0</td><td>65.0</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58.0</td><td>70.0</td><td>88.0</td><td>85.0</td><td>95.0</td></tr></tbody></table></div><p>通过设置 <code>subset</code>参数删除指定列出现空值的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只删除语文和数学列出现空值的行</span><br>df4.dropna(subset=[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>李华</th><td>85.0</td><td>95.0</td><td>97.0</td><td>93.0</td><td>87.0</td></tr><tr><th>李雷</th><td>80.0</td><td>99.0</td><td>85.0</td><td>NaN</td><td>NaN</td></tr><tr><th>王明</th><td>85.0</td><td>85.0</td><td>65.0</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58.0</td><td>70.0</td><td>88.0</td><td>85.0</td><td>95.0</td></tr><tr><th>韩梅梅</th><td>93.0</td><td>87.0</td><td>80.0</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h3 id="填充空缺值">4.1.3 填充空缺值</h3><p><code>fillna()</code>将空缺值填充为指定值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.fillna(value=<span class="hljs-literal">None</span>, method=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>value：数值或字典</li><li>method：基于近邻值填充<ul><li><code>'ffill'</code>：用前一个值填充</li><li><code>'bfill'</code>：用后一个值填充</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr></tbody></table></div><p>全部填充为指定值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>0.0</td><td>0.0</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>0.0</td><td>0.0</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr></tbody></table></div><p><code>fillna(&#123;'列名1': 值1, '列名2', 值2...&#125;)</code>可以设定每个列的空值如何填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 篮球填充为50，舞蹈填充为平均值</span><br>df3.fillna(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;舞蹈&#x27;</span>: df3[<span class="hljs-string">&#x27;舞蹈&#x27;</span>].mean()&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>韩梅梅</th><td>93</td><td>87</td><td>80</td><td>50.0</td><td>93.666667</td></tr><tr><th>李雷</th><td>80</td><td>99</td><td>85</td><td>50.0</td><td>93.666667</td></tr><tr><th>李华</th><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.000000</td></tr><tr><th>王明</th><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.000000</td></tr><tr><th>铁蛋</th><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.000000</td></tr></tbody></table></div><h2 id="去除重复项">4.2 去除重复项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">99</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>])<br>df5 = pd.concat([df3, tmp])<br>df5.reset_index(names=<span class="hljs-string">&#x27;姓名&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>0</th><td>韩梅梅</td><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>李雷</td><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>2</th><td>李华</td><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>3</th><td>王明</td><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>4</th><td>铁蛋</td><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>5</th><td>韩梅梅</td><td>93</td><td>100</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>6</th><td>李雷</td><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><p><code>drop_duplicates()</code>：删除重复行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.drop_duplicates(subset=<span class="hljs-literal">None</span>, keep=<span class="hljs-string">&#x27;first&#x27;</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>subset：指定在哪些列上检查是否重复，多列需要使用<code>[]</code>，默认为所有列</li><li>keep：保留哪个重复项<ul><li><code>'first'</code>：保留第一次出现的（默认）</li><li><code>'last'</code>：保留最后一次出现的</li><li><code>False</code>：重复项全部删除</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除完全重复的行</span><br>df5.drop_duplicates()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>0</th><td>韩梅梅</td><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>李雷</td><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>2</th><td>李华</td><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>3</th><td>王明</td><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>4</th><td>铁蛋</td><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>5</th><td>韩梅梅</td><td>93</td><td>100</td><td>80</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><p>按照姓名的重复值进行删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>0</th><td>韩梅梅</td><td>93</td><td>87</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>李雷</td><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr><tr><th>2</th><td>李华</td><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>3</th><td>王明</td><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>4</th><td>铁蛋</td><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr></tbody></table></div><p>保留最后一个出现的重复值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>, keep=<span class="hljs-string">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>2</th><td>李华</td><td>85</td><td>95</td><td>97</td><td>93.0</td><td>87.0</td></tr><tr><th>3</th><td>王明</td><td>85</td><td>85</td><td>65</td><td>80.0</td><td>99.0</td></tr><tr><th>4</th><td>铁蛋</td><td>58</td><td>70</td><td>88</td><td>85.0</td><td>95.0</td></tr><tr><th>5</th><td>韩梅梅</td><td>93</td><td>100</td><td>80</td><td>NaN</td><td>NaN</td></tr><tr><th>6</th><td>李雷</td><td>80</td><td>99</td><td>85</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h1 id="类型转换与数据变形">5 类型转换与数据变形</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>篮球</th><th>舞蹈</th></tr></thead><tbody><tr><th>刘强</th><td>NaN</td><td>NaN</td><td>NaN</td><td>76.0</td><td>85.0</td></tr><tr><th>李华</th><td>85.0</td><td>95.0</td><td>97.0</td><td>93.0</td><td>87.0</td></tr><tr><th>李雷</th><td>80.0</td><td>99.0</td><td>85.0</td><td>NaN</td><td>NaN</td></tr><tr><th>王明</th><td>85.0</td><td>85.0</td><td>65.0</td><td>80.0</td><td>99.0</td></tr><tr><th>铁蛋</th><td>58.0</td><td>70.0</td><td>88.0</td><td>85.0</td><td>95.0</td></tr><tr><th>韩梅梅</th><td>93.0</td><td>87.0</td><td>80.0</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h2 id="数据类型转换">5.1 数据类型转换</h2><ul><li><code>dtypes</code>：查看每列的数据类型</li><li><code>astype()</code>：转换数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果有空值，转换为int会报错，需要先处理</span><br>display(df4.dtypes)<br>df4[<span class="hljs-string">&#x27;篮球&#x27;</span>] = df4[<span class="hljs-string">&#x27;篮球&#x27;</span>].fillna(<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;i4&#x27;</span>)<br>display(df4.dtypes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文    float64数学    float64英语    float64篮球    float64舞蹈    float64dtype: object语文    float64数学    float64英语    float64篮球      int32舞蹈    float64dtype: object</code></pre><ul><li><code>to_datetime()</code>: 将字符串转换为日期时间类型</li><li><code>round(n)</code>：保留n位小数</li><li><code>astype('category')</code>：转换为分类数据类型</li></ul><p>有一种特殊的数据类型 <code>category</code>对应于统计学中的分类变量。这种变量的特点是：</p><ul><li>有限且固定：取值是有限的、通常是固定的一组可能的值</li><li>标签或名称：数据本质上是标签或名称，而不是可以进行数学运算的数值</li></ul><p>常见例子：性别（男/女）、血型（A/B/O/AB）、等级（高/中/低）、国家名称等。</p><p><code>category</code> 对于每种类别存储一次，然后用较小的整数来表示Series中的每个值，并映射回实际的类别名称，可以大大节省内存并且提高性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;列&#x27;</span>].astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="行列转置">5.2 行列转置</h2><p>行变列，列变行，使用 <code>df.T</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.T<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>韩梅梅</th><th>李雷</th><th>李华</th><th>王明</th><th>铁蛋</th></tr></thead><tbody><tr><th>语文</th><td>93.0</td><td>80.0</td><td>85.0</td><td>85.0</td><td>58.0</td></tr><tr><th>数学</th><td>87.0</td><td>99.0</td><td>95.0</td><td>85.0</td><td>70.0</td></tr><tr><th>英语</th><td>80.0</td><td>85.0</td><td>97.0</td><td>65.0</td><td>88.0</td></tr><tr><th>篮球</th><td>NaN</td><td>NaN</td><td>93.0</td><td>80.0</td><td>85.0</td></tr><tr><th>舞蹈</th><td>NaN</td><td>NaN</td><td>87.0</td><td>99.0</td><td>95.0</td></tr></tbody></table></div><h2 id="分列操作">5.3 分列操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Full_Name&#x27;</span>: [<span class="hljs-string">&#x27;Alice Smith&#x27;</span>, <span class="hljs-string">&#x27;Bob Johnson&#x27;</span>, <span class="hljs-string">&#x27;Charlie Brown&#x27;</span>]&#125;)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Full_Name</th></tr></thead><tbody><tr><th>0</th><td>Alice Smith</td></tr><tr><th>1</th><td>Bob Johnson</td></tr><tr><th>2</th><td>Charlie Brown</td></tr></tbody></table></div><p>利用字符串方法按分隔符拆分字符串列，生成多列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分割，返回列表</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      [Alice, Smith]1      [Bob, Johnson]2    [Charlie, Brown]Name: Full_Name, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用expand参数变成多列</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><th>0</th><td>Alice</td><td>Smith</td></tr><tr><th>1</th><td>Bob</td><td>Johnson</td></tr><tr><th>2</th><td>Charlie</td><td>Brown</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[[<span class="hljs-string">&#x27;First_Name&#x27;</span>, <span class="hljs-string">&#x27;Last_Name&#x27;</span>]] =  df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Full_Name</th><th>First_Name</th><th>Last_Name</th></tr></thead><tbody><tr><th>0</th><td>Alice Smith</td><td>Alice</td><td>Smith</td></tr><tr><th>1</th><td>Bob Johnson</td><td>Bob</td><td>Johnson</td></tr><tr><th>2</th><td>Charlie Brown</td><td>Charlie</td><td>Brown</td></tr></tbody></table></div><h1 id="文本与分箱处理">6 文本与分箱处理</h1><h2 id="文本数据处理">6.1 文本数据处理</h2><p>Pandas中文本数据使用 <code>object</code>类型存储，先使用一个<code>.str</code>把其当做<code>str</code>进行处理，然后就和Python原生的字符串处理方式一致了，字符串处理函数会对<strong>每个元素单独进行处理</strong>。常用字符串处理函数：</p><ul><li><code>lower()</code>：转换为小写</li><li><code>upper()</code>：转换为大写</li><li><code>replace(old, new)</code>：替换指定字符串</li><li><code>split(sep)</code>：按指定分隔符拆分字符串，返回一个列表</li><li><code>strip()</code>：去除字符串两端的空白字符</li><li><code>contains(sub)</code>：判断是否包含指定子字符串，返回布尔值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;First_Name&#x27;</span>].<span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.strings.accessor.StringMethods at 0x2be226bf700&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>] = df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.upper()<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Full_Name</th><th>First_Name</th><th>Last_Name</th></tr></thead><tbody><tr><th>0</th><td>ALICE SMITH</td><td>Alice</td><td>Smith</td></tr><tr><th>1</th><td>BOB JOHNSON</td><td>Bob</td><td>Johnson</td></tr><tr><th>2</th><td>CHARLIE BROWN</td><td>Charlie</td><td>Brown</td></tr></tbody></table></div><h2 id="数据分箱">6.2 数据分箱</h2><p><code>cut</code>：把数据离散化，用于一维数组的分类和打标，返回一个Series区间对象，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.cut(x, bins, right=<span class="hljs-literal">True</span>, labels=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>x：要分箱的序列</li><li>bins：分箱方式<ul><li>整数：等宽分为几段</li><li>列表：自定义分箱边界</li></ul></li><li>right：是否包含右边界，默认包含</li><li>labels：给分箱结果贴标签</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df7 = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;班级&#x27;</span>: [<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>],<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;小刚&#x27;</span>,<span class="hljs-string">&#x27;小李&#x27;</span>,<span class="hljs-string">&#x27;小张&#x27;</span>,<span class="hljs-string">&#x27;小赵&#x27;</span>],<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">35</span>, <span class="hljs-number">83</span>, <span class="hljs-number">45</span>, <span class="hljs-number">95</span>, <span class="hljs-number">72</span>],<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">92</span>],<br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">95</span>, <span class="hljs-number">80</span>, <span class="hljs-number">78</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">90</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">level = pd.cut(df7[<span class="hljs-string">&#x27;语文&#x27;</span>], bins=[<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>], labels=[<span class="hljs-string">&#x27;不及格&#x27;</span>, <span class="hljs-string">&#x27;及格&#x27;</span>, <span class="hljs-string">&#x27;中等&#x27;</span>, <span class="hljs-string">&#x27;良好&#x27;</span>, <span class="hljs-string">&#x27;优秀&#x27;</span>])<br>level<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     及格1    不及格2     良好3    不及格4     优秀5     中等Name: 语文, dtype: categoryCategories (5, object): [&#39;不及格&#39; &lt; &#39;及格&#39; &lt; &#39;中等&#39; &lt; &#39;良好&#39; &lt; &#39;优秀&#39;]</code></pre><p>给原数组加上一列分箱区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>] = level<br>df7<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>班级</th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>语文水平</th></tr></thead><tbody><tr><th>0</th><td>一班</td><td>小明</td><td>70</td><td>90</td><td>95</td><td>及格</td></tr><tr><th>1</th><td>一班</td><td>小红</td><td>35</td><td>85</td><td>80</td><td>不及格</td></tr><tr><th>2</th><td>一班</td><td>小刚</td><td>83</td><td>88</td><td>78</td><td>良好</td></tr><tr><th>3</th><td>二班</td><td>小李</td><td>45</td><td>75</td><td>85</td><td>不及格</td></tr><tr><th>4</th><td>二班</td><td>小张</td><td>95</td><td>80</td><td>88</td><td>优秀</td></tr><tr><th>5</th><td>二班</td><td>小赵</td><td>72</td><td>92</td><td>90</td><td>中等</td></tr></tbody></table></div><h1 id="数据透视">7 数据透视</h1><h2 id="分组">7.1 分组</h2><p><code>groupby()</code>：按照列进行分组，对每组应用聚合函数，多列参数需要使用<code>[]</code>括住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002BE22601180&gt;</code></pre><p>分组得到的是一个分组对象，分组对象本身不返回结果，分组对象有以下属性和方法可以使用：</p><ul><li><code>groups</code>：查看分组数据</li><li><code>get_group(name)</code>：获取某个组的数据</li><li><code>size()</code>：返回各组的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各组数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).groups)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一班数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).get_group(<span class="hljs-string">&#x27;一班&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各班人数：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).size())<br></code></pre></td></tr></table></figure><pre><code class="hljs">各组数据： &#123;&#39;一班&#39;: [0, 1, 2], &#39;二班&#39;: [3, 4, 5]&#125;一班数据：    班级  姓名  语文  数学  英语 语文水平0  一班  小明  70  90  95   及格1  一班  小红  35  85  80  不及格2  一班  小刚  83  88  78   良好各班人数： 班级一班    3二班    3dtype: int64</code></pre><p>进一步可以使用聚合函数，类似SQL的聚合函数，常用：</p><ul><li><code>sum()</code>：求和</li><li><code>mean()</code>：平均值</li><li><code>max()</code>：最大值</li><li><code>min()</code>：最小值</li><li><code>median()</code>：中位数</li><li><code>var()</code>：方差</li><li><code>std()</code>：标准差</li><li><code>size()</code>：所有元素个数</li><li><code>count()</code>：非空元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby(分组字段)[聚合字段].聚合函数()<br></code></pre></td></tr></table></figure><p>聚合函数指定<code>numeric_only=True</code>参数，可以只对数值型数据进行聚合计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">sum</span>(numeric_only=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr><tr><th>班级</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>一班</th><td>188</td><td>263</td><td>253</td></tr><tr><th>二班</th><td>212</td><td>247</td><td>263</td></tr></tbody></table></div><p>还可以对指定列进行分组聚合，通过列表传入，聚合的依据列默认会变为索引，可以使用<code>as_index=False</code>使其不变成索引，保留为普通列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>, as_index=<span class="hljs-literal">False</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].mean()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>班级</th><th>语文</th><th>数学</th></tr></thead><tbody><tr><th>0</th><td>一班</td><td>62.666667</td><td>87.666667</td></tr><tr><th>1</th><td>二班</td><td>70.666667</td><td>82.333333</td></tr></tbody></table></div><h2 id="聚合">7.2 聚合</h2><p><code>agg()</code>：对分组后的数据应用多个聚合函数，使分组聚合更加灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([<span class="hljs-string">&#x27;列名1&#x27;</span>, <span class="hljs-string">&#x27;列名2&#x27;</span>]).agg(&#123;<br>    <span class="hljs-string">&#x27;指定列1&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列2&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列3&#x27;</span>: [<span class="hljs-string">&#x27;聚合函数1&#x27;</span>, <span class="hljs-string">&#x27;聚合函数2&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对语文数学同时计算最小值和最大值</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].agg(&#123;<span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr><th></th><th colspan="2" halign="left">语文</th><th colspan="2" halign="left">数学</th></tr><tr><th></th><th>min</th><th>max</th><th>min</th><th>max</th></tr><tr><th>班级</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>一班</th><td>35</td><td>83</td><td>85</td><td>90</td></tr><tr><th>二班</th><td>45</td><td>95</td><td>75</td><td>92</td></tr></tbody></table></div><p>不同列使用不同聚合函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文计算平均分，数学计算最高分和最低分</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;mean&#x27;</span>,<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr><th></th><th>语文</th><th colspan="2" halign="left">数学</th></tr><tr><th></th><th>mean</th><th>max</th><th>min</th></tr><tr><th>班级</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>一班</th><td>62.666667</td><td>90</td><td>85</td></tr><tr><th>二班</th><td>70.666667</td><td>92</td><td>75</td></tr></tbody></table></div><p>另外<code>agg()</code>当中也可以使用自定义函数，或者直接使用lambda函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[<span class="hljs-string">&#x27;数学&#x27;</span>].agg(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">班级一班     5二班    17Name: 数学, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>()<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>数学</th></tr><tr><th>班级</th><th></th></tr></thead><tbody><tr><th>一班</th><td>5</td></tr><tr><th>二班</th><td>17</td></tr></tbody></table></div><h2 id="过滤">7.3 过滤</h2><p>根据分组后的统计信息对组进行筛选，<code>filter()</code>接收一个函数作为参数，该函数接收每个组，返回<code>True</code>或<code>False</code>决定是否保留该组，结果返回的是符合过滤条件的组内所有成员，而不是仅返回符合条件的组的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>].mean() &gt; <span class="hljs-number">65</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>班级</th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>语文水平</th></tr></thead><tbody><tr><th>3</th><td>二班</td><td>小李</td><td>45</td><td>75</td><td>85</td><td>不及格</td></tr><tr><th>4</th><td>二班</td><td>小张</td><td>95</td><td>80</td><td>88</td><td>优秀</td></tr><tr><th>5</th><td>二班</td><td>小赵</td><td>72</td><td>92</td><td>90</td><td>中等</td></tr></tbody></table></div><h2 id="交叉表">7.4 交叉表</h2><p>交叉表是一种特殊的透视表，主要用于计算两个或多个分类变量的频率分布（计数），统计行中每一个唯一值对应的列每一个唯一值分组个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(index, columns, margins=<span class="hljs-literal">False</span>, normalize=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>margins：是否添加行和列的总计</li><li>normalize：是否将频率转化为百分比</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>语文水平</th><th>不及格</th><th>及格</th><th>中等</th><th>良好</th><th>优秀</th></tr><tr><th>班级</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>一班</th><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><th>二班</th><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>], margins=<span class="hljs-literal">True</span>, normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>语文水平</th><th>不及格</th><th>及格</th><th>中等</th><th>良好</th><th>优秀</th><th>All</th></tr><tr><th>班级</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>一班</th><td>0.166667</td><td>0.166667</td><td>0.000000</td><td>0.166667</td><td>0.000000</td><td>0.5</td></tr><tr><th>二班</th><td>0.166667</td><td>0.000000</td><td>0.166667</td><td>0.000000</td><td>0.166667</td><td>0.5</td></tr><tr><th>All</th><td>0.333333</td><td>0.166667</td><td>0.166667</td><td>0.166667</td><td>0.166667</td><td>1.0</td></tr></tbody></table></div><h2 id="透视表">7.5 透视表</h2><p>透视表更加灵活，不只是计数，可以使用各种聚合函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.pivot_table(values, index, columns, aggfunc=<span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>values：要聚合计算的数值列</li><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>aggfunc：聚合函数，默认为 <code>mean</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>df = pd.DataFrame(data = &#123;<br>    <span class="hljs-string">&#x27;销售人员&#x27;</span>: [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>],<br>    <span class="hljs-string">&#x27;地区&#x27;</span>: [<span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>],<br>    <span class="hljs-string">&#x27;销售额&#x27;</span>: [<span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">250</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>]<br>    &#125;<br>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>销售人员</th><th>地区</th><th>销售额</th></tr></thead><tbody><tr><th>0</th><td>Alice</td><td>北区</td><td>150</td></tr><tr><th>1</th><td>Bob</td><td>南区</td><td>200</td></tr><tr><th>2</th><td>Alice</td><td>南区</td><td>250</td></tr><tr><th>3</th><td>Bob</td><td>北区</td><td>300</td></tr><tr><th>4</th><td>Alice</td><td>南区</td><td>100</td></tr><tr><th>5</th><td>Bob</td><td>南区</td><td>400</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(values=<span class="hljs-string">&#x27;销售额&#x27;</span>, index=<span class="hljs-string">&#x27;销售人员&#x27;</span>, columns=<span class="hljs-string">&#x27;地区&#x27;</span>, aggfunc=<span class="hljs-string">&#x27;max&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>地区</th><th>北区</th><th>南区</th></tr><tr><th>销售人员</th><th></th><th></th></tr></thead><tbody><tr><th>Alice</th><td>150</td><td>250</td></tr><tr><th>Bob</th><td>300</td><td>400</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Pandas索引运算</title>
    <link href="/2024/06/23/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/"/>
    <url>/2024/06/23/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>Pandas索引操作有两种常见类型：</p><ul><li>基于位置的索引（Position-based Indexing）</li><li>基于标签的索引（Label-based Indexing）</li></ul><p>实际操作中，第二种操作更常用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h1 id="dataframe结构">1 DataFrame结构</h1><h2 id="columnindexvalue">1.1 column/index/value</h2><p>DataFrame主要包含以下三个部分：</p><ul><li><code>column</code>：列标签（Index对象）</li><li><code>index</code>：行标签（Index对象）</li><li><code>value</code>：数据域</li></ul><p>基于标签定位就是靠<code>Index</code>对象，在此之外还有动态映射出来的虚拟列号和行号，可以直接基于数组下标进行定位，也就是基于位置定位。</p><figure><img src="06_dataframe.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_excel(<span class="hljs-string">&#x27;data/source_data.xlsx&#x27;</span>)<br>df.index = np.arange(<span class="hljs-number">1001</span>, <span class="hljs-number">1008</span>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1001</th><td>一级</td><td>A区</td><td>44300</td><td>11.78%</td><td>58.79</td><td>306887.83</td></tr><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.10</td></tr><tr><th>1003</th><td>一级</td><td>C区</td><td>18389</td><td>2.50%</td><td>0.28</td><td>129.58</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.20</td></tr><tr><th>1006</th><td>一级</td><td>A区</td><td>2424</td><td>22.07%</td><td>89.33</td><td>47791.60</td></tr><tr><th>1007</th><td>一级</td><td>C区</td><td>2412</td><td>8.21%</td><td>56.04</td><td>11096.42</td></tr></tbody></table></div><h2 id="单独取列行">1.2 单独取列/行</h2><p><code>DataFrame</code>的行和列单独取出来都是一个<code>Series</code>对象，事实上，<code>DataFrame</code>对象就是将多个<code>Series</code>对象组合到一起的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一列，两种方式</span><br><span class="hljs-built_in">print</span>(df[<span class="hljs-string">&#x27;客单价&#x27;</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.客单价)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float641001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一行，两种方式</span><br><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-number">1005</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object</code></pre><h1 id="基于位置定位">2 基于位置定位</h1><p>基于位置索引使用 <code>iloc[行号, 列号]</code>进行选取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1001</th><td>一级</td><td>A区</td><td>44300</td><td>11.78%</td><td>58.79</td><td>306887.83</td></tr><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.10</td></tr><tr><th>1003</th><td>一级</td><td>C区</td><td>18389</td><td>2.50%</td><td>0.28</td><td>129.58</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.20</td></tr><tr><th>1006</th><td>一级</td><td>A区</td><td>2424</td><td>22.07%</td><td>89.33</td><td>47791.60</td></tr><tr><th>1007</th><td>一级</td><td>C区</td><td>2412</td><td>8.21%</td><td>56.04</td><td>11096.42</td></tr></tbody></table></div><p>DataFrame索引方式大体分为下面四种，其中行和列类似Numpy的索引运算，可以使用切片索引、花式索引、布尔索引。</p><ul><li><code>df[列][行]</code>：先选列再选行，链式索引，不推荐</li><li><code>df.loc[行][列]/df.iloc[行][列]</code>：先取行再取列，链式索引可能产生副本，修改不会反映到原对象，不推荐</li><li><code>df.loc[行, 列]</code>：标签方式一次性定位，推荐！</li><li><code>df.iloc[行, 列]</code>：位置方式一次性定位，推荐！</li></ul><h2 id="行选取">2.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 连续选取，使用切片索引</span><br>df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1003</th><td>一级</td><td>C区</td><td>18389</td><td>2.50%</td><td>0.28</td><td>129.58</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.20</td></tr></tbody></table></div><p>花式索引需要构造列表，将列表作为单个参数传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 跨行选取，使用花式索引</span><br>df.iloc[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.10</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1007</th><td>一级</td><td>C区</td><td>2412</td><td>8.21%</td><td>56.04</td><td>11096.42</td></tr></tbody></table></div><h2 id="列选取">2.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[:, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>访客数</th><th>支付转化率</th></tr></thead><tbody><tr><th>1001</th><td>A区</td><td>44300</td><td>11.78%</td></tr><tr><th>1002</th><td>B区</td><td>30612</td><td>13.85%</td></tr><tr><th>1003</th><td>C区</td><td>18389</td><td>2.50%</td></tr><tr><th>1004</th><td>B区</td><td>4509</td><td>10.73%</td></tr><tr><th>1005</th><td>C区</td><td>3769</td><td>5.73%</td></tr><tr><th>1006</th><td>A区</td><td>2424</td><td>22.07%</td></tr><tr><th>1007</th><td>C区</td><td>2412</td><td>8.21%</td></tr></tbody></table></div><h2 id="行列交叉选取">2.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>支付金额</th></tr></thead><tbody><tr><th>1003</th><td>C区</td><td>129.58</td></tr><tr><th>1004</th><td>B区</td><td>31035.14</td></tr><tr><th>1005</th><td>C区</td><td>20068.20</td></tr></tbody></table></div><h1 id="基于标签定位">3 基于标签定位</h1><p>基于标签定位使用 <code>loc['行标签', '列标签']</code>进行选取。</p><p>注意：<code>loc</code>的切片是包含结束值的！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1001</th><td>一级</td><td>A区</td><td>44300</td><td>11.78%</td><td>58.79</td><td>306887.83</td></tr><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.10</td></tr><tr><th>1003</th><td>一级</td><td>C区</td><td>18389</td><td>2.50%</td><td>0.28</td><td>129.58</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.20</td></tr><tr><th>1006</th><td>一级</td><td>A区</td><td>2424</td><td>22.07%</td><td>89.33</td><td>47791.60</td></tr><tr><th>1007</th><td>一级</td><td>C区</td><td>2412</td><td>8.21%</td><td>56.04</td><td>11096.42</td></tr></tbody></table></div><h2 id="行选取-1">3.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[<span class="hljs-number">1003</span>: <span class="hljs-number">1005</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1003</th><td>一级</td><td>C区</td><td>18389</td><td>2.50%</td><td>0.28</td><td>129.58</td></tr><tr><th>1004</th><td>一级</td><td>B区</td><td>4509</td><td>10.73%</td><td>64.12</td><td>31035.14</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.20</td></tr></tbody></table></div><p>结合布尔索引将判断结果作为掩码可以进行筛选数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; <span class="hljs-number">80</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.1</td></tr><tr><th>1005</th><td>一级</td><td>C区</td><td>3769</td><td>5.73%</td><td>92.91</td><td>20068.2</td></tr><tr><th>1006</th><td>一级</td><td>A区</td><td>2424</td><td>22.07%</td><td>89.33</td><td>47791.6</td></tr></tbody></table></div><h2 id="列选取-1">3.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>客单价</th></tr></thead><tbody><tr><th>1001</th><td>A区</td><td>58.79</td></tr><tr><th>1002</th><td>B区</td><td>86.64</td></tr><tr><th>1003</th><td>C区</td><td>0.28</td></tr><tr><th>1004</th><td>B区</td><td>64.12</td></tr><tr><th>1005</th><td>C区</td><td>92.91</td></tr><tr><th>1006</th><td>A区</td><td>89.33</td></tr><tr><th>1007</th><td>C区</td><td>56.04</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[:, [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>客单价</th></tr></thead><tbody><tr><th>1001</th><td>A区</td><td>58.79</td></tr><tr><th>1002</th><td>B区</td><td>86.64</td></tr><tr><th>1003</th><td>C区</td><td>0.28</td></tr><tr><th>1004</th><td>B区</td><td>64.12</td></tr><tr><th>1005</th><td>C区</td><td>92.91</td></tr><tr><th>1006</th><td>A区</td><td>89.33</td></tr><tr><th>1007</th><td>C区</td><td>56.04</td></tr></tbody></table></div><h2 id="行列交叉选取-1">3.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;B区&#x27;</span>) | (df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;C区&#x27;</span>), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>访客数</th><th>客单价</th></tr></thead><tbody><tr><th>1002</th><td>B区</td><td>30612</td><td>86.64</td></tr><tr><th>1003</th><td>C区</td><td>18389</td><td>0.28</td></tr><tr><th>1004</th><td>B区</td><td>4509</td><td>64.12</td></tr><tr><th>1005</th><td>C区</td><td>3769</td><td>92.91</td></tr><tr><th>1007</th><td>C区</td><td>2412</td><td>56.04</td></tr></tbody></table></div><h3 id="query函数">3.3.1 query函数</h3><p><code>query(exp, inplace=False</code>)`：可以使用Python布尔表达式进行选取符合条件的行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&quot;访客数 &gt; 3000 and 访客数 &lt; 20000&quot;</span>)[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>访客数</th><th>客单价</th></tr></thead><tbody><tr><th>1003</th><td>C区</td><td>18389</td><td>0.28</td></tr><tr><th>1004</th><td>B区</td><td>4509</td><td>64.12</td></tr><tr><th>1005</th><td>C区</td><td>3769</td><td>92.91</td></tr></tbody></table></div><h3 id="isin函数">3.3.2 isin函数</h3><p><code>isin()</code>函数：判断是否等于列表中的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;投放地区&#x27;</span>].isin([<span class="hljs-string">&#x27;B区&#x27;</span>, <span class="hljs-string">&#x27;C区&#x27;</span>]), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>投放地区</th><th>访客数</th><th>客单价</th></tr></thead><tbody><tr><th>1002</th><td>B区</td><td>30612</td><td>86.64</td></tr><tr><th>1003</th><td>C区</td><td>18389</td><td>0.28</td></tr><tr><th>1004</th><td>B区</td><td>4509</td><td>64.12</td></tr><tr><th>1005</th><td>C区</td><td>3769</td><td>92.91</td></tr><tr><th>1007</th><td>C区</td><td>2412</td><td>56.04</td></tr></tbody></table></div><h2 id="多条件索引">3.4 多条件索引</h2><p>在使用索引筛选出数据之后，只需要加个统计函数的尾巴就可以直接算出统计数值。</p><ul><li><code>mean()</code> #计算均值</li><li><code>std()</code> #计算标准差</li><li><code>median()</code> #计算中位数</li><li><code>max()</code> #计算最大值</li><li><code>min()</code> #计算最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;客单价平均值&#x27;</span>, df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">客单价平均值 64.01571428571428</code></pre><p>搭配布尔索引进一步进行统计筛选，使用<code>&amp;</code>、<code>|</code>时，表达式注意必须要用括号<code>()</code>括起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;访客数&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;访客数&#x27;</span>].mean()) &amp; (df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }`</style><p>`</p><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>流量级别</th><th>投放地区</th><th>访客数</th><th>支付转化率</th><th>客单价</th><th>支付金额</th></tr></thead><tbody><tr><th>1002</th><td>一级</td><td>B区</td><td>30612</td><td>13.85%</td><td>86.64</td><td>367338.1</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Pandas数据结构</title>
    <link href="/2024/06/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/06/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>Numpy和Pandas的关系：就像先掌握算术才能学代数一样，NumPy就是数据分析的”算术基础”，虽然可以直接用计算器（Pandas），但理解底层原理才能走得更远。</p><p>Pandas核心数据机构是<code>Series</code>(数据系列)、<code>DataFrame</code>(数据窗/数据框)，<code>Series</code>可以看做表中的一列，<code>DataFrame</code>则是整个表格，由多个列构成。除此之外还有一个特殊的<code>Index</code>类，为<code>Series</code>和<code>DataFrame</code>提供索引功能。</p><h1 id="series对象">1 Series对象</h1><h2 id="创建-series-对象">1.1 创建 Series 对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p><code>Series</code>对象内部结构：一个ndarray用来保存数据，一个index用来保存索引。类似Numpy的一维数组，但是增加了“标签”，具有数据和索引。</p><figure><img src="05_series.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><ul><li>通过列表和数组创建<ul><li><code>data</code>：数据</li><li><code>index</code>：索引</li><li><code>name</code>：名称</li></ul></li></ul><p>其中<code>name</code>的作用：</p><ol type="1"><li>创建<code>DataFrame</code>时自动变成列名</li><li>合并时作为对齐依据</li><li>导出csv时成为列名</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 = pd.Series(data=np.arange(<span class="hljs-number">4</span>), index=[<span class="hljs-string">&#x27;春&#x27;</span>, <span class="hljs-string">&#x27;夏&#x27;</span>, <span class="hljs-string">&#x27;秋&#x27;</span>, <span class="hljs-string">&#x27;冬&#x27;</span>], name=<span class="hljs-string">&#x27;季节&#x27;</span>)<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    0夏    1秋    2冬    3Name: 季节, dtype: int64</code></pre><ul><li>通过字典创建<ul><li>字典的键就是索引</li><li>字典的值就是数据</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=&#123;<span class="hljs-string">&#x27;春&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;夏&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;秋&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;冬&#x27;</span>: <span class="hljs-number">4</span>&#125;)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    1夏    2秋    3冬    4dtype: int64</code></pre><h2 id="series-的运算">1.2 Series 的运算</h2><p>由于 Pandas 是基于 Numpy开发的，所以很多性质和数组是一样的，比如<strong>矢量化运算和广播</strong>。</p><h3 id="标量运算">1.2.1 标量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += <span class="hljs-number">10</span><br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    10夏    11秋    12冬    13Name: 季节, dtype: int64</code></pre><h3 id="矢量运算">1.2.2 矢量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += ser2<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    11夏    13秋    15冬    17Name: 季节, dtype: int64</code></pre><h2 id="series-的属性">1.3 Series 的属性</h2><ul><li><code>dtype</code>：返回<code>Series</code>对象的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;int64&#39;)</code></pre><ul><li><code>size</code>：返回<code>Series</code>对象中元素的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.size<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><ul><li><code>index</code>：返回<code>Series</code>对象的索引<code>Index</code>对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;索引对象&#x27;</span>, ser1.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体索引&#x27;</span>, ser1.index[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">索引对象 Index([&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;], dtype=&#39;object&#39;)通过下标取出具体索引 春</code></pre><ul><li><code>values</code>：以<code>ndarray</code>的形式返回<code>Series</code>对象的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ser1.values)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体值&#x27;</span>, ser1.values[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">[11 13 15 17]通过下标取出具体值 11</code></pre><h2 id="series-的方法">1.4 Series 的方法</h2><h3 id="描述性统计">1.4.1 描述性统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;计数：&#x27;</span>, ser1.count())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;求和：&#x27;</span>, ser1.<span class="hljs-built_in">sum</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;均值：&#x27;</span>, ser1.mean())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;中位数：&#x27;</span>, ser1.median())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最小值：&#x27;</span>, ser1.<span class="hljs-built_in">min</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最大值：&#x27;</span>, ser1.<span class="hljs-built_in">max</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;标准差：&#x27;</span>, ser1.std())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方差：&#x27;</span>, ser1.var())<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数： 4求和： 56均值： 14.0中位数： 14.0最小值： 11最大值： 17标准差： 2.581988897471611方差： 6.666666666666667</code></pre><ul><li><code>describe()</code>：获取描述性统计信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.describe()<br></code></pre></td></tr></table></figure><pre><code class="hljs">count     4.000000mean     14.000000std       2.581989min      11.00000025%      12.50000050%      14.00000075%      15.500000max      17.000000Name: 季节, dtype: float64</code></pre><p><code>describe()</code>返回的是一个<code>Series</code>对象，所以可以通过索引访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均值：&#x27;</span>, ser1.describe()[<span class="hljs-string">&#x27;mean&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值，最小值：\n<span class="hljs-subst">&#123;ser1.describe()[[<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均值： 14.0最大值，最小值：max    17.0min    11.0Name: 季节, dtype: float64</code></pre><h3 id="处理数据">1.4.2 处理数据</h3><ul><li><code>isnull()</code>：空值判断</li><li><code>notnull()</code>：非空值判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, np.nan, <span class="hljs-number">30</span>, np.nan])<br>ser2.isnull()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2     True3    False4     Truedtype: bool</code></pre><ul><li><code>dropna()</code>：删除空值</li><li><code>fillna()</code>：填充空值</li></ul><p>处理数据的方法都有一个<code>inplace</code>参数，默认为<code>False</code>。</p><ul><li><code>inplace=False</code>：处理完成返回新的对象</li><li><code>inplace=True</code>：在原对象上进行处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.dropna()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.fillna(<span class="hljs-number">66</span>, inplace=<span class="hljs-literal">True</span>)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.04    66.0dtype: float64</code></pre><ul><li><code>duplicated()</code>：检测重复数据</li><li><code>drop_duplicates()</code>：删除重复数据</li><li><code>unique</code>：去除重复数据，返回一个数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.duplicated()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    False3    False4     Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.drop_duplicates()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.unique()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 20., 66., 30.])</code></pre><h3 id="排序">1.4.3 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用<code>ascending=False</code>参数可以实现降序排列，排序结果返回一个新的<code>Series</code> 对象，原对象不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3 = pd.Series(data=[<span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>], index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_index()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Bob      30Eve      10Jack     50John     20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_values(ascending=<span class="hljs-literal">False</span>, inplace=<span class="hljs-literal">True</span>)<br>ser3<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack     50Bob      30John     20Alice    10Eve      10dtype: int64</code></pre><ul><li><code>head(n)</code>：返回前 n 个元素，默认 n=5</li><li><code>tail(n)</code>：返回后 n 个元素，默认 n=5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack    50Bob     30John    20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.tail(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Eve      10dtype: int64</code></pre><h3 id="绘制图表">1.4.4 绘制图表</h3><p><code>Series</code>对象可以直接绘制图表，默认绘制折线图，还可以绘制柱状图、饼图等，只需指定<code>kind</code>参数即可。默认会使用索引作为横坐标，值作为纵坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: &gt;</code></pre><figure><img src="05_bar.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="dataframe-对象">2 DataFrame 对象</h1><p><code>DataFrame</code>是一个二维的表格型数据结构，既有行索引，也有列索引，可以将其看作由多个<code>Series</code>按列组成的一个字典。是Pandas中最常用的数据结构，可以用来保存和处理异质的二维数据，每个列可以是不同的数据类型，这也是和NumPy 数组的最大区别。</p><p>数据表格三要素贯穿 Pandas 数据分析的始终：</p><ul><li><code>column</code>：对应着列名，也就是列索引</li><li><code>index</code>：代表行索引</li><li><code>value</code>：则指代具体的数据值</li></ul><h2 id="创建-dataframe-对象">2.1 创建 DataFrame 对象</h2><h3 id="通过二维数组列表创建">2.1.1 通过二维数组/列表创建</h3><p><code>data</code>指定数据，<code>columns</code>指定列名，<code>index</code>指定行索引。如果没有指定索引，则默认从 0 开始。如果没有指定列名，则默认从 0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">score = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, size=(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br>course = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]<br>stu_id = [<span class="hljs-string">&#x27;1001&#x27;</span>, <span class="hljs-string">&#x27;1002&#x27;</span>, <span class="hljs-string">&#x27;1003&#x27;</span>, <span class="hljs-string">&#x27;1004&#x27;</span>, <span class="hljs-string">&#x27;1005&#x27;</span>]<br>df1 = pd.DataFrame(data=score, columns=course, index=stu_id)<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>1001</th><td>89</td><td>98</td><td>58</td></tr><tr><th>1002</th><td>15</td><td>48</td><td>24</td></tr><tr><th>1003</th><td>48</td><td>42</td><td>60</td></tr><tr><th>1004</th><td>62</td><td>17</td><td>46</td></tr><tr><th>1005</th><td>18</td><td>54</td><td>71</td></tr></tbody></table></div><h3 id="通过字典创建">2.1.2 通过字典创建</h3><p>字典嵌套列表：按照列名进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">info1 = &#123;<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>],<br>    <span class="hljs-string">&#x27;年龄&#x27;</span>: [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>],<br>    <span class="hljs-string">&#x27;性别&#x27;</span>: [<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>]<br>&#125;<br>df2 = pd.DataFrame(data=info1)<br>df2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>年龄</th><th>性别</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>18</td><td>男</td></tr><tr><th>1</th><td>李四</td><td>19</td><td>女</td></tr><tr><th>2</th><td>王五</td><td>20</td><td>男</td></tr><tr><th>3</th><td>赵六</td><td>21</td><td>女</td></tr></tbody></table></div><p>列表嵌套列表：按照行进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">info2 = [<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;<br>]<br>df3 = pd.DataFrame(data=info2)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>年龄</th><th>性别</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>18</td><td>男</td></tr><tr><th>1</th><td>李四</td><td>19</td><td>女</td></tr><tr><th>2</th><td>王五</td><td>20</td><td>男</td></tr><tr><th>3</th><td>赵六</td><td>21</td><td>女</td></tr></tbody></table></div><h2 id="数据读取和存储">2.2 数据读取和存储</h2><p>实际应用中，单独创建数据结构的情况较少，更多的是通过读取外部数据文件来创建数据结构。</p><h3 id="读取-excel">2.2.1 读取 Excel</h3><p>通过<code>read_excel</code>读取 Excel 文件，默认读取第一个sheet，可以通过<code>sheet_name</code>参数指定读取的 sheet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>张三</th><th>88</th><th>100</th><th>90</th></tr></thead><tbody><tr><th>0</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>1</th><td>王五</td><td>80</td><td>92</td><td>60</td></tr></tbody></table></div><p>Pandas默认会将第一行数据作为列名，如果想自定义列名，可以将<code>header=None</code>告诉Pandas数据中没有表头，然后通过<code>names</code>参数指定列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>, header=<span class="hljs-literal">None</span>, names=[<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>92</td><td>60</td></tr></tbody></table></div><p>此外读取数据还有很多参数，比如：</p><ul><li><code>index_col</code>：指定哪一列作为行索引</li><li><code>usecols</code>：指定读取哪些列</li><li><code>nrows</code>：指定读取多少行</li><li><code>dtype</code>：指定列的数据类型</li></ul><h3 id="读取-csv">2.2.2 读取 CSV</h3><p>通过<code>read_csv</code>函数可以读取 CSV 和 TSV文件，默认使用UTF-8编码格式，如果是其他编码格式，可以通过<code>encoding</code>参数指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td></tr></tbody></table></div><p>大多数CSV文件以逗号分隔，如果是其他字符分隔，可以通过<code>sep</code>参数指定分隔符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>, sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在某些Python版本读取中文路径会报错，因为默认读取引擎是C语言，可以通过<code>engine</code>参数指定为Python引擎。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>mengine=<span class="hljs-string">&#x27;python&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="连接mysql">2.2.3 连接MySQL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要安装pymysql，部分版本需要额外安装sqlalchemy</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+pymysql://root:123456@127.0.0.1:3306/sql_practice03?charset=utf8&#x27;</span>)<br><span class="hljs-comment"># mysql 表示数据库类型</span><br><span class="hljs-comment"># pymysql 表示python操作数据库的包</span><br><span class="hljs-comment"># root:123456 表示数据库的账号和密码，用冒号连接</span><br><span class="hljs-comment"># 127.0.0.1:3306/sql_practice03 表示数据库的ip和端口，以及名叫sql_practice03的库</span><br><span class="hljs-comment"># charset=utf8 规定编码格式</span><br></code></pre></td></tr></table></figure><p>数据库读取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取整张表</span><br>pd.read_sql(<span class="hljs-string">&#x27;dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>DEPTNO</th><th>DNAME</th><th>LOC</th></tr></thead><tbody><tr><th>0</th><td>10</td><td>ACCOUNTING</td><td>NEW YORK</td></tr><tr><th>1</th><td>20</td><td>RESEARCH</td><td>DALLAS</td></tr><tr><th>2</th><td>30</td><td>SALES</td><td>CHICAGO</td></tr><tr><th>3</th><td>40</td><td>OPERATIONS</td><td>BOSTON</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SQL语句查询指定内容</span><br>pd.read_sql(<span class="hljs-string">&#x27;select DEPTNO, DNAME from dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>DEPTNO</th><th>DNAME</th></tr></thead><tbody><tr><th>0</th><td>10</td><td>ACCOUNTING</td></tr><tr><th>1</th><td>20</td><td>RESEARCH</td></tr><tr><th>2</th><td>30</td><td>SALES</td></tr><tr><th>3</th><td>40</td><td>OPERATIONS</td></tr></tbody></table></div><p>写入数据到数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_sql(<span class="hljs-string">&#x27;df_score_table&#x27;</span>, engine, index=<span class="hljs-literal">False</span>, if_exists=<span class="hljs-string">&#x27;append&#x27;</span>)<br><span class="hljs-comment"># index：是否将index写入数据库</span><br><span class="hljs-comment"># if_exists：如果表存在如何操作 </span><br><span class="hljs-comment">#     append：追加  </span><br><span class="hljs-comment">#     replace：覆盖</span><br><span class="hljs-comment">#     fail：报错</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">3</code></pre><h3 id="读取其他文件">2.2.4 读取其他文件</h3><p>Excel和CSV是最常用的，其他文件读取简单了解，读取文件的大部分参数是通用的。</p><ul><li><code>read_table()</code>： 读取文本文件</li><li><code>read_json()</code>： 读取 JSON 文件</li></ul><h3 id="存储数据">2.2.5 存储数据</h3><p>在Pandas中存储数据直接使用<code>to_xxx()</code>方法即可，默认会把索引也存储进去，如果不需要索引，可以通过<code>index=False</code>参数去掉索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="dataframe-的属性">2.3 DataFrame 的属性</h2><ul><li><code>columns</code>：列索引</li><li><code>index</code>：行索引</li><li><code>values</code>：数据值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df4)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n列索引：&#x27;</span>, df4.columns)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;行索引：&#x27;</span>, df4.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据值：\n&#x27;</span>, df4.values)<br></code></pre></td></tr></table></figure><pre><code class="hljs">   姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60列索引： Index([&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;], dtype=&#39;object&#39;)行索引： RangeIndex(start=0, stop=3, step=1)数据值： [[&#39;张三&#39; 88 100 90] [&#39;李四&#39; 82 65 52] [&#39;王五&#39; 80 100 60]]</code></pre><ul><li><code>dtypes</code>：每一列的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.dtypes<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    object语文     int64数学     int64英语     int64dtype: object</code></pre><ul><li><code>ndim</code>：维度</li><li><code>shape</code>：形状</li><li><code>size</code>：元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;维度&#x27;</span>, df4.ndim)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;形状&#x27;</span>, df4.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;元素个数&#x27;</span>, df4.size)<br></code></pre></td></tr></table></figure><pre><code class="hljs">维度 2形状 (3, 4)元素个数 12</code></pre><h2 id="dataframe-的方法">2.4 DataFrame 的方法</h2><h3 id="快速查看">2.4.1 快速查看</h3><ul><li><code>info()</code>：查看DataFrame的基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 3 entries, 0 to 2Data columns (total 4 columns): #   Column  Non-Null Count  Dtype ---  ------  --------------  -----  0   姓名      3 non-null      object 1   语文      3 non-null      int64  2   数学      3 non-null      int64  3   英语      3 non-null      int64 dtypes: int64(3), object(1)memory usage: 224.0+ bytes</code></pre><ul><li><code>describe()</code>：获取统计性描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>count</th><td>3.000000</td><td>3.000000</td><td>3.000000</td></tr><tr><th>mean</th><td>83.333333</td><td>88.333333</td><td>67.333333</td></tr><tr><th>std</th><td>4.163332</td><td>20.207259</td><td>20.033306</td></tr><tr><th>min</th><td>80.000000</td><td>65.000000</td><td>52.000000</td></tr><tr><th>25%</th><td>81.000000</td><td>82.500000</td><td>56.000000</td></tr><tr><th>50%</th><td>82.000000</td><td>100.000000</td><td>60.000000</td></tr><tr><th>75%</th><td>85.000000</td><td>100.000000</td><td>75.000000</td></tr><tr><th>max</th><td>88.000000</td><td>100.000000</td><td>90.000000</td></tr></tbody></table></div><ul><li><code>head(n)</code>：查看前n行数据，默认n=5</li><li><code>tail(n)</code>：查看后n行数据，默认n=5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.head(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.tail(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td></tr></tbody></table></div><ul><li><code>value_counts()</code>：统计每一个唯一值出现的次数，索引为唯一值，值为出现的次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;数学&#x27;</span>].value_counts()<br></code></pre></td></tr></table></figure><pre><code class="hljs">数学100    265     1Name: count, dtype: int64</code></pre><h3 id="描述性统计-1">2.4.2 描述性统计</h3><p>DataFrame也有很多统计性描述信息的方法，和Series一致，不过多了一个<code>axis</code>参数控制聚合轴向：</p><ul><li><code>axis=0</code>：按列进行统计（默认）</li><li><code>axis=1</code>：按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计数：\n<span class="hljs-subst">&#123;df4.count()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;求和：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;均值：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].mean(axis=<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;中位数：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].median()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数：姓名    3语文    3数学    3英语    3dtype: int64求和：姓名    张三李四王五语文       250数学       265英语       202dtype: object均值：0    92.6666671    66.3333332    80.000000dtype: float64中位数：语文     82.0数学    100.0英语     60.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最小值：\n<span class="hljs-subst">&#123;df4[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">max</span>(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;标准差：\n<span class="hljs-subst">&#123;df4.std(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;方差：\n<span class="hljs-subst">&#123;df4.var(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最小值：65最大值：语文     88数学    100英语     90dtype: int64标准差：语文     4.163332数学    20.207259英语    20.033306dtype: float64方差：语文     17.333333数学    408.333333英语    401.333333dtype: float64</code></pre><ul><li><code>idxmax()</code>：求最大值位置</li><li><code>idxmin()</code>：求最小值位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">display(df4.idxmax())<br>display(df4.idxmin())<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    2语文    0数学    0英语    0dtype: int64姓名    0语文    2数学    1英语    1dtype: int64</code></pre><h3 id="累计运算">2.4.3 累计运算</h3><ul><li><code>cumsum()</code>：累计和</li><li><code>cumprod()</code>：累计积</li><li><code>cummax()</code>：累计最大值</li><li><code>cummin()</code>：累计最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cumsum()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>张三李四</td><td>170</td><td>165</td><td>142</td></tr><tr><th>2</th><td>张三李四王五</td><td>250</td><td>265</td><td>202</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cummin()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr><tr><th>1</th><td>张三</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>张三</td><td>80</td><td>65</td><td>52</td></tr></tbody></table></div><ul><li><code>diff()</code>：计算与上一个值的差值</li><li><code>pct_change()</code>：计算与上一个值的百分比变化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].diff()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>-6.0</td><td>-35.0</td><td>-38.0</td></tr><tr><th>2</th><td>-2.0</td><td>35.0</td><td>8.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].pct_change()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>0</th><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>-0.068182</td><td>-0.350000</td><td>-0.422222</td></tr><tr><th>2</th><td>-0.024390</td><td>0.538462</td><td>0.153846</td></tr></tbody></table></div><h3 id="排序-1">2.4.4 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用<code>ascending=False</code>参数可以实现降序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_index(ascending=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_values(<span class="hljs-string">&#x27;英语&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td></tr><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td></tr></tbody></table></div><h3 id="apply自定义函数">2.4.5 apply自定义函数</h3><p>可以将一个函数应用（apply）到 Series 的每个元素上，或者 DataFrame的每一行或每一列上。</p><p>当作用于 Series（DataFrame 的一列）时，apply() 会将函数依次作用于Series 中的每一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_score</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">80</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;高&#x27;</span><br>    <span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">60</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;中&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;低&#x27;</span><br>    <br>df4[<span class="hljs-string">&#x27;英语&#x27;</span>].apply(check_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    高1    低2    中Name: 英语, dtype: object</code></pre><p>当作用于 DataFrame 时，apply() 可以将函数作用于每一列或每一行。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.apply(func, axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></p><ul><li>func：要应用的函数</li><li>axis：指定函数应用方向<ul><li><code>0</code>：默认值，将函数应用到每一列，接收对象是Series</li><li><code>1</code>：将函数应用到每一行，接收对象是Series</li></ul></li></ul><p>沿列应用时，函数接收到的一列数据，通常用于聚合（如求和、最大值等）或对整列进行转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算每一科最高分和最低分的差值</span><br>df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].apply(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文     8数学    35英语    38dtype: int64</code></pre><p>沿行应用时，函数接收到的是一行数据，索引为列名，通常用于使用多列计算新值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;加权分&#x27;</span>] = df4.apply(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;数学&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;英语&#x27;</span>] * <span class="hljs-number">0.2</span>, axis=<span class="hljs-number">1</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><h1 id="index-对象">3 Index 对象</h1><p><code>Index</code>用来唯一标识 DataFrame中的每一行数据，就像数据库表中的主键一样，但它不强制要求是唯一的，类似于一维数组，存储着用于标记各行数据的标签。</p><h2 id="index-的特点">3.1 Index 的特点</h2><ol type="1"><li>标签：作为行标签使用，用来访问特定行<code>df.loc[行标签]</code></li><li>对齐：两个<code>DataFrame</code>之间运算（比如加法、合并等）时，Pandas根据<code>Index</code>和<code>Column</code>自动将数据对齐，而不需要行和列的顺序相同</li><li>不可变性：<code>Index</code>对象一旦创建，不允许被修改，所有修改索引必须整体修改</li></ol><h2 id="index-常用操作">3.2 Index 常用操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><p><code>index</code>：查看index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.index<br></code></pre></td></tr></table></figure><pre><code class="hljs">RangeIndex(start=0, stop=3, step=1)</code></pre><p><code>set_index()</code>：将普通列设为行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.set_index(keys, drop=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>keys：新索引的列名或列名列表</li><li>drop：用于创建新索引的列是否从表中删除，默认为True</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df5 = df4.set_index(<span class="hljs-string">&#x27;姓名&#x27;</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>语文</th><th>数学</th><th>英语</th><th>加权分</th></tr><tr><th>姓名</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>张三</th><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>李四</th><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>王五</th><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><p><code>reset_index</code>：<code>set_index</code>的逆操作，将索引重置为普通列，并且创建一个新的<code>RangeIndex</code>作为索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.reset_index(drop=<span class="hljs-literal">False</span>, name=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>drop：是否删除原有索引，不转化为普通列，默认为False</li><li>names：指定转为为普通列之后的名称</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.reset_index(names=<span class="hljs-string">&#x27;大名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>大名</th><th>语文</th><th>数学</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><p><code>rename()</code>：重命名行索引或列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.rename(columns=<span class="hljs-literal">None</span>, index=<span class="hljs-literal">None</span>, axis=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>columns：重命名列索引，{‘旧列名’: ‘新列名’, …}</li><li>index：重命名行索引，{‘旧行名’: ‘新行名’, …}</li><li>axis：指定重命名行索引还是列索引，0或’index’表示行索引，1或’columns’表示列索引，默认0</li><li>inplace：是否在原数据上修改，默认False表示不修改原数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(columns=&#123;<span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-string">&#x27;Math&#x27;</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>Chinese</th><th>Math</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(index=&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1001</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>姓名</th><th>Chinese</th><th>Math</th><th>英语</th><th>加权分</th></tr></thead><tbody><tr><th>0</th><td>张三</td><td>88</td><td>100</td><td>90</td><td>93.2</td></tr><tr><th>1001</th><td>李四</td><td>82</td><td>65</td><td>52</td><td>69.2</td></tr><tr><th>2</th><td>王五</td><td>80</td><td>100</td><td>60</td><td>84.0</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Numpy结构化数组</title>
    <link href="/2024/06/07/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <url>/2024/06/07/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="创建结构化数组">1 创建结构化数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p>类似C++的结构体，但更加强大，数组的每个元素可以包含多个字段，可以单独处理数组的每一个字段。</p><h2 id="字典方式">1.1 字典方式</h2><p><code>dtype</code>的参数是一个字典：</p><ul><li><code>names</code>：指定字段名称</li><li><code>formats</code>：指定数据类型，可以使用Python类型或Numpy类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dtype = &#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;<br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=my_dtype)<br>arr.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><h2 id="列表元组方式">1.2 列表元组方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype([<br>    (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;U10&#x27;</span>),<br>    (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">int</span>),<br>    (<span class="hljs-string">&#x27;weight&#x27;</span>, <span class="hljs-string">&#x27;f8&#x27;</span>),<br>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><p>如果类型名称不重要可以省略，仅仅指定数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype(<span class="hljs-string">&#x27;U10, i8, f8&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;f0&#39;, &#39;&lt;U10&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;), (&#39;f2&#39;, &#39;&lt;f8&#39;)])</code></pre><p>Numpy数据类型符号表：</p><table><thead><tr><th style="text-align: center;">符号</th><th style="text-align: center;">描述</th><th style="text-align: left;">示例</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>‘b’</strong></td><td style="text-align: center;">字节型 (Boolean or raw bytes)</td><td style="text-align: left;"><code>np.dtype('b')</code></td></tr><tr><td style="text-align: center;"><strong>‘i’</strong></td><td style="text-align: center;">有符号整型 (Signed integer)</td><tdstyle="text-align: left;"><code>np.dtype('i4') == np.int32</code></td></tr><tr><td style="text-align: center;"><strong>‘u’</strong></td><td style="text-align: center;">无符号整型 (Unsigned integer)</td><tdstyle="text-align: left;"><code>np.dtype('u1') == np.uint8</code></td></tr><tr><td style="text-align: center;"><strong>‘f’</strong></td><td style="text-align: center;">浮点型 (Floating-point)</td><tdstyle="text-align: left;"><code>np.dtype('f8') == np.float64</code></td></tr><tr><td style="text-align: center;"><strong>‘c’</strong></td><td style="text-align: center;">复数浮点型 (Complex floating-point)</td><tdstyle="text-align: left;"><code>np.dtype('c16') == np.complex128</code></td></tr><tr><td style="text-align: center;"><strong>‘S’, ‘a’</strong></td><td style="text-align: center;">字节字符串 (Byte string)</td><td style="text-align: left;"><code>np.dtype('S5')</code></td></tr><tr><td style="text-align: center;"><strong>‘U’</strong></td><td style="text-align: center;">Unicode编码字符串 (Unicode string)</td><td style="text-align: left;"><code>np.dtype('U') == np.str_</code></td></tr><tr><td style="text-align: center;"><strong>‘V’</strong></td><td style="text-align: center;">原生数据 (Raw data, void)</td><td style="text-align: left;"><code>np.dtype('V') == np.void</code></td></tr></tbody></table><h1 id="访问结构化数组">2 访问结构化数组</h1><p>数组的每一个字段依然是一个数组，可以用索引、聚合等操作。这里的操作有点像SQL，字段名像列，索引号像行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建结构化数组</span><br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=&#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;)<br><br>arr[<span class="hljs-string">&#x27;name&#x27;</span>] = [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>]<br>arr[<span class="hljs-string">&#x27;age&#x27;</span>] = [<span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">20</span>, <span class="hljs-number">35</span>]<br>arr[<span class="hljs-string">&#x27;weight&#x27;</span>] = [<span class="hljs-number">110.2</span>, <span class="hljs-number">125.3</span>, <span class="hljs-number">103.1</span>, <span class="hljs-number">159.6</span>]<br>arr[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;赵六&#39;], dtype=&#39;&lt;U10&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;arr：&#x27;</span>, arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n通过字段名访问age列表：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过索引访问第一个元素：&#x27;</span>, arr[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;组合字段和索引访问第一个人的名字：&#x27;</span>, arr[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>], arr[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr： [(&#39;张三&#39;, 18, 110.2) (&#39;李四&#39;, 28, 125.3) (&#39;王五&#39;, 20, 103.1) (&#39;赵六&#39;, 35, 159.6)]通过字段名访问age列表： [18 28 20 35]通过索引访问第一个元素： (&#39;张三&#39;, 18, 110.2)组合字段和索引访问第一个人的名字： 张三 张三</code></pre><p>结合布尔索引可以对元素进行筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 年龄小于25岁的人</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>])<br><br><span class="hljs-comment"># 年龄小于25岁的人的姓名和年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>][[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>]])<br></code></pre></td></tr></table></figure><pre><code class="hljs">年龄小于25岁的人的信息 [(&#39;张三&#39;, 18, 110.2) (&#39;王五&#39;, 20, 103.1)]年龄小于25岁的人的信息 [(&#39;张三&#39;, 18) (&#39;王五&#39;, 20)]</code></pre><p>结合描述统计方法对字段进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算平均年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均年龄：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均年龄： 25.25</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Numpy数组运算和函数</title>
    <link href="/2024/06/06/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2024/06/06/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Numpy非常重要的一个特性就是<strong>矢量化</strong>，对数组进行运算时，所有运算会自动作用于数组中的每一个成员，而不需要编写循环。</p><h1 id="数组和标量的运算">1 数组和标量的运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>数组和数值进行加减乘除、取模求幂等运算，对应的运算会作用到数组的每一个元素上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr + 10为：<span class="hljs-subst">&#123;arr + <span class="hljs-number">10</span>&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr * 2为：<span class="hljs-subst">&#123;arr * <span class="hljs-number">2</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr + 10为：[10 11 12 13 14 15 16 17 18 19]arr * 2为：[ 0  2  4  6  8 10 12 14 16 18]</code></pre><p>数组还可以和数值进行关系运算，在布尔索引中也有所应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr % 2 == 0为：<span class="hljs-subst">&#123;arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr % 2 == 0为：[ True False  True False  True False  True False  True False]</code></pre><p>使用<code>数组.T</code>可以很方便的对矩阵进行转置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr转置数组：\n<span class="hljs-subst">&#123;arr.T&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr转置数组：[[ 0  5 10] [ 1  6 11] [ 2  7 12] [ 3  8 13] [ 4  9 14]]</code></pre><h1 id="数组和数组的运算">2 数组和数组的运算</h1><h2 id="相同形状运算">2.1 相同形状运算</h2><p>数组和数组之间的运算会作用到两个数组对应的元素上，要求两个数组的形状相同。</p><p>注意：<code>a * b</code>不是矩阵乘法，而是逐元素相乘，也就是哈达玛积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>)<br>arr2 = np.full(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 * arr2为：\n<span class="hljs-subst">&#123;arr1 * arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以直接应用于布尔索引</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 &lt; arr2为：\n<span class="hljs-subst">&#123;arr1 &lt; arr2&#125;</span>\n&#x27;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[ 0  1  2  3  4  5  6  7  8  9 10]arr2为：[10 10 10 10 10 10 10 10 10 10 10]arr1 + arr2为：[10 11 12 13 14 15 16 17 18 19 20]arr1 * arr2为：[  0  10  20  30  40  50  60  70  80  90 100]arr1 &lt; arr2为：[ True  True  True  True  True  True  True  True  True  True False]</code></pre><h2 id="矩阵乘法">2.2 矩阵乘法</h2><p>矩阵乘法有前提条件，A的列数必须和B的行数相等，也就是两个矩阵必须有<strong>相同的内维</strong>。</p><ul><li>A的形状为(m, n)，B的形状为(n, p)，n就是内维</li><li>内维 = A的列数 = B的行数（内维必须相等，乘积才有定义）</li><li>外维 = m × p（外维是AB乘积结果的形状）</li><li>矩阵乘积AB存在，但BA不一定存在，即便存在，AB和BA通常也不同</li></ul><p><span class="math display">$$\begin{bmatrix} a_{11} &amp; a_{12}&amp; a_{13} \\ a_{21} &amp; a_{22} &amp; a_{23} \end{bmatrix} \times\begin{bmatrix} b_{11} &amp; b_{12} \\ b_{21} &amp; b_{22} \\ b_{31}&amp; b_{32} \end{bmatrix} = \begin{bmatrix} (a_{11}b_{11} +a_{12}b_{21} + a_{13}b_{31}) &amp; (a_{11}b_{12} + a_{12}b_{22} +a_{13}b_{32}) \\ (a_{21}b_{11} + a_{22}b_{21} + a_{23}b_{31}) &amp;(a_{21}b_{12} + a_{22}b_{22} + a_{23}b_{32}) \end{bmatrix}$$</span></p><p>矩阵乘法 C=A×B 的核心运算就是在对 A 的行向量和 B的列向量进行点积。</p><figure><img src="03_dot.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p>在Numpy中可以使用矩阵乘法运算符<code>arr1 @ arr2</code>或函数<code>np.dot(arr1, arr2)</code>的方式计算矩阵乘法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2*3矩阵 × 3*2矩阵</span><br>arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>arr2 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 推荐矩阵乘法运算符</span><br><span class="hljs-built_in">print</span>(arr1 @ arr2, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 函数方式</span><br><span class="hljs-built_in">print</span>(np.dot(arr1, arr2))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[22 28] [49 64]][[22 28] [49 64]]</code></pre><h2 id="广播机制">2.3 广播机制</h2><p>两个数组之间做二元运算，并不必须是完全相同的形状，通过Numpy的广播机制，将原本形状不同的数组变成形状相同的数组，也可以进行二元运算。</p><p>广播机制：在数组之间运算时，自动扩展维度较小的数组，使其形状和维度与较大数组匹配，从而进行运算。</p><ul><li>虚拟扩展<ul><li>Numpy的扩展不是真的复制，而是逻辑上的扩展</li></ul></li><li>维度对齐<ul><li>从尾部维度逐个比较，如果维度相同，继续向前比较</li><li>如果维度不同，但其中一个数组在这个维度上大小为1，则可以扩展为较大的数组，</li><li>否则不能对齐则报错</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br>arr2 = np.full((<span class="hljs-number">5</span>), <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr2为：[1 1 1 1 1]arr1 + arr2为：[[ 1  2  3  4  5] [ 6  7  8  9 10] [11 12 13 14 15]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1*3 和 3*1 的矩阵运算</span><br>arr1 = np.full((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>)<br>arr2 = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为:\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为:\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为:[[1 1 1]]arr2为:[[1] [1] [1]]arr1 + arr2为：[[2 2 2] [2 2 2] [2 2 2]]</code></pre><figure><img src="03_broadcast.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="通用函数">3 通用函数</h1><h2 id="一元函数">3.1 一元函数</h2><p>一元函数的参数是一个数组对象，函数会矢量化地对数组每一个元素进行运算。</p><ul><li><code>abs()</code>/<code>fabs()</code>：求绝对值</li><li><code>sqrt()</code>：求平方根，相当于<code>arr ** 0.5</code></li><li><code>square()</code>：求平方，相当于<code>arr ** 2</code></li><li><code>exp()</code>：求<spanclass="math inline"><em>e</em><sup><em>x</em></sup></span>的函数</li><li><code>log()</code>/<code>log10()</code>/<code>log2()</code>：对数函数</li><li><code>sign()</code>：求元素的符号（1：正数；0：零；-1：负数）</li><li><code>isnan()</code>：判断元素是否为NaN，NaN对应<code>True</code>，否则为<code>False</code></li><li><code>ceil()</code>/<code>floor()</code>：上取整/下取整</li><li><code>sin()</code>/<code>cos()</code>/<code>tan()</code>：三角函数</li><li><code>arcsin()</code>/<code>arccos()</code>/<code>arctan()</code>：反三角函数</li><li><code>rint()</code>：四舍五入函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;abs函数：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">abs</span>(arr)&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;square函数：<span class="hljs-subst">&#123;np.square(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;exp函数：<span class="hljs-subst">&#123;np.exp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sign函数：<span class="hljs-subst">&#123;np.sign(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[ 0  1  2 -3 -5  6  7 -8]abs函数：[0 1 2 3 5 6 7 8]square函数：[ 0  1  4  9 25 36 49 64]exp函数：[1.00000000e+00 2.71828183e+00 7.38905610e+00 4.97870684e-02 6.73794700e-03 4.03428793e+02 1.09663316e+03 3.35462628e-04]sign函数：[ 0  1  1 -1 -1  1  1 -1]</code></pre><h2 id="二元函数">3.2 二元函数</h2><p>二元函数的参数是两个数组对象，函数会对两个数组的对应元素进行运算。</p><ul><li><code>add(x, y)</code>/<code>subtract(x, y)</code>：加法函数/减法函数</li><li><code>multiply(x, y)</code>/<code>divide(x, y)</code>：乘法函数/除法函数</li><li><code>floor_divide(x, y)</code>/<code>mod(x, y)</code>：整除函数/求模函数</li><li><code>power(x, y)</code>：求<spanclass="math inline"><em>x</em><sup><em>y</em></sup></span></li></ul><p><code>axis</code>指定的是数组<strong>将会被折叠的维度，而不是将要返回的维度</strong>，因此<code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合值。</p><ul><li><code>cumsum()</code>：返回一维数组，计算累加和</li><li><code>cumpord()</code>：返回一维数组，计算累乘积</li></ul><p>多维数组默认统计全部维度，如果想要按指定轴进行统计，可以设置<code>axis</code>参数，0按列统计，值为1按行统计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum累加：\n<span class="hljs-subst">&#123;np.cumsum(arr)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿0轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿1轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumprod累乘：\n<span class="hljs-subst">&#123;np.cumprod(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]cumsum累加：[ 1  3  6 10 15 21 28 36 45 55 66 78]cumsum沿0轴累加：[[ 1  2  3  4] [ 6  8 10 12] [15 18 21 24]]cumsum沿1轴累加：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]cumprod累乘：[        1         2         6        24       120       720      5040     40320    362880   3628800  39916800 479001600]</code></pre><ul><li><code>reduce()</code>：对数据进行聚合</li><li><code>accumulate()</code>：显示每一个元素的聚合过程</li></ul><p>可以对<code>add()</code>/<code>subtract()</code>等运算进行聚合，可以使用<code>axis</code>指定聚合维度，默认折叠0轴，按列进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;默认add聚合：<span class="hljs-subst">&#123;np.add.reduce(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add使用axis=1聚合：<span class="hljs-subst">&#123;np.add.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add累加过程：\n<span class="hljs-subst">&#123;np.add.accumulate(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;multiply使用axis=1聚合：<span class="hljs-subst">&#123;np.multiply.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]默认add聚合：[15 18 21 24]add使用axis=1聚合：[10 26 42]add累加过程：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]multiply使用axis=1聚合：[   24  1680 11880]</code></pre><h2 id="其他函数">3.3 其他函数</h2><p><code>where(condition, x, y)</code>：相当于<code>x if condition else y</code>，只不过是矢量化对数组每一个元素操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;where之后为：\n<span class="hljs-subst">&#123;np.where(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-number">66</span>, <span class="hljs-number">11</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]where之后为：[[66 11 66 11 66] [11 66 11 66 11] [66 11 66 11 66]]</code></pre><ul><li><code>all()</code>：判断数组是否都是True，全为True返回True，否则返回False</li><li><code>any()</code>：判断数组是否存在True，有True返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[87 73 24 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Truenp.any(arr)为：True[87 73  0 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Falsenp.any(arr)为：True</code></pre><p>结合布尔逻辑，判断是否存在符合条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 是否存在大于90的元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr &gt; <span class="hljs-number">90</span>)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 是否全都大于10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr &gt; <span class="hljs-number">10</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">TrueFalse</code></pre><ul><li><code>concatenate([arr1, arr2, arr3])</code>：拼接数组，要求维度相同</li><li><code>vstack()</code>/<code>hstack()</code>：按列拼接，按行拼接</li></ul><p>二维数组拼接时，<code>axis</code>默认为0，沿行的方向按列拼接，1为按行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一维数组拼接：&#x27;</span>, np.concatenate([arr1, arr2]), end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr3 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>arr4 = np.arange(<span class="hljs-number">10</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组1：\n&#x27;</span>, arr3, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组2：\n&#x27;</span>, arr4, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;二维数组拼接：\n&#x27;</span>, np.concatenate([arr3, arr4]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\naxis=1拼接：\n&#x27;</span>, np.concatenate([arr3, arr3], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">一维数组拼接： [1 2 3 4 5 6]数组1： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]数组2： [[0 1 2 3 4] [5 6 7 8 9]]二维数组拼接： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14] [ 0  1  2  3  4] [ 5  6  7  8  9]]axis=1拼接： [[ 0  1  2  3  4  0  1  2  3  4] [ 5  6  7  8  9  5  6  7  8  9] [10 11 12 13 14 10 11 12 13 14]]</code></pre><ul><li><code>split(arr, [断点位置])</code>：分割数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维数组</span><br>arr1 = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;分割点3, 5：&#x27;</span>, np.split(arr1, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]))<br><br><span class="hljs-comment"># 二维数组</span><br>arr2 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n按行平均分成3个数组：\n&#x27;</span>, np.split(arr2, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第3行分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">2</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第2列分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">1</span>], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">分割点3, 5： [array([0, 1, 2]), array([3, 4]), array([5, 6, 7, 8, 9])]按行平均分成3个数组： [array([[0, 1, 2, 3, 4]]), array([[5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第3行分割： [array([[0, 1, 2, 3, 4],       [5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第2列分割： [array([[ 0],       [ 5],       [10]]), array([[ 1,  2,  3,  4],       [ 6,  7,  8,  9],       [11, 12, 13, 14]])]</code></pre><ul><li><code>unique()</code>：去除重复元素，返回有序数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>np.unique(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 3, 5, 6])</code></pre><ul><li><code>copy()</code>：返回拷贝后的新数组，拷贝后的数组是独立的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>new_arr = np.copy(arr)<br>new_arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ul><li><code>append()</code>：数组末尾追加元素，返回新的数组</li><li><code>insert()</code>：指定位置插入元素，返回新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.append(arr, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;尾部追加元素：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.insert(arr, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;在下标2插入一个10：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[0 1 2 3 4]尾部追加元素：[ 0  1  2  3  4 10]在下标2插入一个10：[ 0  1 10  2  3  4]</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Numpy索引和布尔逻辑</title>
    <link href="/2024/06/05/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/"/>
    <url>/2024/06/05/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="普通索引">1 普通索引</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>和Python中的<code>list</code>索引类似，在多维数组中有特色用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0][1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[-1][1]为：<span class="hljs-subst">&#123;arr[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 在一个[]内使用逗号分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0, 1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>) <span class="hljs-comment"># 等价于 arr[0][1]</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1 2 3] [4 5 6] [7 8 9]]arr[0][1]为：2arr[-1][1]为：8arr[0, 1]为：2</code></pre><h1 id="切片索引">2 切片索引</h1><p>对于一维数组来说，切片索引与<code>list</code>非常相似，语法为<code>[起始索引, 结束索引, 步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:6:2]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5 6 7 8 9]arr[1:6:2]为：[2 4 6]</code></pre><p>对于二维数组来说，切片有些不同，语法为<code>[起始行:结束行:步长, 起始列:结束列:步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:3, 0:3]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">0</span>:<span class="hljs-number">3</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[1:3, 0:3]为：[[4 5 6] [7 8 9]]</code></pre><blockquote><p>注意：切片得到的是视图，而不是复制。</p></blockquote><h1 id="花式索引">3 花式索引</h1><p>花式索引：将索引数组作为一个<code>ndarray</code>的索引，这个索引数组可以是<code>ndarray</code>，也可以是Python中的<code>list</code>，<code>tuple</code>等可迭代类型。</p><p>一维数组就是依次取对应索引的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[1, -1, 2]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5]arr[[1, -1, 2]]为：[2 5 3]</code></pre><p>对于二维数组来说，需要两个数组参数，每个数组代表一个轴上的索引，按照两个轴的索引一一对应，取出对应值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 索引为[0, 1], [1, 2], [3, 0]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 3], [1, 2, 0]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 如果其中一个轴的值一样，可以简化为一个值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 2, 3], 1]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[[0, 1, 3], [1, 2, 0]]为：[ 2  6 10]arr[[0, 1, 2, 3], 1]为：[ 2  5  8 11]</code></pre><p>对多个维度同样适用，和标准的索引一样，第一个索引指的是行，第二个索引指的是列。利用花哨的索引获得的<strong>结果形状与索引数组的形状一致</strong>，而不是与被索引数据的形状一致</p><p>花式索引结合切片索引，非常灵活，见下图：</p><figure><img src="02_slice.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="布尔索引">4 布尔索引</h1><p>布尔索引就是利用布尔数组作为掩码，利用数组的矢量化特性，选出原数组中所有<code>True</code>对应的元素，而<code>False</code>对应的元素不会被选中。布尔数组除了手动构造之外，还可以通过表达式生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 指定布尔值</span><br>arr1 = arr[[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 通过表达式生成</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr &gt; 5 为：\n<span class="hljs-subst">&#123;arr &gt; <span class="hljs-number">5</span>&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[arr &gt; 5]为：\n<span class="hljs-subst">&#123;arr[arr &gt; <span class="hljs-number">5</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0 1 2 3 4 5 6 7 8 9]arr1为：[0 1 4 7 9]arr &gt; 5 为：[False False False False False False  True  True  True  True]arr[arr &gt; 5]为：[6 7 8 9]</code></pre><p><code>~</code>可以对布尔数组进行取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;~(arr &gt; 5)为：\n<span class="hljs-subst">&#123;~(arr &gt; <span class="hljs-number">5</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[~(arr &gt; 5)]为：\n<span class="hljs-subst">&#123;arr[~(arr &gt; <span class="hljs-number">5</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">~(arr &gt; 5)为：[ True  True  True  True  True  True False False False False]arr[~(arr &gt; 5)]为：[0 1 2 3 4 5]</code></pre><p>可以使用比较运算<code>&gt; &lt;=</code>等，搭配逻辑运算<code>&amp; |</code>筛选出符合条件的布尔数组，再将布尔数组作为掩码取出满足条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;(arr &gt; 5) &amp; (arr % 2 == 0)为：\n<span class="hljs-subst">&#123;(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) | (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) | (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(arr &gt; 5) &amp; (arr % 2 == 0)为：[False False False False False False  True False  True False]arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：[6 8]arr[(arr &gt; 5) | (arr % 2 == 0)]为：[0 2 4 6 7 8 9]</code></pre><p>搭配<code>where()</code>函数，保留想要的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>np.where(arr &gt; <span class="hljs-number">5</span>, arr, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 大于5的保留，否则替换为-1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([-1, -1, -1, -1, -1, -1,  6,  7,  8,  9])</code></pre><p>结合<code>sum()</code>函数，统计符合条件的元素个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">5</code></pre><h1 id="内存关系">5 内存关系</h1><ul><li>切片索引虽然创建了新的数组对象，但是新数组和原数组实际指向同一块内存，存在数据共享。</li><li>花式索引和布尔索引也会创建新的数组对象，不过新数组会完全复制原数组的元素，不存在数据共享。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br>arr_slice = arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 切片数组修改会影响原数组</span><br>arr_slice[<span class="hljs-number">2</span>] = <span class="hljs-number">66</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以使用base查看来源</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice来源于：<span class="hljs-subst">&#123;arr_slice.base&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr来源于：<span class="hljs-subst">&#123;arr.base&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr_slice为：[2 3 4 5]arr为：[ 0  1  2  3 66  5  6  7  8  9]arr_slice为：[ 2  3 66  5]arr_slice来源于：[ 0  1  2  3 66  5  6  7  8  9]arr来源于：None</code></pre><h1 id="图像案例">6 图像案例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/123.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b124cbb80&gt;</code></pre><figure><img src="02_su57.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反向切片，反转图像</span><br>plt.imshow(img[::-<span class="hljs-number">1</span>, ::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b125bdcc0&gt;</code></pre><figure><img src="02_su57_revs.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片抠图</span><br>plt.imshow(img[<span class="hljs-number">430</span>:<span class="hljs-number">610</span>, <span class="hljs-number">350</span>:<span class="hljs-number">510</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128501c0&gt;</code></pre><figure><img src="02_su57_big.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/F35C.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128c2860&gt;</code></pre><figure><img src="02_f35.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片步长降采样</span><br>plt.imshow(img[<span class="hljs-number">3400</span>:<span class="hljs-number">4200</span>:<span class="hljs-number">15</span>, <span class="hljs-number">8000</span>:<span class="hljs-number">8300</span>:<span class="hljs-number">15</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b12954f70&gt;</code></pre><figure><img src="02_f35_big.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Numpy基础属性和方法</title>
    <link href="/2024/06/04/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2024/06/04/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>命令模式下的快捷键：</p><ul><li>Alt + Enter 运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter 运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter 运行当前单元格</li><li>j / k、Shift + j / Shift + k选中下方/上方单元格、连续选中下方/上方单元格</li><li>a / b 在下方/上方插入新的单元格</li><li>c / x 复制单元格 / 剪切单元格</li><li>v / Shift + v 在下方/上方粘贴单元格</li><li>dd / z 删除单元格 / 恢复删除的单元格</li><li>Shift + l 显示或隐藏当前/所有单元格行号</li><li>Space / Shift + Space 向下/向上滚动页面</li></ul><p>编辑模式下的快捷键：</p><ul><li>Shift + Tab 获得提示信息</li><li>Ctrl + ]/ Ctrl + [ 增加/减少缩进</li><li>Alt + Enter 运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter 运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter 运行当前单元格</li><li>Ctrl + Left / Right 光标移到行首/行尾</li><li>Ctrl + Up / Down 光标移动代码开头/结尾处</li><li>Up / Down 光标上移/下移一行或移到上/下一个单元格</li></ul><h1 id="数组的创建">1 数组的创建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><ol type="1"><li>使用 <code>array</code>函数，通过 <code>list</code>创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># array(list)</span><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>arr, <span class="hljs-built_in">type</span>(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(array([1, 2, 3, 4, 5]), numpy.ndarray)</code></pre><ol start="2" type="1"><li>使用 <code>arange</code>函数，指定范围生成数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># arange(起始值, 结束值, 步长)</span><br>arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)  <br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ol start="3" type="1"><li>使用 <code>linspace</code>函数，生成等差数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># linspace(起始值, 结束值, 元素个数)</span><br>arr = np.linspace(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 10.,  20.,  30.,  40.,  50.,  60.,  70.,  80.,  90., 100.])</code></pre><ol start="4" type="1"><li>使用 <code>logspace</code>函数，生成等比数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># logspace(起始指数, 结束指数, num=元素个数, base=底数)</span><br><span class="hljs-comment"># 由起始指数、结束指数和底数确定起始值和结束值，在范围内根据元素个数自动推算公比</span><br>arr = np.logspace(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, num=<span class="hljs-number">5</span>, base=<span class="hljs-number">2</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([   4.,   16.,   64.,  256., 1024.])</code></pre><ol start="5" type="1"><li>使用 <code>fromstring</code>函数，从字符串提取数据创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fromstring(str, sep=’分隔符&#x27;, [dtype=&#x27;数据类型&#x27;])</span><br>arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1., 2., 3., 4., 5.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5])</code></pre><ol start="6" type="1"><li>使用 <code>random</code>函数生成随机数，创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># randint: 生成随机整数</span><br><span class="hljs-comment"># random.randint(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, size=<span class="hljs-number">5</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([8, 1, 3, 8, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uniform: 生成随机浮点数</span><br><span class="hljs-comment"># random.uniform(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[8.89013018, 9.11208169, 2.86415079, 1.87278992, 9.49237558],       [2.72498312, 2.42432246, 1.96473966, 5.23585378, 5.84650235],       [9.42765155, 7.01779665, 3.07567507, 6.34309282, 4.26517489]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># rand: 生成[0, 1)内的随机浮点数</span><br><span class="hljs-comment"># random.rand(数组形状shape)</span><br>arr = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0.25282566, 0.93635239, 0.02265436, 0.89447073],       [0.81152905, 0.70119062, 0.96435302, 0.53702331],       [0.34787245, 0.58961185, 0.61218228, 0.07453859]])</code></pre><ol start="7" type="1"><li>填充指定值的数组</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zeros: 填充为0</span><br>arr = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0., 0.],       [0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ones: 填充为1</span><br>arr = np.ones(<span class="hljs-number">10</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># full: 填充为指定值</span><br>arr = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">66</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[66, 66, 66, 66],       [66, 66, 66, 66],       [66, 66, 66, 66]])</code></pre><ol start="8" type="1"><li>使用 <code>eye</code>函数创建单位矩阵</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># eye(矩阵边长)</span><br>arr = np.eye(<span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1., 0., 0., 0.],       [0., 1., 0., 0.],       [0., 0., 1., 0.],       [0., 0., 0., 1.]])</code></pre><p>创建数组时可以通过<code>dtype</code>指定数组内元素类型，Numpy的每种数据类型有不同位数的版本，可以使用首字母＋字节数简写，如<code>i8</code>是占用8字节的 <code>int64</code>。</p><ul><li>有符号整数 <code>int</code></li><li>无符号整数 <code>uint</code></li><li>浮点数 <code>float</code></li><li>复数 <code>complex</code></li><li>布尔 <code>bool</code></li><li>字符串 <code>string_</code>或 <code>S</code></li><li>Python对象 <code>object</code></li><li>结构化数据类型 <code>void</code></li></ul><h1 id="数组的属性">2 数组的属性</h1><p><code>size</code>：获取数组的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的size为：<span class="hljs-subst">&#123;arr1.size&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的size为：<span class="hljs-subst">&#123;arr2.size&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的size为：3[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的size为：12</code></pre><p><code>shape</code>：获取数组的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的shape为：<span class="hljs-subst">&#123;arr1.shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的shape为：<span class="hljs-subst">&#123;arr2.shape&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的shape为：(3,)[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的shape为：(3, 4)</code></pre><p><code>dtype</code>：获取数组元素的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.rand(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的dtype为：<span class="hljs-subst">&#123;arr1.dtype&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的dtype为：<span class="hljs-subst">&#123;arr2.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的dtype为：int64[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的dtype为：float64</code></pre><p><code>ndim</code>：获取数组的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的ndim为：<span class="hljs-subst">&#123;arr1.ndim&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的ndim为：<span class="hljs-subst">&#123;arr2.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的ndim为：1[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的ndim为：2</code></pre><p><code>itemsize</code>：获取数组内每个元素所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的itemsize为：<span class="hljs-subst">&#123;arr1.itemsize&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的itemsize为：<span class="hljs-subst">&#123;arr2.itemsize&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的itemsize为：8[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的itemsize为：8</code></pre><p><code>nbytes</code>：获取数组所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的nbytes为：<span class="hljs-subst">&#123;arr1.nbytes&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的nbytes为：<span class="hljs-subst">&#123;arr2.nbytes&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的nbytes为：24[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的nbytes为：48</code></pre><h1 id="数组的方法">3 数组的方法</h1><h2 id="描述性统计">3.1 描述性统计</h2><p>Numpy中很多常用方法既可以写成对象的方法调用，也可以写成模块函数的调用。</p><p><code>arr.method()</code>和 <code>np.function(arr)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,        27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,        40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,        53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,        66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,        79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,        92,  93,  94,  95,  96,  97,  98,  99, 100])</code></pre><ul><li><code>sum()</code>：求总和</li><li><code>mean()</code>：求算术平均值</li><li><code>median()</code>：求中位数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">sum</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">sum</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;算术平均值：<span class="hljs-subst">&#123;np.mean(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中位数：<span class="hljs-subst">&#123;np.median(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">总和：5050总和：5050算术平均值：50.5中位数：50.5</code></pre><ul><li><code>amax()</code>/<code>max()</code>：求最大值</li><li><code>amin()</code>/<code>min()</code>：求最小值</li><li><code>ptp()</code>：求全距，即最大值-最小值。</li><li><code>quantile(arr, 分位点)</code>：求分位数。比如0.5表示计算50%分位数，也就是中位数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">max</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;np.amax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">min</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;np.amin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;全距：<span class="hljs-subst">&#123;np.ptp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;分位数：<span class="hljs-subst">&#123;np.quantile(arr, <span class="hljs-number">0.4</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最大值：100最大值：100最小值：1最小值：1全距：99分位数：40.6</code></pre><ul><li><code>var()</code>：求方差</li><li><code>std()</code>：求标准差</li><li><code>arr.std() / arr.mean()</code>：求变异系数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;arr.var()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;np.var(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;arr.std()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;np.std(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;变异系数：<span class="hljs-subst">&#123;arr.std() / arr.mean()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">方差：833.25方差：833.25标准差：28.86607004772212标准差：28.86607004772212变异系数：0.5716053474796459</code></pre><ul><li><code>argmax()</code>：返回最大值索引</li><li><code>argmin()</code>：返回最小值索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">66</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;np.argmax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;arr.argmax()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;np.argmin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;arr.argmin()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[12  5 66  9  1]最大值索引为：2最大值索引为：2最小值索引为：4最小值索引为：4</code></pre><p>可以使用<code>axis</code>对指定维度进行聚合，<code>axis</code>指定的是数组将会被折叠的维度，而不是将要返回的维度，因此<code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合。</p><figure><img src="01_axis.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><p><code>axis</code>的值就是 <code>shape</code>中对应下标的维度。</p><p>一维数组中<code>axis=0</code>：0向维度折叠，也就是按整个数组聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br>arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">np.int64(45)</code></pre><p>二维数组中：</p><ul><li><code>axis=0</code>：0向维度折叠，也就是把行折叠，按列进行统计</li><li><code>axis=1</code>：1向维度折叠，也就是把列折叠，按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按列统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按行统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]按列统计： [15 18 21 24 27]按行统计： [10 35 60]</code></pre><h2 id="其他方法">3.2 其他方法</h2><ul><li><code>reshape()</code>：调整数组形状，注意返回的是原数组的视图，而不是拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br>arr_shape = arr.reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_shape数组：\n<span class="hljs-subst">&#123;arr_shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单列数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单列数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单行数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单行数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342 9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]arr_shape数组：[[3.16428678 1.85703697 8.08660982 3.30281002] [1.65160879 6.65371342 9.35288329 2.33650475] [5.72465209 9.37121035 9.87604912 4.20079867]]二维单列数组：[[3.16428678] [1.85703697] [8.08660982] [3.30281002] [1.65160879] [6.65371342] [9.35288329] [2.33650475] [5.72465209] [9.37121035] [9.87604912] [4.20079867]]二维单行数组：[[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342  9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]]</code></pre><ul><li><code>astype(数据类型)</code>：将数组元素转换为指定类型，返回一个新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br>arr_int = arr.astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_int类型：<span class="hljs-subst">&#123;arr_int.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原类型：float64arr类型：float64arr_int类型：int64</code></pre><ul><li><code>fill()</code>：向数组填充指定元素，修改数组本身</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr.fill(<span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.])</code></pre><ul><li><code>sort()</code>：对原数组进行就地排序<ul><li><code>数组.sort()</code>：就地排序</li><li><code>np.sort(数组)</code>：排序返回新数组，原数组不变</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>arr_st = np.sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的新数组：<span class="hljs-subst">&#123;arr_st&#125;</span>&#x27;</span>)<br><br>arr.sort()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用数组.sort()的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的新数组：[2 5 5 6 6 7 7 7 7 8]使用数组.sort()的原数组：[2 5 5 6 6 7 7 7 7 8]</code></pre><ul><li><code>flatten()</code>：将多维数组扁平化为一维数组，返回一个新数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr.ndim&#125;</span>\n&#x27;</span>)<br><br>arr_f = arr.flatten()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;扁平化数组为：\n<span class="hljs-subst">&#123;arr_f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr_f.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]维度：2扁平化数组为：[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]维度：1</code></pre><ul><li><code>tolist()</code>：将数组转化为 <code>list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = arr.tolist()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ls))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;list&#39;&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00_MySQL基础</title>
    <link href="/2024/06/01/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/00%20MySQL%E5%9F%BA%E7%A1%80/00_MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/01/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/00%20MySQL%E5%9F%BA%E7%A1%80/00_MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据定义语言ddl">1 数据定义语言DDL</h1><p>Data DefinitionLanguage：数据定义语言，用来定义数据库对象(数据库，表，字段)。</p><h2 id="库操作">1.1 库操作</h2><p><strong>创建数据库：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [CHARSET <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;utf8&#x27;</span>];<br></code></pre></td></tr></table></figure></p><p><strong>显示所有库：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure></p><p><strong>使用指定数据库：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure></p><p><strong>删除指定数据库：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名<br></code></pre></td></tr></table></figure></p><h2 id="表操作">1.2 表操作</h2><h3 id="创建表">1.2.1 创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>    字段名<span class="hljs-number">1</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">1</span>注释],<br>    字段名<span class="hljs-number">2</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">2</span>注释],<br>    字段名<span class="hljs-number">3</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">3</span>注释]<br>) [COMMENT 表注释]<br></code></pre></td></tr></table></figure><p>常用主键自增<code>AUTO_INCREMENT</code>。</p><ul><li>常用数据类型：<ul><li>整数：<code>INT</code></li><li>字符串：<code>VARCHAR(长度)</code></li><li>小数：<code>DECIMAL(总位数, 小数位)</code></li><li>时间：<code>DATETIME</code></li></ul></li><li>常用约束<ul><li>主键：<code>PRIMARY KEY</code></li><li>非空：<code>NOT NULL</code></li><li>唯一：<code>UNIQUE</code></li><li>默认：<code>DEFAULT</code></li><li>外键：<code>FOREIGN KEY</code>（影响效率）</li></ul></li></ul><h3 id="查询表">1.2.2 查询表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询当前数据库所有表<br><span class="hljs-keyword">SHOW</span> TABLES;<br><br># 查询表结构<br><span class="hljs-keyword">DESC</span> 表名;<br><br># 查询建表语句<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h3 id="修改表">1.2.3 修改表</h3><p><strong>增加字段：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 [约束];<br></code></pre></td></tr></table></figure></p><p><strong>删除字段：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br></code></pre></td></tr></table></figure></p><p><strong>修改字段类型：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 MODIFY 字段名 新类型;<br></code></pre></td></tr></table></figure></p><p><strong>修改字段名和类型：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 [约束];<br></code></pre></td></tr></table></figure></p><p><strong>修改表名：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 旧表名 RENAME 新表名;<br></code></pre></td></tr></table></figure></p><h3 id="删除表">1.2.4 删除表</h3><p><strong>删除整个表结构：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure></p><p><strong>删除数据保留表结构：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 主键自增序列不清零<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名;<br><br># 主键自增序列清零<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure></p><h1 id="数据操作语言dml">2 数据操作语言DML</h1><p>Data ManipulationLanguage：数据操作语言，用来对数据库中表的数据记录进行增、删、改操作。</p><h2 id="增加insert">2.1 增加INSERT</h2><p><strong>向指定字段添加数据：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></p><p><strong>全部字段添加数据：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure></p><p><strong>批量添加数据（指定字段）：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></p><p><strong>批量添加数据（全部字段）：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure></p><h2 id="删除delete">2.2 删除DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h2 id="修改update">2.3 修改UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span> , 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span><br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h1 id="数据查询语言dql">3 数据查询语言DQL</h1><p>Data Query Language：数据查询语言，用来查询数据库表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br><span class="hljs-keyword">HAVING</span> 分组后条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 排序字段<br>LIMIT 分页参数;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>FROM</code> 加载数据</li><li><code>WHERE</code> 对加载后的数据进行筛选</li><li><code>GROUP BY</code> 对筛选后的数据进行分组</li><li><code>HAVING</code> 对分组后的数据进行筛选</li><li><code>SELECT</code> 返回要查询的字段</li><li><code>ORDER BY</code> 对结果进行排序</li><li><code>LIMIT</code> 限制返回结果</li></ol><h2 id="基础查询">3.1 基础查询</h2><p><strong>通用格式：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure></p><p><strong>查询所有字段：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure></p><p><strong>查询结果去重：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure></p><ul><li>比较运算符<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code><code>&lt;=</code> <code>==</code><code>!=</code>都和Python相同，另有不同的有如下：<ul><li><code>字段 BETWEEN 最小值 AND 最大值</code>：在最小值和最大值范围内即可</li><li><code>字段 IN (值1, 值2...)</code>：在<code>()</code>内满足任意即可</li><li><code>字段 LIKE "占位符"</code>：模糊查询，可以用<code>_</code>代表一个字符，<code>%</code>代表任意个字符</li><li><code>IS NULL</code>：判空专用</li></ul></li><li>逻辑运算符：<ul><li><code>AND</code></li><li><code>OR</code></li><li><code>NOT</code></li></ul></li></ul><h2 id="聚合查询">3.2 聚合查询</h2><p>前面的查询都是横向查询，根据条件一行一行的进行判断。聚合函数查询是纵向查询，它将一列数据作为一个整体，进行纵向计算，然后返回一个结果值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure></p><ul><li><code>COUNT(*)</code>：按照列统计数量</li><li><code>MAX()</code>：按照列计算最大值</li><li><code>MIN()</code>：按照列计算最小值</li><li><code>AVG()</code>：按照列计算平均值</li><li><code>SUM()</code>：按照列计算数值和</li></ul><h2 id="分组查询">3.3 分组查询</h2><p>按列进行分类，把相同的数据归为一类，然后可以对分类完的数据进行合并计算。</p><p>通常和聚合函数联合使用：</p><ol type="1"><li>先分组：把表数据按照指定列的值进行划分，值相同的数据划分到同一个组</li><li>再聚合：分别针对每一组数据使用聚合函数进行统计</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [聚合函数, 分组字段]<br>[<span class="hljs-keyword">WHERE</span> 条件]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br>[<span class="hljs-keyword">HAVING</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><p><code>WHERE</code>与<code>HAVING</code>区别：</p><ul><li>执行时机不同：<ul><li><code>WHERE</code>是分组之前进行过滤，不满足<code>WHERE</code>条件，不参与分组</li><li><code>HAVING</code> 是分组之后对结果进行过滤</li></ul></li><li>判断条件不同：<ul><li><code>WHERE</code> 不能对聚合函数进行判断</li><li><code>HAVING</code> 可以对聚合函数进行判断</li></ul></li></ul><h2 id="排序查询">3.4 排序查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式, 字段<span class="hljs-number">2</span> 排序方式;<br></code></pre></td></tr></table></figure><p>排序方式： <code>ASC</code>：升序（默认值）<code>DESC</code>：降序</p><h2 id="分页查询">3.5 分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br>LIMIT [起始行数,] 总行数;<br></code></pre></td></tr></table></figure><h1 id="多表查询">4 多表查询</h1><p>多表查询<code>SELECT 字段 FROM 表1, 表2</code>会产生笛卡尔积，也就是两个表的所有组合情况。要想消除笛卡尔积，只需要给多表查询加上连接查询的条件即可。</p><h2 id="连接查询">4.1 连接查询</h2><h3 id="内连接">4.1.1 内连接</h3><p><strong>隐式内连接：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure></p><p><strong>显式内连接：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br>[<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure></p><p>内连接只能返回两个表中都存在匹配的行。</p><h3 id="外连接">4.1.2 外连接</h3><p><strong>左外连接：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure></p><p>左外连接是以左表为中心，返回左表所有行，以及右表匹配的行。即使右表没有匹配，则对应列显示<code>NULL</code>。</p><p><strong>右外连接：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure></p><p>右外连接是以右表为中心，返回右表所有行，以及左表匹配的行。即使左表没有匹配，则对应列显示<code>NULL</code>。<img src="mysql_join.png" /></p><h3 id="全连接">4.1.3 全连接</h3><p>全连接<code>FULL OUTER JOIN</code>是取两个表的并集，MySQL本身并不支持全连接，但可以借助<code>UNION</code>实现。</p><p><code>UNION</code>合并，并且去重 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure></p><p><code>UNION ALL</code>合并但不去重 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure></p><blockquote><p>在多表连接中，如果两个表的连接字段名相同，可以不使用<code>ON a.id = b.id</code>，而使用更简洁的<code>USING(id)</code>代替。</p></blockquote><h2 id="子查询">4.2 子查询</h2><p>将查询的结果作为外部<strong>查询的条件、字段或表</strong>来使用，称为嵌套查询，又称子查询。子查询用来提供值、集合或表给外查询作比较或进一步处理。</p><h3 id="常见分类">4.2.1 常见分类</h3><ul><li>相关子查询（Correlated Subquery）<ul><li>子查询<strong>内部引用外查询的列</strong>，子查询需要对外查询的每一行重新计算，每行执行效率较低</li></ul></li><li>非相关子查询（Non-correlated）<ul><li>子查询<strong>独立于外查询</strong>，单独执行一次得到结果，外查询再使用该结果<br /></li></ul></li><li>按返回结果类型<ul><li>标量子查询（Scalar）：返回单个值（单行单列）。可用于<code>= (子查询)</code>、<code>SELECT (子查询)</code>等场景，若返回多行则报错</li><li>单行多列子查询：返回一行，通常用<code>(a, b) = (SELECT x, y ...)</code> 方式比较</li><li>多行单列子查询：返回多行，通常用<code>IN</code>、<code>ANY</code>、<code>SOME</code>、<code>EXISTS</code></li><li>多行多列子查询：返回多行多列，用<code>(a, b) IN (SELECT x, y ...)</code>方式比较，或<strong>当做派生表</strong>处理</li></ul></li></ul><h3 id="常用关键字">4.2.2 常用关键字</h3><ul><li><code>IN</code>：判断一个值<strong>是否在集合</strong>里<ul><li><code>salary IN (SELECT salary FROM …)</code></li></ul></li><li><code>EXISTS</code>：判断是否存在<strong>至少一行</strong>结果<ul><li><code>EXISTS (SELECT 1 FROM …)</code></li></ul></li><li><code>ANY/SOME</code>：和集合中<strong>至少一个值</strong>比较<ul><li><code>salary &gt; ANY (SELECT salary FROM …)</code></li></ul></li><li><code>ALL</code>：和集合中<strong>所有值</strong>比较<ul><li><code>salary &gt; ALL (SELECT salary FROM …)</code></li></ul></li></ul><blockquote><p><code>NOT IN</code> 与 <code>NULL</code>会导致结果为空集，常用<code>NOT EXISTS</code> 来代替<code>NOT IN</code>。</p></blockquote><h3 id="示例">4.2.3 示例</h3><p><strong>标量子查询：</strong> 子查询只返回一个值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 非相关标量子查询<br># 查询工资高于平均工资的员工姓名和工作<br><span class="hljs-keyword">SELECT</span> <br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <br>        <span class="hljs-keyword">FROM</span> emp<br>    );<br></code></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 相关标量子查询<br># 查询工资高于本部门平均工资的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span> <br>    emp <span class="hljs-keyword">AS</span> e<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-operator">=</span> e.dept_id  # 子查询内部引用外部列<br>    );<br></code></pre></td></tr></table></figure><p><strong>多行多列子查询：</strong>子查询返回多行多列数据，通常需要与<code>IN</code>搭配使用。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    (dept, salary) <span class="hljs-keyword">IN</span> (<br>        <span class="hljs-keyword">SELECT</span> dept, <span class="hljs-built_in">MAX</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept<br>    );<br></code></pre></td></tr></table></figure></p><p><strong>派生表：</strong> 子查询结果作为派生表使用，通常需要起别名。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span> e.name, e.dept_id, e.salary<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> dept_id, <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_id<br>) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">ON</span> e.dept_id <span class="hljs-operator">=</span> t.dept_id<br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-operator">=</span> t.max_salary;<br></code></pre></td></tr></table></figure></p><h1 id="开窗函数">5 开窗函数</h1><p>MySQL 窗口函数（Window Functions）是 MySQL 8.0引入的一项强大功能，窗口函数的作用类似于聚合函数，但它并不会像<code>GROUP BY</code>那样把多行聚合成一行，它会在原有表基础上，为<strong>每一行添加一个新列</strong>，返回计算结果。</p><ul><li><code>PARTITION BY</code>：将查询结果分成若干个<strong>独立的窗口（分区）</strong>，窗口函数会分别在每个分区上进行计算，类似于<code>GROUP BY</code>，但它不合并行。</li><li><code>ORDER BY</code>：确定窗口内的顺序，对排名 /偏移函数非常重要。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqlFIRST_VAL">SELECT 字段列表,<br>函数() OVER(<br>    [PARTITION BY 分区列表]<br>    [ORDER BY 排序列表]<br>) [[AS] 别名]<br></code></pre></td></tr></table></figure><p>每加一个开窗函数，就可以在原有表基础上新增一列，具体取决于选用什么函数。</p><ul><li>排名函数<ul><li><code>ROW_NUMBER()</code>：为分区的每一行分配一个<strong>唯一</strong>的连续整数。12 3 4</li><li><code>RANK()</code>：为分区每一行分配排名，有相同排名，但会<strong>跳过后续排名</strong>。1 2 2 4</li><li><code>DENSE_RANK()</code>：为分区每一行分配排名，有相同排名且<strong>连续</strong>。12 2 3</li></ul></li><li>分析/位移函数<ul><li><code>LAG(expr, N)</code>：返回当前行<strong>前面第N行</strong>的<code>expr</code>值，比如计算销售额与前N天的差异。</li><li><code>LEAD(expr, N)</code>：返回当前行<strong>后面第N行</strong>的<code>expr</code>值，比如计算销售额与后N天的差异。</li><li><code>FIRST_VALUE(expr)</code>：返回窗口框架中<strong>第一行</strong>的<code>expr</code>值，比如找出每个部门的最高薪水。</li><li><code>LAST_VALUE(expr)</code>：返回窗口框架中<strong>最后一行</strong>的<code>expr</code>值，比如找出每个部门的最低薪水。</li></ul></li><li>聚合函数<ul><li><code>SUM()</code>：计算窗口内的总和</li><li><code>AVG()</code>：计算窗口内的平均值</li><li>…</li></ul></li></ul><p>窗口函数<strong>只能出现在<code>SELECT</code>列表和<code>ORDER BY</code>中</strong>（不能在<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>中直接使用，因为这些子句在<code>SELECT</code>之前就执行了，而窗口函数是在<code>SELECT</code>阶段才计算的）。</p><p>如果需要对窗口结果做过滤，应该使用子查询或 CTE。</p><p><strong>经典TOP-N问题：</strong> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> id, name, dept, salary,<br>    <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> dept <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span><br>    ) <span class="hljs-keyword">AS</span> rn<br>    <span class="hljs-keyword">FROM</span> employees<br>) t<br><span class="hljs-keyword">WHERE</span> rn <span class="hljs-operator">&lt;=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></p><h1 id="cte">6 CTE</h1><p><strong>CTE（Common TableExpression，公共表表达式）</strong>就是<strong>临时结果集</strong>，可以在一个查询里先把它定义出来，在后续查询中使用。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cte_name  <span class="hljs-keyword">AS</span> (<br>    子查询<br>)<br><br><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> cte_name<br><span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2024/05/29/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/29/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-系统概述">1 Linux 系统概述</h1><ul><li>Linux 发行时间: 1991年</li><li>Linux 的创始人: 林纳斯·托瓦兹</li><li>Linux 的吉祥物: 企鹅</li><li>官网地址: https://www.kernel.org/</li></ul><blockquote><p><strong>Linux 发行版</strong> = Linux 内核 + 系统库 + 系统软件</p><p>Linux 的内核完全开源免费，但是 Linux 的发行版不一定免费。</p></blockquote><p>Linux 是目前服务器端用到的最多的操作系统，支持 7 * 24小时高性能服务。常见的 Linux 发行版：</p><ul><li>RedHat: 世界最大的 Linux 发行版厂商，已经被 IBM 收购</li><li>Ubuntu: 桌面操作系统做最好的</li><li>CentOS: 目前中国市场使用最多的 Linux 版本，目前已经被 RedHat收购,但依然免费</li><li>Deepin: 深度公司开发的 Linux 版本，国内做的最好的 Linux 发行版</li></ul><figure><img src="1739856296312.png" alt="1739856296312" /><figcaption aria-hidden="true">1739856296312</figcaption></figure><h1 id="linux-的目录结构">2 Linux 的目录结构</h1><ul><li>Linux 和 Windows, Mac 一样, 都是文件系统,采用文件和文件夹的形式来管理数据</li><li>只不过在 Linux操作系统中，是没有盘符概念的，任何文件(文件夹)都是从根目录开始进行拆分的</li><li>且 Linux 中采用的是<strong>目录树结构</strong>，Windows中采用的是<strong>森系结构</strong></li></ul><p>Linux 中常用的目录结构:</p><ul><li><code>/etc</code>：存放 Linux 配置文件的目录</li><li><code>/opt</code>：存放应用程序的目录</li><li><code>/bin</code>：终端指令集存放的目录</li><li><code>/sbin</code>：超级管理员用户使用的指令集，包括用户的创建删除等指令</li><li><code>/home</code>：普通用户的家目录</li><li><code>/root</code>：超级管理员的家目录,</li></ul><figure><img src="666666666.png" alt="666666666" /><figcaption aria-hidden="true">666666666</figcaption></figure><h1 id="基础命令">3 基础命令</h1><p>Linux指令的构成：<code>command [-options] [arguments]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">linux指令 = 命令(做什么) + 选项(怎么做) + 参数(对谁做)  <br><br>command: 命令名, 相应功能的英文单词或单词的缩写  <br>-options: 选项, 可用来对命令进行控制, 也可以省略  <br>arguments: 传给命令的参数, 可以是零个、一个或者多个<br></code></pre></td></tr></table></figure><h2 id="文件与目录操作">3.1 文件与目录操作</h2><h3 id="路径导航">3.1.1 路径导航</h3><h4 id="ls列出内容">ls（列出内容）</h4><p><code>ls</code> 源自<strong>list</strong>，用于<strong>查看指定位置的文件和子目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [-a -l -h] [路径信息]<br><br>-a  # all, 显示所有文件（包括以.开头的隐藏文件）<br>-l  # long format, 以长格式列出文件（权限、所有者、大小、修改时间等）<br>-h    # human-readable, 以人类可读的格式（如 KB、MB）显示文件大小（需配合 -l 使用）<br></code></pre></td></tr></table></figure><p>选项可以随意自由组合，且选项的顺序可以随意调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls        # 列出当前目录的文件和子目录（不包括隐藏的）<br>ls -lh  # 以长格式显示文件信息，并以易读的方式显示文件大小<br>ls -al  # 以长格式显示文件信息，包括隐藏文件<br>ls -alh # 以长格式显示文件信息，包括隐藏文件，并以易读的方式显示文件大小<br></code></pre></td></tr></table></figure><p><code>ls</code> 参数可以查看指定路径的文件信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /      # 查看根目录的文件和子目录<br>ls -a aa  # 显示当前目录下的 aa 目录中的文件内容，包括隐藏文件<br>ll        # 完全等价于 ls -l, 可以快速查看文件的详细信息（也可以搭配 -h -a 使用）<br></code></pre></td></tr></table></figure><h4 id="cd切换目录">cd（切换目录）</h4><p><code>cd</code> 源自 <strong>changedirectory</strong>，用于<strong>改变工作目录</strong>。</p><ul><li>绝对路径：从根目录出发，直到目标文件的目录层级</li><li>相对路径：从当前目录出发，直到目标文件目录层级</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd [绝对路径或相对路径]<br><br>..    # 代表上一级目录<br>../   # 同上，代表上一级目录<br>./    # 代表当前路径，可以省略<br></code></pre></td></tr></table></figure><ul><li><code>cd</code> 命令无需选项，只有参数，表示要切换到哪个目录下</li><li><code>cd</code> 命令不写参数直接执行，表示回到用户的家目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc  # 切换到 /etc 目录<br>cd       # 回家，root 账号家目录是 /root，其他账号家目录是 /home<br>cd ~     # 返回家目录，即 cd ~ 等价于 cd，都是回家<br>cd -     # 返回上一次操作的工作目录<br></code></pre></td></tr></table></figure><h4 id="pwd当前路径">pwd（当前路径）</h4><p><code>pwd</code> 源自 <strong>print workdirectory</strong>，用于<strong>打印工作目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd        # 当前在哪个目录, 就打印什么路径.<br></code></pre></td></tr></table></figure><h3 id="增删改">3.1.2 增删改</h3><h4 id="mkdir创建目录">mkdir（创建目录）</h4><p><code>mkdir</code> 源自 <strong>makedirectory</strong>，用于<strong>创建新文件夹</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [-p] 目录名称<br>-p    # parents, 自动创建所需的父目录（如果不存在）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单级目录</span><br>mkdir aa            # 在当前目录下创建 aa 文件夹<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建多级目录</span><br>mkdir aa/bb/cc      # 创建多级目录，如果 aa/bb 目录不存在，则：报错<br>mkdir -p aa/bb/cc   # 自动创建所需要的目录<br></code></pre></td></tr></table></figure><h4 id="touch创建文件">touch（创建文件）</h4><p><code>touch</code>用于<strong>修改文件时间戳</strong>或<strong>创建空文件</strong>。</p><ul><li><code>touch</code>可以创建一个新的文件，文件的扩展名随意，甚至可以是不存在的扩展名</li><li><code>touch</code> 创建的文件如果存在不报错，但是没有新文件产生</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单个文件</span><br>touch 1.txt        <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性创建多个文件</span><br>touch 1.txt 2.jpg 3.mp3<br></code></pre></td></tr></table></figure><h4 id="cp复制">cp（复制）</h4><p><code>cp</code> 源自<strong>copy</strong>，用于<strong>拷贝文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp 源文件 目标文件<br>cp -r 源目录 目标目录<br>-r      # recursive, 递归复制目录（包括子目录和文件）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝文件</span><br>cp 1.txt /aa         # 拷贝 1.txt 到 /aa 目录下<br>cp 1.txt /aa/2.txt   # 拷贝 1.txt 到 /aa 目录下，并命名为 2.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝目录</span><br>cp -r aa bb          # 递归拷贝 aa 文件夹到 bb 文件夹下<br></code></pre></td></tr></table></figure><h4 id="mv移动重命名">mv（移动/重命名）</h4><p><code>mv</code> 源自<strong>move</strong>，用于 <strong>移动</strong>或<strong>重命名文件</strong>文件和目录，类似于windows 剪切。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 源文件 目标路径  # 将文件移动到目标路径<br>mv 旧名字 新名字    # 重命名（本质是在同一目录下移动）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动</span><br>mv file.txt /tmp/          # 移动 file.txt 到 /tmp 目录<br>mv folder/ /backup/        # 移动 folder 到 /backup 目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重命名</span><br>mv old.txt new.txt         # 文件重命名<br>mv old_dir/ new_dir/       # 目录重命名<br></code></pre></td></tr></table></figure><h4 id="rm删除">rm（删除）</h4><p><code>rm</code> 源自 <strong>remove</strong>，用于<strong>删除文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名<br>rm -r 目录名<br>-r      # recursive, 递归删除目录（包括子目录和文件）<br>-f      # force, 强制删除，不进行询问<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件</span><br>rm 1.txt    # 删除当前目录下的 1.txt<br>rm /*.txt   # 删除根目录下的所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件夹</span><br>rm -r aa    # 删除当前目录下的 aa 文件夹<br>rm -rf /bb  # 强制删除根目录下的 bb 文件夹不进行提示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性删除多个</span><br>rm -rf /*              # 通过 * 通配符删除所有文件<br>rm 1.txt 2.jpg 3.mp3   # 一次性删除这三项文件<br></code></pre></td></tr></table></figure><h3 id="内容查看">3.1.3 内容查看</h3><h4 id="cat全量查看">cat（全量查看）</h4><p><code>cat</code> 源自<strong>concatenate</strong>，连接、查看文件内容，常用于<strong>查看小型文本文件</strong>。</p><ul><li>一次性输出全部内容，大文件显示不全，且过于消耗内存，适合小文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名<br>-n  # number, 显示行号<br></code></pre></td></tr></table></figure><h4 id="more分页查看">more（分页查看）</h4><p><code>more</code>是一个分页查看工具，主要用于<strong>查看中型文本文件</strong>。</p><ul><li>分页查看文件，支持手动翻页，更加灵活，但同样消耗内存。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">more 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Enter          向下一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">D(down)/Space  向下一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">B(back)        向上一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Q(quit)        退出</span><br></code></pre></td></tr></table></figure><h4 id="tail查看尾部日志监控">tail（查看尾部，日志监控）</h4><p><code>tail</code>意为“尾部”，用于<strong>查看文件末尾内容</strong> ，适合监控日志文件或实时查看新增内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail [-n NUM -f] 文件名<br>-n NUM   # number, 显示末尾 NUM 行（默认 10）, n 可以省略，简写为 -NUM<br>-f       # follow, 实时跟踪文件更新<br><br>tail 1.txt           # 查看文件末尾 10 行（默认）<br>tail -5 1.txt        # 查看文件末尾 5 行<br>tail -100f log.txt   # 动态查看文件末尾 100 行<br></code></pre></td></tr></table></figure><h2 id="搜索与过滤">3.2 搜索与过滤</h2><h3 id="文件搜索">3.2.1 文件搜索</h3><h4 id="which查找命令路径">which（查找命令路径）</h4><p><code>which</code> 用于<strong>查找命令的完整路径</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">which 命令名<br><br>which ls        # 输出：/usr/bin/ls<br>which ifconfig  # 输出：/usr/sbin/ifconfig<br></code></pre></td></tr></table></figure><h4 id="find按条件递归查找文件">find（按条件递归查找文件）</h4><p><code>find</code>通过条件筛选，用于<strong>查找符合条件的文件和目录</strong>。</p><ul><li>不指定路径时：默认从当前目录递归搜索</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [路径] [筛选条件]<br>-name 按名称过滤<br>-size 按大小过滤  <br>    -size +100M 大于100MB  <br>    -size -1G 小于1GB<br>-type 按类型过滤  <br>    -type f 文件  <br>    -type d 目录 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按名称搜索</span><br>find / -name &#x27;abc*&#x27;         # 查找根目录下所有 abc 开头的文件<br>find /path -name &quot;*.txt&quot;    # 查找 /path 目录下所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按大小搜索</span><br>find / -size +1G            # 查找根目录下大于 1GB 的文件<br>find ~ -size -10M           # 查找家目录下小于 10MB 的文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按类型搜索</span><br>find / -type d -name &quot;log&quot;  # 搜索名为 log 的目录<br></code></pre></td></tr></table></figure><h3 id="内容过滤">3.2.2 内容过滤</h3><h4 id="grep文本匹配">grep（文本匹配）</h4><p><code>grep</code> 源自 <strong>global regular expressionprint</strong>（全局正则表达式打印），用于<strong>搜索符合条件的文本并打印所在行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [-n] &quot;要搜索的内容&quot; 文件名<br>-n       # number, 显示行号<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep &#x27;world&#x27; 1.txt  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep -n &#x27;python&#x27; 1.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容： 2: python world good</span><br></code></pre></td></tr></table></figure><h4 id="wc行词字节统计">wc（行/词/字节统计）</h4><p><code>wc</code> 源自 <strong>wordcount</strong>，用于<strong>统计文本行数、单词数、字节数</strong>。</p><ul><li>单词按照空格划分</li><li>在默认的 UTF-8 编码下，1汉字 = 3字节，1汉字 = 1字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc [-l -w -c -m] 文件名<br>-l             # line, 行数<br>-w             # word, 单词数<br>-c             # character, 字节数<br>-m             # multibyte, 字符数<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：hello world</span><br>wc 1.txt       # 输出：1 2 12 ，分别代表行数、单词数、字节数<br>wc -wlc 1.txt  # 同上，包括 -lwc 都一样，没有顺序之分<br></code></pre></td></tr></table></figure><h2 id="文本打印">3.3 文本打印</h2><h3 id="echo输出文本变量">echo（输出文本/变量）</h3><p><code>echo</code> 意为“回声”，功能类似于 Python 的<code>print</code>，用于 <strong>输出文本或变量内容到标准输出（屏幕）</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [-n -e] &#x27;内容&#x27;<br>-n    不自动换行（末尾不加换行符）<br>-e    启用转义字符（如 \n 换行）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出文本到屏幕</span><br>echo &quot;Hello, World!&quot;      # 输出：Hello, World!<br>echo - e &quot;Hello\nWorld!&quot;  # 输出两行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出变量到屏幕</span><br>name=&#x27;zhu&#x27;                # = 两侧不能有空格<br>echo &quot;my name is $name&quot;   # 使用 $ 表示变量，输出：my name is zhu<br></code></pre></td></tr></table></figure><h2 id="数据流控制">3.4 数据流控制</h2><h3 id="输出重定向">3.4.1<code>&gt;</code>/<code>&gt;&gt;</code>（输出重定向）</h3><p>重定向通过符号控制数据的输入/输出方向，用于<strong>控制数据的流向</strong>（如输出到文件或管道）。</p><ul><li>重定向是命令与文件间的传递，用于保存输出或读取文件输入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">    <span class="hljs-comment"># 覆盖写入文件（若文件不存在则创建）</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;    <span class="hljs-comment"># 追加到文件末尾</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速创建文件</span><br>echo &quot;This is line 1&quot; &gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加文本</span><br>echo &quot;This is line 2&quot; &gt;&gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重定向输出</span><br>ls /usr/bin &gt; cmd.txt   # 将输出信息重定向到 cmd.txt 中，相当于写入<br></code></pre></td></tr></table></figure><h3 id="管道符">3.4.2 <code>|</code>（管道符）</h3><p>管道（Pipe <code>|</code> ）用于将 <strong>前一个命令的输出</strong>作为 <strong>后一个命令的输入</strong>，实现多命令协作处理数据。</p><ul><li>管道符是命令与命令间的传递，用于多命令协作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令1 | 命令2 | 命令3...<br><br>ls / | wc -w    # 输出：20，统计根目录下的目录数<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br>cat 1.txt | grep &#x27;python&#x27; | wc -w   # 输出：3，先查文件，再过滤，再统计单词<br></code></pre></td></tr></table></figure><h3 id="命令替换">3.4.3 <code>`</code>/<code>$()</code>（命令替换）</h3><p>反引号<code>`</code>用于 <strong>命令替换</strong>，可以将<strong>命令的输出结果</strong>作为字符串嵌入到其他命令中，现代脚本中可以使用 <code>$( )</code> 语法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `ls / | wc -w`<br>echo $(ls / | wc -w)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出：20</span><br></code></pre></td></tr></table></figure><h2 id="vivim-命令">3.5 vi/vim 命令</h2><p><code>vi</code> 全称叫: Visual Interface，类似于 windows 的记事本，是Linux 中最经典的文本编辑器。 <code>vim</code> 是 vi 的加强版本，兼容 vi的所有指令，不仅能编辑文本，而且还具有 shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性。</p><ul><li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li><li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 文件名<br>vim 文件名<br></code></pre></td></tr></table></figure><p><code>vi</code> / <code>vim</code> 编辑器的三种工作模式：</p><ul><li><p><strong>命令模式</strong>（默认/Command mode）从键盘上输入的任何字符都被当做命令来解释，但输入的命令并不回显在屏幕上。若输入的字符不是vi 的合法命令，vi 会响铃报警。</p></li><li><p><strong>输入模式</strong>（Insert mode）也就是所谓的编辑模式、插入模式。用户输入的任何字符都被 vi当做文件内容保存起来，并将其显示在屏幕上。</p></li><li><p><strong>底线命令模式</strong>（Last line mode）底线命令模式也称命令行模式。此时 vi会在屏幕最后一行显示一个<code>:</code>作为末行模式的说明符，等待用户输入命令，多数文件管理命令都是在此模式下执行的。</p></li></ul><p><img src="Pasted%20image%2020250729181400.png" /></p><ul><li>命令模式：<ul><li><code>iao</code> 进入编辑模式</li><li><code>:</code> 进入底线命令模式</li><li><code>dd</code> 删除当前行</li><li><code>ndd</code> 向下删除 n 行</li><li><code>yy</code> 复制当前行</li><li><code>nyy</code> 向下复制 n 行</li><li><code>p</code> 粘贴</li><li><code>gg</code> 回到行首（文件开头）</li><li><code>G</code> 回到行尾（文件结尾）</li><li><code>u</code> 撤销</li><li><code>Ctrl</code>+<code>r</code>：反撤销</li><li><code>/文本</code>：查询文本并高亮显示</li></ul></li><li>底线命令模式：<ul><li><code>:q</code> 退出不保存</li><li><code>:q!</code> 强制退出不保存</li><li><code>:wq</code> write quit 退出并保存（快捷键<code>ZZ</code>）</li><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 隐藏行号</li><li><code>:noh</code>/<code>:nohl</code> no highlight，取消高亮显示</li></ul></li><li>输入模式：<ul><li><code>ESC</code> 回到命令模式</li></ul></li></ul><h2 id="命令手册">3.6 命令手册</h2><p>大多数手册都是全英文的，可以通过重定向符：<code>man ls &gt; ls-man.txt</code>，输出手册到文件，然后通过翻译软件查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助文档.</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: 命令名 --<span class="hljs-built_in">help</span></span>  <br>ls --help  <br>​  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助手册</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: man 命令名  manual，手册</span><br>man ls<br></code></pre></td></tr></table></figure><h1 id="用户和权限">4 用户和权限</h1><p>在 Linux系统中，拥有最大权限的账户名为：<code>root</code>（超级管理员）。普通用户的权限，一般在其 HOME 目录内是不受限的，一旦出了 HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限。</p><h2 id="用户和用户组">4.1 用户和用户组</h2><p>Linux系统中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组中</li></ul><p><img src="Pasted%20image%2020250729213542.png" /></p><p>Linux中关于权限的管控级别有2个级别，分别是：</p><ul><li>针对<strong>用户</strong>的权限控制</li><li>针对<strong>用户组</strong>的权限控制</li></ul><h3 id="用户组管理">4.1.1 用户组管理</h3><h4 id="getent-group查看所有用户组">getent group（查看所有用户组）</h4><p><code>getent</code> 源自 <strong>get entries</strong>（entry:条目）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent group<br></code></pre></td></tr></table></figure><h4 id="groupadd创建用户组">groupadd（创建用户组）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> 组名<br></code></pre></td></tr></table></figure><h4 id="groupdel删除用户组">groupdel（删除用户组）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupdel 组名<br></code></pre></td></tr></table></figure><h3 id="用户管理">4.1.2 用户管理</h3><h4 id="getent-passwd查看所有用户">getent passwd（查看所有用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent passwd<br></code></pre></td></tr></table></figure><h4 id="useradd创建用户">useradd（创建用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd [-g 组名] 用户名<br>-g   # group，指定用户所在组。不写会创建和用户名一模一样的组名，并添加用户到该组中<br></code></pre></td></tr></table></figure><h4 id="userdel删除用户">userdel（删除用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel [-r] 用户名<br>-r   # remove，删除用户的同时，把 /home 目录下该用户的目录也删除<br></code></pre></td></tr></table></figure><h4 id="usermod修改用户属性">usermod（修改用户属性）</h4><p><code>usermod</code> 源自 <strong>user modify</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -aG 组名 用户名<br>-aG    # append group，追加用户到附加组<br></code></pre></td></tr></table></figure><h4 id="id查看用户">id（查看用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id [用户名]    # 不指定用户名会查看自身<br></code></pre></td></tr></table></figure><h4 id="passwd修改用户密码">passwd（修改用户密码）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">passwd</span> 用户名<br></code></pre></td></tr></table></figure><h3 id="切换用户及借调权限">4.1.3 切换用户及借调权限</h3><h4 id="su切换用户">su（切换用户）</h4><p><code>su</code> 源自 <strong>swithuser</strong>，用于<strong>切换用户</strong>。</p><ul><li>使用普通用户，切换到其它用户需要输入密码，如切换到 root 用户</li><li>使用 root 用户切换到其它用户，无需密码，可以直接切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su [用户名]      # 省略用户名表示切换到 root<br></code></pre></td></tr></table></figure><blockquote><p>切换用户后，可以通过 <code>exit</code>命令退回上一个用户，也可以使用快捷键：<code>Ctrl</code> +<code>D</code>。</p></blockquote><h4 id="sudo借调权限">sudo（借调权限）</h4><p><code>sudo</code> 源自 <strong>superuserdo</strong>，临时借调权限，为普通的命令授权，<strong>临时以 root身份执行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo 要执行的命令<br></code></pre></td></tr></table></figure><blockquote><p>权限记录在 etc 目录下的 sudoers 文件中，root 用户可以通过 visudo命令修改。如果没有权限, 则会记录该行为到日志。</p></blockquote><h2 id="查看权限信息">4.2 查看权限信息</h2><p>使用 <code>ll</code> 显示如下信息结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件类型和权限 硬链接数 所有者  所属组  文件大小  最后修改时间   文件名/目录名<br>-rw-r--r--       1     user   group   1234    Jul 29 10:00  file.txt<br>drwxr-xr-x       2     user   group   4096    Jul 28 15:32  my_folder<br></code></pre></td></tr></table></figure><ol type="1"><li>第 1 个字符：文件类型<ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录，源自 directory</li><li><code>l</code> 软链接，源自 link</li></ul></li><li>第 2-10 个字符：权限（所有者、所属组、其他用户）<ul><li><code>r</code> 读，源自 read</li><li><code>w</code> 写，源自 write</li><li><code>x</code> 执行，源自 execute</li><li><code>-</code> 无</li></ul></li></ol><p><img src="Pasted%20image%2020250729230728.png" /></p><blockquote><p><strong>注意：</strong>文件/目录的所有者和所属组是两个独立的属性，所有者并不是一定要在所属组内。</p></blockquote><h2 id="修改权限信息">4.3 修改权限信息</h2><h3 id="chmod修改文件权限">4.3.1 chmod（修改文件权限）</h3><p><code>chmod</code> 源自 <strong>changemode</strong>，用于修改文件或目录的<strong>访问权限</strong>，即读（r）、写（w）、执行（x）权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [-R] [权限设置] 文件/目录<br>-R 递归修改目录及其内容权限<br></code></pre></td></tr></table></figure><ul><li>符号模式（ugo+rwx）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x 1.txt  # 所有者:rwx, 所属组:r-x, 其它用户: --x<br>chmod -x 1.txt                # 所有者, 所属组, 其它权限都去掉 x 权限<br>chmod u+x,g-r,o=rw 1.txt    # 所有者 +x 权限, 所属组 -r 权限, 其它权限为: rw-<br></code></pre></td></tr></table></figure><ul><li>数字模式（八进制）</li></ul><table><thead><tr><th style="text-align: center;">数字</th><th style="text-align: center;">权限</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr><td style="text-align: center;">4</td><td style="text-align: center;"><code>r</code></td><td style="text-align: center;">读</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;"><code>w</code></td><td style="text-align: center;">写</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;"><code>x</code></td><td style="text-align: center;">执行</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;"><code>-</code></td><td style="text-align: center;">无权限</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">三类用户（所有者 / 组 / 其他用户）分别对应一个数字，组合成三位数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7 = 4 (r) + 2 (w) + 1 (x) = rwx</span><br>chmod 764 file.txt  # 所有者：rwx，组：rw-，其他：r--<br>chmod 777 1.txt        # 俗称: 满权限.<br></code></pre></td></tr></table></figure><h3 id="chown修改文件归属">4.3.2 chown（修改文件归属）</h3><p><code>chown</code>源自 <strong>changeowner</strong>，用于修改文件或目录的<strong>所有者</strong>和<strong>所属用户组</strong>。</p><p>普通用户无法修改所属为其它用户或组，所以此命令只适用于 root用户执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown [-R] [用户] [:用户组] 文件/目录<br>-R 递归修改目录及其内容所属<br><br>chown zhangsan 1.txt   # 改变文件所有者<br>chown :python  1.txt   # 改变文件所属组<br>chown lisi:dev 1.txt   # 改变所有者和组<br>chown -R wangwu aa     # 改变所有者，包括目录子级<br></code></pre></td></tr></table></figure><h1 id="linux-实用操作">5 Linux 实用操作</h1><h2 id="常用快捷键">5.1 常用快捷键</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Ctrl + C      # 强制结束（执行）<br>Ctrl + L      # 清屏，等价于 clear<br>Ctrl + D      # 强制登出账号，回到上一个账号，等价于 exit<br><br>Ctrl + A      # 跳转到命令 行首<br>Ctrl + E      # 跳转到命令 行尾<br>Ctrl + ←      # 上一个单词<br>Ctrl + →      # 下一个单词<br><br>history       # 查看历史命令<br>!命令名          # 在历史命令中匹配最近的命令<br>Ctrl + r      # 在历史命令中搜索命令<br></code></pre></td></tr></table></figure><h2 id="软件安装与服务管理">5.2 软件安装与服务管理</h2><h3 id="yum软件包管理">5.2.1 yum（软件包管理）</h3><p><code>yum</code> 是 Yellowdog Updater, Modified 的缩写，基于 rpm (RedHat Package Manager) 的高级封装，自动解决依赖 + 仓库管理。类似于 windows或 mac 的<strong>应用商店</strong>，直接从中查找并安装。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>安装软件</strong></td><td><code>yum install package</code></td><td>安装指定软件包及其依赖</td></tr><tr><td><strong>更新软件</strong></td><td><code>yum update package</code></td><td>更新指定软件包（不指定则更新所有）</td></tr><tr><td><strong>卸载软件</strong></td><td><code>yum remove package</code></td><td>删除软件包（保留配置文件）</td></tr><tr><td><strong>搜索软件</strong></td><td><code>yum search keyword</code></td><td>根据关键词搜索软件包</td></tr><tr><td><strong>列出已安装</strong></td><td><code>yum list installed</code></td><td>显示所有已安装的软件包</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum [-y] [install | update | remove | search] 包名<br>-y     # yes，在安装过程中自动回答 yes<br><br>yum -y install wget   # 通过 yum 安装 wget<br></code></pre></td></tr></table></figure><blockquote><p>Debian/Ubuntu 系统中使用 <code>apt</code> 包管理工具，和<code>yum</code> 格式一样，更改为 <code>apt</code> 即可。</p></blockquote><h3 id="systemctl服务管理">5.2.2 systemctl（服务管理）</h3><p><code>systemctl</code> 源自 <strong>system control</strong>，是 Linux系统中用于<strong>管理 systemd 系统和服务管理器</strong>的核心工具。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>启动服务</strong></td><td><code>systemctl start nginx</code></td><td>启动服务</td></tr><tr><td><strong>停止服务</strong></td><td><code>systemctl stop nginx</code></td><td>停止服务</td></tr><tr><td><strong>重启服务</strong></td><td><code>systemctl restart nginx</code></td><td>重启服务</td></tr><tr><td><strong>查看状态</strong></td><td><code>systemctl status nginx</code></td><td>显示服务运行状态和日志片段</td></tr><tr><td><strong>启用开机自启</strong></td><td><code>systemctl enable nginx</code></td><td>设置服务开机自启动</td></tr><tr><td><strong>禁用开机自启</strong></td><td><code>systemctl disable nginx</code></td><td>取消服务开机自启动</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status | enable | disable] 服务名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用服务</span><br>NetworkManager       # 主网络服务<br>network               # 副网络服务<br>firewalld           # 防火墙<br>sshd               # 远程连接服务<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关掉防火墙并取消开机自启动</span><br>systemctl stop firewalld<br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><h2 id="网络操作">5.3 网络操作</h2><h3 id="诊断工具">5.3.1 诊断工具</h3><h4 id="ifconfigip配置">ifconfig（ip配置）</h4><p><code>ifconfig</code> 源自 <strong>interfaceconfiguration</strong>，用于<strong>查看和配置网络接口</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h4 id="ping连通性测试">ping（连通性测试）</h4><p><code>ping</code> 源自 <strong>Packet InterNet Groper</strong> ，发送ICMP 请求包，<strong>测试网络是否通畅及延迟</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping [-c Num] 域名 | ip<br>-c Num    # count，发送 N 次请求后停止<br><br>ping -c 3 baidu.com   # 向百度发送 3 次请求测试连通性<br></code></pre></td></tr></table></figure><h4 id="netstat端口监听">netstat（端口监听）</h4><p><code>netstat</code> 源自 <strong>networkstatistics</strong>，用于<strong>查看网络连接、监听端口、路由信息</strong>。</p><ul><li>IP地址，设备在网络中的唯一标识</li><li>端口号，程序在设备上的唯一标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp   # 查看本机所有端口号<br>-anp           # 来源: all network port<br><br>netstat -anp | grep 3306    # 使用 grep 过滤查看 3306 端口号占用情况<br></code></pre></td></tr></table></figure><blockquote><p>计算机程序之间的通讯，通过 IP只能确定计算机，但是无法确定具体的程序。通过端口可以确定计算机上具体的程序，确保程序之间进行沟通。Linux 系统端口号范围: 0 ~ 65535，其中0 ~1023已经被用作系统端口或者保留端口了。</p></blockquote><h3 id="数据传输">5.3.2 数据传输</h3><h4 id="wget下载文件">wget（下载文件）</h4><p><code>wget</code> 源自 <strong>webget</strong>，用于<strong>从网络上下载文件</strong>，支持HTTP、HTTPS、FTP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget url地址<br><br>wget https://img-home.csdnimg.cn/images/20201124032511.png   # 下载图片<br></code></pre></td></tr></table></figure><h4 id="curl发送请求">curl（发送请求）</h4><p><code>curl</code> 源自 <strong>clientURL</strong>，用于<strong>模拟浏览器发送请求</strong>，常用于测试API、下载网页内容等，支持多种协议（HTTP、FTP、SFTP、SMTP）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl url地址<br><br>curl https://www.bilibili.com/    # 爬取哔哩哔哩网页代码<br></code></pre></td></tr></table></figure><h4 id="lrzsz上传和下载">lrzsz（上传和下载）</h4><p><code>lrzsz</code> 源自 <strong>Linux Receive ZMODEM SendZMODEM</strong>，也就是 Linux ZMODEM收发工具，用于在终端环境中<strong>上传（<code>rz</code>）或下载（<code>sz</code>）文件</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rz           # 弹出文件选择窗口，选择文件后自动上传到当前目录<br>sz 文件名      # 弹出保存对话框，选择保存路径即可<br></code></pre></td></tr></table></figure><p>或者在 FinalShell、Tabby 等工具中直接拖拽即可上传下载。</p><p><img src="Pasted%20image%2020250730224752.png" /></p><h2 id="进程管理">5.4 进程管理</h2><p>程序运行在操作系统中，是被操作系统所管理的。为方便管理运行的程序，每一个程序在运行的时候都会被操作系统注册为系统中的一个<strong>进程</strong>，并会为每一个进程都分配一个独有的PID。</p><h3 id="ps查看进程">5.4.1 ps（查看进程）</h3><p><code>ps</code> 源自 <strong>processstatus</strong>，用于显示当前系统的<strong>进程状态信息</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps [-e -f]<br>-e       # every，列出所有进程<br>-f       # full format，显示完整格式<br><br>ps -ef                # 查看本机运行的所有进程<br>ps -ef | grep mysql      # 查看本机和MySQL相关的进程.<br></code></pre></td></tr></table></figure><h3 id="kill结束进程">5.4.2 kill（结束进程）</h3><p>向进程发送信号（默认 <code>SIGTERM</code>），用于<strong>终止或控制进程</strong>。</p><table><thead><tr><th>信号编号</th><th>信号名</th><th>作用</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>SIGHUP</code></td><td>重启进程（重新加载配置）</td></tr><tr><td><code>2</code></td><td><code>SIGINT</code></td><td>中断进程（等同 <code>Ctrl+C</code>）</td></tr><tr><td><code>9</code></td><td><code>SIGKILL</code></td><td>强制终止（不可被忽略）</td></tr><tr><td><code>15</code></td><td><code>SIGTERM</code></td><td>优雅终止（默认信号）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill [-编号] PID<br><br>kill -9 进程的 PID    # 强制杀死进程，不使用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制。<br></code></pre></td></tr></table></figure><h2 id="软链接和硬链接">5.5 软链接和硬链接</h2><p><code>ln</code> 源自<strong>link</strong>，用于<strong>文件共享</strong>。</p><ul><li>软链接：是一个独立的文件，内容为源文件的路径</li><li>硬链接：是文件系统的目录项，直接指向源文件的 inode</li></ul><table><thead><tr><th><strong>特性</strong></th><th>软链接（Symbolic Link）</th><th>硬链接（Hard Link）</th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>类似 Windows 的快捷方式</td><td>是原始文件的另一个名称（指向相同 inode）</td></tr><tr><td><strong>inode 号</strong></td><td>与源文件不同（新 inode）</td><td>与源文件相同（共享 inode）</td></tr><tr><td><strong>源文件删除</strong></td><td>软链接失效（“断链”）</td><td>硬链接仍有效（数据未删除）</td></tr><tr><td><strong>文件大小</strong></td><td>存储链接路径的字节数（较小）</td><td>不额外占用空间（与源文件共享数据块）</td></tr><tr><td><strong>命令</strong></td><td><code>ln -s 源文件 链接名</code></td><td><code>ln 源文件 链接名</code></td></tr></tbody></table><ul><li>软链接：若源文件被删除，软链接变成“悬空链接”（无法访问）</li><li>硬链接：删除源文件后，硬链接仍能访问数据（直到所有硬链接被删除）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">软链接，类似于 windows 的快捷方式</span><br>ln -s 要链接文件/目录的路径 软链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 ipcfg 配置文件创建软链接 ip</span> <br>ln -s /etc/sysconfig/network-scripts/ifcfg-ens33 ip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">硬链接，原始文件的别名，有点类似 C++ 的引用</span><br>ln 要链接文件的路径 硬链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 a.txt 的硬链接 b.txt</span><br>ln a.txt b.txt<br></code></pre></td></tr></table></figure><blockquote><p><strong>inode</strong>（Index Node）是 Linux/Unix文件系统中的一种<strong>元数据结构</strong>，用于存储文件的<strong>核心属性</strong>（如权限、大小、所有者、数据块位置等），但不包含文件名。每个文件或目录都有一个唯一的inode，通过 inode 号标识。</p></blockquote><h2 id="压缩与解压缩">5.6 压缩与解压缩</h2><p>区分压缩协议好坏, 可以参考三个维度:压缩速度(写)，解压速度(读)，压缩后文件占比。</p><h3 id="tar">5.6.1 tar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [-c -x -f -v -z] 目标文件 源文件或目录<br>-c       # create，创建新的归档文件（打包）<br>-x       # extract，解压归档文件<br>-f       # file，指定归档文件名（必须直接跟文件名，如 -f archive.tar）<br>-v       # verbose，显示操作过程的详细信息<br>-z       # gzip，使用 gzip 压缩/解压（生成 .tar.gz 或 .tgz 文件），文件更小<br>-C       # directory，指定解压到的目录（需放在选项最后）<br></code></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf 压缩包名.tar 要被压缩的文件1 文件2 文件夹        # 打包文件不压缩<br>tar -zcvf 压缩包名.tar.gz 要被压缩的文件1 文件2 文件夹    # 打包并用 gzip 压缩<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不指定 -C 默认解压到当前路径</span><br>tar -xvf 压缩包名.tar [-C 解压路径]      # 解压 tar 压缩包<br>tar -zxvf 压缩包名.tar.gz [-C 解压路径]  # 解压 tar.gz 压缩包<br></code></pre></td></tr></table></figure><h3 id="zip">5.6.2 zip</h3><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip [-r] 压缩包名.zip 要被压缩的文件1 文件2 文件夹<br>-r    # 被压缩的包含文件夹的时候，需要使用-r选项<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip 压缩包名.zip [-d 解压路径]<br>-d    # 不指定 -d 默认解压到当前路径<br></code></pre></td></tr></table></figure><h1 id="远程连接虚拟机">6 远程连接虚拟机</h1><ul><li>vim 编辑 /etc/sysconfig/network-scripts/ifcfg-ens33 文件</li></ul><p><img src="Pasted%20image%2020250731141856.png" /></p><ul><li>修改 VMware 的信息</li></ul><p><img src="1717040397072.png" /></p><ul><li>修改本机 VMNet8 网卡信息</li></ul><p><img src="1717041247890.png" /></p><ul><li>FinalShell 新建连接</li></ul><p><img src="1717041411950.png" /></p><p>另外要确保 <code>services.msc</code> 中 Vmware 的 DHCP 和 NAT服务在启动状态。</p><p><img src="Pasted%20image%2020250731142125.png" /></p>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13_Python数据结构与算法</title>
    <link href="/2024/05/24/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/24/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>鉴于C++章节已做详细说明，本节只做记录，不做详细讲解。</p><h1 id="数据结构">1 数据结构</h1><h2 id="栈">1.1 栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈顶-&gt; &#x27;</span> + <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items[::-<span class="hljs-number">1</span>]))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断栈是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入栈&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 top 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    st = Stack()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取栈顶&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、返回栈的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、遍历栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入栈的元素：&#x27;</span>).strip()<br>                    st.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取栈顶</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.top()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈顶元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> st.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 返回栈的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(st)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 遍历栈</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="队列">1.2 队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队列为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队首-&gt; &#x27;</span> + <span class="hljs-string">&#x27;-&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items)) + <span class="hljs-string">&#x27; &lt;-队尾&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断队列是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入队&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出队&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">front</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队首元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 front 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 rear 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取队首&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、取队尾&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、返回队列的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、遍历队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入队列的元素：&#x27;</span>).strip()<br>                    q.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取队首</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.front()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队首元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 取队尾</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.rear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队尾元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> q.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 返回队列的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队列中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(q)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 遍历队列</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="单链表">1.3 单链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        elem = [data <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>]  <span class="hljs-comment"># 借助 迭代器 使用 列表推导式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, elem)) + <span class="hljs-string">&#x27;-&gt;None&#x27;</span> <span class="hljs-keyword">if</span> elem <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;空链表&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">yield</span> current.data<br>            current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            <span class="hljs-variable language_">self</span>.tail.<span class="hljs-built_in">next</span> = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prepend</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            new_node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-variable language_">self</span>.head = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, data, pos</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        向链表指定下标插入元素</span><br><span class="hljs-string">        :param data: 要插入的元素值</span><br><span class="hljs-string">        :param pos: 要插入的下标，从0开始</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 处理越界问题</span><br>        <span class="hljs-keyword">if</span> pos &gt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>) <span class="hljs-keyword">or</span> pos &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;索引超出界限！&#x27;</span>)<br><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 处理插入头结点和空链表插入的特殊情况</span><br>        <span class="hljs-keyword">if</span> pos == <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.prepend(data)<br>        <span class="hljs-comment"># 其他情况</span><br>        <span class="hljs-keyword">else</span>:<br>            current = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-comment"># 遍历到要插入位置的前一个节点</span><br>            <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos - <span class="hljs-number">1</span>):<br>                current = current.<span class="hljs-built_in">next</span><br><br>            new_node.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span> = new_node<br><br>            <span class="hljs-comment"># 如果插入到了尾节点，维护tail</span><br>            <span class="hljs-keyword">if</span> new_node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        删除链表中值为data的指定数量的节点</span><br><span class="hljs-string">        :param data: 要删除的值</span><br><span class="hljs-string">        :param num: 要删除的数量，1为默认，0表示删除所有</span><br><span class="hljs-string">        :return: 返回删除成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 1、处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法删除！&#x27;</span>)<br><br>        <span class="hljs-comment"># 已删节点数</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 2、处理头结点为目标值的情况</span><br>        <span class="hljs-comment"># 有头结点 且 头结点数据=要删除的数据 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.head.data == data <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-variable language_">self</span>.head = <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span><br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 更新链表长度</span><br>            <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 3、链表被删除为空，更新尾节点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 4、处理后续节点为目标值的情况</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空 且 有下一个节点 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>.data == data:<br>                <span class="hljs-comment"># 删除下一个节点，导致当前节点的下一个节点已经改变</span><br>                current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 更新链表长度</span><br>                <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>                <span class="hljs-comment"># 如果删除了尾结点，需要更新当前节点为尾结点</span><br>                <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-variable language_">self</span>.tail = current<br>            <span class="hljs-comment"># 只有没删除节点时才移动</span><br>            <span class="hljs-keyword">else</span>:<br>                current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replace</span>(<span class="hljs-params">self, data, new_data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        修改并替换链表中的指定值为新值</span><br><span class="hljs-string">        :param data: 要修改的值</span><br><span class="hljs-string">        :param new_data: 修改后的新值</span><br><span class="hljs-string">        :param num: 修改num个，1为默认，0表示替换所有</span><br><span class="hljs-string">        :return: 返回修改成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法修改！&#x27;</span>)<br><br>        cnt = <span class="hljs-number">0</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空  且 （要替换所有 或 已替换数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                current.data = new_data<br>                cnt += <span class="hljs-number">1</span><br>            current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data, <span class="hljs-built_in">all</span>=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        查找链表指定元素的位置</span><br><span class="hljs-string">        :param data: 要查找的元素</span><br><span class="hljs-string">        :param all: 是否要查询所有符合条件的下标，True表示查询所有，False只查询一个，默认为False</span><br><span class="hljs-string">        :return: 返回下标位置，没找到抛出ValueError错误</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        idx = <span class="hljs-number">0</span><br>        idxes = []<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                <span class="hljs-comment"># 查找全部符合条件的下标</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>:<br>                    idxes.append(idx)<br>                <span class="hljs-comment"># 只查一个下标</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> idx<br>            current = current.<span class="hljs-built_in">next</span><br>            idx += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> idxes:<br>            <span class="hljs-keyword">return</span> idxes<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断链表是否为空</span><br><span class="hljs-string">        :return: 为空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;清空当前链表&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ls = LinkedList()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、链表尾部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、链表头部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、指定下标插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、删除链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、修改链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、显示链表长度&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、显示所有元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、查询链表是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;10、清空链表&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 链表尾部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.append(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 链表头部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.prepend(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 指定下标插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x, pos = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值和下标（从0开始）：&#x27;</span>).strip().split()<br>                    ls.insert(x, <span class="hljs-built_in">int</span>(pos))<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 删除链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要删除的元素值 [可选：删除个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">1</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功删除<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 修改链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要替换的元素值和替换后的新值 [可选：替换个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">3</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">2</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功将<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点替换为<span class="hljs-subst">&#123;elems[<span class="hljs-number">1</span>]&#125;</span>，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找链表元素</span><br>                elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素 [可选：是否查询所有]：&#x27;</span>).strip().split()<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>], <span class="hljs-literal">True</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功！该元素下标为<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 显示链表长度</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;链表长度为：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ls)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 显示所有元素</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 查询链表是否为空</span><br>                <span class="hljs-keyword">if</span> ls.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;10&#x27;</span>:  <span class="hljs-comment"># 清空链表</span><br>                <span class="hljs-keyword">try</span>:<br>                    ls.clear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;链表清空成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="二叉树">1.4 二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-comment"># 闭包捕获异常</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exception</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.right = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Node(<span class="hljs-subst">&#123;self.val&#125;</span>)&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Node(val=<span class="hljs-subst">&#123;self.val&#125;</span>, left=<span class="hljs-subst">&#123;self.left.val <span class="hljs-keyword">if</span> self.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>, right=<span class="hljs-subst">&#123;self.right.val <span class="hljs-keyword">if</span> self.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>)&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        向二叉树插入新元素，以逐层遍历的方式找到第一个出现的叶子结点插入</span><br><span class="hljs-string">        只用此方法构建二叉树，会构建出完全二叉树</span><br><span class="hljs-string">        :param data: 要插入的值</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 空树特殊处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.root = new_node<br>            <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 用队列实现逐层遍历，先将根节点入队</span><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])  <span class="hljs-comment"># 借助双端队列实现</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 取出队首元素</span><br>            node = queue.popleft()  <span class="hljs-comment"># O(1)时间完成</span><br><br>            <span class="hljs-comment"># 左子树非空，则将左子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-comment"># 左子树为空，将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.left = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-comment"># 右子树非空，则将右子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>            <span class="hljs-comment"># 右子树为空，则将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.right = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;广度优先搜索，逐层遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        res = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 取出当前节点</span><br>            node = queue.popleft()<br>            res.append(node.val)<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__preorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__preorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;私有方法，执行递归逻辑。先序遍历，根左右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 遍历结果放入列表</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__inorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__inorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;中序遍历，左根右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.left, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__postorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__postorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.right, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在二叉树查找指定元素</span><br><span class="hljs-string">        :param data: 待查找的元素</span><br><span class="hljs-string">        :return: 返回该元素所在节点</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            node = queue.popleft()<br><br>            <span class="hljs-comment"># 查找到目标元素，返回该节点</span><br>            <span class="hljs-keyword">if</span> node.val == data:<br>                <span class="hljs-keyword">return</span> node<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;找不到该元素！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    bt = BinaryTree()<br>    bt.add(<span class="hljs-string">&#x27;10&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;15&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;20&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;30&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;45&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;65&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、二叉树添加节点&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、逐层遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、先序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、中序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、后序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、返回节点数&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、树是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、清空树&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 二叉树添加节点</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>).strip()<br>                flag = bt.add(x)<br>                <span class="hljs-keyword">if</span> flag:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;插入成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 逐层遍历</span><br>                ls = bt.bfs()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;逐层遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 先序遍历</span><br>                ls = bt.preorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;先序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 中序遍历</span><br>                ls = bt.inorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 后序遍历</span><br>                ls = bt.postorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;后序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找元素</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素值：&#x27;</span>).strip()<br>                addr = bt.find(x)<br>                <span class="hljs-keyword">if</span> addr:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功，该元素所在节点为：<span class="hljs-subst">&#123;addr&#125;</span>&#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;左孩子值为：<span class="hljs-subst">&#123;addr.left.val <span class="hljs-keyword">if</span> addr.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>  右孩子值为：<span class="hljs-subst">&#123;addr.right.val <span class="hljs-keyword">if</span> addr.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 返回节点数</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前节点数：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(bt)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 树是否为空</span><br>                <span class="hljs-keyword">if</span> bt.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树为空&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树非空&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 清空树</span><br>                bt.clear()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树已清空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.lower() == <span class="hljs-string">&#x27;y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h1 id="排序">2 排序</h1><h2 id="冒泡排序">2.1 冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>        swaped = <span class="hljs-literal">False</span>  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - i - <span class="hljs-number">1</span>):  <br>            <span class="hljs-keyword">if</span> ls[j] &gt; ls[j + <span class="hljs-number">1</span>]:  <br>                ls[j], ls[j + <span class="hljs-number">1</span>] = ls[j + <span class="hljs-number">1</span>], ls[j]  <br>                swaped = <span class="hljs-literal">True</span>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> swaped:  <br>            <span class="hljs-keyword">break</span>  <br></code></pre></td></tr></table></figure><h2 id="选择排序">2.2 选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):  <br>        idx = i  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):  <br>            <span class="hljs-keyword">if</span> ls[j] &lt; ls[idx]:  <br>                idx = j  <br>        ls[idx], ls[i] = ls[i], ls[idx]  <br></code></pre></td></tr></table></figure><h2 id="插入排序">2.3 插入排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):  <br>        x = ls[i]  <br>        j = i - <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x &lt; ls[j]:  <br>            ls[j + <span class="hljs-number">1</span>] = ls[j]  <br>            j -= <span class="hljs-number">1</span>  <br>        ls[j + <span class="hljs-number">1</span>] = x  <br></code></pre></td></tr></table></figure><h2 id="桶排序">2.4 桶排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bucket_sort</span>(<span class="hljs-params">n</span>):  <br>    bucket = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)]  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:  <br>        bucket[i] += <span class="hljs-number">1</span>  <br>  <br>    ls.clear()  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        <span class="hljs-keyword">if</span> bucket[i] != <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bucket[i]):  <br>                ls.append(i)  <br></code></pre></td></tr></table></figure><h2 id="快速排序">2.5 快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    i = l - <span class="hljs-number">1</span>  <br>    j = r + <span class="hljs-number">1</span>  <br>    pivot = ls[l + r &gt;&gt; <span class="hljs-number">1</span>]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt; j:  <br>        i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[i] &lt; pivot:  <br>            i += <span class="hljs-number">1</span>  <br>        j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[j] &gt; pivot:  <br>            j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">if</span> i &lt; j:  <br>            ls[i], ls[j] = ls[j], ls[i]  <br>  <br>    quick_sort(l, j)  <br>    quick_sort(j + <span class="hljs-number">1</span>, r)  <br></code></pre></td></tr></table></figure><h2 id="归并排序">2.6 归并排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>  <br>    merge_sort(l, mid)  <br>    merge_sort(mid + <span class="hljs-number">1</span>, r)  <br>  <br>    k = l  <br>    i = l  <br>    j = mid + <span class="hljs-number">1</span>  <br>    tmp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= r:  <br>        <span class="hljs-keyword">if</span> ls[i] &lt;= ls[j]:  <br>            tmp[k] = ls[i]  <br>            k += <span class="hljs-number">1</span>  <br>            i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">else</span>:  <br>            tmp[k] = ls[j]  <br>            k += <span class="hljs-number">1</span>  <br>            j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid:  <br>        tmp[k] = ls[i]  <br>        k += <span class="hljs-number">1</span>  <br>        i += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">while</span> j &lt;= r:  <br>        tmp[k] = ls[j]  <br>        k += <span class="hljs-number">1</span>  <br>        j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):  <br>        ls[i] = tmp[i]  <br></code></pre></td></tr></table></figure><h1 id="二分查找">3 二分查找</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]  <br><span class="hljs-built_in">print</span>(ls)  <br>x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;要查找的元素：&#x27;</span>))  <br>  <br>l, r = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ls)  <br><span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">if</span> ls[mid] &lt; x:  <br>        l = mid  <br>    <span class="hljs-keyword">else</span>:  <br>        r = mid  <br>  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一次出现<span class="hljs-subst">&#123;x&#125;</span>的下标为<span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12_Python面向对象高级</title>
    <link href="/2024/05/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2024/05/22/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="slots__限制属性">1 <code>__slots__</code>限制属性</h1><p>Python可以通过<code>对象.属性</code>的方式很方便的添加属性值，但是这种方式太自由了，Python可以定义一个特殊的变量<code>__slots__</code>来限制类的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;__age&#x27;</span>)  <br>    <span class="hljs-comment"># __slots__ = [&#x27;name&#x27;, &#x27;__age&#x27;]  这样也可以</span><br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br>    p1.age = <span class="hljs-number">20</span>  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br><br>    <span class="hljs-comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;gender&#x27;</span><br>    p1.gender = <span class="hljs-string">&#x27;男&#x27;</span><br></code></pre></td></tr></table></figure><p><code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的 <code>__slots__</code>。</p><h1 id="property方法当属性">2 <span class="citation"data-cites="property方法当属性">@property方法当属性</span></h1><p>如果直接把属性暴露出去，可以直接修改属性，但是没办法对值的合法性进行检验，所以可以将属性设为私有属性，然后通过<code>getter</code>方法和<code>setter</code>方法进行私有属性的获取和设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())  <br>    p1.set_age(<span class="hljs-number">20</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())<br></code></pre></td></tr></table></figure><p>但是调用方法终归是略显复杂，没有直接使用属性简单，作为追求简单的Python语言，内置的<code>property</code>可以将方法当做属性使用，常用于<code>getter</code>方法和<code>setter</code>方法。<strong>既能检查参数，又可以用类似属性的简单方式来访问类的变量</strong>。</p><h2 id="装饰器方法">2.1 装饰器方法</h2><ul><li><code>@property</code>修饰获取值的方法</li><li><code>获取值方法名.setter</code>修饰设置值的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br><span class="hljs-meta">    @property  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br><span class="hljs-meta">    @age.setter  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><blockquote><p>通过 <code>@property</code> 装饰器，创建了一个名为 <code>age</code>的“公共接口”或“属性”。这个属性在外部看起来就像一个普通属性，可以用<code>p1.age</code> 来访问它，但实际上，这个访问背后调用的是<code>age()</code> 方法，而赋值时调用的则是 <code>age()</code> 方法下的<code>age.setter</code>。</p></blockquote><h2 id="类属性方法">2.2 类属性方法</h2><p><code>属性名 = property(获取值方法名, 设置值方法名)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><h1 id="枚举类">3 枚举类</h1><p>枚举类就是一种实例有限且固定的特殊类，当需要定义一组命名常量时，可以选择枚举类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum  <br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Week</span>(<span class="hljs-title class_ inherited__">Enum</span>):  <br>    Mon = <span class="hljs-number">1</span>  <br>    Tue = <span class="hljs-number">2</span>  <br>    Wed = <span class="hljs-number">3</span>  <br>    Thu = <span class="hljs-number">4</span>  <br>    Fri = <span class="hljs-number">5</span>  <br>    Sat = <span class="hljs-number">6</span>  <br>    Sun = <span class="hljs-number">7</span>  <br>  <br><br><span class="hljs-comment"># 枚举类可以迭代</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> Week:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;item&#125;</span>---<span class="hljs-subst">&#123;item.name&#125;</span>的值为：<span class="hljs-subst">&#123;item.value&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Week.Mon---Mon的值为：1</span><br><span class="hljs-string">Week.Tue---Tue的值为：2</span><br><span class="hljs-string">Week.Wed---Wed的值为：3</span><br><span class="hljs-string">Week.Thu---Thu的值为：4</span><br><span class="hljs-string">Week.Fri---Fri的值为：5</span><br><span class="hljs-string">Week.Sat---Sat的值为：6</span><br><span class="hljs-string">Week.Sun---Sun的值为：7</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 直接访问枚举成员</span><br><span class="hljs-built_in">print</span>(Week.Mon)  <span class="hljs-comment"># Week.Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.name)  <span class="hljs-comment"># Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.value) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>枚举类正常情况下允许成员有重复值，如果使用<code>@unique</code>可以控制枚举成员不能有重复值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<br><br><br><span class="hljs-meta">@unique</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    RED = <span class="hljs-number">1</span><br>    GREEN = <span class="hljs-number">2</span><br>    BLUE = <span class="hljs-number">3</span><br>    CRIMSON = <span class="hljs-number">1</span> <span class="hljs-comment"># 这里的重复会引发 ValueError</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11_Python网络编程</title>
    <link href="/2024/05/21/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/21/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络协议">1 网络协议</h1><p><ahref="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰互联网协议入门（一）</a> 自下而上讲解互联网如何构成 <ahref="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">阮一峰互联网协议入门（二）</a> 自上而下讲解互联网如何应用</p><h1 id="编解码">2 编解码</h1><p>从网络或磁盘上读取字节流，读到的数据是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法，如果想要将<code>str</code>转为<code>bytes</code>，就需要使用<code>encode()</code>方法。</p><ul><li><code>s.encode(码表)</code>编码，默认码表为 UTF-8</li><li><code>s.decode(码表)</code>解码，默认码表为 UTF-8</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;文件编码&#x27;</span>  <br>bs = s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <br><br><span class="hljs-comment"># b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span><br><span class="hljs-built_in">print</span>(bs)<br><br><span class="hljs-comment"># 文件编码</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span>.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>有一种特殊的编码方式，对于ASCII码表中的字符，可以使用<code>b''</code>包围字符串进行编码，但是注意不能对中文进行编码。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">b&#x27;hello python&#x27;</span>))<br></code></pre></td></tr></table></figure></p><h1 id="网络编程-收发一句话">3 网络编程-收发一句话</h1><p><img src="11_socket.png" /></p><p><strong>只要确定主机和端口，我们就能实现程序之间的交流。</strong>因此，Unix系统就把主机+端口，叫做”套接字”（<code>socket</code>）。有了它，就可以进行网络应用程序开发了。</p><p>TCP服务器端： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br><span class="hljs-comment"># family：地址族，默认AF_INET（IPV4）  AF_INET6(IPV6)</span><br><span class="hljs-comment"># type：socket类型，默认SOCK_STREAM（TCP） SOCK_DGRAM(UDP)</span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号，注意参数必须为元组</span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制</span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息，阻塞到客户连接</span><br>sock, client = serve_socket.accept()  <br><br><span class="hljs-comment"># 5、编码并发送数据</span><br>sock.send(<span class="hljs-string">&#x27;你好我是服务器，欢迎来到socket&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 6、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = sock.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;服务器端收到来自：<span class="hljs-subst">&#123;client&#125;</span>的消息：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 7、释放资源，关闭当前连接，一般服务器不需要关闭</span><br>sock.close()<br></code></pre></td></tr></table></figure></p><p>TCP客户端： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器的ip和端口号</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = client_socket.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;客户端收到：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 4、编码并发送数据 </span><br>client_socket.send(<span class="hljs-string">&#x27;我是客户端&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 5、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure></p><h1 id="网络编程-收发文件">4 网络编程-收发文件</h1><p>TCP服务器端： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号  </span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制  </span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息  </span><br>sock, client = serve_socket.accept()  <br>  <br><span class="hljs-comment"># 5、使用二进制写，接收数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rev_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <br>        data = sock.recv(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>        <br>        f.write(data)  <span class="hljs-comment"># 将接收数据写入本地文件</span><br>  <br><span class="hljs-comment"># 6、释放资源  </span><br>sock.close()<br></code></pre></td></tr></table></figure></p><p>TCP客户端： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器ip和端口号  </span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、使用二进制读，发送数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;send_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <br>        data = f.read(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>       <br>        client_socket.send(data)  <span class="hljs-comment"># 将本地文件发送出去</span><br>  <br><span class="hljs-comment"># 4、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_Python正则表达式</title>
    <link href="/2024/05/19/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/05/19/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="匹配规则">1 匹配规则</h1><h2 id="普通字符">1. 普通字符</h2><p>大多数字符（字母、数字、汉字）就是普通字符，它们匹配自己。</p><ul><li><code>abc</code> 匹配字符串中的 <code>"abc"</code></li><li><code>你好</code> 匹配字符串中的 <code>"你好"</code></li></ul><h2 id="元字符">2. 元字符</h2><ul><li><strong><code>.</code> (点号)</strong>：匹配<strong>任意一个</strong>字符（除了换行符 <code>\n</code>）。<ul><li><code>a.c</code> 匹配 <code>"abc"</code>, <code>"a@c"</code>, <code>"a c"</code></li></ul></li><li><strong><code>\d</code></strong>：匹配任意一个<strong>数字</strong>。等价于 <code>[0-9]</code>。<ul><li><code>\d\d</code> 匹配 <code>"12"</code>, <code>"05"</code></li></ul></li><li><strong><code>\w</code></strong>：匹配任意一个<strong>字母、数字或下划线</strong>。等价于 <code>[A-Za-z0-9_]</code>。<ul><li><code>\w\w</code> 匹配 <code>"Ab"</code>, <code>"a1"</code>, <code>"_x"</code></li></ul></li><li><strong><code>\s</code></strong>：匹配任意一个<strong>空白字符</strong>（包括空格、制表符 <code>\t</code>、换行符 <code>\n</code> 等）。</li><li><strong><code>\D</code>, <code>\W</code>, <code>\S</code></strong>：分别是 <code>\d</code>, <code>\w</code>, <code>\s</code> 的<strong>反面</strong>。<ul><li><code>\D</code> 匹配<strong>非数字</strong>的任意字符。</li></ul></li><li><strong><code>[...]</code> (字符组)</strong>：匹配方括号内的<strong>任意一个</strong>字符。<ul><li><code>[aeiou]</code> 匹配任意一个元音字母。</li><li><code>[a-z]</code> 匹配任意一个小写字母（<code>-</code> 表示范围）。</li><li><code>[0-9a-fA-F]</code> 匹配一个十六进制数字。</li></ul></li><li><strong><code>[^...]</code> (否定字符组)</strong>：匹配<strong>不在</strong>方括号内的任意一个字符。<ul><li><code>[^0-9]</code> 匹配任意一个非数字字符。</li></ul></li></ul><h2 id="量词---控制字符出现的次数">3. 量词 - 控制字符出现的次数</h2><ul><li><strong><code>*</code></strong>：匹配<strong>零次或多次</strong>。<ul><li><code>ab*c</code> 匹配 <code>"ac"</code> (0次b), <code>"abc"</code> (1次b), <code>"abbc"</code> (多次b)</li></ul></li><li><strong><code>+</code></strong>：匹配<strong>一次或多次</strong>。<ul><li><code>ab+c</code> 匹配 <code>"abc"</code>, <code>"abbc"</code>，但不匹配 <code>"ac"</code></li></ul></li><li><strong><code>?</code></strong>：匹配<strong>零次或一次</strong>（即可选的）。<ul><li><code>colou?r</code> 匹配 <code>"color"</code> 和 <code>"colour"</code> (u出现0次或1次)</li></ul></li><li><strong><code>&#123;n&#125;</code></strong>：匹配确定的 <strong>n次</strong>。<ul><li><code>\d&#123;4&#125;</code> 匹配恰好4个数字，如 <code>"2024"</code></li></ul></li><li><strong><code>&#123;n,&#125;</code></strong>：匹配<strong>至少 n 次</strong>。<ul><li><code>\d&#123;2,&#125;</code> 匹配至少2个数字，如 <code>"12"</code>, <code>"123"</code></li></ul></li><li><strong><code>&#123;n,m&#125;</code></strong>：匹配<strong>至少 n 次，最多 m次</strong>。<ul><li><code>\d&#123;2,4&#125;</code> 匹配2到4个数字，如 <code>"12"</code>, <code>"123"</code>, <code>"2024"</code></li></ul></li></ul><h2 id="位置锚点---匹配位置而不是字符">4. 位置锚点 -匹配位置，而不是字符</h2><ul><li><strong><code>^</code></strong>：匹配字符串的<strong>开始</strong>位置。<ul><li><code>^Hello</code> 匹配以 <code>"Hello"</code> 开头的字符串。</li></ul></li><li><strong><code>$</code></strong>：匹配字符串的<strong>结束</strong>位置。<ul><li><code>world!$</code> 匹配以 <code>"world!"</code> 结尾的字符串。</li></ul></li><li><strong><code>\b</code></strong>：匹配一个<strong>单词的边界</strong>（即单词开头或结尾的空隙）。<ul><li><code>\bcat\b</code> 匹配单词 <code>"cat"</code>，但不匹配 <code>"category"</code> 或 <code>"scatter"</code> 中的 <code>"cat"</code>。</li></ul></li></ul><h2 id="分组与捕获">5. 分组与捕获</h2><ul><li><strong><code>(...)</code></strong>：<ol type="1"><li><strong>分组</strong>：将多个字符组合成一个整体，以便对其使用量词。<ul><li><code>(abc)+</code> 匹配 <code>"abc"</code>, <code>"abcabc"</code>。</li></ul></li><li><strong>捕获</strong>：提取匹配到的内容，供后续使用或替换。<ul><li>在替换操作中，可以用 <code>$1</code>, <code>$2</code> 来引用被括号捕获的内容。</li></ul></li></ol></li><li><strong><code>(?:...)</code></strong>：<strong>非捕获分组</strong>。只分组，不捕获，提高效率。</li></ul><h2 id="选择符">6. 选择符</h2><ul><li><strong><code>|</code></strong>：表示“或”关系。<ul><li><code>cat|dog</code> 匹配 <code>"cat"</code> 或 <code>"dog"</code>。</li><li><code>gr(a|e)y</code> 匹配 <code>"gray"</code> 或 <code>"grey"</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-comment"># []表示范围，只匹配一个字符</span><br>[abc]           只能是 a b c 其中之一<br>[a-zA-Z]        a到z 或 A到Z<br><br><br><span class="hljs-comment"># ^ 表示 非</span><br>[^abc]          除 a b c 之外的任何字符<br><br><br><span class="hljs-comment"># &amp;&amp; 表示 且</span><br>[a-z&amp;&amp;[^e-g]]   a 到 z 且 除了 e 到 g（等同于[a-dh-z]）<br><br><br><span class="hljs-comment"># | 表示 或</span><br>[a-z|A-Z]       小写字母或大写字母<br><br><br><span class="hljs-comment"># 预定义字符</span><br>.    任何字符<br>\d   数字<br>\s   空白字符<br>\w   英文字母、数字、下划线<br><br>\D   非数字<br>\S   非空白字符<br>\W   非英文字母、数字、下划线<br><br><br><span class="hljs-comment"># 数量词</span><br>x?       <span class="hljs-number">0</span>个或<span class="hljs-number">1</span>个x<br>x*       <span class="hljs-number">0</span>个或多个x<br>x+       <span class="hljs-number">1</span>个或多个x<br>x&#123;n&#125;     正好n个x<br>x&#123;n,&#125;    至少n个x<br>x&#123;n, m&#125;  n到m个x<br><br><br><span class="hljs-comment"># \ 转义字符</span><br>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]\-[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]   数字-数字<br><br><span class="hljs-comment"># ^ 必须是开头  $ 必须是结尾</span><br>^hello    可以匹配 hello world  不能匹配 say hello<br>world$    可以匹配 hello world  不能匹配 world peace<br></code></pre></td></tr></table></figure><h1 id="python应用">2 Python应用</h1><h2 id="re模块">2.1 re模块</h2><p><code>re</code>模块中包含正则表达式的所有功能，因为Python本来也有转义字符<code>\</code>，所以 <code>\\</code>才能表示<code>\</code>，为了方便，我们可以直接使用<code>r''</code>去除转义功能。 使用<code>re.match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;failed&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="字符串分割">2.2 字符串分割</h2><p>使用正则表达式分割字符串比常规的<code>split()</code>方法更加强大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通split()</span><br><span class="hljs-string">&#x27;1   2 3  4&#x27;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)   <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;]</span><br><br><span class="hljs-comment"># 正则split()</span><br>re.split(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>)<br><br>re.split(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27;1   2 3   4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br><br>re.split(<span class="hljs-string">r&#x27;[\s,;]+&#x27;</span>, <span class="hljs-string">&#x27;1  , 2,;, 3 ,4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="分组">2.3 分组</h2><p><code>()</code>表示要提取的分组，如果正则表达式中定义了组，就可以在<code>Match</code>对象上用 <code>group()</code>方法提取出子串来。<code>group()</code>和<code>group(0)</code>表示匹配的完整字符串，<code>group(1)</code>和<code>group(2)</code>依次代表第1、第2个子串，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re  <br>  <br>qq = <span class="hljs-string">&#x27;qq:12345678&#x27;</span>  <br>reg = <span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>  <br>m = re.<span class="hljs-keyword">match</span>(reg, qq)  <br><span class="hljs-built_in">print</span>(m)  <br><span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># qq</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 12345678</span><br></code></pre></td></tr></table></figure><h2 id="预编译">2.4 预编译</h2><p>如果一个正则表达式要用很多次，可以使用预编译。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 预编译</span><br>re_qq = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>)<br><br><span class="hljs-comment"># 使用</span><br><span class="hljs-built_in">print</span>(re_qq.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;qq:41532531&#x27;</span>).group(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Python多进程和多线程</title>
    <link href="/2024/05/18/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/05/18/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多任务">1 多任务</h1><p>对于操作系统来说，一个任务就是一个<strong>进程（Process）</strong>，比如打开一个浏览器就是启动一个浏览器进程，打开两个记事本就启动了两个记事本进程，</p><p>有些进程内部要同时干多件事，比如Word同时进行打字和拼写检查，需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为<strong>线程（Thread）</strong>。线程是最小执行单元，一个进程至少有一个线程。</p><ul><li>串行：多个任务依次执行</li><li>并发：对于单核CPU，多个任务快速切换执行，看起来好像是多个任务一起执行的</li><li>并行：对于多核CPU，真正实现了多个任务同时执行</li></ul><p>多进程和多线程由操作系统进行调度，执行顺序具有随机性。</p><h1 id="多进程">2 多进程</h1><h2 id="multiprocessing">2.1 multiprocessing</h2><p>Windows可以使用跨平台的 <code>multiprocessing</code>，模块中提供了<code>Process</code>类代表一个进程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;p-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有<code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为进程起的名字，可以通过<code>进程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>首音乐&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br><br><span class="hljs-comment"># 没有 __name__ == &#x27;__main__&#x27; 的保护会导致无限递归</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-comment"># 实例化进程对象</span><br>    p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;)  <br><br>    <span class="hljs-comment"># 启动进程</span><br>    p1.start()  <br>    p2.start()  <br><br>    <span class="hljs-comment"># 等待子进程结束后，再继续执行主进程</span><br>    p1.join()  <br>    p2.join()<br></code></pre></td></tr></table></figure><h2 id="获取进程编号">2.2 获取进程编号</h2><p>每个程序（进程）在设备上都有唯一的进程编号（PID），程序释放时进程编号也会释放，实现了进程编号的重复利用。</p><ul><li>获取当前PID的方式：<ul><li>方式一：<code>os.getpid()</code></li><li>方式二：<code>multiprocessing.current_process().pid</code></li></ul></li><li>获取父进程PID的方式：<ul><li><code>os.getppid()</code></li></ul></li></ul><blockquote><p>在 <code>main</code>中创建的进程，如果没有指定，则它的父进程都是<code>main</code>进程，而 <code>main</code>的父进程是<code>Pycharm</code>程序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time, os  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f1的pid：34568, 34568 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f2的pid：40356, 40356 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;)  <br><br>    <span class="hljs-comment"># process-1 process-2</span><br>    <span class="hljs-built_in">print</span>(p1.name, p2.name)  <br>  <br>    p1.start()  <br>    p2.start()  <br>  <br>    <span class="hljs-comment"># main的pid:32240, 32240 父进程：35464</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;main的pid:<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="数据隔离">2.3 数据隔离</h2><p>多进程有以下特点：</p><ol type="1"><li>进程之间执行是<strong>无序</strong>的</li><li>进程之间有<strong>数据隔离</strong></li><li>主进程会<strong>等待所有子进程执行结束</strong>再结束</li></ol><p>每个进程都有自己独立的内存空间，进程之间的<strong>数据是相互隔离</strong>的，子进程中的资源是父进程资源的拷贝，互不影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>)  <br>    p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>)  <br>  <br>    ls = [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>] <br><br>    <span class="hljs-comment"># 主进程中的ls为[8, 7, 6, 5, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>  <br>    p1.start()  <br>    p2.start()<br></code></pre></td></tr></table></figure><h2 id="守护进程">2.4 守护进程</h2><p>注意这个词的描述非常不准确。正常来说，<strong>主进程会等待所有子进程执行结束之后才结束</strong>，但是有时候想要关闭主进程的同时关闭所有子进程，这个时候需要守护进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正常情况</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了努力工作中</span><br><span class="hljs-string"></span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果想要实现子进程和主进程同步关闭，有两种实现方法：</p><ol type="1"><li>设置子进程为守护进程，将属性 <code>daemon</code>设为<code>True</code></li><li>手动杀死子进程，不过会导致子进程变为僵尸进程，会交由Python解释器自动回收</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 守护进程</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br><br>    <span class="hljs-comment"># 子进程p1设为了守护进程</span><br>    p1.daemon = <span class="hljs-literal">True</span>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="manager实现数据共享">2.5 Manager实现数据共享</h2><p>在多进程中数据共享可以使用 <code>multiprocessing</code>模块中的<code>Manager()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-keyword">with</span> multiprocessing.Manager() <span class="hljs-keyword">as</span> manager:  <br>        <span class="hljs-comment"># 这个 ls 就可以共享</span><br>        ls = manager.<span class="hljs-built_in">list</span>()  <br>        p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(ls, ))  <br>        p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, args=(ls, ))<br></code></pre></td></tr></table></figure><h1 id="多线程">3 多线程</h1><h2 id="threading">3.1 threading</h2><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。进程是CPU分配资源的基本单位，线程是CPU调度资源的最小单位，线程是依附于进程的，一个进程至少含有一个线程。</p><p>多线程之间有以下特点：</p><ol type="1"><li>线程之间执行是<strong>无序</strong>的</li><li>统一进程下的多线程之间<strong>共享</strong>全局变量</li><li>主线程会<strong>等待所有子线程执行结束</strong>再结束</li></ol><p>使用 <code>threading</code>模块中的<code>Thread</code>类创建线程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = threading.Thread(target=coding, args=(name1, age1))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有<code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为线程起的名字，可以通过<code>线程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time, os, multiprocessing  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br>name1, age1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>name2, age2 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t1 = threading.Thread(target=coding, args=(name1, age1))  <br>    t2 = threading.Thread(target=music, args=(name2, age2))  <br>  <br>    t1.start()  <br>    t2.start()<br></code></pre></td></tr></table></figure><h2 id="数据共享">3.2 数据共享</h2><p>多线程之间共用内存空间，数据是共享的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=write)  <br>t2 = threading.Thread(target=read)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><h2 id="守护线程">3.3 守护线程</h2><p>和进程类似，主线程会等待所有子线程结束再结束，如果想要让子线程随主进程结束而结束，应该设置守护线程，<code>线程.daemon = True</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t = threading.Thread(target=work)  <br>  <br>    t.daemon = <span class="hljs-literal">True</span>  <br>    t.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="互斥锁">3.4 互斥锁</h2><p>多线程中<strong>所有变量都由所有线程共享</strong>，最大的危险在于多个线程同时修改同一变量，内容就会出现紊乱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多次运行结果不同</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">add1函数中的num为1451039</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string">-----------------------</span><br><span class="hljs-string">add1函数中的num为1727878</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">import</span> threading, time  <br>  <br>num = <span class="hljs-number">0</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>在上述案例中，<code>num += 1</code>并不是原子操作，而是分为以下几步交由CPU执行：</p><ol type="1"><li>读取当前 <code>num</code> 的值到寄存器</li><li>将寄存器中的值加1</li><li>将结果写回 <code>num</code> 变量</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">时间点 | 线程1              | 线程2              | num的值<br>----------------------------------------------------------------<br>t1    | 读取 num=0         |                    | 0<br>t2    | 计算 0+1=1         |                    | 0  <br>t3    |                    | 读取 num=0         | 0<br>t4    |                    | 计算 0+1=1         | 0<br>t5    | 写入 num=1         |                    | 1<br>t6    |                    | 写入 num=1         | 1 ← 错误！应该是2<br></code></pre></td></tr></table></figure><hr /><p>为了确保计算正确，就要给两个<code>add()</code>函数<strong>上个锁</strong>，当某个线程获得了该锁，其他线程就不能同时执行，而要等待直到获得该锁的线程释放锁，并获得该锁。由于锁只有一个，同一时间只有一个线程可以持有该锁，就不会造成修改的冲突。</p><p>通过 <code>threading.Lock()</code>可以创建一个锁对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>  <br>num = <span class="hljs-number">0</span>  <br><span class="hljs-comment"># 创建一个锁对象</span><br>lock = threading.Lock()  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 上述代码的全局变量改为 num = &#x27;0&#x27; 就会形成死线程，采用try...finally可以解决</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>            num += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>        lock.release()  <span class="hljs-comment"># 不管是否成功执行，一定要释放锁</span><br></code></pre></td></tr></table></figure><blockquote><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p></blockquote><h1 id="进程和线程的区别">4 进程和线程的区别</h1><ol type="1"><li>线程是依附于进程的，<strong>没有进程就没有线程</strong></li><li>一个进程<strong>最少有一个线程</strong>，进程可以创建多个线程</li><li>进程之间<strong>数据隔离</strong>，线程之间<strong>共享全局变量</strong>（使用互斥锁解决资源竞争问题）</li><li>进程是<strong>操作系统分配资源</strong>的基本单位，线程是<strong>CPU调度</strong>的基本单位</li><li>进程更消耗资源，相对更稳定；线程更轻量级，相对更灵活</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Python函数式编程</title>
    <link href="/2024/05/17/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/17/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="高阶函数">1 高阶函数</h1><p><strong>Python中的函数是“一等函数”</strong>，所谓“一等函数”指的就是函数可以赋值给变量，函数可以作为函数的参数，函数也可以作为函数的返回值。把一个函数作为其他函数的参数或返回值的用法，我们通常称之为“高阶函数”。</p><p>在Python中，<code>func()</code>是函数调用，<code>func</code>是函数本身，可以把函数本身赋值给变量，也就是：<strong>变量指向函数</strong>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>)  <span class="hljs-comment"># &lt;built-in function abs&gt;</span><br><br>f = <span class="hljs-built_in">abs</span>  <span class="hljs-comment"># f指向了abs函数</span><br><span class="hljs-built_in">print</span>(f(-<span class="hljs-number">5</span>))  <span class="hljs-comment"># 5  现在f等价于abs</span><br></code></pre></td></tr></table></figure></p><p>其实函数名本身也是变量，函数名指向函数。 <imgsrc="08_func.png" /></p><hr /><p>函数能接收变量，变量可以指向函数，所以函数可以接受函数，这时传递的不是数据，而是<strong>计算逻辑</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):  <br>    <span class="hljs-keyword">return</span> x + y  <br><br><br>func(add, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)  <br></code></pre></td></tr></table></figure><h2 id="map">1.1 map()</h2><p><code>map()</code>接收两个参数，一个是函数，一个是可迭代对象<code>Iterable</code>，<code>map()</code>将函数依次作用到可迭代对象的每个元素，并将结果作为一个新的迭代器对象<code>Iterator</code>返回。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br><span class="hljs-comment"># 将f作用到列表中的每一个元素</span><br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(r))<br></code></pre></td></tr></table></figure></p><p>上述代码中，由于<code>map()</code>返回的是一个惰性序列<code>Iterator</code>，所以通过<code>list()</code>把整个序列算出来返回一个<code>list</code>。</p><p>输入一行数据作为列表： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27; &#x27;</span>)))<br></code></pre></td></tr></table></figure></p><h2 id="reduce">1.2 reduce()</h2><p><code>reduce()</code>把一个函数作用到一个序列中，其中这个函数必须<strong>接收两个参数</strong>，<code>reduce()</code>将计算结果继续和下一个元素累计计算。使用<code>reduce()</code>需要导入<code>from functools import reduce</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><br><span class="hljs-built_in">print</span>(reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))  <span class="hljs-comment"># 累加求和 55</span><br><br><span class="hljs-comment"># 使用lambda匿名函数</span><br><span class="hljs-built_in">print</span>(reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure></p><h2 id="filter">1.3 filter()</h2><p><code>filter</code>接收一个函数一个序列，把传入的函数作用到每一个元素上，根据返回值决定是否保留，<code>True</code>保留元素，<code>False</code>丢弃元素。最终结果作为<code>Iterator</code>返回，也就是一个惰性序列，需要使用<code>list()</code>获取所有计算结果。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 求出0~100的所有偶数</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(f, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br></code></pre></td></tr></table></figure></p><h2 id="sorted">1.4 sorted()</h2><p><code>sorted()</code>可以对序列进行排序，返回一个新的列表。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">sorted</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></p><p>还可以接收一个<code>key</code>函数实现自定义排序，<code>key</code>将指定函数作用到序列的每一个值上，并按照返回值进行排序。另外还可以使用<code>reverse=True</code>表示逆序排列。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><br><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br><br><span class="hljs-comment"># 按照第二个元素分数进行排序</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=f)<br><br><span class="hljs-comment"># 使用lambda并且逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><h1 id="匿名函数">2 匿名函数</h1><ul><li><code>def</code> 关键字，可以定义带有名称的函数</li><li><code>lambda</code> 关键字，可以定义匿名函数（无名称）</li></ul><p>有名称的函数，可以基于名称重复使用。无名称的匿名函数，只可<strong>临时</strong>使用一次。表达式内容自动成为返回值，不可使用<code>return</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 传入参数: 函数体（一行代码）<br></code></pre></td></tr></table></figure></p><p>实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br><br><br><span class="hljs-comment"># 传入一个一次性的函数</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x * y, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></p><h1 id="闭包">3 闭包</h1><h2 id="闭包的定义">3.1 闭包的定义</h2><p>调用了外部函数变量的内部函数就称之为<strong>闭包（Closure）</strong>，闭包可以增强安全性，将原本的全局变量变为外部函数的参数，对于内层函数来说这个变量又是外部变量。</p><p>闭包的三个必要条件：</p><ol type="1"><li>有嵌套：函数嵌套</li><li>有引用：内部函数引用外部函数变量</li><li>有返回：外部函数返回内部函数名（对象）</li></ol><p>银行取款非闭包写法：这种写法余额<code>initial_value</code>是全局变量，有被修改的风险。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">initial_value = <span class="hljs-number">10000</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>    <span class="hljs-keyword">if</span> flag:  <br>        initial_value += value  <br>    <span class="hljs-keyword">else</span>:  <br>        initial_value -= value  <br><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment">#  存款1000，变为11000</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款2000，变为9000</span><br></code></pre></td></tr></table></figure></p><p>闭包写法：<code>initial_value</code>变成了外部函数<code>count()</code>的参数，外部无法访问。想在内部函数引用外部变量需要使用<code>nonlocal</code>声明，否则会被认为是内部函数局部变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">initial_value=<span class="hljs-number">0</span></span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>        <span class="hljs-keyword">nonlocal</span> initial_value  <span class="hljs-comment"># 声明为外部变量</span><br>        <span class="hljs-keyword">if</span> flag:  <br>            initial_value += value  <br>        <span class="hljs-keyword">else</span>:  <br>            initial_value -= value  <br>  <br>    <span class="hljs-keyword">return</span> atm  <br>  <br><br><span class="hljs-comment"># 现在 fn 存储的是 atm() 函数，并且保存了 initial_value = 10000 的状态</span><br>fn = count(<span class="hljs-number">10000</span>)  <br><br><span class="hljs-comment"># 使用 fn 可以调用 atm() 函数</span><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 存款</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款</span><br></code></pre></td></tr></table></figure></p><h2 id="闭包的原理">3.2 闭包的原理</h2><p>闭包有点类的思想，外层函数中的参数像类的元素一样被保留了下来。实际上在Python的函数对象中存储了一些属性：</p><ul><li><code>__code__</code>：保存函数的字节码。</li><li><code>__globals__</code>：保存全局作用域引用。</li><li><code>__closure__</code>：保存了被捕获的自由变量（也就是闭包变量）。</li></ul><p>在上述案例中<code>fn = count(10000)</code>执行后，<code>fn</code>是<code>atm</code>这个函数对象。所以<code>initial_value=10000</code>这个变量其实是保存在 <code>fn.__closure__</code>里的，Python会把它包装为一个<strong>cellobject</strong>（细胞对象），用来存活并保持可变。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">可以访问到 initial_value 的值</span><br><span class="hljs-string">fn.__closure__ 是一个元组，里面的元素就是 cell 对象</span><br><span class="hljs-string">cell_contents 就是捕获到的变量值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(fn.__closure__[<span class="hljs-number">0</span>].cell_contents)  <span class="hljs-comment"># 10000</span><br></code></pre></td></tr></table></figure></p><h1 id="装饰器">4 装饰器</h1><h2 id="基本用法">4.1 基本用法</h2><p><strong>装饰器（Decorator）</strong>就是创建一个闭包函数，在闭包函数内调用目标函数，可以达到不改变目标函数的同时，增加额外的功能。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我开始了&#x27;</span>)  <span class="hljs-comment"># 执行前扩展</span><br>        func()  <span class="hljs-comment"># 原函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我结束了&#x27;</span>)  <span class="hljs-comment"># 执行后扩展</span><br><br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 将 demo 函数对象传入 outer()，fn 现在是保存了 func 状态的 inner 函数对象</span><br>fn = outer(demo)<br><br>fn()  <span class="hljs-comment"># 其实执行的就是 inner() 函数的内容</span><br></code></pre></td></tr></table></figure></p><p>上述写法还不够优雅，可以使用<code>@函数名</code>的方式，也叫语法糖。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># @outer 放在函数定义处相当于执行了 demo = outer(demo)</span><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 此时执行 demo() 已经是扩展之后的功能了</span><br>demo()<br></code></pre></td></tr></table></figure></p><blockquote><p>原来的<code>demo()</code>函数仍然存在，只是同名<code>demo</code>变量指向了新的函数，于是调用<code>demo()</code>会执行扩展后的函数，其实就是保存了<code>func</code> 状态的 <code>inner()</code>函数。</p></blockquote><h2 id="带参有返回值">4.2 带参有返回值</h2><p>要被装饰的原函数带参有返回值，并且原函数接收不定长参数，有一些细节需要注意。</p><ul><li><code>fn(args, kwargs)</code>是位置参数：相当于<code>get_sum((1,2,3,4), &#123;'math':18&#125;)</code></li><li><code>fn(*args, **kwargs)</code>是不定长参数：相当于<code>get_sum(1,2,3,4, math=18)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):  <span class="hljs-comment"># 接收过来 args 已经是元组， kwargs 是字典  </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始计算...&#x27;</span>)  <br>        <span class="hljs-comment"># return fn (args, kwargs)  # 这种写法是错误的，被当做位置参数了</span><br>        <span class="hljs-keyword">return</span> fn(*args, **kwargs)  <span class="hljs-comment"># 现成的容器传入不定长需要 * 和 **  </span><br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sum</span>(<span class="hljs-params">*args, **kwargs</span>):  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(args) + <span class="hljs-built_in">sum</span>(kwargs.values())  <br>  <br>  <br>a = get_sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, math=<span class="hljs-number">10</span>, eng=<span class="hljs-number">30</span>)  <br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">开始计算...</span><br><span class="hljs-string">50</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="多个装饰器">4.3 多个装饰器</h2><p>多个装饰器一层一层进入函数，再一层一层返回，装饰器的应用顺序是：<strong>自下而上，依次包裹</strong>。</p><ul><li>执行顺序是由外到内（先进入 <code>outer1</code>，再进入<code>outer2</code>，再执行原函数）</li><li>返回顺序是由内到外（先从 <code>outer2</code> 返回，再从<code>outer2</code> 返回）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer1</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer2</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer1  </span><br><span class="hljs-meta">@outer2  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是猪猪侠&#x27;</span>)  <br>  <br>  <br>hello()<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">装饰器1开始</span><br><span class="hljs-string">装饰器2开始</span><br><span class="hljs-string">测试函数</span><br><span class="hljs-string">装饰器2结束</span><br><span class="hljs-string">装饰器1结束</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码的两个装饰器相当于<code>hello = outer1(outer2(hello))</code>。</p><ol type="1"><li><code>hello</code>先被<code>outer2</code>装饰，返回一个新函数</li><li>这个新函数再被<code>outer1</code>装饰，又得到一个新函数</li></ol><blockquote><p>多个装饰器有点递归或者栈调用的感觉，只不过多个装饰器是采用多层函数嵌套，并没有无限调用自己，只是采用了类似的套娃结构。</p><p>如果说递归是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……递归是：无限重复的同一个壳。</p><p>那么多个装饰器是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……从前有条河，河里有条船，船上有个老船员，正在给小船员讲故事！故事是……多个装饰器是：多层不同的外壳。</p></blockquote><h2 id="带参装饰器">4.4 带参装饰器</h2><p>在普通装饰器中<code>@outer 相当于 demo = outer(demo)</code>，默认接收一个被装饰的函数参数，这里所说的带参装饰器是在<code>@outer</code>的参数，语法糖的格式<strong>只允许接收一个参数</strong>，所以要使用三层函数嵌套来进行额外的传参。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">name</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">msg</span>):   <span class="hljs-comment"># 可以接收参数</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我开始执行了&#x27;</span>)<br>            fn(msg)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我执行结束了&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:测试返回值&#x27;</span>   <span class="hljs-comment"># 可以返回值</span><br>        <span class="hljs-keyword">return</span> inner<br>    <span class="hljs-keyword">return</span> outer<br><br><br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&#x27;猪猪侠&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-built_in">print</span>(msg)<br><br><br>hello(<span class="hljs-string">&#x27;大家好啊&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">大家好</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(hello(<span class="hljs-string">&#x27;hhh&#x27;</span>))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">hhh</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">猪猪侠:测试返回值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></p><p>在上述代码中，<code>@deco('猪猪侠')</code>相当于<code>hello = deco('猪猪侠')(hello)</code>，<code>hello</code>实际是一个指向<code>inner</code>函数的变量。</p><ul><li>第一次调用<code>deco('猪猪侠')</code>，返回一个真正的装饰器函数，也就是<code>outer</code>函数</li><li>第二次相当于是<code>outer(hello)</code>，和之前的普通装饰器一样</li></ul><blockquote><p>如果使用传统格式，而不使用语法糖，也可以直接在外层函数传参，而不需要三层函数，用法为<code>hello = outer(hello, name)</code>。</p></blockquote><h1 id="偏函数">5 偏函数</h1><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partialfunction）。偏函数可以<strong>固定函数的某些参数</strong>，生成一个新的函数，在调用时可以减少重复参数的输入，降低调用难度。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int()默认将字符串按照10进制进行转换，可以通过base设置进制</span><br><span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;152&#x27;</span>, base=<span class="hljs-number">8</span>)<br><br><span class="hljs-comment"># 固定base参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int2</span>(<span class="hljs-params">x, base=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x, base)<br><br><span class="hljs-comment"># functools.partial可以很方便地构造偏函数</span><br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Python生成器和迭代器</title>
    <link href="/2024/05/14/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/05/14/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代">1 迭代</h1><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 可迭代对象:<br>    代码块<br></code></pre></td></tr></table></figure><h1 id="推导式生成式">2 推导式（生成式）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h1 id="生成器">3 生成器</h1><p>受到内存限制，列表的容量是有限的，存储大量数据要占用大量的空间。</p><p>生成器解决了这个问题，<strong>生成器（generator）允许按需生成值，而不是一次性在内存中创建并存储整个序列。</strong>在每次请求时（使用 <code>next()</code> 或在 <code>for</code> 循环中）才计算并返回一个值。计算完一个值后，它会“暂停”执行，保存当前的状态（包括局部变量），直到下一次请求到来时再“唤醒”并从暂停的地方继续执行。这种方式被称为<strong>惰性求值</strong>。</p><h2 id="生成器表达式">3.1 生成器表达式</h2><p>生成器表达式在语法上类似于列表推导式，把 <code>[]</code>改成<code>()</code>就创建了一个 <code>generator</code>。</p><ul><li><strong>列表推导式</strong>：立即生成所有元素，并存储在内存中。</li><li><strong>生成器表达式</strong>：返回一个生成器对象，按需生成元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br><span class="hljs-built_in">print</span>(g)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x00000280B9CA04A0&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(g))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="生成器函数">3.2 生成器函数</h2><p>推导算法复杂的时候可以使用函数实现，这是最常见的方法，写法和普通函数类似，不过使用 <code>yield</code> 语句而不是 <code>return</code> 语句来返回值。</p><ul><li><code>return</code>：函数遇到 <code>return</code> 会立即终止，并返回一个值。每次调用函数都会从第一行代码重新开始执行。</li><li><code>yield</code>：函数遇到 <code>yield</code> 会暂停执行，将值返回给调用者，并<strong>记住函数当前的所有状态</strong>。下次调用时，函数会从上次返回的<code>yield</code>语句继续执行。</li></ul><p>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个<code>generator</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无限序列生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> count<br>        count += <span class="hljs-number">1</span><br><br>f = counter() <br><span class="hljs-built_in">print</span>(f)  <span class="hljs-comment"># &lt;generator object counter at 0x0000018E4602B610&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>generator</code>函数会创建一个<code>generator</code>对象，多次调用<code>generator</code>函数会创建多个相互独立的<code>generator</code>，所以正确做法是创建一个<code>generator</code>对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">f = counter()  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0  创建了新的generator对象</span><br></code></pre></td></tr></table></figure><h2 id="生成器的访问">3.3 生成器的访问</h2><p>如果要访问生成器，可以使用<code>next()</code>函数。<code>generator</code>保存的是算法，每次调用<code>next()</code>就计算<code>g</code>的下一个值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>不过一般不会使用 <code>next()</code>，由于<code>generator</code>也是可迭代对象，可以通过<code>for</code>循环去迭代它，并且不用担心相关<code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代generator对象</span><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:<br>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h1 id="迭代器">4 迭代器</h1><h2 id="可迭代对象">4.1 可迭代对象</h2><p>可以直接作用于<code>for</code>循环的对象统称为<strong>可迭代对象（Iterable）</strong>，包括：</p><ul><li>集合数据类型（都是 <code>Iterable</code>，但不是<code>Iterator</code>，可以使用 <code>iter()</code>函数转化为迭代器）<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器（都是 <code>Iterable</code>，又是 <code>Iterator</code>）<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>可以使用<code>isinstance</code>方法判断是否为<strong>可迭代对象</strong><code>Iterable</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure><h2 id="迭代器对象">4.2 迭代器对象</h2><p>生成器不但可以作用于 <code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。迭代器是一个实现了 <code>__iter__()</code> 和 <code>__next__()</code>方法的对象，可以被<code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器（Iterator）</strong>。</p><p>也可以使用<code>isinstance</code>方法判断是否为<strong>迭代器对象</strong><code>Iterator</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>((i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator))  <span class="hljs-comment"># True，迭代器</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>([], Iterator))  <span class="hljs-comment"># False，列表不是迭代器</span><br></code></pre></td></tr></table></figure><p>生成器都是 <code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是 <code>Iterator</code>。 把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成 <code>Iterator</code>可以使用<code>iter()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]  <br>ls = <span class="hljs-built_in">iter</span>(ls)  <span class="hljs-comment"># 转换为了Iterator</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(ls, Iterator))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><ul><li>凡是可作用于 <code>for</code>循环的对象都是<code>Iterable</code>类型</li><li>凡是可作用于 <code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列</li></ul><blockquote><p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？ 这是因为Python的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p></blockquote><p>Python的 <code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面两种方式完全等价</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 首先获得Iterator对象: </span><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <br><span class="hljs-comment"># 循环: </span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <br>    <span class="hljs-keyword">try</span>:       <br>        <span class="hljs-comment"># 获得下一个值:       </span><br>        x = <span class="hljs-built_in">next</span>(it)   <br>    <span class="hljs-keyword">except</span> StopIteration:      <br>        <span class="hljs-comment"># 遇到StopIteration就退出循环       </span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Python赋值与深浅拷贝</title>
    <link href="/2024/05/11/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/05/11/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="可变对象和不可变对象">1 可变对象和不可变对象</h1><p>可变对象和不可变对象的划分依据：<strong>在不改变地址的前提下，元素值能否修改</strong>。</p><ul><li>可变对象：该对象所指内存的值可以被改变<ul><li>列表<code>list</code></li><li>集合<code>set</code></li><li>字典<code>dict</code></li><li>自定义对象</li></ul></li><li>不可变对象：该对象所指向的内存中的值不能被改变，一旦创建就<strong>不可修改</strong>，想要修改对象的值，需要复制一份后再改变，会返回一个新地址<ul><li>数字<code>int</code> <code>float</code></li><li>字符串<code>str</code></li><li>元组<code>tuple</code></li><li>布尔<code>bool</code></li></ul></li></ul><p>可以通过<code>id()</code>查看对象的地址。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不可变对象：改变元素值本质是创建了一个新的对象，指向了新的对象</span><br>a = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202913808</span><br>a = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202914128，内容修改，地址也变了</span><br><br><span class="hljs-comment"># 可变对象：</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536</span><br>ls[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536，内容修改，地址不变</span><br></code></pre></td></tr></table></figure></p><h1 id="赋值">2 赋值</h1><p>与C++不同，Python的赋值<code>=</code>属于<strong>引用赋值</strong>，只是了创建对象的另一个<strong>引用（别名）</strong>，新旧变量指向同一个内存对象，通过任一引用修改对象（需要可变），其他引用都会发生变化。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引用赋值，a和b都指向同一内存空间</span><br>a = <span class="hljs-number">10</span><br>b = a<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 1437435953680</span><br><br><span class="hljs-comment"># c和d也指向同一内存空间</span><br>c = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>d = c<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 2028769177536</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(d))  <span class="hljs-comment"># 2028769177536</span><br></code></pre></td></tr></table></figure></p><p>Python解释器在执行<code>a = 10</code>赋值时做以下操作：</p><ol type="1"><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p>把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br>b = a<br>a = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure></p><p><img src="06_assign.png" /></p><h1 id="浅拷贝">3 浅拷贝</h1><p>浅拷贝和深拷贝使用需要导入<code>import copy</code>模块，它们的区别是拷贝层级不同，都可以操作可变对象和不可变对象，但是一般不会操作不可变对象。</p><blockquote><p>不论是深拷贝还是浅拷贝，针对不可变类型的拷贝，都不会开辟新的空间，而是拷贝对象的引用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b = copy.copy(a)<br>c = copy.deepcopy(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 1553475958912</span><br></code></pre></td></tr></table></figure></p></blockquote><p>浅拷贝<code>copy.copy()</code>会创建新对象，<strong>复制最外层的数据</strong>，但内部容器仍然是引用。</p><ul><li>外层独立：外层修改互不影响</li><li>共享内层：嵌套对象的修改会影响所有拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]<br>b = copy.copy(a)  <span class="hljs-comment"># 实际拷贝了 [1, 2, 3, 地址]</span><br><br><span class="hljs-comment"># 外层在新的对象中</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 2785582893824</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 2785582894016</span><br><br><span class="hljs-comment"># 内层还是原来的引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [66, 5, 6]]，外层独立，内层仍然是旧引用</span><br></code></pre></td></tr></table></figure><p>在最外层只暴露了深层的引用，浅拷贝只会拷贝这个地址，而不会拷贝深层数据。<img src="06_variable.png" /></p><h1 id="深拷贝">4 深拷贝</h1><p>深拷贝<code>copy.deepcopy()</code>会创建新的对象，并且<strong>完全独立</strong>的，会递归复制所有嵌套对象。</p><ul><li>完全隔离：任何修改都不会影响其他拷贝</li><li>内存开销：需要更多内存，因为创建所有对象的副本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy  <br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]  <br>b = copy.deepcopy(a)  <br><br><span class="hljs-comment"># 外层是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1823162354432</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1823162354624</span><br><br><span class="hljs-comment"># 内层也是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357568</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357952</span><br>  <br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 6]]，完全独立，不受影响</span><br></code></pre></td></tr></table></figure><h1 id="总结区分">5 总结区分</h1><p><strong>普通赋值和浅拷贝：</strong> <imgsrc="06_assign_copy.png" /></p><p><strong>浅拷贝和深拷贝：</strong></p><ul><li>浅拷贝只拷贝第一层中的数据并开辟空间存储</li><li>深拷贝拷贝所有的数据并开辟对应的空间存储</li></ul><p><img src="06_copy_deepcopy.png" /></p><p><strong>拷贝不可变类型：</strong>深浅拷贝对于不可变类型来说，非常类似普通的赋值，只是复制了引用。 <imgsrc="06_unvariable.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Python面向对象</title>
    <link href="/2024/05/10/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/05/10/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象就是老板思想，需要什么工作就派给什么职位（类）的员工，对于相同的职位都有相同的特征，每一种职位都有很多不同的人（对象）在岗位上，而每一个人又有自己的特点（属性）和技能（方法）。</p><h1 id="类和对象">1 类和对象</h1><ul><li>类：<strong>抽象的模板</strong>，是对一群有相同特征或行为的事物的统称，不能直接使用。（比如学生类）<ul><li><strong>属性</strong>：这类事物具有什么样的<strong>特征</strong><br /></li><li><strong>方法</strong>：这类事物具有什么样的<strong>行为</strong></li></ul></li><li>对象：<strong>具体的实体</strong>，是由类创建出来的一个具体存在，可以直接使用。（比如张三）</li></ul><h2 id="定义类和创建对象">1.1 定义类和创建对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义类，类名一般使用大驼峰</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">方法名</span>:<br>        ...<br>    ...<br><br><span class="hljs-comment"># 如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 创建对象</span><br>对象名 = 类名()<br><br><span class="hljs-comment"># 通过对象名调用内部方法</span><br>对象名.方法名()<br></code></pre></td></tr></table></figure><blockquote><p>在Python中，<strong>函数</strong>是独立的代码块，可以在任何地方定义和调用。<strong>方法</strong>是定义在类内部的函数，通常用于操作类的实例或类本身。</p></blockquote><p><code>self</code>关键字：类似Java的<code>this</code>为了在类的内部区分是哪个对象调用了类的方法，哪一个对象调用的方法，<code>self</code>就是哪一个对象的引用。调用方法时，不需要传递<code>self</code>参数。<br />在方法内部：</p><ul><li>通过<code>self.</code>访问对象的属性<br /></li><li>通过<code>self.</code>调用对象的其他方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 谁调用就是谁</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;self是<span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)  <br>  <br>  <br>car = Car()  <br>car.run()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;car对象<span class="hljs-subst">&#123;car&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>实例方法的第一个参数必须为<code>self</code>！</p></blockquote><h2 id="属性的增加与访问">1.2 属性的增加与访问</h2><p>与Java不同的是，Python可以在类的外面直接添加属性，但<strong>不推荐</strong>这种方式，属性应该封装到类的内部，参考下一节的<code>__init__</code>方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 增加属性</span><br>对象名.属性名 = 属性值<br></code></pre></td></tr></table></figure></p><blockquote><p>由于这种方法的存在，和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，同一个类的不同实例，拥有的变量名称可能不同</p></blockquote><p>属性的访问： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类外部访问</span><br>对象名.属性名<br><br><span class="hljs-comment"># 类内部访问</span><br><span class="hljs-variable language_">self</span>.属性名<br></code></pre></td></tr></table></figure></p><h2 id="获取对象信息">1.3 获取对象信息</h2><p><code>dir(对象)</code>可以查看该对象有哪些属性和方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure></p><p>使用<code>dir()</code>只能把属性和方法列出来，搭配<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>可以改变对象的属性和方法。</p><ul><li><code>hasattr()</code>查看是否有指定属性</li><li><code>getattr()</code>获取指定属性</li><li><code>setattr()</code>设置指定属性 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看是否有name属性，返回True和False</span><br><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br><br><span class="hljs-comment"># 获取指定属性，如果没有则抛出AttributeError的错误</span><br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">404</span>)  <span class="hljs-comment"># 如果属性不存在返回指定值，自行设定</span><br><br><span class="hljs-comment"># 设置指定属性值，可以是之前没有的</span><br><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>只有在不知道对象信息的时候，我们才会去获取对象信息，否则直接使用<code>对象.属性</code>即可。</p></blockquote><h2 id="身份运算符isis-not">1.4 身份运算符is、is not</h2><p>身份运算符<code>is</code>、<code>is not</code>用于<strong>比较两个对象的内存地址</strong>是否一致——是否是对同一个对象的引用。</p><ul><li><code>is</code>用于判断两个变量<strong>引用对象</strong>是否为同一个</li><li><code>==</code>用于判断<strong>引用变量的值</strong>是否相等</li></ul><blockquote><p>针对<code>None</code>的比较，建议使用<code>is</code>。</p></blockquote><h1 id="魔法方法">2 魔法方法</h1><p>魔法方法使用<code>__xx__</code>双下划线包围，在特殊情况下会自动调用。</p><h2 id="init__方法">2.1 <code>__init__</code>方法</h2><p><code>__init__</code>就是Python的<strong>构造方法</strong>，也用来声明<strong>实例属性</strong>，创建对象时自动触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><br><br><span class="hljs-comment"># 有参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br></code></pre></td></tr></table></figure><h2 id="str__方法">2.2 <code>__str__</code>方法</h2><p>使用<code>print()</code>打印对象时，默认是打印对象的内存地址，如果不想要输出内存地址，就需要定义<code>__str__</code>方法。<code>__str__</code>方法的<strong>返回值必须是字符串</strong>，打印时将会打印其返回值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;name: <span class="hljs-subst">&#123;self.name&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure></p><h2 id="repr__方法">2.3 <code>__repr__</code>方法</h2><ul><li><code>__str__</code>：面向<strong>用户</strong>，强调可读性，在print时会调用</li><li><code>__repr__</code>：面向<strong>开发者</strong>，强调更准确、更标准的对象表示形式，通常是调试用的，交互式解释器中会调用</li></ul><p>如果只写 <code>__repr__</code> 而没写 <code>__str__</code>，那<code>print(obj)</code> 也会退回调用 <code>__repr__</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.item = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack(top-&gt; &quot;</span> + <span class="hljs-string">&quot;, &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.item[::-<span class="hljs-number">1</span>])) + <span class="hljs-string">&quot;)&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Stack(<span class="hljs-subst">&#123;self.item!r&#125;</span>)&quot;</span><br><br><br><span class="hljs-built_in">print</span>(st)     <span class="hljs-comment"># 调用 __str__，输出：Stack(top-&gt; 3, 2, 1)</span><br>st            <span class="hljs-comment"># 调用 __repr__，输出：Stack([1, 2, 3])</span><br></code></pre></td></tr></table></figure></p><h2 id="del__方法">2.4 <code>__del__</code>方法</h2><p>当删除对象时，会自动调用<code>__del__</code>方法，让对象在销毁前做一些事情。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span>被销毁了&#x27;</span>)<br><br>stu = Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>)<br><br><span class="hljs-comment"># 使用del手动删除对象，执行__del__方法，否则在对象自然销毁时执行</span><br><span class="hljs-keyword">del</span> stu<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序结束&#x27;</span>)<br></code></pre></td></tr></table></figure></p><h2 id="len__方法">2.5 <code>__len__</code>方法</h2><p>定义调用<code>len(对象)</code>函数时，返回的长度值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br></code></pre></td></tr></table></figure></p><h2 id="iter__方法">2.6 <code>__iter__</code>方法</h2><p>通过实现<code>__iter__</code>方法，使用<code>yield</code>关键字，可以使自定义类成为可迭代对象，方便使用<code>for</code>循环进行遍历。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <br>        current = <span class="hljs-variable language_">self</span>.head  <br>        <span class="hljs-keyword">while</span> current:  <br>            <span class="hljs-keyword">yield</span> current.data  <br>            current = current.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure></p><h1 id="封装">3 封装</h1><p>根据职责将属性和方法封装到一个抽象的类中，外界使用类创建对象，让对象使用属性、调用方法，<strong>对象方法的细节都被封装在类的内部</strong>。</p><p>私有属性和私有方法只能在类的内部使用，在类的外部使用需要通过公共接口。</p><h2 id="私有属性">3.1 私有属性</h2><p>格式：在属性名前面加两个下划线<code>__</code>。用法：和Java一样，定义公有方法<code>get_xxx</code>获取私有属性、<code>set_xxx</code>设置私有属性。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__属性名<br></code></pre></td></tr></table></figure></p><h2 id="私有方法">3.2 私有方法</h2><p>格式：在方法名前面加两个下划线<code>__</code>。用法：定义公有方法调用私有方法。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__方法名</span>():<br>    ...<br></code></pre></td></tr></table></figure></p><blockquote><p>了解：其实Python中没有真正的私有，在外部使用<code>类名.__属性</code>、<code>类名.__方法</code>也可以访问，但<strong>不要这样做</strong>。实际上Python内部只是将私有成员改了一个名，<code>__属性</code>变成了<code>_类名__属性</code>，<code>__方法</code>变成了<code>_类名__方法</code>。</p></blockquote><h2 id="dict__属性">3.3 <code>__dict__</code>属性</h2><p><code>___dict___</code> 是 Python中的一个特殊属性，用于存储对象的所有属性及其对应的值。它以字典形式呈现，键为属性名，值为属性值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.gender = gender<br><br><br>p = Person(<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;男&#x27;</span>)    <br><span class="hljs-built_in">print</span>(p.__dict__)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;猪猪侠&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></code></pre></td></tr></table></figure></p><p>在文件写入中可以使用<code>__dict__</code>将对象转为字典，再将字典转为字符串进行写入。</p><h1 id="继承">4 继承</h1><h2 id="继承的定义">4.1 继承的定义</h2><ul><li>父类：也叫作基类</li><li>子类：也叫作派生类或扩展类</li></ul><p>子类默认继承父类所有的属性和方法，Python的子类<strong>不会直接继承</strong>父类的私有属性和私有方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">父类名</span>):<br>    ...<br><br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(父类名<span class="hljs-number">1</span>, 父类名<span class="hljs-number">2</span>):<br>    ...<br></code></pre></td></tr></table></figure></p><p>当多个父类中存在相同名字的属性或方法，默认使用第一个父类的同名属性和方法，可以使用<code>__mro__</code>属性或<code>mro()</code>方法查看先后顺序。MRO(Method Resolution Order)：方法解析顺序 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(类名.__mro__)<br><span class="hljs-built_in">print</span>(类名.mro())<br></code></pre></td></tr></table></figure></p><p>在Python中，<code>object</code>是所有类的基类，即所有Python对象的根源。如果没有指定父类，会默认使用<code>object</code>作为该类的基类（可以使用<code>dir</code>函数查看）。</p><h2 id="重写">4.2 重写</h2><p>父类方法不满足子类需求时，可以<strong>重写（override）</strong>，直接在子类中使用和父类相同名字的属性和方法即可进行重写。重写之后会调用子类的方法，而不是父类的。</p><h3 id="覆盖父类">4.2.1 “覆盖”父类</h3><p>子类方法和父类方法完全不同，在子类中写一个和父类同名的方法实现即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工作&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CowHorse</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 当牛马就行了</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当牛马&#x27;</span>)<br></code></pre></td></tr></table></figure></p><h3 id="扩展父类">4.2.2 “扩展”父类</h3><p>方式一：<code>父类名.父类方法(self)</code></p><p>这种方法可以精准访问指定的父类。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        School.__init__(<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># 将当前实例传给父类的__init__方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>煎饼果子&#x27;</span>)  <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 现代煎饼果子</span><br></code></pre></td></tr></table></figure></p><p>方式二：<code>super().父类方法()</code>（更常用）</p><p><code>super()</code> 实际上返回的是一个 <strong>代理对象（superobject）</strong>。这个代理对象知道两件事：</p><ol type="1"><li>当前是哪个类（<code>__class__</code>）</li><li>当前实例的 MRO 是什么</li></ol><p>只能访问最近的父类，有就用，没有就往后找，找不到再报错。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从当前类的 MRO 中，从当前类的下一个开始，依次查找 __init__ 方法 ，并调用第一个</span><br><span class="hljs-built_in">super</span>().__init__()<br></code></pre></td></tr></table></figure></p><p><code>super()</code>零参数时，Python 解释器会自动填充两个参数：</p><ul><li><code>__class__</code>：当前正在定义的类。</li><li><code>self</code>：当前实例。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):    <br>        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 会自动填充当前实例的self和当前类</span><br>        <span class="hljs-built_in">super</span>().make() <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 古法Master煎饼果子</span><br></code></pre></td></tr></table></figure><blockquote><p>在Python中<code>super</code>是一个特殊的类，<code>super()</code>是使用<code>super</code>类创建出来的对象。使⽤<code>super()</code>可以⾃动查找⽗类，适合单继承使⽤，多继承不建议使用。</p></blockquote><h1 id="多态">5 多态</h1><h2 id="多态的定义">5.1 多态的定义</h2><p>当我们定义一个<code>class</code>的时候，我们实际上就定义了一种数据类型，判断一个变量是否是某个类型可以用<code>isinstance()</code>判断。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(dog, Dog)  <span class="hljs-comment"># True，Dog类型</span><br><span class="hljs-built_in">isinstance</span>(cat, Cat)  <span class="hljs-comment"># True，Cat类型</span><br><span class="hljs-built_in">isinstance</span>(dog, Animal)  <span class="hljs-comment"># True，既是Dog类型，又是Animal类型</span><br></code></pre></td></tr></table></figure><p>多态指的是<strong>同一函数对于传入的不同对象做出不同的响应</strong>。多态的好处在于，当我们需要传入<code>Dog</code>、<code>Cat</code>等等时，我们只需要接收<code>Animal</code>这个父类类型就可以，并且原有的函数对于新增的<code>Animal</code>子类也生效，这就是多态的含义。</p><p>实现多态的条件：</p><ol type="1"><li>有继承（子类继承父类）</li><li>有方法重写（子类重写父类方法）</li><li>父类引用指向子类对象（子类对象传给父类对象调用者）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;动物叫&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;汪汪汪&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;喵喵喵&#x27;</span>  <br>  <br>    <span class="hljs-comment"># 注意没有继承Animal  </span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>  <br>  <br>  <br><span class="hljs-comment"># 这个函数不关心传入的是什么类型，只关心是否有 speak 方法  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br><span class="hljs-comment"># 显式写出类型，但实际没有作用  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal: Animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br>dog = Dog()  <br>cat = Cat()  <br>car = Car()  <br>sound(dog)  <br>sound(cat)  <br>  <br><span class="hljs-comment"># 鸭子类型的体现，car虽然不是Animal，但是有speak方法  </span><br><span class="hljs-comment"># 注意这个不叫多态，因为多态的条件是有继承有重写  </span><br>sound(car)<br></code></pre></td></tr></table></figure><p>对于静态语言Java来说，多态需要继承同一父类或接口，在刚刚的例子中必须是<code>Animal</code>或其子类。而在Python中，<strong>不关心对象的类型，只关心对象的行为</strong>（即它有什么方法）。只要一个对象具有所需的方法和属性，它就可以被当作预期的类型来使用，在刚刚的例子中比如一个<code>Car</code>类，只要有<code>speak</code>方法，就可以实现多态。</p><p>Python的多态最大的特点是：<strong>鸭子类型（DuckTyping）</strong>。“如果它走起路来像鸭子，叫起来像鸭子，那么它就是鸭子。”</p><h2 id="多态的应用">5.2 多态的应用</h2><h3 id="方法重写最常见的形式">5.2.1 方法重写（最常见的形式）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">pass</span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):  <br>        <span class="hljs-variable language_">self</span>.width = width  <br>        <span class="hljs-variable language_">self</span>.height = height  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.width * <span class="hljs-variable language_">self</span>.height  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):  <br>        <span class="hljs-variable language_">self</span>.radius = radius  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>  <br>  <br>  <br><span class="hljs-comment"># 多态的体现  </span><br>shapes = [Square(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>), Circle(<span class="hljs-number">3</span>), Square(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)]  <br>  <br><span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;面积: <span class="hljs-subst">&#123;shape.area()&#125;</span>&quot;</span>)  <span class="hljs-comment"># 同样的方法调用，不同的结果</span><br></code></pre></td></tr></table></figure><h3 id="运算符重载">5.2.2 运算符重载</h3><p>相同的运算符（如 <code>+</code>, <code>*</code>）对不同类型的对象有不同的行为。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># + 运算符的多态</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)        <span class="hljs-comment"># 数字加法: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; World&quot;</span>)  <span class="hljs-comment"># 字符串拼接: Hello World</span><br><span class="hljs-built_in">print</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])     <span class="hljs-comment"># 列表合并: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></p><h3 id="内置函数的多态">5.2.3 内置函数的多态</h3><p>像 <code>len()</code> 这样的函数可以对多种类型的对象工作。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello&quot;</span>))     <span class="hljs-comment"># 字符串长度: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))   <span class="hljs-comment"># 列表元素个数: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;))  <span class="hljs-comment"># 字典键值对数量: 2</span><br></code></pre></td></tr></table></figure></p><h2 id="抽象类接口">5.3 抽象类（接口）</h2><p>在Python中，抽象类和接口是一个东西，方法体是<strong>空实现的</strong>（<code>pass</code>）称之为<strong>抽象方法</strong>，<strong>含有抽象方法的类</strong>称之为<strong>抽象类</strong>。</p><ul><li>父类用来确定有哪些方法（<strong>父类制定接口标准</strong>）</li><li>具体的方法实现有子类来实现（<strong>子类实现接口标准</strong>）</li></ul><p>在Python中，抽象类的子类并不是必须要实现所有的抽象方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;吃&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;工作&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># Person的子类要去实现eat和work两个方法</span><br></code></pre></td></tr></table></figure><h1 id="其他特性">6 其他特性</h1><h2 id="实例属性和实例方法">6.1 实例属性和实例方法</h2><p>使用<code>类名()</code>创建对象，创建对象的动作有两步：</p><ol type="1"><li>在内存中为对象分配空间<br /></li><li>调用初始化方法<code>__init__</code>为对象初始化</li></ol><p>对象创建后，内存中就有了一个对象的实实在在的存在——<strong>实例</strong>。</p><ul><li>创建出来的对象叫做<strong>类的实例</strong>，创建对象的动作叫做<strong>实例化</strong><br /></li><li>对象的属性叫做<strong>实例属性</strong>，对象的方法叫做<strong>实例方法</strong></li></ul><p>对象各自拥有自己的实例属性，可以通过<code>self.</code>访问自己的属性、调用自己的方法。</p><blockquote><p>每一个对象都有自己<strong>独立的内存空间，保存各自不同的属性</strong>。多个对象的方法，在内存中只有一份，调用方法时，需要把对象的引用传递到方法的内部。</p></blockquote><h2 id="类属性和类方法">6.2 类属性和类方法</h2><ul><li>在程序运行时，类同样会被加载到内存，在Python中，类是一个特殊的对象——<strong>类对象</strong>。</li><li>在程序运行时，类对象在内存中<strong>只有一份</strong>，使用一个类可以创建出<strong>很多个对象的实例</strong>。</li></ul><p>除了封装<strong>实例的属性和方法</strong>外，类对象还可以拥有<strong>自己的属性和方法</strong>——<strong>类属性、类方法</strong>。</p><ul><li>类属性：给类对象定义的属性，与具体对象无关，用来记录<strong>类对象的相关特征</strong></li><li>类方法：给类对象定义的方法，可以访问类对象或调用其他类方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment"># 定义类属性，描述学生数量</span><br>    count = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 定义类方法，使用@classmethod标识</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;学生的数量为<span class="hljs-subst">&#123;cls.count&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>类方法第一个参数必须为类对象，通常用<code>cls</code>表示，类似实例方法中的<code>self</code>，不需要传值。在类方法中，哪个类调用的方法，<code>cls</code>就是哪个类的引用，可以通过<code>cls.</code>访问类属性或调用类方法。</p></blockquote><p><img src="05_class_method.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问类属性</span><br>类名.类属性  <span class="hljs-comment"># 推荐</span><br>对象名.类属性 <br><br><span class="hljs-comment"># 调用类方法   </span><br>类名.类方法  <span class="hljs-comment"># 推荐</span><br>对象名.类方法<br></code></pre></td></tr></table></figure><h2 id="静态方法">6.3 静态方法</h2><p>既不需要访问实例属性和实例方法，又不需要访问类属性和类方法，就可以使用<strong>静态方法</strong>，使用装饰器<code>@staticmethod</code>来标识。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>():  <span class="hljs-comment"># 不需要self</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>)<br><br><span class="hljs-comment"># 调用静态方法</span><br>类.静态方法()   <span class="hljs-comment"># 推荐</span><br>对象.静态方法()<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Python异常与模块</title>
    <link href="/2024/05/08/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/05/08/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理">1 异常处理</h1><h2 id="异常的捕获">1.1 异常的捕获</h2><p>世界上没有完美的程序，程序运行都可能出现异常，出现异常有下面两种情况：</p><ol type="1"><li>整个程序因为一个BUG停止运行</li><li>对BUG进行提醒，整个程序继续运行</li></ol><p>实际开发更多是第2种情况，就需要<strong>捕获异常</strong>，它的作用在于：提前假设某处会出现异常，提前做好准备，当真的出现异常的时候，可以有后续手段，一般<code>try</code> 下方只放一行尝试执行的代码。</p><ul><li><code>try</code>：只有在 <code>try</code>内部的代码，才会被捕获异常</li><li><code>except</code>：匹配机制，用来匹配特定异常</li><li><code>else</code>：没有异常的时候执行</li><li><code>finally</code>：有没有异常都会执行</li></ul><p>用<code>try</code>来运行可能出错的代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至<code>except</code>语句块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">else</span>:<br>    没有异常的处理代码<br><span class="hljs-keyword">finally</span>:<br>    有没有异常都会执行的代码<br></code></pre></td></tr></table></figure><hr /><p>捕获常规异常 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span>:<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure></p><p>捕获指定异常：如果异常类型和要捕获的异常类型不一致，则无法捕获异常<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 变量:<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure></p><p>捕获多个异常：在except后使用元组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> (异常类型<span class="hljs-number">1</span>, 异常类型<span class="hljs-number">2</span>):<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure></p><p>捕获异常并输出描述信息 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> e:<br>    pirnt(e)<br></code></pre></td></tr></table></figure></p><p>捕获所有异常：<code>Exception</code>是所有异常的父类，任何异常都可以用 <code>Exception</code> 抓住<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    pirnt(e)<br></code></pre></td></tr></table></figure></p><p><code>except</code>不仅会捕获指定异常，还会将其子类一网打尽，常见错误类型和继承关系：https://docs.python.org/3/library/exceptions.html#exception-hierarchy</p><h2 id="异常的记录与抛出">1.2 异常的记录与抛出</h2><p>记录错误，使用Python内置的<code>logging</code>模块可以很方便的记录异常信息，打印完错误信息程序还会继续正常执行。通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    logging.exception(e)<br></code></pre></td></tr></table></figure></p><p>异常本质上也是一个<code>class</code>，捕获异常就是捕获该类的一个实例。异常不是凭空产生的，而是有意创造的并抛出的。必要时我们可以定义一个异常<code>class</code>，并选择好合适的继承关系，用<code>raise</code>进行抛出。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):  <br>    <span class="hljs-keyword">pass</span>  <br><br><br>a = <span class="hljs-number">10</span>  <br>b = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">&#x27;分母为0&#x27;</span>)  <br><span class="hljs-built_in">print</span>(a / b)<br></code></pre></td></tr></table></figure></p><h1 id="异常的传递">2 异常的传递</h1><p>当函数 <code>func01</code> 中发生异常,并且没有捕获处理这个异常的时候, 异常会传递到函数 <code>func02</code>, 当<code>func02</code> 也没有捕获处理这个异常的时候，<code>main</code>函数会捕获这个异常,  这就是异常的传递性。<strong>当所有函数都没有捕获异常的时候, 程序就会报错</strong>。</p><p><img src="04_exception.png" /></p><blockquote><p>利用异常具有传递性的特点，当我们想要保证程序不会因为异常崩溃的时候，就可以在<code>main</code> 函数中设置异常捕获，由于无论在整个程序哪里发生异常,最终都会传递到 <code>main</code>函数中，这样就可以确保所有的异常都会被捕获。</p></blockquote><h1 id="模块与包">3 模块与包</h1><h2 id="模块基本用法">3.1 模块基本用法</h2><p>模块就是一个Python文件，里面有类、函数、变量等，可以导入模块去使用，类似C++的头文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">from</span> 包|模块] <span class="hljs-keyword">import</span> 包|模块|函数|变量|类... [<span class="hljs-keyword">as</span> 别名]<br></code></pre></td></tr></table></figure><p>实例： 代码文件 <code>B.py</code> 中有函数：<code>B1</code><code>B2</code> <code>B3</code>，在代码文件A中使用，可以有如下写法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法一</span><br><span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 别名</span><br><span class="hljs-keyword">import</span> B <span class="hljs-keyword">as</span> b<br>b.B1()<br>b.B2()<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法二</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> B1, B2<br>B1()<br>B2()<br><span class="hljs-comment"># B3没有导入，不能使用</span><br><br><span class="hljs-comment"># 导入B中所有函数，但不推荐，因为没有方法一可读性强，归属关系不清楚</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br>B3()<br></code></pre></td></tr></table></figure><h2 id="python内置变量">3.2 Python内置变量</h2><p><code>__name__</code>变量：任何一个Python代码中，都隐式附带这个变量。</p><ul><li>当这个代码文件直接执行的时候，此变量记录值是：<code>__main__</code></li><li>当这个代码文件，作为模块被其它代码文件导入的时候，此变量记录值是：<code>代码文件名本身</code></li></ul><p>基于这个特性，我们可以区分这个文件是执行了还是被导入了。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ...       <span class="hljs-comment"># 在测试的时候，可以避免其他文件导入时该文件时，都执行测试代码</span><br></code></pre></td></tr></table></figure></p><p><code>__all__</code>变量：表示的是如果文件被<code>from 模块 import *</code>导入，则内部的哪些函数可以被<code>*</code>导入。默认是全部导入，如果不想要全部的话，可以手动赋值此变量。示例如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># B3不会被其他文件导入</span><br>__all__ = [<span class="hljs-string">&quot;B1&quot;</span>, <span class="hljs-string">&quot;B2&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B1</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B2</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B3</span>():<br>    ...<br></code></pre></td></tr></table></figure></p><h2 id="包">3.3 包</h2><p>概念：Python的包是一个特殊文件夹，这个文件夹内包含：</p><ol type="1"><li><code>__init__.py</code>的文件（用来控制模块的导入行为）</li><li>其它模块（<code>.py</code>）文件</li></ol><p>包可以帮助我们<strong>管理模块</strong>,包的作用就是包含多个模块，但包的本质依然是模块。 <imgsrc="04_init_package.png" /></p><p>实例： 文件夹<code>my_package</code>内有：</p><ul><li><code>__init__.py</code>文件</li><li>有<code>A.py</code> <code>C.py</code> 模块文件</li><li>有<code>B.py</code> 模块文件，这个模块内提供<code>B1</code><code>B2</code> <code>B3</code> 三个函数</li></ul><p>方式一：不受<code>__init__.py</code>控制 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不推荐，不好写</span><br><span class="hljs-keyword">import</span> my_package.B<br>my_package.B.B1()<br>my_package.B.B2()<br></code></pre></td></tr></table></figure></p><p>方式二：受到<code>__init__.py</code>控制 在<code>__init__.py</code>文件内写上：<code>__all__ = ["A", "B"]</code>，则可以使用A和B两个模块，无法用C这个模块。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> *<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> B1<br>B1()    <span class="hljs-comment"># 无法使用B2和B3</span><br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br></code></pre></td></tr></table></figure></p><h2 id="安装第三方包">3.4 安装第三方包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install 包名称<br></code></pre></td></tr></table></figure><p>如果网络不好可以用清华镜像，如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称<br></code></pre></td></tr></table></figure></p><p>在Pycharm直接安装 <img src="04_add_package.png" /></p><h2 id="anaconda">3.5 Anaconda</h2><p>Anaconda内置了非常多的第三方库，可以用来管理Python模块。默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习\\试学班&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_display&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\python310.zip&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\DLLs&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib\\site-packages&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_matplotlib_backend&#x27;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></p><p>可以设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。</p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Python文件操作</title>
    <link href="/2024/05/07/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/05/07/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="文件打开">1 文件打开</h1><p><code>open</code>函数，可以打开已存在的文件，或创建一个新文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(name, mode, encoding)<br></code></pre></td></tr></table></figure></p><ul><li><code>name</code>：文件路径</li><li><code>mode</code>：工作模式：只读、写入、追加等</li><li><code>encoding</code>：编码格式（推荐UTF-8）</li></ul><p>工作模式：</p><ul><li><code>r</code> ：只读（默认）</li><li><code>rb</code>：读取非文本文件（内部是01），否则会被默认按UTF-8编码）</li><li><code>wb</code>：写入非文本文件（01）</li><li><code>w</code> ：覆盖写入，原有内容会被删除</li><li><code>a</code> ：追加写入，在原有内容后追加</li></ul><p><img src="03_open_func.png" /></p><p>实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于encoding的位置不是第三个，所以要用关键字参数显式指明</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;python.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment"># 此时f是open函数的文件对象，拥有属性和方法</span><br></code></pre></td></tr></table></figure></p><h1 id="文件关闭">2 文件关闭</h1><p><code>close()</code>关闭文件对象，和打开文件是配套操作。如果不关闭，文件会被Python一直占用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.close()  <span class="hljs-comment"># 同时会自动调用 文件对象.flush() </span><br></code></pre></td></tr></table></figure></p><h1 id="文件读取">3 文件读取</h1><p>文件读取的前置要求是文件要先打开。</p><p><code>read()</code>方法： 读取文件，返回一个<strong>字符串</strong>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.read(num)<br><span class="hljs-comment"># num表示读取的长度（单位字节），没有传入num默认读取文件所有数据</span><br></code></pre></td></tr></table></figure></p><p><code>readlines()</code>方法：读取整个文件，按照行进行切分，返回一个<strong>列表</strong>，每一行数据作为一个元素，末尾添加<code>\n</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readlines()<br></code></pre></td></tr></table></figure></p><p><code>readline()</code>方法：调用一次读取一行内容，返回<strong>字符串</strong>，末尾带有<code>\n</code>。如需读取多行，需要多次调用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readline()<br></code></pre></td></tr></table></figure></p><blockquote><p>读取文件有指针标记位置，使用<code>f.seek(0)</code>回拨指针到开头。</p></blockquote><p>循环读取： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象:<br>    ...     <span class="hljs-comment"># line是每一行的字符串</span><br><br><span class="hljs-comment"># 方式二</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象.readlines():<br>    ...     <span class="hljs-comment"># line是每一行的字符串</span><br></code></pre></td></tr></table></figure></p><p><code>with open</code>：这是一种包含打开、操作、关闭的快捷操作方式，在<code>with open</code>的语句块中完成文件操作，操作完成后自动关闭文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(...) <span class="hljs-keyword">as</span> 文件对象:<br>    文件对象.read()<br>    ...<br><br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    ls = f.readlines()<br>    <span class="hljs-built_in">print</span>(ls)<br></code></pre></td></tr></table></figure></p><h1 id="文件写入">4 文件写入</h1><p>覆盖写入：</p><ul><li>调用<code>write</code>时内容并未真正写入文件，而是会积攒在程序的内存中，称之为<strong>缓冲区</strong></li><li>当调用 <code>flush</code> 的时候，内容才会真正写入文件</li><li>这样做可以避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写入磁盘）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-comment"># 2、覆盖写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入文件，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure></li></ul><p>追加写入： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-comment"># 2、追加写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入目的地，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Python数据容器</title>
    <link href="/2024/05/06/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/05/06/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="列表list">1 列表(list)</h1><h2 id="列表的创建与访问">1.1 列表的创建与访问</h2><p>列表类似C++的数组，不过列表中的数据可以为<strong>不同的数据类型</strong>，并且可以嵌套，嵌套时类似C++的多维数组。列表定义用<code>[]</code>包围，以<code>,</code>分割，正向下标从0开始，有<strong>反向索引</strong>，从-1开始，从后往前，依次递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = []   <span class="hljs-comment"># 空列表</span><br><br>demo_list = [<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;哈哈&#x27;</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>]]<br><span class="hljs-comment"># 正向索引    0      1     2       3 </span><br><span class="hljs-comment"># 反向索引   -4     -3    -2      -1</span><br><br>demo[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 得到 &#x27;哈哈&#x27;</span><br>demo[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 得到 1</span><br></code></pre></td></tr></table></figure><p>列表可以使用<code>+</code>拼接或使用<code>*</code>实现重复计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ls1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] * <span class="hljs-number">2</span><br>ls2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-built_in">print</span>(ls1)  <span class="hljs-comment"># [1, 2, 1, 2]</span><br><span class="hljs-built_in">print</span>(ls1 + ls2)  <span class="hljs-comment"># [1, 2, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="列表生成式">1.2 列表生成式</h2><p>列表生成式的效率很高，<strong>强烈建议使用列表生成式来创建列表</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ls.append(i + <span class="hljs-number">1</span>)<br>    <br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h2 id="列表的遍历">1.3 列表的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># while方式</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(my_list):<br>    <span class="hljs-built_in">print</span>(my_list[i])<br>    i++<br><br><span class="hljs-comment"># for方式</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="常用方法">1.4 常用方法</h2><p><img src="02_list.png" /></p><h1 id="元组tuple">2 元组(tuple)</h1><h2 id="元组的创建与访问">2.1 元组的创建与访问</h2><p>元组与列表类似，不同之处在于元组的元素<strong>不能修改</strong>，元组使用<code>()</code>，列表使用<code>[]</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = ()    <span class="hljs-comment"># 空元组</span><br><br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 元组内只有一个元素时，需要有逗号在内，否则小括号会识别为运算符</span><br>nums = (<span class="hljs-number">1</span>,)  √<br>nums = (<span class="hljs-number">1</span>)   ×<br><br><span class="hljs-comment"># 元组的访问和列表完全一样，通过下标访问，支持反向下标</span><br>nums[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></p><h2 id="元组的可变">2.2 元组的“可变”</h2><p>元组内有<code>list</code>的时候，元组依然遵循元素不可变，但<code>list</code>内的元素可以修改。这是因为元组存储的时候本质上存的是<code>list</code>的地址，只要地址不变，元组元素就没有修改，而所指内容是否变化和元组无关。正因为如此，替换为别的<code>list</code>也是不被允许的，因为地址发生了改变。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, 地址)<br></code></pre></td></tr></table></figure></p><p><img src="02_tuple_var.png" /></p><h2 id="打包和解包">2.3 打包和解包</h2><p>当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打包操作</span><br>a = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 解包操作</span><br>i, j, k = a<br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 10 100</span><br></code></pre></td></tr></table></figure></p><blockquote><p>解包操作对所有序列的成立，包括列表、元组、字符串、<code>range</code>都可以使用解包操作。</p></blockquote><p>解包时元素个数和变量个数不匹配会引发<code>ValueError</code>异常，不过我们可以使用星号表达式解决变量少于元素个数的情况，让一个变量接收多个值。</p><ol type="1"><li>星号修饰的变量会变成一个列表，可以存放0个或多个元素</li><li>解包语法中，只能有一个型号表达式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  <br><br><span class="hljs-comment"># 可以改变型号表达式的位置，会自动匹配</span><br>i, j, *k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 2 [3, 4, 5, 6]</span><br>  <br>*i, j, k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># [1, 2, 3, 4] 5 6</span><br></code></pre></td></tr></table></figure><blockquote><p><code>a, b = b, a</code>和<code>a, b, c = b, c, a</code>实际并没有用到打包解包语法，而是有特定的字节码指令实现这两个操作，效率非常高，在三个以上的变量交换时需要使用打包解包。</p></blockquote><h2 id="常用方法-1">2.4 常用方法</h2><p><img src="02_tuple.png" /></p><h1 id="字符串str">3 字符串(str)</h1><h2 id="字符串的创建和访问">3.1 字符串的创建和访问</h2><p>字符串同列表、元组一样，可以通过下标和反向下标进行访问。不过和C++非常不同的一点是，字符串是<strong>无法修改</strong>的容器。也就是说如果要完成修改操作，只能得到一个新的字符串，旧的字符串是无法修改的。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字符串可以使用单引号、双引号、三引号进行定义，使用三引号时可以跨行。</span><br><br>s = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment"># 空字符串</span><br><br>s = <span class="hljs-string">&#x27;hhh&#x27;</span><br>s = <span class="hljs-string">&quot;hhh&quot;</span><br>s = <span class="hljs-string">&quot;&quot;&quot;hhh</span><br><span class="hljs-string">hhhh</span><br><span class="hljs-string">hh</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 单引号里面可以包双引号，双引号里面可以包单引号</span><br>s = <span class="hljs-string">&quot;人工&#x27;智&#x27;能&quot;</span><br>s = <span class="hljs-string">&#x27;人工&quot;智&quot;能&#x27;</span><br><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></p><ul><li>字符串内部使用<code>\</code>进行转义，比如<code>\n</code>换行、<code>\t</code>缩进，又或者转义<code>\ ' "</code>这些特殊字符</li><li>Python中以<code>r</code>或<code>R</code>开头的字符串叫做原始字符串，字符串内都是本来的含义，没有所谓转义字符<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 很多字符需要转义需要很多\，可以使用r&#x27;&#x27;或R&#x27;&#x27;表示内部字符串默认不转义</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)  <span class="hljs-comment"># \    \</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>) <span class="hljs-comment"># \\\t\\</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串的运算">3.2 字符串的运算</h2><ul><li>字符串比较时按照字典序从前往后，只要其中一位大，后面就不用比较了</li><li>可以使用<code>+</code>进行拼接，还可以使用<code>*</code>将字符串重复</li></ul><h2 id="字符串的格式化">3.3 字符串的格式化</h2><p>两种方法变量的位置都可以填写表达式，Python会先计算再填入。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="常用方法-2">3.4 常用方法</h2><p>由于字符串<strong>不可变</strong>，所以使用字符串的方法并不会改变原来的字符串，而是产生新的字符串。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 转大写</span><br>su = s.upper()<br><br><span class="hljs-comment"># 转小写</span><br>sl = s.lower()<br><br><span class="hljs-comment"># replace用法，生成新的字符串，原字符串不变</span><br>s = <span class="hljs-string">&quot;Python好玩真好玩&quot;</span><br>new_s = s.replace(<span class="hljs-string">&quot;好玩&quot;</span>, <span class="hljs-string">&quot;有趣&quot;</span>)<br><span class="hljs-built_in">print</span>(s)      <span class="hljs-comment"># 结果还是  Python好玩真好玩</span><br><span class="hljs-built_in">print</span>(new_s)  <span class="hljs-comment"># 修改后的  Python有趣真有趣</span><br><br><span class="hljs-comment"># split用法，原字符串不变，生成一个新列表</span><br>name = <span class="hljs-string">&quot;Python-Java-C++&quot;</span><br>name_list = name.split(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-built_in">print</span>(name)        <span class="hljs-comment"># Python-Java-C++</span><br><span class="hljs-built_in">print</span>(name_list)   <span class="hljs-comment"># [&#x27;Python&#x27;, &#x27;Java&#x27;, &#x27;C++&#x27;]</span><br><br><span class="hljs-comment"># strip用法，去除前后指定字符串</span><br>demo = <span class="hljs-string">&quot;   hhhh  &quot;</span><br>new1 = demo.strip()       <span class="hljs-comment"># 默认去除前后空格和换行符</span><br>demo = <span class="hljs-string">&quot;1211哈哈哈21121&quot;</span><br>new2 = demo.strip(<span class="hljs-string">&quot;12&quot;</span>)   <span class="hljs-comment"># 按照单个字符，&#x27;1&#x27;和&#x27;2&#x27;都会删除</span><br><span class="hljs-built_in">print</span>(new2)    <span class="hljs-comment"># 哈哈哈</span><br></code></pre></td></tr></table></figure></p><p><img src="02_str.png" /></p><h1 id="序列的切片">4 序列的切片</h1><p>序列是指：<strong>内容连续、有序，可使用下标索引</strong>的一类数据容器。上述的列表、元组、字符串都是序列。序列支持切片操作，切片就是从原序列中取出一个子序列。</p><p>语法：<code>序列[起始下标:结束下标:步长]</code>（类似<code>range</code>序列，<code>[起始,结束)</code>范围内指定步长）表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。</p><ul><li>起始下标表示从何处开始，可以留空，留空视作从头开始</li><li>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾</li><li>步长表示依次取元素的间隔（可以为负，反向走，起始下标也要在结束下标右边）</li></ul><p><strong>注意，此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</strong></p><h1 id="字典dict">5 字典(dict)</h1><h2 id="字典的创建和访问">5.1 字典的创建和访问</h2><p>字典使用<code>&#123;&#125;</code>包围，存储的元素是<strong>键值对</strong><code>key:value</code>，并且<code>key</code>不可重复，重复会覆盖原有数据。</p><ul><li><code>key</code>数据类型<strong>必须为不可变类型</strong>，不可为字典、列表，一般类型用：字符串、整数</li><li><code>value</code> 数据类型随意，不限制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;&#125;      <span class="hljs-comment"># 空字典</span><br>d = <span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># 空字典</span><br><br>d = &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&quot;lisi&quot;</span>:<span class="hljs-number">59</span>&#125;<br><br><span class="hljs-comment"># 集合不可用下标进行访问，但可以使用key来取得对应的value</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&quot;zhangsan&quot;</span>])  <span class="hljs-comment"># 结果为100</span><br></code></pre></td></tr></table></figure><p>字典访问到不存在的<code>key</code>会报错，可以使用<code>in</code>或<code>字典.get(键, 返回值)</code>来检验。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 in 检验</span><br>d = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span> <span class="hljs-keyword">in</span> d:  <span class="hljs-comment"># 相反还有 not in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在字典&#x27;</span>)<br><br><span class="hljs-comment"># 使用 字典.get(键, 返回值) 方法</span><br><span class="hljs-comment"># 键存在则返回值，键不存在默认返回 None，也可以指定返回值</span><br><span class="hljs-keyword">if</span> d.get(<span class="hljs-string">&#x27;lisi&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># d.get(&#x27;lisi&#x27;, 1) == 1 作用一样  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不在字典&#x27;</span>)<br><br><span class="hljs-comment"># 可以用get()很方便地统计出现次数</span><br>s = <span class="hljs-built_in">input</span>()  <br>counter = &#123;&#125;  <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:  <br>    <span class="hljs-keyword">if</span> c.isalpha():  <br>        counter[c] = counter.get(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 存在返回已有值，不存在返回0</span><br></code></pre></td></tr></table></figure></p><blockquote><p>字典通过哈希算法计算<code>key</code>的位置，所以字典的<strong>查找和插入操作极快</strong>。由于要保证hash的正确性，作为<code>key</code>的对象就不能变。在Python中，字符串和整数都不可变，可以放心用作<code>key</code>，<code>list</code>可变不能作为<code>key</code>。</p></blockquote><h2 id="字典的遍历">5.2 字典的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代字典的键</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d.keys():  <span class="hljs-comment"># 等同于 for i in d:</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;k&#125;</span> 分数：<span class="hljs-subst">&#123;d[k]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 迭代字典的值</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> d.values():<br>    <span class="hljs-built_in">print</span>(v)<br><br><span class="hljs-comment"># 迭代字典的键值对</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>: <span class="hljs-subst">&#123;v&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="常用方法-3">5.3 常用方法</h2><p><img src="02_dict.png" /></p><h1 id="集合set">6 集合(set)</h1><h2 id="集合的创建">6.1 集合的创建</h2><p><code>set</code>和<code>dict</code>类似也是一组<code>key</code>的集合，但不存储<code>value</code>，由于<code>key</code>不能重复，所以在<code>set</code>中没有重复的<code>key</code>。集合内部是<strong>去重并且无序</strong>的，使用<code>&#123;&#125;</code>包围。因为无序，所以集合不可用下标进行访问。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 空集合，s = &#123;&#125; 不是空集合，而是空字典</span><br><br>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <br></code></pre></td></tr></table></figure></p><p><code>set</code>和<code>dict</code>底层原理一样，唯一的区别仅仅在于没有存储<code>value</code>，<code>key</code>是唯一的保证了<code>set</code>内部不会有重复元素，由于无法判断两个可变对象是否相等，所以<strong>不能存放可变对象</strong>。</p><blockquote><p>注意与C++非常不同的是，<strong>集合不会自动排序</strong>，<code>dict</code>和 <code>set</code>的底层哈希表会让它看起来好像有顺序，但这不是排序，只是哈希存储的结果，顺序不稳定）</p></blockquote><h2 id="集合的运算">6.2 集合的运算</h2><p><code>set</code>之间有很方便的取交集<code>&amp;</code>和取并集<code>|</code>运算。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>s2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-built_in">print</span>(s1 &amp; s2)  <span class="hljs-comment"># 交集 &#123;1, 2&#125;</span><br><span class="hljs-built_in">print</span>(s1 | s2)  <span class="hljs-comment"># 并集 &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="集合的遍历">6.3 集合的遍历</h2><p>由于集合不支持下标访问，所以不能使用<code>while</code>循环。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure></p><h2 id="常用操作">6.4 常用操作</h2><p><img src="02_set.png" /></p><h1 id="容器对比">7 容器对比</h1><p>列表、元组字符串为序列类型，集合、字典为非序列类型。</p><ul><li>是否支持下标索引<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否支持重复元素：<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否可以修改<ul><li>支持：列表、集合、字典</li><li>不支持：元组、字符串</li></ul></li></ul><p><img src="02_total_sum.png" /></p><h1 id="容器通用操作">8 容器通用操作</h1><p><img src="02_general_method.png" /></p><ul><li><code>sorted</code>：接收任意可迭代对象（<code>list、tuple、set、dict、str</code>等），返回一个<strong>新的列表</strong>（不修改原对象）。</li><li><code>.sort()</code>：<code>list</code>专属方法，<strong>直接在原列表上排序</strong>，不会返回新列表（返回<code>None</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>tp_ls = <span class="hljs-built_in">sorted</span>(tp)  <span class="hljs-comment"># 返回值为列表</span><br><br>ls = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br>ls.sort()  <span class="hljs-comment"># 直接对ls本身进行排序</span><br></code></pre></td></tr></table></figure><p><code>sorted</code>有类似C++中的<code>cmp</code>函数，可以自定义排序规则，并且支持<code>lambda</code>匿名函数，用法如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以第一个元素作为依据进行排序</span><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br>ls = <span class="hljs-built_in">sorted</span>(ls)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># x 是需要排序容器的一个元素，sorted 会把每个元素传入自定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br>    <br><span class="hljs-comment"># 自定义排序规则</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=cmp)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;bob&#x27;, 70), (&#x27;alice&#x27;, 80), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># lambda函数＋逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;carl&#x27;, 100), (&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70)]</span><br></code></pre></td></tr></table></figure></p><ul><li><code>enumerate(iterable, start=0)</code>：<ul><li><strong><code>iterable</code></strong>:任何可迭代对象（列表、元组、集合、字典、字符串等）。</li><li><strong><code>start</code></strong>:可选参数，指定索引计数的起始值。默认为 0。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]<br><br><span class="hljs-comment"># 默认 start=0</span><br><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;索引: <span class="hljs-subst">&#123;index&#125;</span>, 值: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">索引: 0, 值: apple</span><br><span class="hljs-string">索引: 1, 值: banana</span><br><span class="hljs-string">索引: 2, 值: cherry</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 使用 start=1</span><br><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits, start=<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;编号: <span class="hljs-subst">&#123;index&#125;</span>, 水果: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">编号: 1, 水果: apple</span><br><span class="hljs-string">编号: 2, 水果: banana</span><br><span class="hljs-string">编号: 3, 水果: cherry</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Python基础语法</title>
    <link href="/2024/05/05/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/05/05/coding/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="注释">1 注释</h1><ul><li>单行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br></code></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>Python不区分单双引号，都可以。</p></blockquote><h1 id="变量">2 变量</h1><p>Python的变量与C++不同，<strong>变量本身没有类型</strong>，但存储的数据本身是有类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;哈哈哈&#x27;</span><br>name = <span class="hljs-number">666</span><br><span class="hljs-built_in">print</span>(name)  <span class="hljs-comment"># name 内的值变成了666</span><br></code></pre></td></tr></table></figure><blockquote><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，例如Java和C++。</p></blockquote><p>Python变量一般不使用驼峰命名法，而是使用<strong>全小写加下划线</strong>。变量命名规则：</p><ol type="1"><li>字母、数字、下划线组成</li><li>不能以数字开头</li><li>区分大小写</li><li>不能使用关键字</li></ol><p>Python中可以把任何数据都看成一个“对象”，而变量就是在程序中用来<strong>指向这些数据对象</strong>的，对变量赋值就是把数据和变量给关联起来。</p><p>Python解释器在执行<code>a = 10</code>赋值时做以下操作：</p><ol type="1"><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p><img src="01_variable.png" /></p><h1 id="数据类型">3 数据类型</h1><p><img src="01_type.png" /></p><p>可以使用<code>type()</code>查看变量内存储的是什么类型。</p><p>数据类型转换：</p><ul><li><code>int()</code>转换为整数</li><li><code>float()</code>转换为浮点数</li><li><code>str()</code>转换为字符串</li><li><code>bool</code>转化为布尔</li><li><code>list()</code>转换为列表</li><li>…</li></ul><p>字符处理相关：</p><ul><li><code>ord()</code>获取字符的整数表示</li><li><code>chr()</code>把编码转换为对应的字符</li></ul><h1 id="运算符">4 运算符</h1><p><strong>算术运算符</strong></p><ul><li><code>+</code> 加法</li><li><code>-</code> 减法</li><li><code>*</code> 乘法</li><li><code>/</code> 除法</li><li><code>//</code> 整除</li><li><code>%</code> 取余</li><li><code>**</code> 乘方</li></ul><p><strong>赋值运算符</strong></p><ul><li><code>=</code> 将右侧结果赋予左侧变量</li></ul><p><strong>复合赋值运算符</strong></p><ul><li><code>a?=b</code> 相当于：<code>a = a?b</code> ，这个<code>?</code>可以是任何的算术运算符</li></ul><p><strong>比较运算符</strong></p><ul><li><code>==</code> 相等</li><li><code>!=</code> 不相等</li><li><code>&gt;</code> 大于</li><li><code>&lt;</code> 小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li></ul><p><strong>逻辑运算符</strong></p><ul><li><code>and</code> 全真为真</li><li><code>or</code> 全假为假</li><li><code>not</code> 取反</li></ul><h1 id="输入输出">5 输入输出</h1><h2 id="print输出">5.1 print输出</h2><p><code>print()</code>语句（函数）可以向屏幕内一次性输出多份内容，语法如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以空格分隔，内容可以是：字面量、变量、表达式。</span><br><span class="hljs-built_in">print</span>(内容<span class="hljs-number">1</span>, 内容<span class="hljs-number">2</span>, ... ,..., 内容N)<br><br><span class="hljs-comment"># 默认以回车结束，可以使用end设置</span><br><span class="hljs-built_in">print</span>(内容, end = <span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure></p><p><strong>格式化输出：</strong>两种方法变量的位置都可以填写表达式，Python会先计算再填入。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="input输入">5.2 input输入</h2><p><code>input()</code> 可以获取用户的键盘录入数据。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>()  <span class="hljs-comment"># 从键盘输入内容，赋值给name变量  </span><br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)  <span class="hljs-comment"># 输入前会输出指定的提示</span><br></code></pre></td></tr></table></figure></p><p>注意：<code>input</code>输入的内容会自动转换为<strong>字符串</strong>类型，如果需要输入数字类型，要自行转换类型。</p><p><strong>在同一行输入多个内容：</strong><code>map()</code> 的作用是：将一个函数应用到可迭代对象（如列表、元组等）的每一个元素上，并返回一个包含所有结果的迭代器。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原理：input()输入进来是字符串，split()默认按照空格分割，返回一个字符串列表</span><br><span class="hljs-comment"># map将int()函数应用到列表里的每一个元素，返回一个迭代器，可以使用变量分别接收</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>name, pwd = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure></p><p><strong>一行内输入列表：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将map返回的迭代器转换为列表</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure></p><p><strong>连续输入多行数据：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：逐行读取</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = []  <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>    row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))  <br>    mp.append(row)<br><br><span class="hljs-comment"># 特殊的字符矩阵</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>mp = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())  <span class="hljs-comment"># 将输入的字符串处理空行换行之后转为列表</span><br>    mp.append(row)<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：列表推导式</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ls.append(i + <span class="hljs-number">1</span>)<br>    <br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><h1 id="分支语句">6 分支语句</h1><h2 id="if-elif-else">6.1 if-elif-else</h2><p><code>else if</code> 可以简写为 <code>elif</code>。特殊地，Python不同于C++，<code>a &gt; 1 and a &lt; 100</code>可以简写为<code>1 &lt; a &lt; 100</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件<span class="hljs-number">1</span>:<br>    代码块<span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">2</span>:<br>    代码块<span class="hljs-number">2</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">3</span>:<br>    代码块<span class="hljs-number">3</span><br><span class="hljs-keyword">else</span>:<br>    代码块<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></p><blockquote><p>Python通过缩进区分代码块，缩进需要严格准确。缩进可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，Python对缩进极其依赖，<strong>不要使用制表键（Tab键）来缩进代码</strong>，可以在编辑器中设置Tab为4个空格。</p></blockquote><p>Python中为了简化<code>if-else</code>结构，也引入了三元运算符，结构如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">真值结果 <span class="hljs-keyword">if</span> 条件 <span class="hljs-keyword">else</span> 假值结果<br>num = <span class="hljs-number">10</span><br>res = <span class="hljs-string">&#x27;偶数&#x27;</span> <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;奇数&#x27;</span><br><span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 偶数</span><br></code></pre></td></tr></table></figure></p><h2 id="match-case">6.2 match-case</h2><p>类似C++的<code>switch-case</code>，但有所差别，不像C++遇到<code>break</code>才停止，而是只执行匹配条件的代码块。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">alp = <span class="hljs-string">&#x27;a&#x27;</span>  <br>  <br><span class="hljs-keyword">match</span> alp:  <br>    <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= x &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:  <span class="hljs-comment"># 使用条件，并且返回匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;小写字母<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写A&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span> | <span class="hljs-string">&#x27;C&#x27;</span> | <span class="hljs-string">&#x27;D&#x27;</span>:  <span class="hljs-comment"># 多个匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写B C D&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> _:  <span class="hljs-comment"># _ 代表其他情况，类似C++的default</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;其他情况&#x27;</span>)<br></code></pre></td></tr></table></figure></p><h1 id="循环语句">7 循环语句</h1><h2 id="while循环">7.1 while循环</h2><p>与C++不同的是，Python有独特的<code>循环-else</code>结构：</p><ul><li><code>else</code> 子句只在循环正常完成时执行</li><li>如果循环被 <code>break</code> 中断，<code>else</code> 部分不会执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 条件:<br>    代码块<br><span class="hljs-keyword">else</span>:<br>    代码块<br></code></pre></td></tr></table></figure><h2 id="for循环">7.2 for循环</h2><p><code>for</code>循环与C++有所不同，从待处理数据集中，挨个取出内容，将其赋给临时变量，然后执行循环语句，循环往复。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 待处理数据集:<br>    代码块<br><span class="hljs-keyword">else</span>:<br>    代码块<br></code></pre></td></tr></table></figure></p><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>，上述语法的待处理数据集，本质上应当是：<strong>可迭代对象</strong>，可以使用<code>isinstance</code>方法判断是否为可迭代对象。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure></p><p>可迭代对象（类型）：<strong>其内容可以一个个依次取出的一种类型</strong>，包括：</p><ul><li>集合数据类型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>和C++相同，Python可以使用<code>continue</code>跳过本轮循环，使用<code>break</code>中断整个循环。</p><blockquote><p>在Python中，变量作用域有些特殊，在for循环的外部访问临时变量，<strong>实际上可以访问到，但在编程规范上不建议这样做。</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure>在规范中，Python通过<code>:</code>和缩进控制作用域，实现C++中<code>&#123;&#125;</code>的作用。</p></blockquote><hr /><p><code>range()</code>可以生成数字序列，生成的数字序列是<strong>可迭代对象</strong>，与列表类似，但不是列表类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成从0开始，到num结束（但不包括num），也就是 [0, num)</span><br><span class="hljs-built_in">range</span>(num) <br><br><span class="hljs-comment"># 从num1开始，到num2结束（不包括num2），为[num1, num2)</span><br><span class="hljs-built_in">range</span>(num1, num2)<br><br><span class="hljs-comment"># 和上一个范围一样，但步长由step决定</span><br><span class="hljs-built_in">range</span>(num1, num2, step)<br></code></pre></td></tr></table></figure><p><code>range()</code>可以和<code>for</code>循环进行搭配，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-comment"># 等价于以下C++代码</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr /><p>另外Python还可以使用<code>zip</code>将多个可迭代对象放在一个循环内进行迭代。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]<br><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(x, y):<br>    <span class="hljs-built_in">print</span>(i, j)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1 10</span><br><span class="hljs-string">2 11</span><br><span class="hljs-string">3 12</span><br><span class="hljs-string">4 13</span><br><span class="hljs-string">5 14</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></p><h1 id="函数">8 函数</h1><h2 id="语法格式">8.1 语法格式</h2><p>参数和返回值可以省略，函数必须先定义再调用。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">[形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2.</span>..]</span>):<br>    函数内容<br>    [<span class="hljs-keyword">return</span> 返回值]<br><span class="hljs-comment"># Python PEP8规范：函数定义的前后分别空两行</span><br><br><span class="hljs-comment"># 调用函数</span><br>函数名([实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2.</span>..])<br></code></pre></td></tr></table></figure></p><p>实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><span class="hljs-built_in">sum</span> = add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 形参和实参一一对应，与C++不同的是，实参的传入类型不受限制。</span><br>add(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>在Python中函数可以有多个返回值，并且可以是不同类型，按照返回值顺序，用多个变量接收即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>   <span class="hljs-comment"># 本质是返回了一个元组 (&quot;zhangsan&quot;, 18)</span><br><br>name, age = test()          <span class="hljs-comment"># 等同于 name, age = (&quot;zhangsan&quot;, 18)</span><br></code></pre></td></tr></table></figure></p><p>Python是动态强类型语言，函数中可以显式声明接收的数据类型，但是没有实际作用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 规定num接收int类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(func(<span class="hljs-string">&#x27;哈哈哈&#x27;</span>))  <span class="hljs-comment"># 甚至可以传字符串</span><br></code></pre></td></tr></table></figure></p><p>在函数定义时，Python 3.5 引入了<code>-&gt;</code> 符号，常用于<strong>函数注解 (FunctionAnnotation)</strong> ，指示函数的返回值类型。可以提高代码的可读性以及可维护性，同时也能帮助工具在开发过程中进行静态类型检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>: <br>    <span class="hljs-keyword">return</span> x + y<br></code></pre></td></tr></table></figure><h3 id="位置参数">8.1.1 位置参数</h3><p>就是C++最普通的函数传值方式， 传递的参数和定义的参数<strong>一一对应</strong>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>    ...<br><br><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 数量一致，顺序一致，一一对应</span><br></code></pre></td></tr></table></figure></p><h3 id="关键字参数">8.1.2 关键字参数</h3><p>通过<strong>键值对形式</strong>显式指明形参的名称，由于会自动匹配，所以可以不按照顺序进行传入。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>    ...<br><br><br>func(x=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>, y=<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 和位置参数混用的时候，关键字传参必须在位置参数的后面，否则无法对应</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, z=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></p><h3 id="默认参数">8.1.3 默认参数</h3><p>默认参数也叫缺省参数，在定义函数时<strong>提供默认值</strong>，调用该函数时如果不传该参数则使用默认参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意有默认值的参数要在无默认值参数的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name, age=<span class="hljs-number">18</span></span>):<br>    ...<br><br><br>func(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>func(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure></p><blockquote><p>注意：缺省参数必须指向不可变对象！因为可变对象在函数内部可能会被修改，而导致和默认值不同。</p></blockquote><h3 id="不定长参数">8.1.4 不定长参数</h3><p>不定长参数也叫可变参数，用于在调用时<strong>参数数量不确定</strong>，可以使用元组接收或字典接收。</p><ul><li><p>使用元组接收： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以传入元组或列表，但args都接收为元组类型，在函数内不可变</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, *args</span>):<br>    ...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个元组，接收3, 4, 5, 6</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 已经有现成元组或列表，传入时可以加上 * 变成不定长参数</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, *ls)  <span class="hljs-comment"># x接收1，y接收2，args接收列表内的元素</span><br></code></pre></td></tr></table></figure></p></li><li><p>使用字典接收： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, **kwargs</span>):<br>    ...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个字典，内部有三个键值对</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 已经有现成字典，传入时可以加上 ** 变成不定长参数</span><br>d = &#123;name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, age: <span class="hljs-number">18</span>&#125;<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, **d)  <span class="hljs-comment"># x接收1，y接收2，kwargs接收字典内的元素</span><br><br><span class="hljs-comment"># kwargs只是d的拷贝，在函数内修改kwargs不会影响d的内容</span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="none">8.2 None</h2><p>在Python中有一个数据类型：<code>NoneType</code>，它只有一个字面量：<code>None</code>，并且不可变。 函数如果没有写<code>return</code>，则默认返回值是 <code>None</code>，或者也可以显式写<code>return None</code>。</p><p>作用：</p><ul><li><p>用在 <code>if</code> 判断中， <code>None</code>等同于<code>False</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">score</span>):<br>    <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;good&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 本行也可以省略</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(<span class="hljs-number">59</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不及格&#x27;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>用在变量声明时，暂不需要初始值可以使用 <code>None</code> 代替<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>  age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-comment"># 为了避免作用域问题，age需要在for循环外部定义</span><br><span class="hljs-comment"># for循环外定义的时候，不需要初始值，可以以None代替</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最后一个同学的年龄是：%d &quot;</span> % age)<br></code></pre></td></tr></table></figure></p></li><li><p>用于函数无返回值时</p></li></ul><h2 id="函数规范注释">8.3 函数规范注释</h2><p>使用多行注释，在函数体之前为函数进行说明解释，在Pycharm中调用函数时通过鼠标悬停可以显示函数的说明文档。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    函数说明文本</span><br><span class="hljs-string">    :param 参数1: 参数1的说明</span><br><span class="hljs-string">    :param 参数2: 参数2的说明</span><br><span class="hljs-string">    :return: 返回值的说明</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    函数体<br>    <span class="hljs-keyword">return</span> ...<br></code></pre></td></tr></table></figure></p><h2 id="变量作用域">8.4 变量作用域</h2><p>局部变量：写在函数内部的是局部变量，其作用范围只在函数内部有效。全局变量：写在函数外部的是全局变量，其作用范围在函数内外都生效。</p><p><code>global</code>关键字：可以<strong>在函数内部将局部变量声明为全局变量</strong>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():  <br>    <span class="hljs-keyword">global</span> a  <br>    a = <span class="hljs-number">100</span>  <span class="hljs-comment"># 使用global声明后，可以在函数内部修改全局变量</span><br>  <br>  <br>fun()  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出为100</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用指南</title>
    <link href="/2023/08/26/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/26/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统！</p><h1 id="安装和配置git">1 安装和配置Git</h1><h2 id="linux环境">1.1 Linux环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否安装 git</span><br>git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS 系列</span><br>sudo yum install git <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu 系列</span><br>sudo apt install git<br></code></pre></td></tr></table></figure><h2 id="macos环境">1.2 macOS环境</h2><p>使用Homebrew可以很方便地安装。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 Homebrew 是否安装</span><br>brew -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Homebrew</span><br>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>brew install git<br></code></pre></td></tr></table></figure></p><h2 id="windows环境">1.3 Windows环境</h2><p>可以先安装一个包管理工具<a href="https://scoop.sh/">Scoop</a>。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>scoop install git<br></code></pre></td></tr></table></figure></p><h2 id="配置">1.4 配置</h2><p>由于Git是分布式版本控制系统，所以安装之后还要配置个人信息。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure></p><h1 id="版本库">2 版本库</h1><p><strong>版本库又名仓库</strong>（Repository），可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪。</p><h2 id="创建版本库">2.1 创建版本库</h2><p>进入文件夹执行<code>git init</code>命令就可以把这个目录变成Git管理的仓库：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></p><blockquote><p>目录下会自动生成一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，不要乱动。</p></blockquote><p>如果想要把<code>.git</code>目录生成到别的文件夹，可以使用下面的命令指定：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init --separate-git-dir=D:/Develop/GitRecord<br></code></pre></td></tr></table></figure></p><p>实际是生成了一个<code>.git</code>文件里面写入了<code>gitdir: D:/Develop/GitRecord</code>。</p><h2 id="添加文件到版本库">2.2 添加文件到版本库</h2><p>假设当前有一个仓库叫做DemoProject，在这个目录下创建文件<code>readme.txt</code>，把文件放入仓库一共需要两步。使用<code>add</code>添加多个文件到仓库，使用<code>commit</code>一次性提交到仓库。</p><ol type="1"><li><p>使用<code>git add</code>把文件添加到仓库 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add readme.txt<br></code></pre></td></tr></table></figure>执行上面的命令，没有任何显示，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p></li><li><p>使用<code>git commit</code>把文件提交到仓库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;提交说明&quot;<br></code></pre></td></tr></table></figure></p></li></ol><p>如果想要把已有目录交给<code>git</code>管理，可以使用<code>git add .</code>将所有文件全部添加到暂存区，然后一次性<code>git commit</code>进行提交。</p><blockquote><p>所有的版本控制系统，都只能跟踪文本文件的改动，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化。另外不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。</p></blockquote><h2 id="git工作流程">2.3 Git工作流程</h2><p>牢记Git分为以下三个核心区域，它们是并列关系，构成了Git的核心工作流。</p><ul><li><strong>工作区 (Working Directory / WorkingTree)</strong>：电脑上看到的实际目录，实际开发的地方</li><li><strong>暂存区 (Staging Area / Index)</strong>：一个缓存区，保存了<code>git add</code> 准备提交的文件快照</li><li><strong>版本库 (Local Repository)</strong>：已经<code>git commit</code> 的所有历史版本</li></ul><blockquote><p>工作区有一个隐藏目录<code>.git</code>不算工作区，里面存储的是Git的<strong>版本库</strong>。暂存区（<code>index</code>文件）虽然物理上位于 <code>.git</code> 目录中，但它不属于版本库。</p></blockquote><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的<strong>暂存区</strong>，还有Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<img src="repo.png" /></p><p>了解了工作区和版本库，对于很多操作就明白实际是做什么了。</p><ul><li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区</li><li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支</li></ul><blockquote><p><strong>Git管理的是修改，而不是文件。</strong>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p></blockquote><h1 id="版本管理">3 版本管理</h1><h2 id="查看信息">3.1 查看信息</h2><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，比如是否有文件修改（新增、删除都属于修改）。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   readme.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br></code></pre></td></tr></table></figure></p><p><code>git diff</code>命令可以知道某个文件具体修改了什么内容。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff readme.txt<br></code></pre></td></tr></table></figure></p><p>提交修改和提交新文件是一样的，第一步<code>git add</code>，第二步<code>git commit</code>。</p><h2 id="版本回退">3.2 版本回退</h2><p>每一次<code>commit</code>相当于一个版本，使用<code>git log</code>可以查看版本历史记录，加上<code>--pretty=oneline</code>参数可以让显示更清晰。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log [--pretty=oneline]<br></code></pre></td></tr></table></figure></p><p>使用<code>git reset</code>回到指定版本，Git中<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，更早的版本是<code>HEAD~n</code>，n表示上n个版本，也可以直接指定版本号（不用写全，Git会自动去找）。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD^<br></code></pre></td></tr></table></figure></p><h2 id="撤销修改">3.3 撤销修改</h2><h3 id="未到暂存区">3.3.1 未到暂存区</h3><p>使用<code>git checkout -- file</code>可以丢弃工作区的修改。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure></p><blockquote><p><code>--</code> 双破折号非常重要，它告诉Git后面的参数是一个文件路径，而不是一个分支名。</p></blockquote><p>Git会执行以下操作：</p><ol type="1"><li>查找<strong>暂存区</strong>中 <code>readme.txt</code>的版本（找不到会从 <code>HEAD</code>，即最后一次提交中恢复。）</li><li>用这个版本的文件<strong>覆盖</strong>工作目录中的<code>readme.txt</code></li></ol><p>本质上这是一个反向的 <code>git add</code> 操作：<code>git add &lt;file&gt;</code>会将工作目录中的文件快照存入暂存区（index）。<code>git checkout -- &lt;file&gt;</code>会将暂存区里的文件快照<strong>还原</strong>到工作目录，从而丢弃对文件所做的所有本地修改。</p><h3 id="已到暂存区">3.3.2 已到暂存区</h3><ol type="1"><li>使用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD readme.txt<br></code></pre></td></tr></table></figure></li></ol><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><ol start="2" type="1"><li>放回工作区后，暂存区是干净的，工作区有所修改，再使用未到暂存区的处理方式<code>git checkout -- file</code>。</li></ol><h2 id="删除文件">3.4 删除文件</h2><p>当删除文件之后，工作区和版本库不一致，有两种选择。</p><ol type="1"><li>确实要从版本库删除该文件</li></ol><p>和添加文件类似，第一步<code>git rm</code>从暂存区移除，第二步<code>git commit</code>提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm readme.txt<br><br>git commit<br></code></pre></td></tr></table></figure><blockquote><p>先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和直接使用<code>git rm &lt;file&gt;</code>效果是完全相同的。</p></blockquote><ol start="2" type="1"><li>误删文件，想要恢复</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h1 id="远程仓库">4 远程仓库</h1><h2 id="ssh密钥配置">4.1 SSH密钥配置</h2><ol type="1"><li>生成SSH密钥对</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>生成在C:.ssh目录下，<code>id_ed25519.pub</code>是公钥，<code>id_ed25519</code>是私钥。</p><ol start="2" type="1"><li>将公钥添加到 GitHub<ul><li>打开 <code>C:\Users\你的用户名\.ssh\id_ed25519.pub</code>，复制内容</li><li>进入 GitHub → Settings → SSH and GPG keys → 添加新 SSH 密钥</li></ul></li><li>SSH测试连接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果看到 <code>Hi 你的用户名! You've successfully authenticated...</code> 说明SSH 配置成功。</p><h2 id="添加到远程库">4.2 添加到远程库</h2><ol type="1"><li>先在Github创建远程仓库，在本地仓库执行以下命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure></li></ol><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><ol start="2" type="1"><li>使用<code>git remote -v</code>可以检查远程仓库地址：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure></li></ol><p>如果能显示下列信息，说明远程仓库配置没问题，可以进行推送和拉取了。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">origin  git@github.com:账户名/仓库名.git (fetch)<br>origin  git@github.com:账户名/仓库名.git (push)<br></code></pre></td></tr></table></figure></p><h2 id="推送到远程库">4.3 推送到远程库</h2><p>使用远程库比本地工作流程多一步push，为下面三步：</p><ol type="1"><li><p>把改动放入暂存区 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;文件&gt;<br></code></pre></td></tr></table></figure></p></li><li><p>把暂存区改动提交到本地仓库，生成一个新的commit<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;说明&quot;<br></code></pre></td></tr></table></figure></p></li><li><p>把本地仓库的commit推送到远程仓库 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure></p></li></ol><blockquote><p>注意：如果远程仓库的默认分支是 <code>main</code>，命令里的<code>master</code> 改成 <code>main</code> 即可。Github后来把默认主分支改成<code>main</code>了。</p></blockquote><hr /><p>每次推送执行<code>git push origin master</code>命令较长，推荐<strong>在第一次推送时</strong>加上<code>-u</code>参数，除了推送之外，它还会把本地分支<code>master</code> 与远程分支 <code>origin/master</code> 关联起来。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin master<br></code></pre></td></tr></table></figure></p><p>与远程分支关联以后就可以简化命令，直接使用<code>push</code>推送，使用<code>pull</code>拉取，Git就会自动知道本地的 <code>master</code> 对应远程的<code>origin/master</code>。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br>git pull<br></code></pre></td></tr></table></figure></p><h2 id="从远程库克隆">4.4 从远程库克隆</h2><p>在本地目录运行下面命令即可克隆一个本地库。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure></p><p><code>git clone</code> 下来的仓库，Git 会自动创建一个名为<code>origin</code>的远程别名，本地分支和远程分支已经自动关联了，一般直接<code>git push / git pull</code> 就可以，不需要再手动<code>-u</code>。</p><h1 id="分支管理">5 分支管理</h1>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传和阿里云OSS</title>
    <link href="/2023/08/22/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
    <url>/2023/08/22/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。</p><p><strong>前端程序：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>  <br>    姓名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>    年龄: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>    头像: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;image&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上传文件的原始 form表单，要求表单必须具备以下三点（上传文件页面三要素）：</p><ul><li><p>表单必须有 <code>file</code> 域，用于选择要上传的文件</p></li><li><p>表单提交方式必须为 <code>POST</code>通常上传的文件会比较大，所以需要使用 <code>POST</code> 提交方式</p></li><li><p>表单的编码类型 <code>enctype</code>必须要设置为：<code>multipart/form-data</code>默认的编码格式只能上传文件名，不适合传输大型的二进制数据</p></li></ul><p><strong>后端程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span>  &#123;<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在服务端定义一个 Controller 用来进行文件上传，在 Controller当中定义一个方法来处理<code>/upload</code> 请求</li><li>在定义的方法中接收提交的数据（方法中的形参名和请求参数的名字保持一致）<ul><li>用户名：<code>String name</code></li><li>年龄： <code>Integer age</code></li><li>文件： <code>MultipartFile image</code></li></ul></li></ul><blockquote><p>Spring 中提供了一个API：<code>MultipartFile</code>，用来接收上传的文件</p></blockquote><p>后端程序打个断点，以 debug 方式启动项目，打开浏览器输入：<ahref="http://localhost:8080/upload.html">http://localhost:8080/upload.html</a>录入数据并提交，通过后端程序控制台可以看到，表单提交的三项数据(姓名、年龄、文件)存放在一个临时目录，分别存储在不同的临时文件中，当程序运行完毕之后，临时文件会自动删除。所以如果想要实现文件上传，需要将这个临时文件转存到我们的磁盘目录中。</p><p><img src="0.png" /></p><h1 id="本地存储">2. 本地存储</h1><ol type="1"><li>在服务器本地磁盘上创建 images 目录，用来存储上传的文件（例：E盘创建images 目录）</li><li>使用 <code>MultipartFile</code> 类提供的 API方法，把临时文件转存到本地磁盘目录下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">getOriginalFilename</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取原始文件名</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(File dest)</span>; <span class="hljs-comment">//将接收的文件转存到磁盘文件中</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取文件的大小，单位：字节</span><br><span class="hljs-type">byte</span>[] getBytes(); <span class="hljs-comment">//获取文件内容的字节数组</span><br>InputStream <span class="hljs-title function_">getInputStream</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取接收到的文件内容的输入流</span><br></code></pre></td></tr></table></figure><p>为保证每次上传文件时文件名都唯一的，可以使用 UUID获取随机文件名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);<br>        <span class="hljs-comment">//获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">//找到最后一个.的位置截取文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        <span class="hljs-comment">//使用UUID获取随机文件名+文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extname;<br>        <span class="hljs-comment">//将文件存储在服务器的磁盘目录</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span>+newFileName));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要上传大文件，可以在 <code>application.properties</code>进行如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置单个文件最大上传大小  </span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB  </span><br><span class="hljs-attr">​</span>  <span class="hljs-string"></span><br><span class="hljs-comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)  </span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>不安全：磁盘如果损坏，所有的文件就会丢失</li><li>容量有限：如果存储大量的图片，磁盘空间有限(磁盘不可能无限制扩容)</li><li>无法直接访问</li></ul><p>为了解决上述问题，通常有两种解决方案：</p><ul><li>自己搭建存储服务器，如：fastDFS 、MinIO</li><li>使用现成的云服务，如：阿里云，腾讯云，华为云</li></ul><h1 id="阿里云-oss">3. 阿里云 OSS</h1><p>1.在官网<ahref="https://www.aliyun.com/product/oss?spm=5176.28508143.nav-v2-dropdown-menu-0.d_main_2_0_0_2.64da154a9GfrZE&amp;scm=20140722.X_data-47ed1f95c8b1f5f652d4._.V_1">对象存储OSS_云存储服务_企业数据管理_存储-阿里云(aliyun.com)</a>注册并实名认证，打开控制台开通 OSS 对象存储服务。</p><p><img src="1.png" /></p><p>2.进入 OSS 控制台，创建 Bucket存储容器，选择<strong>本地冗余存储</strong>和<strong>公共读</strong>。</p><p><img src="2.png" /></p><p>3.在 Java 中使用 OSS，参考<ahref="https://help.aliyun.com/zh/oss/developer-reference/java-installation?spm=a2c4g.11186623.0.0.2a471d24UL9AWX">官方文档</a>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是 Java 9及以上的版本，还需要引入以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- no more than 2.3.3--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）获取 AccessKeyId</p><p><img src="3.png" /></p><p>（3）图片上传 在 Java 程序中使用 OSS服务需要提供 <code>endpoint、accessKeyId、accessKeySecret、bucketName</code> 四个量。前三个用于创建OSSClient对象，<code>OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</code>，最后一个用于确定上传的图片放在哪个Bucket 下边。 先构造一个 <code>PutObjectRequest</code> 或者<code>GetObjectRequest</code>，然后通过 <code>ossclient</code> 调用<code>putObject</code> (put 请求)/ <code>getObject</code> (get请求)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建put请求 </span><br><span class="hljs-type">PutObjectRequest</span> <span class="hljs-variable">putObjectRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PutObjectRequest</span>(bucketName, objectName, inputStream); <br><span class="hljs-comment">// 调用这个put请求，返回请求的result结果 </span><br><span class="hljs-type">PutObjectResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ossClient.putObject(putObjectRequest);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.aliyun.oss.ClientException;<br><span class="hljs-keyword">import</span> com.aliyun.oss.OSS;<br><span class="hljs-keyword">import</span> com.aliyun.oss.common.auth.*;<br><span class="hljs-keyword">import</span> com.aliyun.oss.OSSClientBuilder;<br><span class="hljs-keyword">import</span> com.aliyun.oss.OSSException;<br><span class="hljs-keyword">import</span> com.aliyun.oss.model.PutObjectRequest;<br><span class="hljs-keyword">import</span> com.aliyun.oss.model.PutObjectResult;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Endpoint以华北2（北京）为例，其它Region请按实际情况填写。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-beijing.aliyuncs.com&quot;</span>;<br>        <span class="hljs-comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。 </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yourAccessKeyId&quot;</span>; <br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yourAccessKeySecret&quot;</span>;<br>        <span class="hljs-comment">// 填写Bucket名称，例如examplebucket。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;examplebucket&quot;</span>;<br>        <span class="hljs-comment">// 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exampledir/exampleobject.txt&quot;</span>;<span class="hljs-comment">// 图片上传之后的名字</span><br>        <span class="hljs-comment">// 填写本地文件的完整路径，例如D:\\localpath\\examplefile.txt。</span><br>        <span class="hljs-comment">// 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。</span><br>        String filePath= <span class="hljs-string">&quot;D:\\localpath\\examplefile.txt&quot;</span>;<br>        <br>        <span class="hljs-comment">// 创建OSSClient实例。</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br>            <span class="hljs-comment">// 创建PutObjectRequest对象。</span><br>            <span class="hljs-type">PutObjectRequest</span> <span class="hljs-variable">putObjectRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PutObjectRequest</span>(bucketName, objectName, inputStream);<br>            <span class="hljs-comment">// 创建PutObject请求。</span><br>            <span class="hljs-type">PutObjectResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ossClient.putObject(putObjectRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (OSSException oe) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span><br><br>                    + <span class="hljs-string">&quot;but was rejected with an error response for some reason.&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());<br>            System.out.println(<span class="hljs-string">&quot;Error Code:&quot;</span> + oe.getErrorCode());<br>            System.out.println(<span class="hljs-string">&quot;Request ID:&quot;</span> + oe.getRequestId());<br>            System.out.println(<span class="hljs-string">&quot;Host ID:&quot;</span> + oe.getHostId());<br>        &#125; <span class="hljs-keyword">catch</span> (ClientException ce) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught an ClientException, which means the client encountered &quot;</span><br><br>                    + <span class="hljs-string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span><br>                    + <span class="hljs-string">&quot;such as not being able to access the network.&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Error Message:&quot;</span> + ce.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (ossClient != <span class="hljs-literal">null</span>) &#123;<br>                ossClient.shutdown();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>可以修改上述代码定义成阿里云 OSS 上传文件工具类，使用<code>@Component</code> 注解交给 IOC 容器管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.aliyun.oss.OSS;  <br><span class="hljs-keyword">import</span> com.aliyun.oss.OSSClientBuilder;  <br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;  <br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br><span class="hljs-keyword">import</span> java.util.UUID;  <br>  <br><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOssUtil</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-beijing.aliyuncs.com&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.oss-cn-beijing.aliyuncs.com/&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yourAccessKeyId&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yourAccessKeySecret&quot;</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;examplebucket&quot;</span>;  <br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-comment">// 获取上传文件的输入流  </span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();  <br>        <br>        <span class="hljs-comment">//获取文件原始名  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();  <br>        <span class="hljs-comment">//获取文件扩展名  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>));  <br>        <span class="hljs-comment">//拼接随机名加扩展名作为文件名  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFilename</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + extname;  <br>        <br>        <span class="hljs-comment">// 创建OSSClient实例。  </span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);  <br>        <span class="hljs-comment">//上传文件到 OSS       </span><br>        ossClient.putObject(bucketName, newFilename, inputStream);  <br>        <br>        <span class="hljs-comment">//文件访问路径  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> prefix + bucketName +  point + newFilename;  <br>        <br>        <span class="hljs-keyword">return</span> url;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="/2023/08/19/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/SpringBoot%E5%85%A5%E9%97%A8/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <url>/2023/08/19/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/SpringBoot%E5%85%A5%E9%97%A8/SpringBoot%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-简介">1. Spring 简介</h1><p>在正式学习 SpringBoot 之前，我们要先来了解下什么是 Spring。打开Spring 的官网<a href="https://spring.io/">Spring |Home</a>，看一下Spring的简介：<strong>Spring makes Javasimple</strong>。</p><p>Spring 发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套Spring 家族的技术，来解决对应领域的问题，我们称这一套技术为<strong>Spring 全家桶</strong>。</p><p><img src="assets/1.1.png" /></p><p>Spring 家族旗下这么多的技术，最基础、最核心的是SpringFramework。其他的 Spring 家族的技术，都是基于 SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p><p>直接基于 SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。 通过 SpringBoot可以快速的帮我们构建应用程序，SpringBoot最大的特点就是简化配置和快速开发。</p><h1 id="springboot-快速开始">2. SpringBoot 快速开始</h1><h2 id="入门程序">2.1 入门程序</h2><ol type="1"><li>创建 SpringBoot 工程项目</li></ol><p>基于 Spring 官方骨架，创建 SpringBoot工程。这一步需要联网，如果创建较慢也可以使用阿里的骨架，将 Server URL改为 <code>http://start.aliyun.com</code>。</p><p><img src="assets/2.1.png" /></p><p>基本信息描述完毕之后，勾选所需的依赖，需要什么添加什么，这里添加 Web开发相关依赖。</p><p><img src="assets/2.2.png" /></p><p>点击 Create 之后，就会联网创建这个 SpringBoot 工程。注意：在联网创建过程中，会下载相关资源(请耐心等待)</p><ol start="2" type="1"><li>定义请求处理类</li></ol><p>在 com.baoduo 这个包下创建一个子包 controller，在 controller包下新建一个类 HelloController，添加如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>运行测试</li></ol><p>运行 SpringBoot 自动生成的启动类SpringBootQuickStartApplication，打开浏览器，输入<code>http://localhost:8080/hello</code> 即可访问。</p><blockquote><p>在 SpringBoot 项目中，静态资源(html，css，js等前端资源)默认可以存放的目录： - classpath:/static/ -classpath:/public/ - classpath:/resources/ -classpath:/META-INF/resources/</p><p>classpath：代表的是类路径，在 Maven 的项目中，其实指的就是src/main/resources 或者 src/main/java，但是 Java 目录是存放 Java代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources下。</p></blockquote><h2 id="web分析">2.2 Web分析</h2><p>浏览器：</p><ul><li>输入网址：<code>http://192.168.100.11:8080/hello</code>，通过 IP地址192.168.100.11定位到网络上的一台计算机</li></ul><blockquote><p>之前在浏览器中输入的 localhost，就是127.0.0.1（本机）</p></blockquote><ul><li>通过端口号8080找到计算机上运行的程序</li></ul><blockquote><p><code>localhost:8080</code> ,意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote><ul><li>/hello 是请求资源位置<ul><li>资源：对计算机而言资源就是数据</li><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul><blockquote><p><code>localhost:8080/hello</code>，意思是向本地计算机中的8080端口程序，获取资源位置是 /hello 的数据8080端口程序，在服务器找 /hello 位置的资源数据，发给浏览器</p></blockquote></li></ul><p>服务器：（可以理解为 ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：/hello）</li><li>在服务器上找到 /hello 的资源</li><li>把资源发送给浏览器</li></ul><blockquote><p>网络三要素： - IP ：网络中计算机的唯一标识 - 端口：计算机中运行程序的唯一标识 - 协议 ：网络中计算机之间交互的规则</p></blockquote><blockquote><p><strong>问题：浏览器和服务器两端进行数据交互，使用什么协议？</strong><strong>答案： HTTP 协议</strong></p></blockquote><h2 id="起步依赖">2.3 起步依赖</h2><p>在 SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在刚刚的入门程序中引用的<code>spring-boot-starter-web</code> 和<code>spring-boot-starter-test</code>，就是起步依赖。</p><p>以入门程序中引入的起步依赖为例：</p><ul><li><code>spring-boot-starter-web</code>：包含了 Web应用开发所需要的常见依赖</li><li><code>spring-boot-starter-test</code>：包含了单元测试所需要的常见依赖</li></ul><p><code>spring-boot-starter-web</code> 内部把关于 Web开发所有的依赖都已经导入并且指定了版本，只需引入<code>spring-boot-starter-web</code> 依赖就可以通过依赖传递自动导入 Web开发需要依赖</p><blockquote><p>刚刚的 SpringBoot 入门程序中，并没有把程序部署到 Tomcat 的 webapps目录下也可以运行，是因为 SpringBoot 中引入了 Web 运行环境(也就是引入spring-boot-starter-web 起步依赖)，其内部已经集成了内置的 Tomcat服务器。 我们可以通过 IDEA 开发工具右侧的 Maven面板中，看到当前工程引入的依赖。其中已经将 Tomcat的相关依赖传递下来了，也就是说在 SpringBoot 中可以直接使用 Tomcat服务器。</p></blockquote><p><img src="assets/2.3.png" /></p><p>Spring 的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的 starter即可。官方地址：<ahref="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters">SpringBoot Reference Documentation</a></p><p>每一个起步依赖，都用于开发一个特定的功能。</p><blockquote><p>举例：当我们开发中需要使用 Redis 数据库时，只需要在 SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入 Redis开发所需要的依赖。</p></blockquote><h2 id="springboot-父工程">2.4 SpringBoot 父工程</h2><p>前面的 SpringBoot 入门程序中，通过 Maven引入的依赖，是没有指定具体的依赖版本号的。因为每一个 SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</p><p><img src="assets/2.4.png" /></p><h1 id="请求响应">3. 请求响应</h1><h2 id="前言">3.1 前言</h2><p>在入门程序中，我们在浏览器发起请求，请求了后端 Web服务器(也就是内置的 Tomcat)。请求会被部署在 Tomcat 中的 Controller接收，然后 Controller 给浏览器响应了一个字符串 “HelloWorld”，而在请求响应的过程中是遵循 HTTP 协议的。</p><p>其实在 Tomcat 这类 Web 服务器中，是不识别我们自己定义的 Controller的。但前面提到 Tomcat 是一个 Servlet 容器，是支持 Serlvet 规范的，所以在Tomcat 中可以识别 Servlet 程序。 那我们所编写的 XxxController是如何处理请求的，又与 Servlet 之间有什么联系呢？</p><p>在 SpringBoot 进行 Web 程序开发时，它内置了一个核心的 Servlet 程序DispatcherServlet，称之为核心控制器。 DispatcherServlet负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由 DispatcherServlet给浏览器响应数据。</p><p>浏览器发送请求，会携带请求数据，包括：请求行、请求头。请求到达 Tomcat之后，Tomcat 会负责解析这些请求数据，然后将解析后的请求数据封装到HttpServletRequest 对象中，我们可以通过 HttpServletRequest对象获取到请求数据；对请求进行处理之后，通过 HttpServletResponse对象可以设置响应数据， 然后 Tomcat 将响应数据响应给浏览器。</p><p>•请求（HttpServletRequest）：获取请求数据•响应（HttpServletResponse）：设置响应数据</p><p><img src="assets/3.1.png" /></p><p>上述的这种浏览器/服务器的架构模式，我们称之为：BS架构。</p><ul><li>BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。在浏览器网页直接访问的都是BS 架构（维护方便  体验一般）</li><li>CS 架构：Client/Server，客户端/服务器架构模式。需要下载安装的都是 CS架构（开发、维护麻烦   体验不错）</li></ul><h2 id="请求">3.2 请求</h2><h3 id="postman">3.2.1 Postman</h3><p>在前后端分离开发模式下，后端技术人员在开发过程中，没有前端页面怎么测试自己所开发的程序？</p><p>方式1：直接使用浏览器，在浏览器中输入地址测试后端程序。</p><ul><li>在浏览器地址栏中输入地址这种方式都是 GET 请求，不能使用 POST请求</li><li>要使用 POST 请求，需要自己编写前端代码（比较麻烦）</li></ul><p>方式2：使用专业的接口测试工具，比如 Postman，还有一些基于 Postman衍生的 Apipost 和 Apifox。</p><p><strong>Postman</strong> 是一款功能强大的网页调试与发送网页 HTTP请求的应用，常用于进行接口测试。</p><blockquote><p>Postman 原是 Chrome浏览器的插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP 请求 使用 Postman还可以在发起请求时，携带一些请求参数、请求头等信息</p></blockquote><p><a href="https://www.postman.com/downloads/">Download Postman | GetStarted for Free</a>直接安装</p><p><img src="assets/3.2.png" /></p><h3 id="简单参数">3.2.2 简单参数</h3><p>在原始的 Web 程序中，需要通过 Servlet 中提供的API：<code>HttpServletRequest</code>（请求对象），获取请求的相关信息。</p><blockquote><p>Tomcat 接收到 HTTP 请求时：把请求的相关信息封装到<code>HttpServletRequest</code> 对象中</p></blockquote><p>在 Controller 中，要想获取 <code>HttpServletRequest</code>对象，可以直接在方法的形参中声明 <code>HttpServletRequest</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br><span class="hljs-comment">//http://localhost:8080/simpleParam?name=Tom&amp;age=10</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//name就是请求参数名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//age就是请求参数名</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(ageStr);<span class="hljs-comment">//需要手动进行类型转换</span><br>        System.out.println(name+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Springboot 的环境中，对原始的 API进行了封装，接收参数的形式更加简单。如果是简单参数，参数名与形参变量名相同，定义<strong>同名的形参即可接收参数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name , Integer age )</span>&#123;<br>    <span class="hljs-comment">//形参名和请求参数名保持一致即可，SpringBoot自动完成类型转换</span><br>        System.out.println(name+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不论是 GET 请求还是 POST 请求，对于简单参数来讲，只要保证请求参数名和Controller 方法中的形参名保持一致，就可以获取到请求参数中的数据值。</p></blockquote><p>如果方法形参名称与请求参数名称不一致，Controller方法中的形参就无法接收到请求数据，如果我们开发中，需要请求参数名和Controller 方法中的形参名不相同时，可以使用 Spring 提供的<code>@RequestParam</code> 注解完成映射。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;<br>        System.out.println(username+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><span class="citation" data-cites="RequestParam">@RequestParam</span>中的 required 属性默认为true，代表该请求参数必须传递，如果不传递将报错，如果该参数是可选的，可以将required 属性设置为false，<code>@RequestParam(name = "name", required = false)</code></p></blockquote><h3 id="实体参数">3.2.3 实体参数</h3><p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端Controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p><p>此时，我们可以将请求参数封装到一个实体类对象中。要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong>，注意是<strong>属性名</strong>。</p><p>定义 entity 实体类（POJO）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    getter setter toString...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleEntity?name=Tom&amp;age=10</span><br>    <span class="hljs-comment">//请求参数与实体的属性名相同</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleEntity&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplePojo</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果实体中有属性也是实体，属于复杂实体类。要遵循：<strong>请求参数名与形参对象属性名相同，请求参数按照对象层次结构关系中间用<code>.</code> 连接</strong>。</p><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">//地址对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/complexPojo?name=Tom&amp;age=10&amp;address.province=henan&amp;address.city=zhengzhou</span><br>    <span class="hljs-comment">//请求参数使用 xxx.xxx 表示嵌套属性</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/complexEntity&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">complexPojo</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组集合参数">3.2.4 数组集合参数</h3><p>在 HTML的表单中，复选框是支持多选的，可以提交选择的多个值。其实多个值也是一个一个的提交，后端程序接收多个值可以使用数组或集合。</p><p><strong>数组</strong>：<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//方式一：http://localhost:8080/arrayParam?hobby=game&amp;hobby=java</span><br>    <span class="hljs-comment">//方式二：http://localhost:8080/arrayParam?hobby=game,java</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[] hobby)</span>&#123;<br>    <span class="hljs-comment">//1. 形参定义为数组类型</span><br>    <span class="hljs-comment">//2. 请求参数与数组名相同</span><br>        System.out.println(Arrays.toString(hobby));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>集合</strong>：<strong>请求参数名与形参集合对象名相同且请求参数为多个，<code>@RequestParam</code>绑定参数关系</strong></p><blockquote><p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用<code>@RequestParam</code>绑定参数关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//方式一：http://localhost:8080/arrayParam?hobby=game&amp;hobby=java</span><br>    <span class="hljs-comment">//方式二：http://localhost:8080/arrayParam?hobby=game,java</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/listParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; hobby)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@RequestParam注解</span><br>    <span class="hljs-comment">//2. 请求参数与集合对象名相同</span><br>        System.out.println(hobby);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日期参数">3.2.5 日期参数</h3><p>日期的格式多种多样（如：2024-08-08 10:05:45 、2024/08/0810:05:45），那么对于日期类型的参数在进行封装的时候，需要通过<code>@DateTimeFormat</code> 注解，以及其 pattern属性来设置日期的格式。</p><ul><li><code>@DateTimeFormat</code> 注解的 <code>pattern</code>属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。</li><li>后端 Controller 方法中，需要使用 <code>Date</code> 类型或<code>LocalDateTime</code> 类型，来封装传递的参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/dateParam?updateTime=2024-08-08 10:05:45</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@DateTimeFormat注解，并指定pattern</span><br>    <span class="hljs-comment">//2. 形参使用Date或LocalDateTime类型，请求参数名与形参名相同</span><br>        System.out.println(updateTime);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="json-参数">3.2.6 JSON 参数</h3><p>在前后端进行交互时，如果是比较复杂的参数，通常会使用 JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）</p><p>学习 JSON 格式参数，主要从以下两个方面着手：</p><ol type="1"><li>Postman 在发送请求时，如何传递 JSON 格式的请求参数</li></ol><p><img src="assets/3.3.png" /></p><ol start="2" type="1"><li>在服务端的 Controller 方法中，如何接收 JSON 格式的请求参数</li></ol><ul><li>传递 JSON 格式的参数，在 Controller 中会使用实体类进行封装。</li><li>封装规则：<strong>JSON 数据键名与形参对象属性名相同，定义 entity实体类型形参即可接收参数。需要使用 <code>@RequestBody</code>标识。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">//地址对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/jsonParam 参数在请求体中</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/jsonParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@RequestBody注解</span><br>    <span class="hljs-comment">//2. 使用实体接收参数，实体属性名与JSON键名相同</span><br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径参数">3.2.7 路径参数</h3><p>在开发中，经常还会直接在请求的URL中传递参数。例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/user/<span class="hljs-number">1</span>          <br><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">880</span>/user/<span class="hljs-number">1</span>/<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>上面这种传递请求参数的形式我们称之为：路径参数。</p><ul><li>前端：通过请求 URL 直接传递参数</li><li>后端：使用 <code>&#123;…&#125;</code> 来标识该路径参数，需要使用<code>@PathVariable</code> 注解获取路径参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/1/ogonez   </span><br>    <span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id, <span class="hljs-meta">@PathVariable</span> String name)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@PathVariable注解获取路径参数</span><br>    <span class="hljs-comment">//2. 请求路径中用&#123;&#125;标识路径参数</span><br>        System.out.println(id+ <span class="hljs-string">&quot; : &quot;</span> +name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结">3.2.8 小结</h3><ol type="1"><li>简单参数<ul><li>定义方法形参，请求参数名与形参变量名一致</li><li>如果不一致，通过 <code>@RequestParam</code> 手动映射</li></ul></li><li>实体参数<ul><li>请求参数名与实体对象的属性名一致</li></ul></li><li>数组集合参数<ul><li>数组：请求参数名与数组名一致</li><li>集合：请求参数名与集合名一致，<code>@RequestParam</code>绑定关系</li></ul></li><li>日期参数<ul><li><code>@DateTimeFormat</code></li><li><code>pattern</code> 属性指定日期格式</li></ul></li><li>JSON参数<ul><li><code>@RequestBody</code>，键名和对象属性名一致</li></ul></li><li>路径参数<ul><li><code>@PathVariable</code>，使用<code>&#123;...&#125;</code>表示路径</li></ul></li></ol><h2 id="响应">3.3 响应</h2><h3 id="responsebody">3.3.1 <span class="citation"data-cites="ResponseBody">@ResponseBody</span></h3><p>前面提到 HTTP 协议的交互方式：请求响应模式（有请求就有响应）Controller 程序除了接收请求外，还可以进行响应。</p><p>在前面所编写的 Controller 方法中，都已经设置了响应数据。Controller方法中的 return 的结果，怎么响应给浏览器呢？使用<code>@ResponseBody</code> 注解：</p><ul><li>类型：方法注解、类注解</li><li>位置：书写在 Controller 方法上或类上</li><li>作用：将<strong>方法返回值直接响应给浏览器</strong><ul><li>如果返回值类型是实体对象/集合，将会转换为 JSON格式后再响应给浏览器</li></ul></li></ul><p>但是刚刚写的的 Controller 中，只是在类上添加了<code>@RestController</code> 注解、方法添加了<code>@RequestMapping</code> 注解，这是因为 <code>@RestController</code>注解是一个组合注解，在类上添加 <code>@RestController</code>就相当于添加了 <code>@ResponseBody</code>注解，表示当前类下所有的方法返回值做为响应数据。</p><p><code>@RestController</code> = <code>@Controller</code> +<code>@ResponseBody</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@RestController源码：</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span>   <span class="hljs-comment">//元注解（修饰注解的注解）</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="hljs-comment">//元注解</span><br><span class="hljs-meta">@Documented</span>    <span class="hljs-comment">//元注解</span><br><span class="hljs-meta">@Controller</span>   <br><span class="hljs-meta">@ResponseBody</span> <br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RestController &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = Controller.class</span><br><span class="hljs-meta">    )</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一响应结果">3.3.2 统一响应结果</h3><p>如果我们开发一个大型项目，项目中 Controller方法将成千上万，返回值各种各样，没有任何的规范，将造成整个项目难以维护。所以我们会定义一个统一的返回结果。方案如下：</p><p>前端：只需要按照统一格式的返回结果进行解析，就可以拿到数据。</p><p>统一的返回结果使用类来描述，在这个结果中包含：</p><ul><li>响应状态码 <code>code</code>：当前请求是成功，还是失败</li><li>状态码信息 <code>msg</code>：给页面的提示信息</li><li>返回的数据<code>data</code>：给前端响应的数据（字符串、对象、集合）</li></ul><p>定义在一个实体类 Result 来包含以上信息。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应码 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(Integer code, String msg, Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    getter setter...<br><br>    <span class="hljs-comment">//增删改 成功响应(不需要给前端返回数据)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应(把查询结果做为返回数据响应给前端)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;success&quot;</span>, data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>( <span class="hljs-number">0</span>, msg, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分层解耦">4. 分层解耦</h1><h2 id="前言-1">4.1 前言</h2><p>如果将获取数据的代码，处理数据的逻辑代码，给页面响应的代码全部都堆积在一起，写在Controller 方法中。业务逻辑稍微复杂一点，Controller方法的代码量就会很大。</p><ul><li>当我们要修改操作数据部分的代码，需要改动 Controller</li><li>当我们要完善逻辑处理部分的代码，需要改动 Controller</li><li>当我们需要修改数据响应的代码，还是需要改动 Controller</li></ul><p>这样就会造成我们整个工程代码的复用性比较差，而且代码难以维护。在现在的开发中，有非常成熟的解决思路，那就是分层开发。</p><h2 id="三层架构">4.2 三层架构</h2><p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一。</p><blockquote><p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p></blockquote><p>我们的程序大致上有这样三部分：</p><ul><li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li><li>逻辑处理：负责业务逻辑处理的代码。</li><li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li></ul><p>按照上述的三个部分，在项目开发中，我们可以将代码分为三层：</p><ul><li>Controller：控制层。接收前端发送的请求，与浏览器直接交互，对请求进行处理，并响应数据。</li><li>Service：业务逻辑层。处理具体的业务逻辑。</li><li>Dao：数据访问层(Data AccessObject)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li></ul><blockquote><p>在传统的 Java 应用中，通常会使用 DAO（Data AccessObject）模式来处理数据的访问和持久化。而在 MyBatis等持久层框架中，通常会使用 Mapper 来实现类似的功能。DAO 和 Mapper在目标上是相似的，都是用来处理数据的访问，但它们在具体的实现和用法上有一些区别。1. 命名和用法： DAO是一种设计模式，通常使用接口和实现类来定义和实现对数据的访问。在传统的Java 应用中，DAO 接口中定义了访问数据库的方法，而 DAO的实现类则包含了具体的数据库操作。 Mapper 是 MyBatis 中的概念，用于执行SQL 语句并映射结果。在 MyBatis 中，Mapper 通常是一个 Java接口，其中定义了与数据库交互的 SQL 映射语句。 2. SQL 映射： DAO 通常将SQL 语句嵌入到 DAO 实现类中，可能是直接写在代码里，也可能通过 XML等方式配置在实现类中。 Mapper 中的 SQL 语句通常是通过 XML文件进行配置，这样可以将 SQL 语句与 Java 代码分离，使代码更易于维护。 3.框架依赖： DAO 模式是一种通用的设计模式，可以在任何 Java应用中使用，不依赖于特定的持久层框架。 Mapper 是 MyBatis框架的概念，特定于 MyBatis 的用法和配置。 4. 数据映射： DAO通常返回原始的数据对象，需要手动将结果集映射到 Java 对象。 Mapper 使用MyBatis 提供的 ResultMap 等机制，自动将结果集映射为 Java 对象。</p></blockquote><p>基于三层架构的程序执行流程：</p><p><img src="assets/4.1.png" /></p><ul><li>Controller 层<strong>接收</strong>前端发起的请求，调用 Service层来进行处理（接收 Service返回的结果之后将数据<strong>响应</strong>给前端）</li><li>Serivce 层从 Dao层获取数据进行<strong>逻辑处理</strong>（处理完成之后，把处理结果返回给Controller 层）</li><li>Dao 层<strong>操作数据库中的数据</strong>（Dao 拿到的数据返回给Service 层）</li></ul><p>结构如下：</p><p><img src="assets/4.2.png" /></p><p>Controller 层中调用 Service 层的方法，先创建 Service 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EmpService</span> <span class="hljs-variable">empService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpServiceImpleA</span>();<br></code></pre></td></tr></table></figure><p>Service 层中调用 Dao 层的方法，先创建 Dao 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EmpDao</span> <span class="hljs-variable">empDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpDao</span>();<br></code></pre></td></tr></table></figure><p>三层架构的好处：</p><ol type="1"><li>复用性强</li><li>便于维护</li><li>利用扩展</li></ol><h2 id="分层解耦-1">4.3 分层解耦</h2><p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p><ul><li>内聚：软件中各个功能模块内部的功能联系。</li><li>耦合：衡量软件中各个层/模块之间的依赖、关联的程度。</li></ul><p><strong>软件设计原则：高内聚低耦合。</strong></p><blockquote><p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即“高内聚”。低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p></blockquote><p>在刚刚的程序中，把业务类变为 EmpServiceB 时，需要修改 Controller层中的代码，Service 的命名发生改变时，Controller 里创建的 Service对象也要改名。Service 代码和 Controller 产生耦合。</p><p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p><p><img src="assets/4.3.png" /></p><p>之前的程序中，需要什么对象，就直接 new一个，这种做法会使层与层之间代码耦合，所以不能 new，但是不 new就没有对象，程序就会报错。</p><p>我们可以找一个中间人来联系它们，我们采用以下思路：</p><ul><li>提供一个容器，容器中存储一些对象(例：EmpService对象)</li><li>Controller 程序从容器中获取 EmpService 类型的对象</li></ul><p>我们想要实现上述解耦操作，就涉及到 Spring 中的两个核心概念：</p><ul><li><p><strong>控制反转：</strong> Inversion Of Control，简称<strong>IOC</strong>。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p><blockquote><p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或 Spring 容器</p></blockquote></li><li><p><strong>依赖注入：</strong> Dependency Injection，简称<strong>DI</strong>。容器为应用程序提供运行时所依赖的资源，称之为依赖注入。</p><blockquote><p>程序运行时需要某个资源，此时容器就为其提供这个资源。例：EmpController 程序运行时需要 EmpService 对象，Spring容器就为其提供并注入 EmpService 对象</p></blockquote></li></ul><p>IOC 容器中创建、管理的对象，称之为：bean 对象</p><p>要想实现解耦，可以将 Service 层及 Dao 层的实现类，交给 IOC 容器管理<code>@Component</code> 表示当前类由 IOC 容器管理 为 Controller程序中注入依赖的 Service 层对象，为 Service 程序中注入依赖的 Dao层对象时依赖的对象 <code>@Autowired</code> ，就可以实现程序运行时 IOC容器自动注入需要的依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpServiceA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmpService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span><br>    <span class="hljs-keyword">private</span> EmpDao empDao ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ioc">4.4 IOC</h2><p>IOC 控制反转，就是将对象的控制权交给 Spring 的 IOC 容器，由 IOC容器创建及管理对象。IOC 容器创建的对象称为 Bean 对象。</p><p>要把对象交给 IOC容器管理，需要在类上添加一个注解：<code>@Component</code></p><p>Spring 框架为了更好的标识 Web 应用程序开发中 bean对象到底归属于哪一层，又提供了 <code>@Component</code> 的衍生注解：</p><table><thead><tr><th>注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td><span class="citation"data-cites="Controller">@Controller</span></td><td><span class="citation"data-cites="Component的衍生注解">@Component的衍生注解</span></td><td>标注在控制器类上（RestController包含了）</td></tr><tr><td><span class="citation" data-cites="Service">@Service</span></td><td><span class="citation"data-cites="Component的衍生注解">@Component的衍生注解</span></td><td>标注在业务类上</td></tr><tr><td><span class="citation"data-cites="Repository">@Repository</span></td><td><span class="citation"data-cites="Component的衍生注解">@Component的衍生注解</span></td><td>标注在数据访问类上（由于与mybatis整合，用的少）</td></tr><tr><td><span class="citation" data-cites="Component">@Component</span></td><td>声明bean的基础注解</td><td>不属于以上三类时，用此注解</td></tr></tbody></table><p><code>@Service</code> 和 <code>@Repository</code> 源码：</p><p><img src="assets/4.4.png" /></p><p>在 IOC 容器中，每一个 Bean 都有一个属于自己的名字，可以通过注解的value 属性指定 bean 的名字。如果没有指定，默认为类名首字母小写。</p><p>在 IDEA 中运行项目之后可以在 Actuator 中查看所有 Bean：</p><p><img src="assets/4.5.png" /></p><blockquote><p>使用以上四个注解都可以声明 Bean，但是在 SpringBoot 集成 Web开发中，声明控制器 Bean 只能用 <code>@Controller</code>。</p></blockquote><p>使用四大注解声明的 Bean，要想生效，还需要被组件扫描注解<code>@ComponentScan</code> 扫描，<code>@ComponentScan</code>注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解<code>@SpringBootApplication</code> 中，<strong>默认扫描的范围是SpringBoot 启动类所在包及其子包</strong>。</p><h2 id="di">4.5 DI</h2><p>DI 依赖注入，是指 IOC容器要为应用程序提供运行时所依赖的资源，而资源指的就是对象。</p><p><code>@Autowired</code> 完成依赖注入的操作，而这个 Autowired翻译过来叫：自动装配。</p><p><code>@Autowired</code>注解，默认是按照<strong>类型</strong>进行自动装配的（去 IOC容器中找某个类型的对象，然后完成注入操作）</p><blockquote><p>举例：在 EmpController 运行的时候，要到 IOC 容器当中去查找 EmpService这个类型的对象，而我们通过 <code>@Service</code> 将 EmpService这个类型的对象交给了 IOC容器，所以就找到了这个类型的对象完成注入操作。</p></blockquote><p>如果在 IOC 容器中，存在多个相同类型的 Bean 对象，比如上面的EmpServiceA 和 EmpServiceB，可以使用以下方案：</p><ul><li><code>@Primary</code> 注解：设定当前类为默认的实现。</li></ul><p><img src="assets/4.6.png" /></p><ul><li><code>@Qualifier</code> 注解：指定要注入的 Bean 对象，通过 value属性指定要注入的 Bean 的名称。不能单独使用，必须配合<code>@Autowired</code> 使用</li></ul><p><img src="assets/4.7.png" /></p><ul><li><code>@Resource</code> 注解：指定要注入的 Bean 对象，通过 name属性指定要注入的 Bean 的名称。</li></ul><p><img src="assets/4.8.png" /></p><p><code>@Autowird</code> 与 <code>@Resource</code> 的区别</p><ul><li><code>@Autowired</code> 是 <strong>Spring</strong>框架提供的注解，而 <code>@Resource</code> 是 <strong>JDK</strong>提供的注解</li><li><code>@Autowired</code> 默认是按照<strong>类型</strong>注入，而<code>@Resource</code> 是按照<strong>名称</strong>注入</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpingBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis教程</title>
    <link href="/2023/08/16/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MyBatis%E6%95%99%E7%A8%8B/MyBatis%E6%95%99%E7%A8%8B/"/>
    <url>/2023/08/16/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MyBatis%E6%95%99%E7%A8%8B/MyBatis%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis-简介">1. MyBatis 简介</h1><p>在图形化客户端工具中，编写增删改查的 SQL语句，发给数据库管理系统，由数据库管理系统执行 SQL语句并返回执行结果。（增删改操作：返回受影响行数。查询操作：返回结果集）</p><p>后端开发人员通常需要使用 Java程序操作数据库，现在主流的方式是：Mybatis。</p><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong>，用于简化 JDBC的开发。<ul><li>持久层：数据访问层(Dao)，用来操作数据库。</li><li>框架：是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。</li></ul></li><li>MyBatis 本是 Apache 的一个开源项目 iBatis，2010年这个项目由 Apache迁移到了 google code，并且改名为 MyBatis 。2013年11月迁移到Github。</li><li>官网：<a href="https://mybatis.net.cn/">MyBatis中文网</a></li></ul><h1 id="mybatis-快速开始">2. MyBatis 快速开始</h1><h2 id="开始程序">2.1 开始程序</h2><ol type="1"><li>创建工程，添加依赖</li></ol><p><img src="2.1.png" /></p><ol start="2" type="1"><li><p>准备数据，创建表并创建对应的实体类。实体类的属性名与表中的字段名一一对应。</p></li><li><p>配置 MyBatis</p></li></ol><p>图形化界面连接数据库需要以下信息，称为数据库连接四要素：</p><ul><li>驱动</li><li>用户名</li><li>密码</li><li>数据库连接字符串</li></ul><p><img src="2.2.png" /></p><p>MyBatis 的配置同样需要这些信息，在 SpringBoot 项目中，可以编写<code>application.properties</code> 文件，配置数据库连接信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#驱动类名称</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment">#数据库连接的url</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/cater</span><br><span class="hljs-comment">#连接数据库的用户名</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-comment">#连接数据库的密码</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>编写 SQL 语句（注解/XML）</li></ol><p>在 SpringBoot 项目中，在启动类所在包下，创建一个包 mapper，在 mapper包下创建一个接口 XxxMapper，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper，和 Dao 层一样）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;        <br>    <span class="hljs-comment">//查询所有用户数据    </span><br>    <span class="hljs-meta">@Select(&quot;select name, age, gender from user&quot;)</span>    <br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Mapper</code> 注解：表示是 Mybatis 中的 Mapper 接口(代替SpringBoot 中的 <code>@Repository</code>)程序运行时会自动生成接口的实现类对象(代理对象)，并给交 Spring 的 IOC容器管理</p><p><code>@Select</code> 注解：代表的就是 select 查询，用于书写 SQL语句，还有<code>@Insert</code>，<code>@Delete</code>，<code>@Update</code></p><ol start="5" type="1"><li>单元测试</li></ol><p>在 SpringBoot 项目中，src 下的 test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解<code>@SpringBootTest</code>，代表该测试类已经与 SpringBoot 整合。该测试类在运行时，会自动通过启动类加载 Spring的环境（IOC容器）。我们测试 bean 对象，可以通过 <code>@Autowired</code>直接将其注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisDemoApplicationTests</span> &#123;  <br>    <span class="hljs-meta">@Autowired</span>  <br>    NavMapper navMapper;  <br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;  <br>        List&lt;Nav&gt; navList =  navMapper.list();  <br>        <span class="hljs-keyword">for</span> (Nav nav : navList) &#123;  <br>            System.out.println(nav);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sql-提示和警告">2.2 SQL 提示和警告</h2><p>如果 SQL 语句没有提示，可以按照下图设置：</p><p><img src="2.3.png" /></p><p>如果表名不识别，IDEA 配置时选择数据库：</p><p><img src="2.4.png" /></p><h1 id="jdbc">3. JDBC</h1><h2 id="jdbc-简介">3.1 JDBC 简介</h2><p>JDBC： ( Java DataBase Connectivity )，使用 Java语言操作关系型数据库的一套 API。 Java语言操作数据库只能通过一种方式：使用 sun 公司提供的 JDBC 规范。</p><p><img src="3.1.png" /></p><ul><li>sun 公司官方定义的一套操作所有关系型数据库的规范，即接口。</li><li>各个数据库厂商去实现这套接口，提供数据库<strong>驱动 jar包</strong>。（数据库驱动就是各个厂商的实现）</li><li>我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动 jar包中的实现类。</li></ul><h2 id="jdbc-实现">3.2 JDBC 实现</h2><p>JDBC 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.pojo.User;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJdbc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 注册驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>        <span class="hljs-comment">//2. 获取数据库连接</span><br>        String url=<span class="hljs-string">&quot;jdbc:mysql://localhost/cater&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>        <span class="hljs-comment">//3. 执行SQL</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement(); <span class="hljs-comment">//操作SQL的对象</span><br>        String sql=<span class="hljs-string">&quot;select nav_id, nav_title, nav_link, nav_status from nav&quot;</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<span class="hljs-comment">//SQL查询结果会封装在ResultSet对象中</span><br><br>        List&lt;Nav&gt; navList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//集合对象（用于存储User对象）</span><br>        <span class="hljs-comment">//4. 处理SQL执行结果</span><br>        <span class="hljs-keyword">while</span> (rs.next())&#123;<br>            <span class="hljs-comment">//取出一行记录中nav_id,nav_title, nav_link, nav_status下的数据</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">navId</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;nav_id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">navTitle</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;nav_title&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">navLink</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;nav_link&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">navStatus</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;nav_status&quot;</span>);<br>            <span class="hljs-comment">//把一行记录中的数据，封装到User对象中</span><br>            <span class="hljs-type">Nav</span> <span class="hljs-variable">nav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Nav</span>(navId,navTitle,navLink,navStatus);<br>            navList.add(nav);<span class="hljs-comment">//Nav对象添加到集合</span><br>        &#125;<br>        <span class="hljs-comment">//5. 释放资源</span><br>        statement.close();<br>        connection.close();<br>        rs.close();<br><br>        <span class="hljs-comment">//遍历集合</span><br>        <span class="hljs-keyword">for</span> (Nav nav : navList) &#123;<br>            System.out.println(nav);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>DriverManager</code>(类)：数据库驱动管理类。</p><ol type="1"><li>注册驱动</li><li>创建 Java 代码和数据库之间的连接，即获取 <code>Connection</code>对象</li></ol></li><li><p><code>Connection</code>(接口)：建立数据库连接的对象作用：用于建立 Java 程序和数据库之间的连接</p></li><li><p><code>Statement</code>(接口)： 数据库操作对象(执行 SQL语句的对象)。 作用：用于向数据库发送 SQL 语句</p></li><li><p><code>ResultSet</code>(接口)：结果集对象（一张虚拟表） 作用：SQL查询语句的执行结果会封装在 <code>ResultSet</code> 中</p></li></ul><h2 id="jdbc-与-mybatis">3.3 JDBC 与 MyBatis</h2><p>JDBC 缺点：</p><ol type="1"><li>数据库连接的四要素(驱动、链接、用户名、密码)全部硬编码在 Java代码中。</li><li>查询结果的解析及封装非常繁琐。</li><li>每一次查询数据库都需要获取连接,操作完毕后释放连接, 资源浪费,性能降低。</li></ol><p>Mybatis 框架，就是对原始 JDBC 程序的封装。在 MyBatis中通过以下方案解决 JDBC 的问题。</p><ol type="1"><li>数据库连接四要素(驱动、链接、用户名、密码)，都配置在 SpringBoot默认的配置文件 <code>application.properties</code>中。</li><li>查询结果的解析及封装，由 MyBatis自动完成映射封装，我们无需关注。</li><li>在 MyBatis中使用了数据库连接池技术，避免了频繁的创建连接、销毁连接而带来的资源浪费。</li></ol><h1 id="数据库连接池">4. 数据库连接池</h1><h2 id="介绍">4.1 介绍</h2><p>没有使用数据库连接池时，客户端执行 SQL语句：要先创建一个新的连接对象，然后执行 SQL 语句，SQL语句执行后又需要关闭连接对象从而释放资源。每次执行 SQL都需要创建连接、销毁链接，这种频繁的重复创建销毁的过程比较耗费计算机性能。</p><p><img src="3.2.png" /></p><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)。程序在启动时，会在数据库连接池(容器)中，创建一定数量的 Connection对象。</p></li><li><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。客户端执行 SQL 时，先从连接池中获取一个 Connection 对象，再执行 SQL语句，执行完毕把 Connection 对象归还给连接池。（Connection对象可以复用）</p></li><li><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏。客户端获取到 Connection 对象，但是 Connection对象并没有访问数据库(处于空闲)，数据库连接池发现 Connection对象的空闲时间 &gt;连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象。</p></li></ul><p>数据库连接池的好处：</p><ol type="1"><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ol><h2 id="产品">4.2 产品</h2><p>官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）功能：获取连接 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br></code></pre></td></tr></table></figure></p><p>第三方组织必须按照 DataSource 接口实现，常见的数据库连接池：</p><ul><li>C3P0</li><li>DBCP</li><li>Druid</li><li>Hikari (SpringBoot 默认)</li></ul><p>现在使用更多的是：Hikari、Druid （性能更优越）</p><ul><li>Hikari（追光者） （默认的连接池）</li></ul><p><img src="4.1.png" /></p><ul><li>Druid（德鲁伊）<ul><li>Druid 连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是 Java 语言最好的数据库连接池之一</li></ul></li></ul><p>如果想把默认的数据库连接池切换为 Druid数据库连接池，只需要完成以下两步操作即可：</p><blockquote><p>参考官方地址：<ahref="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">druid/druid-spring-boot-starterat master · alibaba/druid · GitHub</a></p></blockquote><ol type="1"><li>在 <code>pom.xml</code> 文件中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Druid连接池依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在 <code>application.properties</code> 中引入数据库连接配置</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">//方式1：</span><br><span class="hljs-attr">spring.datasource.druid.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver  </span><br><span class="hljs-attr">spring.datasource.druid.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/cater </span><br><span class="hljs-attr">spring.datasource.druid.username</span>=<span class="hljs-string">root  </span><br><span class="hljs-attr">spring.datasource.druid.password</span>=<span class="hljs-string">123456</span><br><br><span class="hljs-attr">//方式2：</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver  </span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/cater</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root  </span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h1 id="lombok">5. Lombok</h1><h2 id="lombok-介绍">5.1 Lombok 介绍</h2><p>Lombok 是一个实用的 Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的 Java代码。通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化 Java 开发、提高效率。</p><table><thead><tr><th><strong>注解</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><span class="citation" data-cites="Getter">@Getter</span>/<spanclass="citation" data-cites="Setter">@Setter</span></td><td>为所有的属性提供get/set方法</td></tr><tr><td><span class="citation" data-cites="ToString">@ToString</span></td><td>会给类自动生成易阅读的 toString 方法</td></tr><tr><td><span class="citation"data-cites="EqualsAndHashCode">@EqualsAndHashCode</span></td><td>根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法</td></tr><tr><td><span class="citation" data-cites="Data">@Data</span></td><td>提供了更综合的生成代码功能（<span class="citation"data-cites="Getter">@Getter</span> + <span class="citation"data-cites="Setter">@Setter</span> + <span class="citation"data-cites="ToString">@ToString</span> + <span class="citation"data-cites="EqualsAndHashCode">@EqualsAndHashCode</span>）</td></tr><tr><td><span class="citation"data-cites="NoArgsConstructor">@NoArgsConstructor</span></td><td>为实体类生成无参的构造器方法</td></tr><tr><td><span class="citation"data-cites="AllArgsConstructor">@AllArgsConstructor</span></td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td></tr></tbody></table><blockquote><p>Lombok 会在编译时，自动生成对应的 Java 代码。使用 Lombok时，还需要安装一个 Lombok 的插件(IDEA 自带)。</p></blockquote><h2 id="lombok-使用">5.2 Lombok 使用</h2><p>第1步：在 <code>pom.xml</code> 文件中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第2步：在实体类上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span> <span class="hljs-comment">//getter方法、setter方法、toString方法、hashCode方法、equals方法</span><br><span class="hljs-meta">@NoArgsConstructor</span> <span class="hljs-comment">//无参构造</span><br><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-comment">//全参构造 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> Integer id;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> Short age; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><span class="citation" data-cites="Data">@Data</span>注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造。</p></blockquote><h1 id="数据封装">6. 数据封装</h1><ul><li>实体类属性名和数据库表查询返回的字段名一致，MyBatis会自动封装。</li><li>实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</li></ul><p><img src="6.1.png" /></p><p>解决方案：</p><ol type="1"><li><strong>起别名</strong></li></ol><p>在 SQL 语句中，对不一样的列名起别名，别名和实体类属性名一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select nav_id as navId, nav_title as navTitle from nav where nav_id = #&#123;navId&#125;&quot;)</span>  <br><span class="hljs-keyword">public</span> Nav <span class="hljs-title function_">getByID</span><span class="hljs-params">(Integer navId)</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>手动结果映射</strong></li></ol><p>通过 <code>@Results</code> 及 <code>@Result</code>进行手动结果映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Results(&#123;@Result(column = &quot;nav_id&quot;, property = &quot;navId&quot;),</span><br><span class="hljs-meta">          @Result(column = &quot;nav_title&quot;, property = &quot;navTitle&quot;)&#125;)</span><br><span class="hljs-meta">@Select(&quot;select nav_id, nav_title from nav where nav_id = #&#123;navId&#125;&quot;)</span>  <br><span class="hljs-keyword">public</span> Nav <span class="hljs-title function_">getByID</span><span class="hljs-params">(Integer navId)</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>使用<code>@Param</code>注解</strong></li></ol><p>使用 <code>@Param</code>注解，可以为参数明确地指定一个名称，这个名称将与 SQL中的占位符对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(&quot;insert into nav(nav_title, nav_status) values(#&#123;navTitle&#125;, #&#123;navStatus&#125;)&quot; )</span>  <br><span class="hljs-comment">//@Param(&quot;navTitle&quot;) 将方法的navTitle参数绑定到SQL语句中的#&#123;navTitle&#125;占位符。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;navTitle&quot;)</span> String navTitle, <span class="hljs-meta">@Param(&quot;navStatus&quot;)</span> String navStatus)</span>;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>开启驼峰命名(推荐)</strong>：</li></ol><p>如果字段名与属性名符合驼峰命名规则，MyBatis会自动通过驼峰命名规则映射。</p><p>驼峰命名规则： abc_xyz =&gt; abcXyz</p><ul><li>表中字段名：abc_xyz</li><li>类中属性名：abcXyz</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 在application.properties中添加：</span><br><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><blockquote><p>实体类的属性与数据库表中的字段名必须严格遵守驼峰命名。</p></blockquote><h1 id="基础操作">7. 基础操作</h1><h2 id="删除">7.1 删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NavMapper</span> &#123;<br>    <span class="hljs-meta">@Delete(&quot;delete from nav where nav_id = #&#123;navId&#125;&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Integer navId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果 mapper 接口方法形参只有一个普通类型的参数，<code>#&#123;…&#125;</code>里面的属性名可以随便写，如：#{id}、#{value}。但形参名和属性名最好还是保持一致。</p></blockquote><h2 id="mybatis-日志">7.2 MyBatis 日志</h2><p>在 <code>application.properties</code>文件中开启mybatis的日志，并指定输出到控制台</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#指定mybatis输出日志的位置, 输出控制台  </span><br><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><p>开启日志之后，再次运行单元测试，可以看到在控制台中，输出了以下的 SQL语句信息：</p><p><img src="7.1.png" /></p><p>输入的参数42并没有在后面拼接，nav_id 的值是使用 <code>?</code>进行占位。这种 SQL 语句称为预编译 SQL。</p><h2 id="预编译-sql">7.3 预编译 SQL</h2><p>预编译 SQL 有两个优势：</p><ol type="1"><li><p>性能更高 预编译 SQL，编译一次之后会将编译后的 SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同）</p></li><li><p>更安全(防止SQL注入) 将敏感字进行转义，保障 SQL的安全性。</p></li></ol><p><img src="7.2.png" /></p><p>SQL 注入：通过操作输入的数据来修改事先定义好的 SQL语句，达到执行代码对服务器进行攻击的方法。举个简单例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> $&#123;username&#125; <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> $&#123;password&#125;<br></code></pre></td></tr></table></figure><p>上述 SQL中，若用户密码输入<code>' or '1' = '1</code>，账号随便输入都可以登陆成功，拼接之后的 SQL句义已经改变：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;hh&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>由于没有对用户输入进行充分检查，SQL又是拼接而成，在用户输入参数时，在参数中添加一些 SQL 关键字，达到改变SQL 运行结果的目的，完成恶意攻击。</p></blockquote><p>在 MyBatis 中提供的参数占位符有两种：</p><ul><li><code>#&#123;...&#125;</code><ul><li>预编译 SQL，执行 SQL 时，会将 <code>#&#123;…&#125;</code> 替换为<code>?</code>，自动设置参数值</li><li>使用时机：参数传递，都使用 <code>#&#123;…&#125;</code></li></ul></li><li><code>$&#123;...&#125;</code><ul><li>拼接 SQL，直接将参数拼接在 SQL 语句中，存在 SQL 注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><blockquote><p>注意事项：在项目开发中，建议使用 <code>#&#123;...&#125;</code>，生成预编译SQL，防止 SQL 注入，更安全。</p></blockquote><h2 id="增加">7.4 增加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NavMapper</span> &#123;<br>    <span class="hljs-meta">@Insert(&quot;insert into nav(nav_title, nav_status) values(#&#123;navTitle&#125;, #&#123;navStatus&#125;)&quot; )</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Nav nav)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="7.3.png" /></p><blockquote><p><code>#&#123;...&#125;</code> 里面写的名称是对象的属性名，MyBatis会自动完成映射</p></blockquote><h2 id="主键返回">7.5 主键返回</h2><p>在数据添加成功后，获取插入数据库数据的主键。</p><blockquote><p>在多对多的关系下，新增数据还需要维护中间表，需要获取插入数据的主键。</p></blockquote><p>默认情况下，执行插入操作不会返回主键值。如果想要拿到主键值，需要在Mapper 接口中的方法上添加 <code>@Options</code> 注解，指定属性<code>useGeneratedKeys=true</code> 和<code>keyProperty="实体类属性名"</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-comment">//会自动将生成的主键值，赋值给nav对象的navId属性</span><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;navId&quot;)</span>  <br>    <span class="hljs-meta">@Insert(&quot;insert into nav(nav_title, nav_status) values(#&#123;navTitle&#125;, #&#123;navStatus&#125;)&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Nav nav)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertTest</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Nav</span> <span class="hljs-variable">nav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Nav</span>();  <br>    nav.setNavTitle(<span class="hljs-string">&quot;好好好&quot;</span>);  <br>    nav.setNavStatus(<span class="hljs-string">&quot;启用&quot;</span>);  <br>    navMapper.insert(nav);  <br>    System.out.println(nav.getNavId());  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改">7.6 修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Update(&quot;update nav set nav_status = #&#123;navStatus&#125; where nav_id = #&#123;navId&#125;&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Nav nav)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询">7.7 查询</h2><p>更新数据时，会发送一个请求到服务端，根据 id查询数据，并将数据回显在页面上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select nav_id, nav_title, nav_link, nav_order, nav_status, nav_ctime from nav where nav_id = #&#123;navId&#125;&quot;)</span>  <br>    <span class="hljs-keyword">public</span> Nav <span class="hljs-title function_">getByID</span><span class="hljs-params">(Integer navId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模糊查询的时候，<code>'$&#123;&#125;'</code>有 SQL注入风险，<code>%#&#123;&#125;%</code>不能使用，可以使用 MySQL提供的字符串拼接函数：<code>concat('%' , '关键字' , '%')</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from nav where nav_title like concat(&#x27;%&#x27; , #&#123;navTitle&#125; , &#x27;%&#x27;) &quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Nav&gt; <span class="hljs-title function_">getByTitle</span><span class="hljs-params">(String navTitle)</span>;<br></code></pre></td></tr></table></figure><p><img src="7.4.png" /></p><h2 id="参数说明">7.8 参数说明</h2><ul><li>在 SpringBoot 1.x版本/单独使用 MyBatis（使用 <code>@Param</code>注解来指定 SQL 语句中的参数名）</li></ul><p><img src="7.5.png" /></p><p>在编译时，生成的字节码文件中，不会保留 Mapper接口中方法的形参名称，而是使用var1、var2、…这样的形参名字，此时要获取参数值时，就要通过<code>@Param</code> 注解来指定 SQL 语句中的参数名。</p><p><img src="7.6.png" /></p><ul><li>在 SpringBoot 2.x版本，保证参数名一致即可</li></ul><p><img src="7.7.png" /></p><p>SpringBoot 的父工程对 compiler 编译插件进行了默认的参数 parameters配置。如果没有父工程，可以在 <code>pom.xml</code> 文件的<code>&lt;build&gt;</code> 标签中添加或修改如下这个<code>&lt;plugin</code> 标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Maven Compiler Plugin 配置 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">compilerArgs</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>-parameters<span class="hljs-tag">&lt;/<span class="hljs-name">arg</span>&gt;</span>  <br>             <span class="hljs-comment">&lt;!-- 如果没有使用这个参数，编译器默认不会保留参数名 --&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">compilerArgs</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在编译时，在生成的字节码文件中会保留原方法形参的名称，所以<code>#&#123;…&#125;</code>里面可以直接通过形参名获取对应的值。</p><p><img src="7.8.png" /></p><h1 id="mybatis-的-xml-配置文件">8. MyBatis 的 XML 配置文件</h1><h2 id="xml-配置文件规范">8.1 XML 配置文件规范</h2><p>使用 MyBatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的 SQL功能，建议使用 XML 来配置映射语句，也就是将 SQL 语句写在 XML配置文件中。</p><p>在 MyBatis 中使用 XML 映射文件方式开发，需要符合一定的规范：</p><ol type="1"><li>XML 映射文件的名称与 Mapper 接口名称一致，并且将 XML 映射文件和Mapper 接口放置在相同包下（<strong>同包同名</strong>）</li><li>XML 映射文件的 namespace 属性为 Mapper 接口全类名一致</li><li>XML 映射文件中 SQL 语句的 id 与 Mapper接口中的方法名一致，并保持返回类型一致。</li></ol><h2 id="xml-配置文件实现">8.2 XML 配置文件实现</h2><p><strong>1.创建 XML 映射文件</strong> 在 resources 下创建Directory，由于是文件夹路径，想达到包的效果需要使用/，<code>com/baoduo/mapper</code>，和mapper 接口<strong>同包同名</strong></p><p><img src="8.1.png" /></p><p><strong>2.编写 XML 映射文件</strong> XML 映射文件中的 dtd约束，直接从 MyBatis 官网复制即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="8.2.png" /></p><p>可以在 IDEA 中自定义模板：</p><p><img src="8.3.png" /></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span>  </span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span>  <br><span class="hljs-comment">&lt;!--  </span><br><span class="hljs-comment">    mapper为映射的根节点，用来管理mapper接口  </span><br><span class="hljs-comment">    namespace指定mapper接口的完整类名，表示mapper配置文件管理哪个mapper接口(包.接口名)  </span><br><span class="hljs-comment">    mybatis会依据这个接口动态创建一个实现类去实现这个接口，而这个实现类是一个Mapper对象  </span><br><span class="hljs-comment"> --&gt;</span>  <br><span class="hljs-comment">&lt;!--namespace=&quot;包名.类名&quot;--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.baoduo.mapper.NavMapper&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--  </span><br><span class="hljs-comment">        id = &quot;接口中的方法名&quot;  </span><br><span class="hljs-comment">        parameterType = &quot;接口中传入方法的参数类型&quot;  </span><br><span class="hljs-comment">        resultType = &quot;返回实体类对象：包.类名&quot; 单条记录所封装的类型。处理结果集 自动封装  </span><br><span class="hljs-comment">        注意:sql语句后不要出现&quot;;&quot;号  </span><br><span class="hljs-comment">        #&#123;&#125; 占位符表示字段数据 #&#123;student_id&#125;            查询：select标签  </span><br><span class="hljs-comment">            增加：insert标签  </span><br><span class="hljs-comment">            修改：update标签  </span><br><span class="hljs-comment">            删除：delete标签  </span><br><span class="hljs-comment">    --&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击 Copy Reference 快速复制全包名：</p><p><img src="8.4.png" /></p><h2 id="mybatisx">8.3 MyBatisX</h2><p>MyBatisX 是一款基于 IDEA 的快速开发 MyBatis 的插件。</p><p><img src="8.5.png" /></p><h1 id="mybatis-动态-sql">9. MyBatis 动态 SQL</h1><p>随着用户的输入或外部条件的变化而变化的 SQL 语句，我们称为动态 SQL。在MyBatis 中提供了很多实现动态 SQL 的标签，下面介绍几个常用的动态 SQL标签。 ## 9.1 &lt;if&gt;&lt;where&gt;&lt;set&gt;</p><ul><li><code>&lt;if&gt;</code>：用于判断条件是否成立。使用 test属性进行条件判断，如果条件为 true，则拼接 SQL。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>if  test<span class="hljs-operator">=</span>&quot;name != null&quot;<span class="hljs-operator">&gt;</span><br>   name <span class="hljs-keyword">like</span> concat(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;where&gt;</code>：where元素只会在子元素有内容的情况下才插入 where子句，而且会自动去除子句的开头的 AND 或 OR</li><li><code>&lt;set&gt;</code>：动态地在行首插入 SET关键字，并会删掉额外的逗号。（用在 update 语句中）</li></ul><h2 id="foreach">9.2 &lt;foreach&gt;</h2><p>批量删除功能中，可以使用<code>&lt;foreach</code>遍历 id。</p><ul><li><code>collection</code>：集合名称</li><li><code>item</code>：集合遍历出来的元素/项</li><li><code>separator</code>：每一次遍历使用的分隔符</li><li><code>open</code>：遍历开始前拼接的片段</li><li><code>close</code>：遍历结束后拼接的片段</li></ul><p>Mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML 映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>  <br>    delete from nav where nav_id in    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>  <br>        #&#123;id&#125;    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="sqlinclude">9.3 &lt;sql&gt;&lt;include&gt;</h2><p>在 XML 映射文件中配置的SQL，可能会存在很多重复的片段，此时就会存在很多冗余的代码。对重复的代码片段进行抽取，将其通过<code>&lt;sql&gt;</code>标签封装到一个SQL 片段，然后再通过 <code>&lt;include&gt;</code> 标签进行引用。</p><ul><li><code>&lt;sql&gt;</code>：定义可重用的 SQL 片段，定义唯一 id</li><li><code>&lt;include&gt;</code>：通过属性 refid，指定包含的 SQL 片段的id</li></ul><p>SQL片段： 抽取重复的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span>  <br>    select nav_id, nav_title, nav_link, nav_order, nav_status, nav_ctime<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后通过<code>&lt;include&gt;</code>标签在需要的地方进行引用。操作如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByID&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.baoduo.entity.Nav&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>     where nav_id = #&#123;navId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MaBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL简易教程</title>
    <link href="/2023/08/10/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <url>/2023/08/10/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库概述">1. 数据库概述</h1><p>数据库：英文为 DataBase，简称 DB，它是存储和管理数据的仓库。</p><p>像我们日常访问的电商网站京东，企业内部的管理系统 OA、ERP、CRM这类的系统，大家所看到的数据，都是存储在数据库中的。这些数据只是在浏览器或app 中展示出来而已，数据的存储和管理都是数据库负责的。</p><p><img src="mysql01.png" /></p><p>数据库管理系统：DataBase Management System (DBMS)，操纵和管理数据库的大型软件。</p><p>SQL：Structured QueryLanguage，结构化查询语言，操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。学习数据库开发，最为重要的就是学习SQL 语句 。</p><blockquote><p>程序员给数据库管理系统(DBMS)发送 SQL语句，再由数据库管理系统操作数据库当中的数据。</p></blockquote><p>下面罗列一些常见数据库：</p><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。（通常是不差钱的公司会选择使用这个数据库）</li><li>MySQL：开源免费的中小型数据库，后来 Sun 公司收购了 MySQL，而 Oracle又收购了 Sun 公司。目前 Oracle 推出两个版本的Mysql：社区版(开源免费)、商业版(收费)。</li><li>SQL Server：Microsoft公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM 公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是 MySQL数据库的另外一个分支、另外一个衍生产品，与 MySQL数据库有很好的兼容性。</li></ul><p>这些数据库都是属于关系型数据库，要操作关系型数据库都是通过 SQL语句来实现的，而 SQL 语句又是操作关系型数据库的统一标准。</p><h1 id="mysql-概述">2. MySQL 概述</h1><h2 id="安装连接和卸载">2.1 安装连接和卸载</h2><p>MySQL官方提供了两个版本：</p><ul><li>商业版本（MySQL Enterprise Edition）<ul><li>该版本是收费的，可以免费使用30天。 官方会提供对应的技术支持。</li></ul></li><li>社区版本（MySQL Community Server）<ul><li>该版本是免费的，但是 MySQL 不会提供任何的技术支持。</li></ul></li></ul><p>下载地址：<ahref="https://downloads.mysql.com/archives/community/">MySQL :: DownloadMySQL Community Server (Archived Versions)</a></p><ol type="1"><li>下载完成直接解压，添加环境变量，在系统变量中新建 MYSQL_HOME 设定为MySQL 解压目录，在 Path 中添加 %MYSQL_HOME%，在 cmd 中输入<code>mysql</code>如果提示<code>Can't connect to MySQL server on 'localhost'</code>则证明添加成功。</li><li>在命令行中输入 <code>mysqld --initialize-insecure</code> 初始化MySQL，如果出现没有出现报错信息，则证明 data目录初始化没有问题，此时再查看 MySQL 目录下已经有 data 目录生成。</li><li>输入<code>mysqld -install</code> 注册 MySQL 服务</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">net start mysql  <span class="hljs-regexp">//</span> 启动mysql服务<br>net stop mysql  <span class="hljs-regexp">//</span> 停止mysql服务<br>mysqladmin -u root password <span class="hljs-number">123456</span>  <span class="hljs-regexp">//</span>修改密码<br>mysql -uroot -p123456  <span class="hljs-regexp">//</span>登录<br>mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>) -P端口号(默认<span class="hljs-number">3306</span>)  <span class="hljs-regexp">//</span>用来连接服务器<br><span class="hljs-keyword">exit</span>  <span class="hljs-regexp">//</span>退出<br>quit  <span class="hljs-regexp">//</span>退出<br><span class="hljs-regexp">//</span>卸载 MySQL<br>net stop mysql<br>mysqld -remove mysql<br></code></pre></td></tr></table></figure><p>也可以使用 <ahref="https://www.xp.cn/php-study">小皮面板-好用、安全、稳定的Linux服务器面板！(xp.cn)</a> 一键启动</p><p>真实的企业开发中，MySQL数据库服务器是在公司的服务器上安装的，需要在我们的电脑上去远程连接这台MySQL。如果想提前体验一下企业中数据库的使用方式，可以在我们的电脑上安装一个VMware，在 Vmware 虚拟机上在安装一个服务器操作系统 Linux，再在 Linux服务器上安装各种企业级软件，或者使用腾讯云阿里云等云服务。</p><h2 id="数据模型">2.2 数据模型</h2><p><strong>关系型数据库（RDBMS）</strong>建立在关系模型基础上，由多张相互连接的<strong>二维表</strong>组成的数据库。</p><p><img src="mysql02.png" /></p><p>二维表的优点：</p><ul><li>使用表存储数据，格式统一，便于维护</li><li>使用 SQL 语言操作，标准统一，使用方便，可用于复杂查询</li></ul><blockquote><p>之前提到的 MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。</p><p>结论：基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库（比如Redis，就属于非关系型数据库）。</p></blockquote><p>MySQL 数据库当中到底是如何来存储数据的，也就是 MySQL的数据模型。具体的结构图如下:</p><p><img src="mysql03.png" /></p><p>一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。</p><blockquote><p>在 MySQL 数据库服务器中存储数据： 1.先创建数据库（可以创建多个数据库，之间是相互独立的） 2.在数据库下再去创建数据表（一个数据库下可以创建多张表） 3.再将数据存放在数据表中（一张表可以存储多行数据）</p></blockquote><h2 id="sql-简介">2.3 SQL 简介</h2><p>SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。</p><p>SQL 通用语法：</p><ul><li>SQL 语句可以单行或多行书写，以分号结尾。</li><li>SQL 语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写。</li><li>单行注释：<code>--</code> 注释内容 或 <code>#</code> 注释内容(MySQL特有)</li><li>多行注释： <code>/*</code> 注释内容 <code>*/</code></li></ul><p>SQL 语句分为四大类：</p><table><thead><tr><th><strong>分类</strong></th><th><strong>全称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的访问权限（少用）</td></tr></tbody></table><p>开发数据库的三个阶段：</p><ol type="1"><li>数据库设计阶段<ul><li>参照页面原型以及需求文档设计数据库表结构</li></ul></li><li>数据库操作阶段<ul><li>根据业务功能的实现，编写 SQL语句对数据表中的数据进行增删改查操作</li></ul></li><li>数据库优化阶段<ul><li>通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等</li></ul></li></ol><h2 id="数据类型">2.4 数据类型</h2><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p><strong>数值类型</strong>：无符号在类型后面加 unsigned 即可，例如tinyint unsigned。</p><table style="width:100%;"><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td><code>SMALLINT</code></td><td>2bytes</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td></tr><tr><td><code>MEDIUMINT</code></td><td>3bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td><code>INT/INTEGER</code></td><td>4bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td><code>BIGINT</code></td><td>8bytes</td><td>(-2<sup>63，2</sup>63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr><tr><td><code>FLOAT</code></td><td>4bytes</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351 E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td><code>DOUBLE</code></td><td>8bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td><code>DECIMAL</code></td><td></td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table><p><strong>字符串类型</strong>：char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar 是变长字符串，指定的长度为最大占用长度 。由于 varchar需要去判断字符长度，所以 char 的性能会更高些。</p><p>char：性能高 浪费空间 varchar：性能低 节省空间</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td><code>CHAR</code></td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td><code>VARCHAR</code></td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td><code>TINYBLOB</code></td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td><code>TINYTEXT</code></td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td><code>BLOB</code></td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td><code>TEXT</code></td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td><code>MEDIUMBLOB</code></td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td><code>MEDIUMTEXT</code></td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td><code>LONGBLOB</code></td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td><code>LONGTEXT</code></td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p><strong>日期时间类型</strong></p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td><code>DATE</code></td><td>3</td><td>1000-01-01 至 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td><code>TIME</code></td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td><code>YEAR</code></td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td><code>DATETIME</code></td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td><code>TIMESTAMP</code></td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><blockquote><p>实际开发中常用 create_time 记录数据插入的时间。 update_time记录数据最后更新的时间。</p></blockquote><h1 id="数据库设计-ddl">3. 数据库设计-DDL</h1><p>Data DefinitionLanguage：数据定义语言，用来定义数据库对象(数据库，表，字段)。</p><h2 id="数据库操作">3.1 数据库操作</h2><p><strong>创建</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span>  database [ if  <span class="hljs-keyword">not</span>  <span class="hljs-keyword">exists</span> ]   数据库名 ;  <span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-comment">-- if  not  exists，如果数据库不存在，再创建该数据库，否则不创建</span><br></code></pre></td></tr></table></figure><p><strong>使用</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use  数据库名 ;  <span class="hljs-comment">-- 使用数据库</span><br></code></pre></td></tr></table></figure><p><strong>查询</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;  <span class="hljs-comment">-- 查询所有数据库</span><br><span class="hljs-keyword">select</span> database();  <span class="hljs-comment">-- 查询当前数据库</span><br></code></pre></td></tr></table></figure><p><strong>删除</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span>  database [ if <span class="hljs-keyword">exists</span> ]   数据库名 ;  <span class="hljs-comment">-- 删除数据库</span><br><span class="hljs-comment">-- if exists ，如果数据库存在，再执行删除，否则不执行删除。</span><br></code></pre></td></tr></table></figure><blockquote><p>上述语法中<code>[]</code>代表可选项，database 也可以替换成schema。但推荐使用 database。</p></blockquote><h2 id="表操作">3.2 表操作</h2><h3 id="创建">3.2.1 创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span>  表名(<br>  字段<span class="hljs-number">1</span>  字段类型  [ 约束 ]  [ comment  字段<span class="hljs-number">1</span>注释 ] ,<br>  ......<br>  字段n  字段类型  [ 约束 ]  [ comment  字段n注释 ]  <span class="hljs-comment">-- 最后一个字段没有逗号</span><br>) [ comment  表注释 ] ;<br></code></pre></td></tr></table></figure><p><strong>约束：</strong>概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。作用：就是来保证数据库当中数据的正确性、有效性和完整性。</p><p>在 MySQL 数据库中，提供了以下5种约束：</p><table><thead><tr><th><strong>约束</strong></th><th><strong>描述</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为 null</td><td><code>not null</code></td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td><code>unique</code></td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td><code>primary key</code></td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td><code>default</code></td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td><code>foreign key</code></td></tr></tbody></table><blockquote><p>常用主键自增：<code>auto_increment</code> -每次插入新的行记录时，数据库自动生成 id 字段(主键)下的值 - 具有<code>auto_increment</code>的数据列是一个正数序列开始增长(从1开始自增)</p></blockquote><h3 id="查询">3.3.2 查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> tables;  <span class="hljs-comment">-- 查询当前数据库所有表：</span><br><span class="hljs-keyword">desc</span>  表名;  <span class="hljs-comment">-- 查询表结构</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create table</span> 表名;  <span class="hljs-comment">-- 查询建表语句</span><br></code></pre></td></tr></table></figure><h3 id="修改">3.3.3 修改</h3><ul><li>添加字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter table</span> 表名  <span class="hljs-keyword">add</span>  字段名  类型(长度)  [comment  注释]  [约束];  <br></code></pre></td></tr></table></figure><ul><li>修改字段类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter table</span> 表名 modify  字段名  新数据类型(长度);<br></code></pre></td></tr></table></figure><ul><li>修改字段名和字段类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter table</span> 表名 change  旧字段名  新字段名  类型 (长度)  [comment 注释]  [约束];<br></code></pre></td></tr></table></figure><ul><li>删除字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter table</span> 表名 <span class="hljs-keyword">drop</span>  <span class="hljs-keyword">column</span> 字段名;<br></code></pre></td></tr></table></figure><ul><li>修改表名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">rename <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">to</span>  新表名;<br></code></pre></td></tr></table></figure><h3 id="删除">3.3.4 删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> [ if <span class="hljs-keyword">exists</span> ] 表名;  <span class="hljs-comment">-- 删除表</span><br></code></pre></td></tr></table></figure><blockquote><p>在删除表时，表中的全部数据也会被删除。</p></blockquote><h3 id="图形化工具">3.3.5 图形化工具</h3><p>在项目开发当中，为了提高开发效率，都会借助于现成的图形化管理工具来操作数据库。目前 MySQL 主流的图形化界面工具有 SQLyog、Navicat、DataGrip，在旗舰版IDEA 中集成了 DataGrip。</p><p><img src="mysql04.png" /></p><p>在相应的库或表上右键使用 new 来新建，使用 modify 来修改，使用 drop删除，十分方便。</p><h1 id="数据库操作-dml">4. 数据库操作-DML</h1><p>Data ManipulationLanguage：数据操作语言，用来对数据库中表的数据记录进行增、删、改操作。</p><h2 id="增加-insert">4.1 增加 INSERT</h2><ul><li>向指定字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert into</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><ul><li>全部字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert into</span> 表名 <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><ul><li>批量添加数据（指定字段）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert into</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><ul><li>批量添加数据（全部字段）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert into</span> 表名 <span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><blockquote><p>插入数据时，指定的字段需要与值的顺序是一一对应的。字符串和日期型数据应该包含在引号中。插入的数据大小，应该在字段的规定范围内。</p></blockquote><h2 id="修改-update">4.2 修改 UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span> , 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span> , .... [<span class="hljs-keyword">where</span> 条件] ;<br></code></pre></td></tr></table></figure><blockquote><p>UPDATE 语句如果没有条件，则会修改整张表的所有数据。在修改数据时，一般需要同时修改公共字段update_time，将其修改为当前操作时间。</p></blockquote><h2 id="删除-delete">4.3 删除 DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名  [<span class="hljs-keyword">where</span>  条件] ;<br></code></pre></td></tr></table></figure><blockquote><p>DELETE 语句如果没有条件，则会删除整张表的所有数据。 DELETE语句不能删除某一个字段的值(如果要操作，可以使用 UPDATE，将该字段的值置为NULL)。</p></blockquote><h1 id="数据库操作-dql">5. 数据库操作-DQL</h1><p>Data Query Language：数据查询语言，用来查询数据库表中的记录。</p><p>查询操作是所有 SQL语句当中最为常见，也是最为重要的操作。在一个正常的业务系统中，查询操作的使用频次是要远高于增删改操作的。当我们打开某个网站或APP所看到的展示信息，都是通过从数据库中查询得到的，而在这个查询过程中，还会涉及到条件、排序、分页等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    字段列表<br><span class="hljs-keyword">FROM</span><br>    表名列表<br><span class="hljs-keyword">WHERE</span><br>    条件列表<br><span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span><br>    分组字段列表<br><span class="hljs-keyword">HAVING</span><br>    分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>    排序字段列表<br>LIMIT<br>    分页参数<br></code></pre></td></tr></table></figure><h2 id="基本查询">5.1 基本查询</h2><ul><li>查询多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, 字段<span class="hljs-number">3</span> <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ul><li>查询所有字段（通配符）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span>  表名;  <span class="hljs-comment">-- 不推荐，推荐显式写出所有字段名，更加清晰</span><br></code></pre></td></tr></table></figure><ul><li>设置别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span> [ [<span class="hljs-keyword">as</span>] 别名<span class="hljs-number">1</span> ] , 字段<span class="hljs-number">2</span> [ [<span class="hljs-keyword">as</span>] 别名<span class="hljs-number">2</span> ]  <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ul><li>去除重复记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段列表 <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><h2 id="条件查询">5.2 条件查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <span class="hljs-keyword">from</span>   表名   <span class="hljs-keyword">where</span>   条件列表 ; <span class="hljs-comment">-- 条件列表：可以有多个条件</span><br></code></pre></td></tr></table></figure><p>在 SQL 语句当中构造条件的运算符分为两类：比较运算符和逻辑运算符</p><table><thead><tr><th><strong>比较运算符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>=</code></td><td>等于</td></tr><tr><td><code>&lt;&gt;</code> 或 <code>!=</code></td><td>不等于</td></tr><tr><td><code>between ... and ...</code></td><td>在某个范围之内(含最小、最大值)</td></tr><tr><td><code>in(...)</code></td><td>在 in 之后的列表中的值，多选一</td></tr><tr><td><code>like '占位符'</code></td><td>模糊匹配(<code>_</code>匹配单个字符,<code>%</code>匹配任意个字符)</td></tr><tr><td><code>is null</code></td><td>是 null，不能使用 <code>=null</code></td></tr></tbody></table><table><thead><tr><th><strong>逻辑运算符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>and</code> 或 <code>&amp;&amp;</code></td><td>并且 (多个条件同时成立)</td></tr><tr><td><code>or</code> 或 <code>\|\|</code></td><td>或者 (多个条件任意一个成立)</td></tr><tr><td><code>not</code> 或 <code>!</code></td><td>非 , 不是</td></tr></tbody></table><h2 id="聚合函数">5.3 聚合函数</h2><p>前面的查询都是横向查询，根据条件一行一行的进行判断，而使用聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  聚合函数(字段列表)  <span class="hljs-keyword">from</span>  表名 ;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>函数</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>count</code></td><td>统计数量，按照列去统计有多少行数据。</td></tr><tr><td><code>max</code></td><td>最大值，计算指定列的最大值。</td></tr><tr><td><code>min</code></td><td>最小值，计算指定列的最小值。</td></tr><tr><td><code>avg</code></td><td>平均值，计算指定列的平均值。</td></tr><tr><td><code>sum</code></td><td>求和，计算指定列的数值和，如果不是数值类型，那么计算结果为0。</td></tr></tbody></table><blockquote><p>注意 : 所有聚合函数都会忽略空值，对 NULL 值不作为统计。统计数量可以使用：count(*)   count(字段)  count(常量)，推荐使用count(*)，MySQL 底层对 count(*) 有优化。</p></blockquote><h2 id="分组查询">5.4 分组查询</h2><p>按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <br><span class="hljs-keyword">from</span>  表名  <br>[<span class="hljs-keyword">where</span> 条件]  <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名  <br>[<span class="hljs-keyword">having</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><blockquote><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义执行顺序：where &gt; 聚合函数 &gt; having</p></blockquote><p><strong>where 与 having 区别：</strong></p><ul><li>执行时机不同：where 是分组之前进行过滤，不满足 where条件，不参与分组；而 having 是分组之后对结果进行过滤。</li><li>判断条件不同：where 不能对聚合函数进行判断，而 having 可以。</li></ul><h2 id="排序查询">5.5 排序查询</h2><p>排序在开发中是非常常见的一个操作，有升序排序，也有降序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <br><span class="hljs-keyword">from</span>   表名   <br>[<span class="hljs-keyword">where</span>  条件列表] <br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>  分组字段 ] <br><span class="hljs-keyword">order</span>  <span class="hljs-keyword">by</span>  字段<span class="hljs-number">1</span>  排序方式<span class="hljs-number">1</span> , 字段<span class="hljs-number">2</span>  排序方式<span class="hljs-number">2</span> … ;<br></code></pre></td></tr></table></figure><p>排序方式：</p><ul><li>ASC ：升序（默认值）</li><li>DESC：降序</li></ul><blockquote><p>如果是升序, 可以不指定排序方式 ASC。如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p></blockquote><h2 id="分页查询">5.6 分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <span class="hljs-keyword">from</span>   表名  limit  起始索引, 查询记录数;<br></code></pre></td></tr></table></figure><blockquote><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT。如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p></blockquote><p>查询的数据可以通过 <ahref="https://echarts.apache.org/zh/index.html">Apache ECharts</a>很方便地使用图表显示出来。</p><h1 id="多表设计">6. 多表设计</h1><h2 id="一对多">6.1 一对多</h2><p>表结构之间存在联系，一条数据对应多条数据就是一对多，例如学生表和班级表，一个班级里可以有很多学生。</p><p><strong>在数据库表中多的一方，添加外键字段，来关联另一方的主键。</strong></p><p>外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时指定</span><br><span class="hljs-keyword">create table</span> 表名(<br>    字段名    数据类型,<br>    ...<br>    [<span class="hljs-keyword">constraint</span>]   [外键名称]  <span class="hljs-keyword">foreign  key</span> (外键字段名)   <span class="hljs-keyword">references</span>   主表 (主表列名)    <br>);<br><br><span class="hljs-comment">-- 建完表后，添加外键</span><br><span class="hljs-keyword">alter table</span>  表名  <span class="hljs-keyword">add constraint</span>  外键名称  <span class="hljs-keyword">foreign key</span>(外键字段名) <span class="hljs-keyword">references</span> 主表(主表列名);<br></code></pre></td></tr></table></figure><p><strong>物理外键和逻辑外键</strong></p><ul><li>物理外键<ul><li>使用 <code>foreign key</code> 定义外键关联另外一张表。</li><li>缺点：<ul><li>影响增、删、改的效率（需要检查外键关系）。</li><li>仅用于单节点数据库，不适用与分布式、集群场景。</li><li>容易引发数据库的死锁问题，消耗性能。</li></ul></li></ul></li><li>逻辑外键<ul><li>在业务层逻辑中，解决外键关联。</li></ul></li></ul><blockquote><p>在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。甚至在一些数据库开发规范中，会明确指出禁止使用物理外键<code>foreign key</code></p></blockquote><h2 id="一对一">6.2 一对一</h2><p>一对一关系表通常是用来做单表的拆分，就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他不太常用的字段放在另外一张表当中，以此来提高数据的操作效率。一对一可以看成一种特殊的一对多，只需要在任意一方来添加一个外键就可以了。</p><p><strong>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(<code>UNIQUE</code>)</strong></p><h2 id="多对多">6.3 多对多</h2><p>多对多的关系在开发中也比较常见。比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。</p><p><strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p><h2 id="小结">6.4 小结</h2><ul><li>一对多：在多的一方添加外键，关联另外一方的主键。</li><li>一对一：任意一方添加外键，关联另外一方的主键。</li><li>多对多：通过中间表来维护，中间表的两个外键分别关联两张表的主键。</li></ul><h1 id="多表查询">7. 多表查询</h1><h2 id="概述">7.1 概述</h2><p>多表查询：查询时从多张表中获取所需数据。</p><p>执行多表查询，只需要使用逗号分隔多张表即可，如：<code>select 字段列表 from 表1, 表2;</code>多表查询会产生笛卡尔积，也就是两个表的所有组合情况。要想消除笛卡尔积，只需要给多表查询加上连接查询的条件即可。</p><blockquote><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合(A集合 和B集合)的所有组合情况。(在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据)</p></blockquote><p>多表查询可以分为：</p><ol type="1"><li>连接查询<ul><li>内连接：查询交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据(包括非交集部分的左表数据)</li><li>右外连接：查询右表所有数据(包括非交集部分的右表数据)</li></ul></li></ul></li><li>子查询</li></ol><p><img src="mysql05.png" /></p><h2 id="连接查询">7.2 连接查询</h2><h3 id="内连接">7.2.1 内连接</h3><ul><li>隐式内连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span>   <span class="hljs-keyword">where</span>  条件 ... ;<br></code></pre></td></tr></table></figure><ul><li>显式内连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  [ <span class="hljs-keyword">inner</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><p>多表查询时给表起别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">tableA  <span class="hljs-keyword">as</span>  别名<span class="hljs-number">1</span>  ,  tableB  <span class="hljs-keyword">as</span>  别名<span class="hljs-number">2</span> ;<br>tableA  别名<span class="hljs-number">1</span>  ,  tableB  别名<span class="hljs-number">2</span> ;<br></code></pre></td></tr></table></figure><blockquote><p>一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</p></blockquote><h3 id="外连接">7.2.2 外连接</h3><ul><li>左外连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  <span class="hljs-keyword">left</span>  [ <span class="hljs-keyword">outer</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><blockquote><p>左外连接相当于查询表1(左表)的所有数据，包含表1和表2交集部分的数据。</p></blockquote><ul><li>右外连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  <span class="hljs-keyword">right</span>  [ <span class="hljs-keyword">outer</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><blockquote><p>右外连接相当于查询表2(右表)的所有数据，包含表1和表2交集部分的数据。内连接只能查询到两表之间有联系的数据，而外连接可以查询到没联系的数据。左外连接和右外连接是可以相互替换的，只需要调整连接查询时 SQL语句中表的顺序就可以。在日常开发使用时，更偏向于左外连接。</p></blockquote><h2 id="子查询">7.3 子查询</h2><p>SQL 语句中嵌套 select语句，将查询的结果作为条件再次进行查询等操作，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span>   t1   <span class="hljs-keyword">WHERE</span>  column1 <span class="hljs-operator">=</span>  ( <span class="hljs-keyword">SELECT</span>  column1  <span class="hljs-keyword">FROM</span>  t2 ... );<br></code></pre></td></tr></table></figure><blockquote><p>子查询外部的语句可以是 insert / update / delete / select的任何一个，最常见的是 select。</p></blockquote><p>根据子查询结果的不同分为：</p><ol type="1"><li>标量子查询<ul><li>子查询返回的结果为单个值(数字、字符串、日期等)。</li><li>常用的操作符： <code>= &lt;&gt; &gt; &gt;= &lt; &lt;=</code></li></ul></li><li>列子查询<ul><li>子查询结果为一列。</li><li>常用的操作符：<code>in  、not in</code></li></ul></li><li>行子查询<ul><li>子查询结果为一行</li><li>常用的操作符：<code>=  、&lt;&gt; 、in 、not  in</code></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询和张三名字和性别都一样的学生数据，可以使用 (字段1, 字段2...) = 行子查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <br><span class="hljs-keyword">from</span> student  <br><span class="hljs-keyword">where</span> (name, gender) <span class="hljs-operator">=</span>  <br>      (<span class="hljs-keyword">select</span> name, gender  <br>       <span class="hljs-keyword">from</span> student  <br>       <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>表子查询<ul><li>子查询结果为多行多列，常作为临时表。</li><li>常用的操作符：<code>in</code></li></ul></li></ol><p>子查询可以书写的位置：</p><ol type="1"><li><code>where</code> 之后</li><li><code>from</code> 之后</li><li><code>select</code> 之后</li></ol><h1 id="事务">8. 事务</h1><p>在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL 语句全部执行成功；要么其中有 SQL 语句失败，就进行事务的回滚，所有的SQL 语句全部执行失败。</p><p>事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败。</strong></p><p>MYSQL 中有两种方式进行事务的操作：</p><ol type="1"><li>自动提交事务：执行一条 SQL 语句提交一次事务。（MySQL的事务默认是自动提交）</li><li>手动提交事务：先开启，再提交。</li></ol><ul><li>开启手动控制事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 二者都可以</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">begin</span> ;<br></code></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span>;<br></code></pre></td></tr></table></figure><blockquote><p>手动提交事务使用步骤： - 第1种情况：开启事务 =&gt; 执行 SQL 语句=&gt; 成功 =&gt; 提交事务 - 第2种情况：开启事务 =&gt; 执行 SQL 语句=&gt; 失败 =&gt; 回滚事务</p></blockquote><p>事务的四大特性：<strong>ACID</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li></ul><blockquote><p>如果事务成功完成，那么数据库的所有变化将生效。如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。</p></blockquote><ul><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li></ul><blockquote><p>多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰。多个并发的事务之间相互隔离，一个事务的成功或失败对其他的事务没有影响。</p></blockquote><ul><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h1 id="索引">9. 索引</h1><p>索引(index)：是帮助数据库高效获取数据的数据结构，使用空间换时间，使用索引可以提高查询的效率。</p><ul><li>优点：<ol type="1"><li>提高数据查询的效率，降低数据库的 IO 成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 消耗。</li></ol></li><li>缺点：<ol type="1"><li>索引会占用存储空间。</li><li>索引大大提高了查询效率，同时却也降低了 insert、update、delete的效率。（增删改除了本身操作，还需要维护索引表）</li></ol></li></ul><blockquote><p>现在存储空间并不是问题，而且索引占用的存储空间也不是很大；在实际开发中，查询占了90%以上，增删改本就不太常用，优化主要是针对查询进行优化；缺点已经不算什么了。</p></blockquote><p>MySQL 数据库支持的索引结构有很多，如：Hash 索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree结构组织的索引。</p><p>如果使用二叉搜索树，当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，极端情况下会形成一个单向链表，搜索性能会打折扣。</p><p><img src="mysql06.png" /></p><p>使用二叉树或红黑树最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。因为不管是二叉搜索树还是红黑树，一个节点下面只能有两个子节点。在数据量大的情况下，就会造成树的高度比较高，检索速度就会降低。</p><p><img src="mysql07.png" /></p><p>为了减少树的高度，就得增加树的宽度，不再像红黑树一样每个节点只能保存一个数据，引入另一种数据结构，一个节点可以保存多个数据，这样宽度就会增加，从而降低树的高度。这种数据结构B+Tree 就满足。</p><p>B+Tree(多路平衡搜索树)：</p><ul><li>每一个节点，可以存储多个 key（有 n 个 key，就有 n 个指针）。</li><li>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据。</li><li>叶子节点形成一个双向链表，便于数据的排序及区间范围查询。</li></ul><p><img src="mysql08.png" /></p><blockquote><p>非叶子节点都是由key+指针域组成的，一个key占8字节，一个指针占6字节，而一个节点总共容量是16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节/ (8+6)=1170个元素。</p><ul><li>查看mysql索引节点大小：show global status like ‘innodb_page_size’; –节点大小：16384</li></ul><p>当根节点中可以存储1170个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储1170个元素，那么第二层即第二次IO的时候就会找到数据大概是：1170*1170=135W。也就是说B+Tree数据结构中只需要经历两次磁盘IO就可以找到135W条数据。</p><p>对于第二层每个元素有指针，那么会找到第三层，第三层由key+数据组成，假设key+数据总大小是1KB，而每个节点一共能存储16KB，所以一个第三层一个节点大概可以存储16个元素(即16条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是135W个元素，那么第三层总元素大小就是：135W*16结果就是2000W+的元素个数。</p><p>结合上述分析B+Tree有如下优点：</p><ul><li><p>千万条数据，B+Tree可以控制在小于等于3的高度</p></li><li><p>所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找</p></li></ul></blockquote><ul><li>创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span>  [ <span class="hljs-keyword">unique</span> ]  index 索引名  <span class="hljs-keyword">on</span>  表名 (字段名,... ) ;<br></code></pre></td></tr></table></figure><ul><li>查看索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span>  index  <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span>  index  索引名  <span class="hljs-keyword">on</span>  表名;<br></code></pre></td></tr></table></figure><blockquote><p>主键字段，在建表时会自动创建主键索引，是所有索引中性能最高的添加唯一约束时，数据库实际上会添加唯一索引</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议与Tomcat服务器</title>
    <link href="/2023/08/07/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/08/07/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="http-协议">1. HTTP 协议</h1><h2 id="http-概述">1.1 HTTP 概述</h2><p>概念：Hyper Text TransferProtocol，超文本传输协议，<strong>规定了浏览器和服务器之间数据传输的规则</strong>。</p><p><img src="1.1.png" /></p><ul><li>HTTP 是互联网上应用最为广泛的一种网络协议</li><li>HTTP协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</li></ul><h2 id="http特点">1.2 HTTP特点</h2><ul><li><p><strong>基于TCP协议:</strong> 面向连接，安全</p><blockquote><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong>一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong>对于数据没有记忆能力。每次请求-响应都是独立的</p><blockquote><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点: 多次请求间不能共享数据</li><li>优点: 速度快</li></ul><p>请求之间无法共享数据会引发的问题：</p><ul><li>如：京东购物。加入购物车和去购物车结算是两次请求</li><li>由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是 Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。这个我们后面会介绍。</p></blockquote></li></ul><h2 id="http-请求响应">1.3 HTTP 请求响应</h2><p>浏览器和服务器是按照 HTTP 协议进行数据通信的。HTTP协议又分为：请求协议和响应协议。 刚才提到 HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?我们可以打开浏览器，点击 <code>F12</code> 打开开发者工具，点击 Network来查看</p><p><img src="1.2.png" /></p><ul><li>浏览器向服务器进行请求时：服务器按照固定的格式进行解析</li><li>服务器向浏览器进行响应时：浏览器按照固定的格式进行解析</li></ul><p>所以，我们学习 HTTP 主要就是学习请求和响应数据的具体格式内容。</p><h3 id="http-请求">1.3.1 HTTP 请求</h3><ul><li>请求协议：浏览器将数据以请求格式发送到服务器</li><li>包括：<strong>请求行</strong>、<strong>请求头</strong>、<strong>请求体</strong></li></ul><p>在 HTTP1.1 版本中，浏览器访问服务器的几种方式：</p><table><thead><tr><th>请求方式</th><th>请求说明</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>获取资源。 向特定的资源发出请求。例<ahref="http://www.baidu.com/s?wd=tomcat">http://www.baidu.com/s?wd=tomcat</a></td></tr><tr><td><strong>POST</strong></td><td>传输实体主体。向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td></tr><tr><td>OPTIONS</td><td>返回服务器针对特定资源所支持的 HTTP 请求方式。因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS 就是用来询问服务器支持的方法。</td></tr><tr><td>HEAD</td><td>获得报文首部。 HEAD 方法类似 GET 方法，不同的是 HEAD方法不要求返回数据。通常用于确认 URI 的有效性及资源更新时间等。</td></tr><tr><td>PUT</td><td>传输文件。 PUT 方法用来传输文件。类似 FTP协议，文件内容包含在请求报文的实体中，然后请求保存到 URL指定的服务器位置。</td></tr><tr><td>DELETE</td><td>删除文件。 请求服务器删除 Request-URI 所标识的资源</td></tr><tr><td>TRACE</td><td>追踪路径。 回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理。 HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p>在我们实际应用中常用的就是 ：<strong>GET、POST</strong></p><p><strong>GET方式的请求协议：</strong></p><p><img src="1.3.png" /></p><ul><li><strong>请求行</strong> ：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）<ul><li>请求方式：GET</li><li>资源路径：/api/sysuser/delete?id=3<ul><li>请求路径：/api/sysuser/delete</li><li>请求参数：id=3<ul><li>请求参数是以 <code>key=value</code> 形式出现</li><li>多个请求参数之间使用 <code>&amp;</code> 连接</li></ul></li><li>请求路径和请求参数之间使用 <code>?</code> 连接</li></ul></li><li>协议/版本：HTTP/1.1</li></ul></li><li><strong>请求头</strong>：第二行开始，上图绿色部分内容就是请求头。格式为 <code>key: value</code>形式，HTTP是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">Host:</span> 表示请求的主机名  <br><span class="hljs-params">User-Agent:</span> 浏览器版本。 例如：Chrome 浏览器的标识类似 Mozilla<span class="hljs-symbol">/5.0</span> ...Chrome<span class="hljs-symbol">/79</span> ，IE浏览器的标识类似 Mozilla<span class="hljs-symbol">/5.0</span> (Windows NT ...)like Gecko  <br>Accept：表示浏览器能接收的资源类型，如 `text<span class="hljs-comment">/*`，`image/*` 或者 `*/</span><span class="hljs-operator">*</span>` 表示所有<br>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页<br>Accept-Encoding：表示浏览器可以支持的压缩类型，例如 gzip, deflate 等<br>Content-Type：请求主体的数据类型  <br>Content-Length：数据主体的大小（单位：字节）<br></code></pre></td></tr></table></figure><p>GET 请求的请求参数在请求行中，故不需要设置请求体</p><blockquote><p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p><p>比如: - 不同浏览器解析 HTML 和 CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果-服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题）</p></blockquote><p><strong>POST方式的请求协议：</strong></p><p><img src="1.4.png" /></p><ul><li><strong>请求行</strong>：上图红色部分，包含<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>,<ul><li>请求方式：POST</li><li>资源路径：/api/sysuser/add</li><li>协议/版本：HTTP/1.1</li></ul></li><li><strong>请求头</strong>：上图绿色部分</li><li><strong>请求体</strong>：上图蓝色部分，存放请求参数，请求体和请求头之间有一个空行隔开，用于标记请求头结束，Chrome浏览器在 Payload 中</li></ul><p><strong>GET</strong> 请求和 <strong>POST</strong> 请求的区别：</p><table><thead><tr><th>区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td>请求参数</td><td>请求参数在请求行中。<br/>例：/api/sysuser/delete?id=3</td><td>请求参数在请求体中</td></tr><tr><td>请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td>安全性</td><td>请求参数暴露在浏览器地址栏中，安全性低。</td><td>安全性相对高</td></tr></tbody></table><h3 id="http-响应">1.3.2 HTTP 响应</h3><ul><li>响应协议：服务器将数据以响应格式返回给浏览器</li><li>包括：<strong>响应行</strong> 、<strong>响应头</strong>、<strong>响应体</strong></li></ul><p>与 HTTP 请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong>、<strong>响应体</strong></p><p><img src="1.5.png" /></p><ul><li><strong>响应行</strong>：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>组成<ul><li>协议/版本：HTTP/1.1</li><li>响应状态码：200</li></ul></li><li><strong>响应头</strong>：响应数据的第二行开始，上图绿色部分。格式为<code>key：value</code> 形式，HTTP是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>：表示该响应内容的类型，例如 <span class="hljs-type">text</span>/html，image/jpeg，application/<span class="hljs-type">json</span><br>Content-Length：表示该响应内容的长度（字节数）<br>Content-<span class="hljs-keyword">Encoding</span>：表示该响应压缩算法，例如 gzip<br><span class="hljs-keyword">Cache</span>-Control：指示客户端应如何缓存，例如 max-age=<span class="hljs-number">300</span> 表示可以最多缓存<span class="hljs-number">300</span>秒 <br><span class="hljs-keyword">Set</span>-Cookie: 告诉浏览器为当前页面所在的域设置 cookie<br></code></pre></td></tr></table></figure><ul><li><strong>响应体</strong>：响应数据的最后一部分，上图蓝色部分，存放响应数据<ul><li>响应体和响应头之间有一个空行隔开，用于标记响应头结束，Chrome浏览器在 Payload 中</li></ul></li></ul><h3 id="响应状态码">1.3.3 响应状态码</h3><p>响应状态码主要分为以下五类：</p><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> —临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> —重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> —处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> —处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>这里再罗列一些常见的响应状态码：</p><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>==200==</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>==404==</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td>指示用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code>Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>==500==</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr></tbody></table><p>想了解更多可以去这里查看：：<ahref="https://cloud.tencent.com/developer/chapter/13553">状态 | Status -HTTP 中文开发手册 - 开发者手册 - 腾讯云开发者社区-腾讯云(tencent.com)</a></p><p>关于响应状态码，我们主要认识三个状态码，其余的等后期用到了再去掌握：</p><ul><li><strong>200 OK</strong> 客户端请求成功</li><li><strong>404 Not Found</strong> 请求资源不存在，一般是 URL输入错误或网站资源被删除</li><li><strong>500 Internal Server Error</strong>服务端发生不可预期的错误，服务器出现异常</li></ul><h2 id="http-协议解析">1.4 HTTP 协议解析</h2><p>可以使用 ServerSocket 编写服务器代码对 HTTP 进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * 自定义web服务器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>); <span class="hljs-comment">// 监听指定端口</span><br>        System.out.println(<span class="hljs-string">&quot;server is running...&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> ss.accept();<br>            System.out.println(<span class="hljs-string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(sock);<br>            t.start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Socket sock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Socket sock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sock = sock;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.sock.getInputStream();<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.sock.getOutputStream()) &#123;<br>                handle(input, output);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.sock.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;client disconnected.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(InputStream input, OutputStream output)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));<br>        <span class="hljs-comment">// 读取HTTP请求:</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">requestOk</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> reader.readLine();<br>        <span class="hljs-keyword">if</span> (first.startsWith(<span class="hljs-string">&quot;GET / HTTP/1.&quot;</span>)) &#123;<br>            requestOk = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">header</span> <span class="hljs-operator">=</span> reader.readLine();<br>            <span class="hljs-keyword">if</span> (header.isEmpty()) &#123; <span class="hljs-comment">// 读取到空行时, HTTP Header读取完毕</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(header);<br>        &#125;<br>        System.out.println(requestOk ? <span class="hljs-string">&quot;Response OK&quot;</span> : <span class="hljs-string">&quot;Response Error&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!requestOk) &#123;<span class="hljs-comment">// 发送错误响应:</span><br>            writer.write(<span class="hljs-string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;Content-Length: 0\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            writer.flush();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 发送成功响应:</span><br>            <span class="hljs-comment">//读取html文件，转换为字符串</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Server.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;html/a.html&quot;</span>);<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                data.append(line);<br>            &#125;<br>            br.close();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> data.toString().getBytes(StandardCharsets.UTF_8).length;<br><br>            writer.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;Connection: keep-alive\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;Content-Type: text/html\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;Content-Length: &quot;</span> + length + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>            writer.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 空行标识Header和Body的分隔</span><br>            writer.write(data.toString());<br>            writer.flush();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>浏览器输入：<code>http://localhost:8080</code> 就会访问到ServerSocket 程序，ServerSocket 程序会读取服务器上<code>html/a.html</code> 文件，并把文件数据发送给浏览器，浏览器接收到<code>a.html</code> 文件中的数据后进行解析并呈现在页面上。</p><p>现在大家知道了服务器是可以使用 Java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的。而在开发中真正用到的Web服务器，我们不用自己写，都是使用目前比较流行的Web 服务器，比如 Jetty、WebLogic、WebSphere，以及最受欢迎的 Apache软件基金会的 <strong>Tomcat</strong>。</p><p><img src="1.6.png" /></p><p>Web 服务器是一个软件程序，对 HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析HTTP 协议规则)，让 Web 开发更加便捷，主要功能是 “提供网上信息浏览服务”。</p><h1 id="tomcat-服务器">2. Tomcat 服务器</h1><h2 id="服务器概述">2.1 服务器概述</h2><p><strong>服务器硬件</strong>指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。</p><p>服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong> 服务器软件：基于 ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p><img src="2.1.png" /></p><p>Web 服务器是安装在服务器端的一款软件，将来我们把自己写的 Web项目部署到 Tomcat 服务器软件中，当 Web 服务器软件启动后，部署在 Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><h2 id="tomcat-简介">2.2 Tomcat 简介</h2><p>Tomcat 服务器软件是一个免费的开源的 Web 应用服务器。是 Apache软件基金会的一个核心项目。由 Apache，Sun和其他一些公司及个人共同开发而成。</p><p>由于 Tomcat 只支持 Servlet/JSP 少量 JavaEE规范，所以是一个开源免费的轻量级 Web 服务器。</p><blockquote><p>JavaEE规范： JavaEE =&gt; Java Enterprise Edition(Java企业版)</p><p>JavaEE 规范就是指 Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、JavaIDL、JTS、JTA、JavaMail、JAF</p></blockquote><p>因为 Tomcat 支持 Servlet/JSP 规范，所以 Tomcat 也被称为 Web容器、Servlet 容器。JavaWeb 程序需要依赖 Tomcat 才能运行。</p><p>Tomcat的官网: <a href="https://tomcat.apache.org/">Apache Tomcat® -Welcome!</a></p><h2 id="tomcat-基本使用">2.3 Tomcat 基本使用</h2><p><strong>下载：</strong> 直接从官方网站下载：<ahref="https://tomcat.apache.org/download-90.cgi">Apache Tomcat® - ApacheTomcat 9 Software Downloads</a></p><blockquote><p>Tomcat软件类型说明： - tar.gz文件，是 linux 和 mac操作系统下的压缩版本 - zip文件，是 window操作系统下压缩版本（我们选择zip文件）</p></blockquote><p>Tomcat 是绿色版，直接解压即可</p><blockquote><p>注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。</p></blockquote><p>Tomcat 目录结构：</p><p><img src="2.2.png" /></p><p><code>bin</code>：目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows 系统的可执行文件，一种是以 <code>.sh</code> 结尾的，是 Linux系统的可执行文件。 <code>webapps</code>：就是以后项目部署的目录。</p><p><strong>卸载</strong>：绿色版直接删除目录即可</p><p><strong>启动</strong>：双击 Tomcat 解压目录/bin/<strong>startup.bat</strong> 文件即可启动 Tomcat</p><blockquote><p>注意: Tomcat 服务器启动后，黑窗口不会关闭，只要黑窗口不关闭，就证明Tomcat 服务器正在运行</p></blockquote><p>Tomcat 的默认端口为8080，所以在浏览器的地址栏输入：<code>http://127.0.0.1:8080</code>即可访问 Tomcat 服务器，127.0.0.1 也可以使用 localhost代替。如：<code>http://localhost:8080</code></p><blockquote><p>Tomcat 启动的过程中，遇到控制台有中文乱码时，可以修改conf/logging.prooperties 文件，将下面这行的 UTF-8 改为 GBK</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prooperties">java.util.logging.ConsoleHandler.encoding = UTF-8<br></code></pre></td></tr></table></figure><p><strong>关闭</strong>： 直接×掉运行窗口：强制关闭（不建议）bin\shutdown.bat：正常关闭 Ctrl+C：正常关闭</p><p><strong>部署项目</strong>： 将项目放置到 webapps 目录下，即部署完成</p><p><strong>常见问题一</strong>：Tomcat启动时，窗口一闪而过 检查JAVA_HOME 环境变量是否正确配置</p><p><strong>常见问题二</strong>：端口号冲突找到对应程序，将其关闭掉，或者修改 Tomcat 启动的端口号，需要修改conf/server.xml 文件中的 port</p><blockquote><p>注: HTTP 协议默认端口号为80，如果将 Tomcat 端口号改为80，则将来访问Tomcat 时，将不用输入端口号。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven使用教程</title>
    <link href="/2023/08/05/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/08/05/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="maven-简介">1. Maven 简介</h1><p>Maven 是 Apache 旗下的一个开源项目，它基于项目对象模型(Project ObjectModel , 简称:POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。是一款用于<strong>管理和构建Java 项目的工具</strong>。 官网：<ahref="https://maven.apache.org/">Maven – Welcome to Apache Maven</a></p><blockquote><p>Apache软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。开源项目：<ahref="https://www.apache.org/index.html#projects-list">Welcome to TheApache Software Foundation!</a></p></blockquote><h1 id="maven-的作用">2. Maven 的作用</h1><h2 id="方便的依赖管理">2.1 方便的依赖管理</h2><ul><li>方便的依赖管理：方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题。</li></ul><p>若没有通过 Maven进行大型项目的依赖管理，我们在开发项目时，需要引入大量的 jar 包，jar包和 jar 包之间很多时候是需要版本匹配的，很容易出现版本冲突问题。当使用Maven 进行项目依赖（jar包）管理，则可以很方便地解决这个问题。我们只需要在 Maven 项目的 pom.xml 文件中，修改配置即可实现。</p><h2 id="统一的项目结构">2.2 统一的项目结构</h2><ul><li>统一的项目结构：提供标准、统一的项目结构。</li></ul><p>在项目开发中，当使用不同的开发工具(如：Eclipse、IDEA)，创建项目工程时，项目目录结构是不一样的，若我们创建的是一个Maven 工程，可以帮我们自动生成统一、标准的项目目录结构：</p><p><img src="assets/2.2.png" /></p><h2 id="标准的项目构建流程">2.3 标准的项目构建流程</h2><ul><li>标准的项目构建流程：标准跨平台（Linux、Windows、MacOS）的自动化项目构建方式。</li></ul><p>我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven 提供了一套简单的命令来完成项目构建。</p><h1 id="maven-模型">3. Maven 模型</h1><p>Maven 由以下三个部分组成：</p><p><img src="assets/3.1.png" /></p><ul><li>项目对象模型 (Project ObjectModel)：将我们自己的项目抽象成一个对象模型，有自己专属的坐标。</li></ul><blockquote><p>坐标：就是资源（jar包）的唯一标识，通过坐标可以定位到所需资源（jar包）位置</p></blockquote><ul><li>依赖管理模型(Dependency)：使用坐标来描述当前项目依赖哪些第三方jar包。</li></ul><p><img src="assets/3.2.png" /></p><ul><li>构建生命周期/阶段(Build lifecycle &amp;phases)：用来完成标准化构建流程。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。</li></ul><h1 id="maven-仓库">4. Maven 仓库</h1><p>之前我们项目中需要 jar 包时，直接就把 jar 包复制到项目下的 lib目录，而现在书写在 pom.xml 文件中的坐标又是怎么能找到所要的 jar包文件的呢？ Maven 仓库：用于存储资源，管理各种 jar 包</p><blockquote><p>仓库的本质就是一个目录（文件夹），这个目录被用来存储开发中所有依赖就是（jar包）和插件</p></blockquote><p>Maven仓库分为：</p><ul><li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li><li>中央仓库：由 Maven 团队维护的全球唯一的。仓库地址：<ahref="https://repo1.maven.org/maven2/">Central Repository:(maven.org)</a></li><li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li></ul><p>当项目中使用坐标引入对应依赖 jar包后，首先会查找本地仓库中是否有对应的 jar 包</p><ul><li>如果有，则在项目直接引用</li><li>如果没有，则去中央仓库中下载对应的 jar 包到本地仓库</li></ul><p>如果搭建远程仓库(私服)，jar 包的查找顺序则变为： 本地仓库 –&gt;远程仓库–&gt; 中央仓库</p><h1 id="maven-安装和配置">5. Maven 安装和配置</h1><p>下载地址：<a href="https://maven.apache.org/download.cgi">Maven –Download Apache Maven</a></p><ol type="1"><li>直接解压到没有中文、特殊字符的路径下。</li></ol><p>解压后的目录结构如下：</p><p><img src="assets/5.png" /></p><ul><li>bin目录：存放的是可执行命令。（mvn 命令重点关注）</li><li>conf目录：存放 Maven的配置文件。（settings.xml配置文件后期需要修改）</li><li>lib目录：存放 Maven 依赖的jar包。（Maven 也是使用 java开发的，所以它也依赖其他的 jar 包）</li></ul><ol start="2" type="1"><li>配置本地仓库：修改 conf/settings.xml 中的<code>&lt;localRepository&gt;</code> 为一个指定目录，这个目录是将来存放jar 包的地方。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Develop\Development Tool\mvn-repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span>  <br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>配置阿里云私服：由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。修改conf/settings.xml 中的 <code>&lt;mirrors&gt;</code>标签，为其添加如下子标签：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--配置阿里云镜像--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span> <br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <br>          <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>只可配置一个 &lt;mirror&gt; (另一个要注释)，不然两个可能发生冲突，导致 jar 包无法下载！！！</p></blockquote><ol start="4" type="1"><li>配置环境变量：MAVEN_HOME 为 Maven 的解压目录，并将其 bin 目录加入PATH 环境变量。<ol type="1"><li>在系统变量处新建一个变量 MAVEN_HOME，值设置为 maven的解压安装目录</li><li>在 Path 中进行配置，值设置为 %MAVEN_HOME%\bin</li><li>打开 cmd 命令提示符进行验证，输入 <code>mvn -v</code> 显示 Maven版本则成功</li></ol></li></ol><h1 id="idea-集成-maven">6. IDEA 集成 Maven</h1><ol type="1"><li>设置 IDEA 使用本地安装的 Maven，并修改配置文件及本地仓库路径</li></ol><p><img src="assets/6.1.png" /></p><ol start="2" type="1"><li>配置工程的编译版本和运行版本为 17</li></ol><p><img src="assets/6.2.png" /></p><blockquote><p>在项目中的设置是针对当前项目的设置，再打开别的项目是无效的，关闭项目在IDEA 欢迎页面的设置才是全局设置。</p></blockquote><h1 id="maven-项目">7. Maven 项目</h1><ol type="1"><li>创建空项目</li></ol><p><img src="assets/7.1.png" /></p><ol start="2" type="1"><li>创建 Maven 模块</li></ol><p><img src="assets/7.2.png" /></p><p>Maven 项目的目录结构如下：</p><p><img src="assets/7.3.png" /></p><p>Maven 项目的导入有以下两种方式： 通过右侧 Maven 面板或者在 ProjectStructure 中导入模块，直接选择对应模块的 pom 文件即可。</p><p><img src="assets/7.4.png" /></p><h1 id="pom-配置详解">8. POM 配置详解</h1><p>POM (Project Object Model) ：指的是项目对象模型，用来描述当前的 Maven项目。使用 pom.xml 文件来实现，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- POM模型版本 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 当前项目坐标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baoduo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_project1<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 打包方式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;project&gt;</code> ：pom 文件的根标签，表示当前 Maven项目</li><li><code>&lt;modelVersion&gt;</code> ：声明项目描述遵循哪一个 POM模型版本，虽然模型本身的版本很少改变，但它仍然是必不可少的。目前 POM模型版本是4.0.0</li><li>坐标：<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code>，定位项目在本地仓库中的位置</li><li><code>&lt;packaging&gt;</code> ：Maven 项目的打包方式，通常设置为jar 或 war（默认值：jar）</li></ul><p>什么是坐标？</p><ul><li>Maven 中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p>Maven坐标主要组成：</p><ul><li><code>groupId</code>：定义当前 Maven项目隶属组织名称（通常是域名反写，例如：com.baoduo）</li><li><code>artifactId</code>：定义当前 Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li><code>version</code>：定义当前项目版本号</li></ul><blockquote><p><strong>注意：</strong>上面所说的资源可以是插件、依赖、当前项目。我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</p></blockquote><h1 id="依赖管理">9. 依赖管理</h1><h2 id="依赖配置">9.1 依赖配置</h2><p>依赖：指当前项目运行所需要的 jar 包。一个项目中可以引入多个依赖。</p><ol type="1"><li>在 pom.xml 中编写<code>&lt;dependencies&gt;</code>标签</li><li>在<code>&lt;dependencies&gt;</code>标签中使用<code>&lt;dependency&gt;</code>引入坐标</li><li>定义坐标的<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code></li><li>点击刷新按钮，引入最新加入的坐标，证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li></ol><p>添加或修改配置之后记得点击这个小按钮刷新。</p><p><img src="assets/9.1.png" /></p><p>如果不知道依赖的坐标信息，可以到<ahref="https://mvnrepository.com/">Maven Repository:Search/Browse/Explore (mvnrepository.com)</a>中搜索。</p><p>还可以使用 IDEA 工具搜索依赖，<code>Alt</code> + <code>Insert</code>中选择 <code>Dependency</code> 直接搜索需要的依赖。</p><p><img src="assets/9.2.png" /></p><blockquote><p>如果引入的依赖在本地仓库不存在，将会连接远程仓库/中央仓库，然后下载依赖。（这个过程会比较耗时，耐心等待）</p></blockquote><h2 id="依赖传递">9.2 依赖传递</h2><p>依赖具有传递性： 直接依赖：在当前项目中通过依赖配置建立的依赖关系间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p><p>如下图，projectA 依赖了 projectB。对于projectA 来说，projectB就是直接依赖。而 projectB 依赖了 projectC 及其他 jar 包。 那么此时，在projectA 中也会将 projectC 的依赖传递下来。对于projectA来说，projectC就是间接依赖。</p><p><img src="assets/9.3.png" /></p><p>如果 A 依赖 B，B 依赖 C，如果 A 不想将 C 依赖进来，可以使用排除依赖。排除依赖：指主动断开依赖的资源，被排除的资源无需指定版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--排除依赖, 主动断开依赖的资源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="依赖范围">9.3 依赖范围</h2><p>依赖的 jar 包，默认情况下，可以在任何地方使用。可以通过<code>&lt;scope&gt;…&lt;/ scope &gt;</code> 设置其作用范围。</p><p>作用范围：</p><ul><li>主程序范围有效。（main文件夹范围内）</li><li>测试程序范围有效。（test文件夹范围内）</li><li>是否参与打包运行。（package指令范围内）</li></ul><p><code>scope</code> 标签的取值范围：</p><table><thead><tr><th><strong>scope</strong>值</th><th><strong>主程序</strong></th><th><strong>测试程序</strong></th><th><strong>打包（运行）</strong></th><th><strong>范例</strong></th></tr></thead><tbody><tr><td>compile（默认）</td><td>Y</td><td>Y</td><td>Y</td><td>log4j</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr></tbody></table><h2 id="生命周期">9.4 生命周期</h2><p>Maven 的生命周期就是为了对所有的构建过程进行抽象和统一。描述了一次项目构建，经历哪些阶段。在 Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p><p>Maven从大量项目和构建工具中学习和反思，总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。</p><p>Maven对项目构建的生命周期划分为3套（<strong>相互独立</strong>）：</p><ul><li>clean：清理工作。</li><li>default：核心工作。如：编译、测试、打包、安装、部署等。</li><li>site：生成报告、发布站点等。</li></ul><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。这意味着：在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。</p><p><img src="assets/9.4.png" /></p><p>我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：• clean：移除上一次构建生成的文件，target 目录会被清除 •compile：编译项目源代码，将 class 字节码文件放在 target 目录下 •test：使用合适的单元测试框架运行测试(junit) •package：将编译后的文件打包放在 target 目录下，如：jar、war等 •install：安装项目到本地仓库，也就是将打好的 jar 包安装到本地仓库中</p><p><img src="assets/9.5.png" /></p><p>执行指定生命周期的两种方式：</p><ul><li>在idea中，右侧的 Maven 工具栏，选中对应的生命周期，双击执行。</li><li>在命令行中，通过命令执行。 mvn clean、 mvn compile…</li></ul><p>由于在同一套生命周期中，运行后面的阶段时，前面的阶段都会运行。在 IDEA的 Maven 面板中可以跳过不想执行的阶段。</p><p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong>IDEA工具为了方便程序员使用 Maven 生命周期，在右侧的 Maven工具栏中，已给出快速访问通道。</p><p><img src="assets/9.6.png" /></p><h1 id="附录">10. 附录</h1><h2 id="更新依赖索引">10.1 更新依赖索引</h2><p>有时候给 IDEA 配置完 Maven 仓库信息后，在 IDEA 中依然搜索不到仓库中的jar 包。这是因为仓库中的 jar 包索引尚未更新到 IDEA中。这个时候我们就需要更新 IDEA 中 Maven 的索引了，具体做法如下：打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update</p><p><img src="assets/9.7.png" /></p><h2 id="清理-maven-仓库">10.2 清理 Maven 仓库</h2><p>初始情况下，我们的本地仓库是没有任何 jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的 jar 包都是以 lastUpdated 结尾。此时，Maven不会再重新下载，我们需要删除这些以 lastUpdated 结尾的文件，然后 Maven才会再次自动下载这些 jar 包。</p><p><img src="assets/10.png" /></p><p>如果本地仓库中有很多这样的以 lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">set</span> REPOSITORY_PATH=D:\Develop\Development Tool\mvn-repository<br><span class="hljs-comment">rem 正在搜索...</span><br><br><span class="hljs-built_in">del</span> /s /q <span class="hljs-variable">%REPOSITORY_PATH%</span>\*.lastUpdated<br><span class="hljs-comment"></span><br><span class="hljs-comment">rem 搜索完毕</span><br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>上面的 <code>REPOSITORY_PATH=</code>后面是本地仓库的地址。定义批处理文件 del_lastUpdated.bat(直接创建一个文本文件，命名为 del_lastUpdated，后缀名直接改为 bat 即可)，需要清理 Maven 仓库的时候双击运行即可删除 Maven仓库中的残留文件。</p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web前端开发</title>
    <link href="/2023/08/01/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2023/08/01/coding/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="web标准">1. Web标准</h1><ul><li>Web标准也称为网页标准，由一系列的标准组成，大部分由W3C（ World WideWeb Consortium，万维网联盟）负责制定。</li><li>三个组成部分：<ul><li><strong>HTML</strong>：负责网页的结构（页面元素和内容）。</li><li><strong>CSS</strong>：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。</li><li><strong>JavaScript</strong>：负责网页的行为（交互效果）。</li></ul></li></ul><p>文档查阅：<a href="https://www.w3school.com.cn/">w3school在线教程</a></p><h1 id="html">2. HTML</h1><h2 id="html-简介">2.1 HTML 简介</h2><p>HTML（<strong>H</strong>yper<strong>T</strong>ext<strong>M</strong>arkup<strong>L</strong>anguage）：超文本标记语言。</p><ul><li>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。</li><li>标记语言：由标签构成的语言。</li></ul><h2 id="html-特点">2.2 HTML 特点</h2><ul><li>HTML标签不区分大小写</li><li>HTML属性值单双引号都可以（建议使用双引号）</li><li>HTML语法松散</li></ul><p>在HTML页面中无论输入了多少个空格, 最多只会显示一个。可以使用空格占位符（<code>&amp;nbsp；</code>）来生成空格，如果需要多个空格，就使用多次占位符。</p><h2 id="html-基本标签">2.3 HTML 基本标签</h2><p>以下罗列了一下最常见的 HTML 标签，需要其他标签可以查阅官方文档 <ahref="https://www.w3school.com.cn/tags/index.asp">HTML 标签参考手册(w3school.com.cn)</a></p><p><strong>标题标签</strong>： <code>&lt;h1&gt;…&lt;/h1&gt;</code> （h1→ h6 重要程度依次降低）</p><p><strong>段落标签</strong> <code>&lt;p&gt;</code></p><p><strong>换行标签</strong> <code>&lt;br&gt;</code></p><p><strong>水平线标签</strong> <code>&lt;hr&gt;</code></p><p><strong>文本加粗标签</strong><code>&lt;b&gt;  &lt;strong&gt;</code></p><p>文本倾斜标签 <code>&lt;i&gt;  &lt;em&gt;</code></p><p><strong>图片标签</strong><code>&lt;img src="" width="" height=""&gt;</code></p><ul><li>绝对路径：绝对磁盘路径（D:/xxxx）、绝对网络路径（https://xxxx）</li><li>相对路径：从当前文件开始查找（./ : 当前目录, ../ : 上级目录）</li></ul><p><strong>超链接标签</strong><code>&lt;a href="" target=""&gt;</code></p><ul><li>href：指定资源访问的url</li><li>target：指定在何处打开资源链接<ul><li>self：默认值，在当前页面打开</li><li>_blank：在空白页面打开</li></ul></li></ul><p><strong>视频标签</strong><code>&lt;video scr="" controls="" width="" height=""&gt;</code></p><ul><li>src：规定视频的url</li><li>controls：显示播放控件</li></ul><p><strong>音频标签</strong><code>&lt;audio scr="" controls=""&gt;</code></p><ul><li>src：规定音频的url</li><li>controls：显示播放控件</li></ul><p><strong>表格标签</strong></p><ul><li><code>&lt;table boder="" width="" cellspacing=""&gt;</code>定义表格整体，可以包裹多个<code>&lt;tr&gt;</code><ul><li>border：规定表格边框的宽度</li><li>width：规定表格的宽度</li><li>cellspacing：规定单元格之间的空间</li></ul></li><li><code>&lt;tr&gt;</code>定义表格钟的行，可以包裹多个<code>&lt;td&gt;</code></li><li><code>&lt;td&gt;</code>定义表格单元格，可以包裹内容；特殊地，表头单元格使用<code>&lt;th&gt;</code>，具有加粗居中效果</li></ul><p><strong>表单标签</strong>在网页中主要负责数据采集功能，如注册、登录等数据采集<code>&lt;form action="" method=""&gt;</code></p><ul><li>action：规定当提交表单时向何处发送表单数据，URL</li><li>method：规定用于发送表单数据的方式。GET、POST<ul><li>GET：表单数据是拼接在url后面的， 如：xxxxxxxxxxx?username=Tom&amp;age=12，url中能携带的表单数据大小是有限制的</li><li>POST： 表单数据是在请求体（消息体）中携带的，大小没有限制</li></ul></li></ul><p><strong>表单项标签</strong></p><ul><li><code>&lt;input type="" name="" value=""&gt;</code>定义表单项，通过type属性控制输入形式</li></ul><table><thead><tr><th>type取值</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>text</td><td>默认值，定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>date/time/datetime-local</td><td>定义日期/时间/日期时间</td></tr><tr><td>number</td><td>定义数字输入框</td></tr><tr><td>email</td><td>定义邮件输入框</td></tr><tr><td>hidden</td><td>定义隐藏域</td></tr><tr><td>submit / reset / button</td><td>定义提交按钮 / 重置按钮 / 可点击按钮</td></tr></tbody></table><ul><li><code>&lt;select name=""&gt;</code>定义下拉列表，<code>&lt;option value=""&gt;</code> 定义列表项。</li><li><code>&lt;textarea name=""&gt;</code> 定义文本域</li></ul><p>表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定<strong>name</strong>属性。否则，无法提交该表单项。服务器接收到的数据是<strong>value</strong>的值。（submit和reset、button的value值决定按钮上显示的是什么）</p><p><strong>布局标签</strong> <code>&lt;div&gt;  &lt;span&gt;</code></p><h1 id="css">3. CSS</h1><h2 id="css-简介">3.1 CSS 简介</h2><p>CSS（<strong>C</strong>ascading <strong>S</strong>tyle<strong>S</strong>heet）：层叠样式表，用于控制页面的样式（表现）。</p><h2 id="css-引入方式">3.2 CSS 引入方式</h2><ul><li>行内样式：写在标签的style属性中（不推荐）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;xxx: xxx; xxx: xxx;&quot;</span>&gt;</span>中国新闻网<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="language-css">     xxx: xxx;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>外联样式：写在一个单独的.css文件中（需要通过 link标签在网页中引入）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/news.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="css-选择器">3.3 CSS 选择器</h2><ul><li>元素选择器：<code>标签名 &#123; … &#125;</code></li><li>id选择器：<code>#id属性值 &#123; … &#125;</code></li><li>类选择器：<code>.class属性值 &#123; … &#125;</code></li><li>优先级：id选择器 &gt; 类选择器 &gt; 元素选择器</li></ul><h2 id="盒子模型">3.4 盒子模型</h2><p>盒子：页面中所有的元素（标签），都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）</p><p><img src="3.4div.png" /></p><p><strong>布局标签：</strong> 实际开发网页中，会大量频繁的使用<code>div</code> 和 <code>span</code> 这两个没有语义的布局标签</p><p><code>div</code>标签： 一行只显示一个（独占一行）宽度默认是父元素的宽度，<strong>高度默认由内容撑开</strong>可以设置宽高（width、height） <code>span</code>标签： 一行可以显示多个<strong>宽度和高度默认由内容撑开</strong>不可以设置宽高（width、height）</p><p><code>width：</code>设置宽度（可以是像素，可以是百分比，百分比相对父元素）<code>height：</code>设置高度（可以是像素，可以是百分比，百分比相对父元素）<code>border：</code>设置边框的属性，如：1px solid #000；<code>padding：</code>内边距 <code>margin：</code>外边距</p><blockquote><p>注意：如果只需要设置某一个方位的边框、内边距、外边距，可以在属性名后加上–位置，如：padding-top、padding-left、padding-right …</p></blockquote><h2 id="css-基本属性">3.5 CSS 基本属性</h2><p>下面提供了一些最基本的 CSS 属性，如需其他属性可以查阅官方文档 <ahref="https://www.w3school.com.cn/cssref/index.asp">CSS 参考手册(w3school.com.cn)</a></p><p><code>color：</code> 设置文本的颜色有以下三种表示方式</p><table><thead><tr><th>表示方式</th><th>表示含义</th><th>取值</th></tr></thead><tbody><tr><td>关键字</td><td>预定义的颜色名</td><td>red、green、blue</td></tr><tr><td>rgb表示法</td><td>红绿蓝三原色，取值范围：0-255</td><td>rgb(255,255,255)</td></tr><tr><td>十六进制表示法</td><td>#开头，用十六进制表示</td><td>#000000 #000</td></tr></tbody></table><p><code>font-size：</code> 字体大小 （注意：记得加px）<code>text-decoration：</code>规定添加到文本的修饰，none表示定义标准的文本<code>line-height：</code>设置行高<code>text-indent：</code>定义第一个行内容的缩进<code>text-align：</code>规定元素中的文本的水平对齐方式</p><h1 id="javascript">4. JavaScript</h1><h2 id="javascript-简介">4.1 JavaScript 简介</h2><ul><li>JavaScript（简称：JS）是一门<strong>跨平台</strong>、<strong>面向对象</strong>的<strong>脚本语言</strong>（不需要编译，由浏览器解释执行）。是用来控制网页行为的，它能使网页可交互。</li><li>JavaScript 和 Java是完全不同的语言，不论是概念还是设计，但是基础语法类似。</li><li>JavaScript 在 1995 年由 Brendan Eich 发明，并于 1997 年成为 ECMA标准。</li><li>ECMAScript6 (<strong>ES6</strong>) 是最主流的 JavaScript版本（发布于 2015 年)。</li></ul><blockquote><p>ECMA： ECMA国际（前身为欧洲计算机制造商协会），制定了标准化的脚本程序设计语言ECMAScript，这种语言得到广泛应用。而 JavaScript 是遵守 ECMAScript的标准的。</p></blockquote><h2 id="js-引入方式">4.2 JS 引入方式</h2><ul><li>内部脚本：将JS代码定义在<strong>HTML页面中</strong><ul><li>JavaScript代码必须位于<code>&lt;script&gt;&lt;/script&gt;</code>标签之间</li><li>在HTML文档中，可以在任意地方，放置任意数量的<code>&lt;script&gt;</code></li><li>一般会把脚本置于<code>&lt;body&gt;</code>元素的底部，可改善显示速度</li></ul></li><li>外部脚本：将 JS 代码定义<strong>在外部 JS文件中</strong>，然后引入到 HTML 页面中<ul><li>外部 JS 文件中，只包含 JS代码，不包含<code>&lt;script&gt;</code>标签</li><li><code>&lt;script&gt;</code>标签不能自闭合（否则不生效）</li><li><code>&lt;script src="js/demo.js"&gt;&lt;/script&gt;</code></li></ul></li></ul><h2 id="js-基础语法">4.3 JS 基础语法</h2><h3 id="书写语法">4.3.1 书写语法</h3><p>除了分号可有可无，其他地方和 Java 基本类似</p><ul><li>区分大小写：与 Java一样，变量名、函数名以及其他一切东西都是区分大小写的</li><li>每行结尾的分号<strong>可有可无</strong>（建议加上）</li><li>注释：<ul><li>单行注释：// 注释内容</li><li>多行注释：/* 注释内容 */</li></ul></li><li>大括号表示代码块</li></ul><p>JS 的三种<strong>输出语句</strong>：</p><table><thead><tr><th>api</th><th>描述</th></tr></thead><tbody><tr><td>window.alert()</td><td>写入警告框，浏览器弹出警告框（window可省略）</td></tr><tr><td>document.write()</td><td>写入 HTML 输出，在浏览器展示</td></tr><tr><td>console.log()</td><td>写入浏览器控制台，在控制台显示</td></tr></tbody></table><h3 id="变量">4.3.2 变量</h3><p>变量的声明和 Java 有很大的不同，JS主要使用以下三种关键字来声明变量</p><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>var</td><td>声明变量，全局作用域/函数作用域，允许重复声明</td></tr><tr><td>let</td><td>声明变量，块级作用域，不允许重复声明</td></tr><tr><td>const</td><td>声明常量，一旦声明，常量的值不能改变</td></tr></tbody></table><blockquote><p><strong>注意</strong>：在 JS 中，被 const修饰的简单类型（或者说是基本类型）是不能发生改变的，但是被 const修饰的引用数据类型的内容是可以被修改的，因为 const仅限制了指向的值不可更改，而不限制其指向的对象内容不可更改。</p></blockquote><ul><li>JavaScript是一门<strong>弱类型</strong>语言，变量可以存放<strong>不同类型</strong>的值。</li><li>变量名需要遵循如下规则：<ul><li>组成字符可以是任何字母、数字、下划线（_）或美元符号（$）</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//同一变量可以存放不同类型的值</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    a = <span class="hljs-string">&quot;张三&quot;</span>;<br>    <span class="hljs-title function_">alert</span>(a);<br><br>    <span class="hljs-comment">//var：全局变量，可以重复定义</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;A&quot;</span>;<br>    &#125;<br>    <span class="hljs-title function_">alert</span>(x);<br>    <br>    <span class="hljs-comment">//let：局部变量，只在代码块内有效，不能重复定义 </span><br>    &#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-title function_">alert</span>(x);  <span class="hljs-comment">//报错</span><br><br>    <span class="hljs-comment">//const：常量，一旦声明，常量的值就不能改变</span><br>    <span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span>;<br>        pi = <span class="hljs-number">3.15</span>;  <span class="hljs-comment">//报错</span><br>        <span class="hljs-title function_">alert</span>(pi);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="数据类型">4.3.3 数据类型</h3><p>JavaScript中分为：<strong>原始类型</strong> 和<strong>引用类型</strong>。</p><p>原始类型： <code>number</code>：数字（整数、小数、NaN(Not a Number)）<code>string</code>：字符串，单双引号都可以<code>boolean</code>：布尔。true，false <code>null</code>：对象为空<code>undefined</code>：当声明的变量未初始化时，该变量的默认值是undefined</p><p>既然 JavaScript中的变量不声明类型，我们怎么知道数据是什么类型呢？我们可以使用<code>typeof</code> 运算符可以获取数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span>  a);<br></code></pre></td></tr></table></figure><h3 id="运算符">4.3.4 运算符</h3><p>算术运算符：+ , - , * , / , % , ++ , – 赋值运算符：= , += , -= , *= ,/= , %= 比较运算符：&gt; , &lt; , &gt;= , &lt;= , != , <code>==</code> ,<code>===</code> 逻辑运算符：&amp;&amp; , || , ! 三元运算符：条件表达式? true_value: false_value</p><p>运算符和 Java 几乎完全一致，<code>==</code> <code>===</code>值得注意一下</p><ul><li><code>==</code>：只比较值是否相等，不区分<strong>数据类型</strong>，哪怕类型不一致，也会自动转换类型进行值得比较</li><li><code>===</code>：不光比较值，还要比较<strong>数据类型</strong>，如果类型不一致，直接返回false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> _age = <span class="hljs-string">&quot;20&quot;</span>;<br><span class="hljs-keyword">var</span> $age = <span class="hljs-number">20</span>;<br><br><span class="hljs-title function_">alert</span>(age == _age);<span class="hljs-comment">//true ，只比较值</span><br><span class="hljs-title function_">alert</span>(age === _age);<span class="hljs-comment">//false ，类型不一样</span><br><span class="hljs-title function_">alert</span>(age === $age);<span class="hljs-comment">//true ，类型一样，值一样</span><br></code></pre></td></tr></table></figure><p>在 JavaScript中虽然不区分数据类型，但有时涉及数值运算，我们希望得到数值类型，可以进行<strong>类型转换</strong>，JS为我们提供了这样的函数。</p><ul><li>字符串类型转为数字：<code>parseInt()</code></li><li>将字符串字面值转为数字。 如果字面值不是数字，则转为 NaN。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类型转换 - 其他类型转为数字</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;12&quot;</span>)); <span class="hljs-comment">//12</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;12A45&quot;</span>)); <span class="hljs-comment">//12  识别到不是数字停止</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;A45&quot;</span>));<span class="hljs-comment">//NaN (not a number)</span><br></code></pre></td></tr></table></figure><p>在 JS 中，还有非常重要的一点是：<code>0</code>, <code>NaN</code>,<code>null</code>, <code>undefined</code>, <code>"",</code>可以理解成false,反之理解成 true。</p><ul><li><code>Number</code>：0 和 NaN 为 false，其他均转为 true。</li><li><code>String</code>：空字符串为 false，其他均转为 true。</li><li><code>null</code> 和 <code>undefined</code> ：均转为 false。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-title class_">NaN</span>)&#123;<span class="hljs-comment">//false</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;NaN 转换为false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程控制语句">4.3.5 流程控制语句</h3><p>流程控制语句与 Java 中完全一样，此处不再赘述</p><ul><li>if…else if …else…</li><li>switch</li><li>for</li><li>while</li><li>do … while</li></ul><h2 id="js-函数">4.4 JS 函数</h2><p>Java 中通过方法提高代码的复用性，在 JavaScript中可以使用函数完成类似的事情，JavaScript 使用 <code>function</code>关键字定义函数，有两种定义语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>.</span>)&#123;   <br>    <span class="hljs-comment">//要执行的代码  </span><br>&#125;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">var</span> functionName = <span class="hljs-keyword">function</span> (<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>.</span>)&#123;   <br>    <span class="hljs-comment">//要执行的代码  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意与 Java 中不同的 JS 函数特性</p><ul><li>形式参数<strong>不需要类型</strong>。因为 JavaScript是弱类型语言</li><li>返回值也<strong>不需要类型</strong>，可以在函数内部直接使用 return返回即可</li></ul><p>在函数的调用上与 Java 类似，直接 <code>函数名(参数列表)</code>，但是在 JavaScript中，函数的调用只需要名称正确即可，函数调用可以传递<strong>任意个数的参数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"> a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">var</span> res = <span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<br><span class="hljs-title function_">alert</span>(res);  <span class="hljs-comment">//结果为30，多余的参数直接忽略</span><br></code></pre></td></tr></table></figure><h2 id="js-对象">4.5 JS 对象</h2><p>JavaScript 中有很多对象，可以参考官方文档 <ahref="https://www.w3school.com.cn/jsref/index.asp">JavaScript 和 HTMLDOM 参考手册 (w3school.com.cn)</a>这些对象大致可以分为三类，分别是：</p><ul><li>基本对象，在这里主要学习 Array 和 JSON 和 String</li><li>BOM 对象，主要是和浏览器相关的几个对象</li><li>DOM对象，JavaScript 中将 html 的每一个标签都封装成一个对象</li></ul><h3 id="基本对象">4.5.1 基本对象</h3><h4 id="array-对象">4.5.1.1 Array 对象</h4><p>JavaScript 中 Array 对象用于定义数组，相当于 Java中集合，但数组的<strong>长度是可变的</strong>，JavaScript又是弱类型语言，所以可以存储<strong>任意类型</strong>的数据。</p><p>常用定义语法有以下两种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrary</span>( <span class="hljs-number">1</span>, <span class="hljs-string">&quot;喝喝&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//方式二，更简洁</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;喝喝&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>数组定义好了，该如何获取数组里面的值呢？和 Java 一样通过索引<code>arr[1]</code> 来获取值。 需要注意与 Java 不同的特点：</p><ul><li>长度可变</li><li>存储任意类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>arr[<span class="hljs-number">10</span>] = <span class="hljs-number">50</span>;  <span class="hljs-comment">//长度可变</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">9</span>]); <span class="hljs-comment">//未定义的部分是 undefined</span><br><br>arr[<span class="hljs-number">9</span>] = <span class="hljs-string">&quot;A&quot;</span>;  <span class="hljs-comment">//添加不同类型的值</span><br>arr[<span class="hljs-number">8</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>作为一个对象，官方文档中提供了许多 Array的属性和函数，在这里只列出最常用的属性和函数。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>设置或返回数组中元素的数量。</td></tr></tbody></table><ul><li><code>length</code> 属性 length属性可以用来获取数组的长度，我们可以用来遍历数组中的元素：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>arr[<span class="hljs-number">10</span>] = <span class="hljs-number">50</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种遍历方式，可以使用以下语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  <span class="hljs-comment">// i仅仅是索引</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]); <span class="hljs-comment">// arr[i]才是数组值</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>forEach()</td><td>遍历数组中的每个<strong>有值</strong>元素，并调用一次传入的函数。</td></tr><tr><td>push()</td><td>将新元素添加到数组的末尾，并返回新的长度。</td></tr><tr><td>splice()</td><td>从数组中删除元素。</td></tr></tbody></table><ul><li><code>forEach()</code> 函数这个函数是用来遍历的，那么遍历的目的是做什么？所以这个方法的参数，需要传递一个函数，每次遍历都会执行这个函数，而且这个函数接受一个参数，就是遍历时数组元素的值。修改之前的遍历代码如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//e是形参，接收的是数组遍历时元素的值</span><br><span class="hljs-comment">//每次遍历都将数组元素传给 function 函数并执行</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;  <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;)<br></code></pre></td></tr></table></figure><p>在 ES6中，为了简化函数定义的语法，引入<strong>箭头函数</strong>的写法，语法类似Java 中 lambda 表达式，具体形式为:  <code>(…) =&gt; &#123; … &#125;</code>，如果需要给箭头函数起名字：<code>var  xxx = (…) =&gt; &#123; … &#125;</code>，修改上述代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;) <br></code></pre></td></tr></table></figure><p>既然都是遍历，那么 forEach() 函数和 for循环遍历结果一致吗？答案是<strong>不一致</strong>，对于 forEach()函数来说，没有元素的内容是不会输出的，forEach() 只会遍历有值的元素；而for循环会遍历数组中的每一个值，具体使用哪一个要看使用场景是否需要空值元素。</p><ul><li><code>push()</code> 函数这个函数用于向数组的末尾添加元素，其中函数的参数就是需要添加的元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><ul><li><code>splice()</code> 函数这个函数用来删除数组中的元素，函数中填入2个参数。参数1：表示从哪个索引位置删除 参数2：表示删除元素的个数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从索引2的位置开始删，删除2个元素</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><h4 id="string-对象">4.5.1.2 String 对象</h4><p>JavaScript 中 String 对象用于定义字符串，和 Java 类似。</p><p>常用定义语法有以下两种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello String&quot;</span>);<br><span class="hljs-comment">//方式二，更加简洁</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello String&quot;</span>;<br></code></pre></td></tr></table></figure><p>String 对象也提供了许多属性和函数，在这里我们介绍一些最常用的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>返回字符串的长度。</td></tr></tbody></table><ul><li><code>length</code> 属性 可以用于返回字符串的长度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td>indexOf()</td><td>检索字符串，返回起始索引。</td></tr><tr><td>trim()</td><td>去除字符串两边的空格。</td></tr><tr><td>substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr></tbody></table><ul><li><code>charAt()</code> 函数用于返回在指定索引位置的字符，函数的参数就是索引</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><ul><li><code>indexOf()</code> 函数用于检索指定内容在字符串中的索引位置的，返回值是索引，参数是指定的内容</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;llo&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li><code>trim()</code> 函数用于去除字符串两边的空格的，返回一个新字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;  Hello String    &quot;</span>;<br><span class="hljs-keyword">var</span> s = str.<span class="hljs-title function_">trim</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">length</span>);<br></code></pre></td></tr></table></figure><ul><li><code>sustring()</code> 函数 用于截取字符串的，函数有2个参数。和Java 一样包头不包尾。 参数1：表示从哪个索引位置开始截取。参数2：表示到哪个索引位置结束。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h4 id="json-对象">4.5.1.3 JSON 对象</h4><p>介绍 JSON 之前我们需要先来介绍一下 JavaScript 的自定义对象，类似 Java的类或 C++ 的结构体，在 JS 中自定义对象非常简单，其语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 对象名 = &#123;<br>属性名<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>,<br>属性名<span class="hljs-number">2</span>: 属性值<span class="hljs-number">2</span>,<br>属性名<span class="hljs-number">3</span>: 属性值<span class="hljs-number">3</span>,<br><br>函数名称: <span class="hljs-keyword">function</span>(<span class="hljs-params">形参列表</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>对象名.属性名</code> 获取属性，通过<code>对象名.函数名()</code> 调用函数，下面是一个自定义对象示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> user = &#123;<br>       <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>       <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>       <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;male&quot;</span>,<br> <span class="hljs-comment">//      eat: function()&#123;</span><br> <span class="hljs-comment">//         console.log(&quot;用膳~&quot;);</span><br> <span class="hljs-comment">//      &#125;</span><br>    <span class="hljs-comment">//函数定义语法可以简化成这样，类似 C++ 中的函数</span><br>       <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;用膳~&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>了解了 JS 的自定义对象，接下来有请我们的 JSON 隆重登场。</p><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject<strong>N</strong>otation，JavaScript对象标记法。是通过 JavaScript对象标记法书写的文本。其格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;key&quot;</span>:value,<br>    <span class="hljs-string">&quot;key&quot;</span>:value,<br>    <span class="hljs-string">&quot;key&quot;</span>:value<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，key必须使用<strong>双引号</strong>标记，value可以是任意数据类型。在互联网中有许多JSON 在线解析网站，大家可以在搜索引擎中搜索试试。</p><p>那么 JSON这种数据格式的文本应用在什么地方呢？经常用作前后台交互的数据载体。如下图所示：前后台交互时，我们需要传输数据，但是 Java中的对象我们该怎么去描述呢？我们可以使用如图所示的 xml格式，可以清晰的描述 Java 中需要传递给前端的 Java 对象。</p><p><img src="4.5xml.png" /></p><p>很明显 xml 格式存在如下问题：</p><ul><li>标签需要编写双份，标签甚至比数据还多，占用带宽，浪费资源</li><li>解析繁琐</li></ul><p>所以我们可以使用 JSON 来替代，相比xml，JSON是一种非常高效的数据格式，如下图所示：</p><p><img src="4.5json.png" /></p><p>我们可以采用如下方式定义 JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//整个 JSON 字符串用 &#x27;&#x27; </span><br><span class="hljs-comment">//字符串用 &quot;&quot;</span><br><span class="hljs-comment">//数字直接写</span><br><span class="hljs-comment">//布尔值直接写 true false</span><br><span class="hljs-comment">//数组用 [] 围起来</span><br><span class="hljs-comment">//对象用 &#123;&#125; 围起来</span><br><span class="hljs-keyword">var</span> userStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Jerry&quot;,&quot;age&quot;:18, &quot;address&quot;:[&quot;北京&quot;,&quot;上海&quot;]&#125;&#x27;</span>;<br><span class="hljs-comment">//这里不能换行</span><br></code></pre></td></tr></table></figure><p>定义好了 JSON，接下来我们访问 JSON 中的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(userStr.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><p>浏览器输出了 undefined，为什么？这是因为上述定义是一个 JSON字符串，而不是 JSON 对象。JS 为我们提供了对它们进行转换的函数：</p><ul><li><code>JSON.parse()</code> 函数 将 JSON 字符串转换为 JSON对象，返回一个对象需要接收</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsObject = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(userStr);<br></code></pre></td></tr></table></figure><ul><li><code>JSON.stringify()</code> 对象 将 JSON 对象转换为 JSON字符串，返回一个字符串需要接收</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(jsObject);<br></code></pre></td></tr></table></figure><h3 id="bom-对象">4.5.2 BOM 对象</h3><p>接下来我们学习 BOM 对象，BOM 的全称是 Browser ObjectModel，翻译过来是浏览器对象模型。JavaScript将浏览器的各个组成部分封装成了对象，允许JavaScript 与浏览器对话。我们要操作浏览器的部分功能，可以通过操作 BOM对象的相关属性或者函数来完成。</p><p>BOM 提供了如下五个对象：</p><table><thead><tr><th>对象名称</th><th>描述</th></tr></thead><tbody><tr><td>Window</td><td>浏览器窗口对象</td></tr><tr><td>Navigator</td><td>浏览器对象</td></tr><tr><td>Screen</td><td>屏幕对象</td></tr><tr><td>History</td><td>历史记录对象</td></tr><tr><td>Location</td><td>d地址栏对象</td></tr></tbody></table><p><img src="4.5bom.png" /></p><p>在此我们重点介绍 Window 和 Location 对象</p><h4 id="window-对象">4.5.2.1 Window 对象</h4><p>window 对象指的是浏览器窗口对象，window 对象是全局对象，所以对于window 对象，我们可以直接使用，并且对于 window对象的函数和属性，我们可以省略 <code>window.</code>。例如：我们之前学习的 alert() 函数其实是属于 window对象的，其完整的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure><p>所以对于 window 对象的属性和函数，我们都是采用简写的方式。window提供了很多属性，下表列出了常用属性，window对象提供了获取其他BOM对象的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>history</td><td>对 History 对象的只读引用。请参阅 <ahref="https://www.w3school.com.cn/jsref/dom_obj_history.asp">History对象</a> 。</td></tr><tr><td>location</td><td>用于窗口或框架的 Location 对象。请参阅 <ahref="https://www.w3school.com.cn/jsref/dom_obj_location.asp">Location对象</a>。</td></tr><tr><td>navigator</td><td>对 Navigator 对象的只读引用。请参阅 <ahref="https://www.w3school.com.cn/jsref/dom_obj_navigator.asp">Navigator对象</a>。</td></tr><tr><td>screen</td><td>用于获取Screen对象</td></tr></tbody></table><p>也就是说我们要使用 location 对象，只需要通过代码<code>window.location</code> 或者简写 <code>location</code>即可使用。</p><p>window也提供了一些常用的函数，如下表格所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>comfirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr></tbody></table><ul><li><code>alert()</code> 函数弹出警告框，函数的内容就是警告框的内容。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello BOM Window&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><code>comfirm()</code> 函数弹出确认框，函数的内容就是确认框的内容，并且提供用户2个按钮，分别是确认和取消。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;您确认删除该记录吗?&quot;</span>);<br></code></pre></td></tr></table></figure><p>但是我们怎么知道用户点击了确认还是取消呢？所以这个函数有一个返回值，当用户点击确认时，返回值为true，点击取消时，返回值为false。我们根据返回值来决定是否执行后续操作。修改代码如下，可以查看返回值true 或者 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> flag = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;您确认删除该记录吗?&quot;</span>);<br><span class="hljs-title function_">alert</span>(flag);<br></code></pre></td></tr></table></figure><ul><li><code>setInterval()</code> 函数定时器，用于周期性的执行某个功能，并且是<strong>循环执行</strong>。该函数需要传递2个参数：参数1：函数，需要周期性执行的功能代码 参数2：间隔时间（单位毫秒）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定时器 - setInterval -- 周期性的执行某一个函数</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     i++;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;定时器执行了&quot;</span>+i+<span class="hljs-string">&quot;次&quot;</span>);<br>&#125;,<span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><ul><li><code>setTimeout()</code> 函数定时器，只会在一段时间后<strong>执行一次功能</strong>。参数和上述setInterval一致。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定时器 - setTimeout -- 延迟指定时间执行一次 </span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;JS&quot;</span>);<br>&#125;,<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h4 id="location-对象">4.5.2.2 Location 对象</h4><p>location 是指代浏览器的地址栏对象，使用 window.location 获取，其中<code>window.</code> 可以省略。对于这个对象，我们常用的是 href属性，用来获取或者设置浏览器的地址栏信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//获取浏览器地址栏信息</span><br><span class="hljs-title function_">alert</span>(location.<span class="hljs-property">href</span>);<br><span class="hljs-comment">//设置浏览器地址栏信息，设置之后浏览器自动跳转指定地址</span><br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="dom-对象">4.5.3 DOM 对象</h3><p>DOM：<strong>D</strong>ocument <strong>O</strong>bject<strong>M</strong>odel 文档对象模型，JavaScript 将 HTML文档的各个组成部分封装为对应的对象：</p><ol type="1"><li>Core DOM - 所有文档类型的标准模型<ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li>XML DOM - XML 文档的标准模型</li><li>HTML DOM - HTML 文档的标准模型<ul><li>Image：&lt;img scr=““&gt;</li><li>Button ：&lt;input type=“button”&gt;</li><li>……</li></ul></li></ol><p>在这里我们主要学习 HTML DOM，HTML DOM 将所有的 HTML标签都封装成了对象，具体的属性和函数可以查阅 <ahref="https://www.w3school.com.cn/jsref/index.asp">JavaScript 和 HTMLDOM 参考手册 (w3school.com.cn)</a></p><p><img src="4.5dom.png" /></p><p>DOM 的主要作用如下：</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><p>总之就是达到<strong>动态</strong>改变页面效果目的</p><p>学习 DOM，核心就是两点：</p><ol type="1"><li>获取 DOM 中的元素对象（Element对象 ，也就是标签）</li><li>操作 Element 对象的属性，也就是标签的属性。</li></ol><p>首先就是如何获取 DOM 对象 HTML 中的 Element 对象可以通过 Document对象获取，而 Document 对象是通过 window 对象获取的（window 可以省略）。Document 对象中提供了以下获取 Element 元素对象的函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>根据 id 属性值获取，返回单个 Element 对象</td></tr><tr><td>document.getElementsByTagName()</td><td>根据标签名称获取，返回 Element 对象数组</td></tr><tr><td>document.getElementsByName()</td><td>根据 name 属性值获取，返回 Element 对象数组</td></tr><tr><td>document.getElementsByClassName()</td><td>根据 class 属性值获取，返回 Element 对象数组</td></tr></tbody></table><p>如下代码是通过 id 获取 id 值为 “h1” 的元素对象，返回给变量 h：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> h = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这些函数都非常简单，在这里不再一一演示，需要注意的是其他三个获取方式由于并不唯一，返回的都是对象数组，需要使用下标取出对应的对象。</p><p>获取到对象之后如何操作标签的属性呢？通过查阅文档，在这里演示一个修改标签内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;content&#x27;</span>);<br><span class="hljs-keyword">var</span> div1 = divs[<span class="hljs-number">0</span>];<br><br>div1.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;666&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="js-事件监听">4.6 JS 事件监听</h2><p>什么是事件呢？HTML 事件是发生在 HTML 元素上的 “事情”，例如：</p><ul><li>按钮被点击</li><li>鼠标移到元素上</li><li>输入框失去焦点</li><li>……</li></ul><p>而我们可以给这些事件绑定函数，当<strong>事件触发</strong>时，<strong>执行相应的代码</strong>，完成对应的功能，这就是事件监听，是JS 非常重要的一部分。</p><p>JavaScript 提供了两种事件绑定方式：</p><ul><li>方式一：通过 HTML标签中的事件属性进行绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;button&quot;</span> onclick=<span class="hljs-string">&quot;on()&quot;</span> value=<span class="hljs-string">&quot;按钮1&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我被点击了!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>方式二：通过 DOM 中 Element 元素的事件属性进行绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;button&quot;</span> id=<span class="hljs-string">&quot;btn&quot;</span> value=<span class="hljs-string">&quot;按钮2&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我被点击了!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>除了以上演示的点击事件，以下再列出一些常用事件：</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击元素</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onmouseover</td><td>鼠标移到某元素上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p>更多的事件在文档中查阅 <ahref="https://www.w3school.com.cn/jsref/dom_obj_event.asp">HTML DOM 事件(w3school.com.cn)</a></p><h1 id="vue">5. Vue</h1><h2 id="引言">5.0 引言</h2><p>通过上述学习的 HTML + CSS + JS已经能够开发美观的页面了，但是开发的效率还有待提高，那么如何提高呢？一个完整的HTML页面包括了视图和数据，数据是通过请求从后台获取的，那么意味着我们需要将后台获取到的数据呈现到页面上，这就需要我们使用DOM 操作。正因为这种开发流程，所以我们引入了一种叫做<strong>MVVM(Model-View-ViewModel)</strong>的前端开发思想，即让我们开发者更加关注数据，而非数据绑定到视图这种机械化的操作。那么具体什么是MVVM思想呢？</p><p><strong>MVVM</strong>：Model-View-ViewModel 的缩写</p><ul><li>Model: 数据模型，特指前端中通过请求从后台获取的数据</li><li>View: 视图，用于展示数据的页面，可以理解成我们的 HTML + CSS搭建的页面，但是没有数据</li><li>ViewModel: 数据绑定到视图，负责将数据（Model）通过 JavaScript 的 DOM技术，将数据展示到视图（View）上</li></ul><p>如图所示就是 MVVM 开发思想的含义：</p><p><img src="5.0vue.png" /></p><p>基于上述的 MVVM 思想，其中的 Model 我们可以通过 <strong>Ajax</strong>来发起请求从后台获取；对于 View 部分，我们在下一个章节会学习一款<strong>ElementUI</strong> 框架替代 HTML + CSS 来更加方便的搭建View；而接下来我们要学习的就是侧重于 ViewModel 部分开发的<strong>Vue</strong> 前端框架，用来替代 JavaScript 的 DOM操作，让数据展示到视图的代码开发变得更加的简单。可以简单到什么程度呢？可以参考下图对比：</p><p><img src="5.0vuecom.png" /></p><p>在更加复杂的 DOM 操作中，Vue只会变得更加的简单！在上述的代码中，我们看不到之前的DOM操作，因为 Vue全部帮我们封装好了。</p><h2 id="vue-简介">5.1 Vue 简介</h2><p>接下来正式开始学习 Vue，目前最新版本为 Vue3，但目前企业大多还在使用Vue2，所以在这里我们仍然学习 Vue2。 官网：<ahref="https://v2.cn.vuejs.org/">Vue.js (vuejs.org)</a></p><p><strong>Vue.js</strong>（读音 /vjuː/, 类似于 view）是一套构建用户界面的<strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。Vue 基于 MVVM思想，实现数据的双向绑定，将编程的关注点放在数据上。Vue的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue.js的目标是通过尽可能简单的 API实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p><blockquote><p>框架即是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷、更加高效。</p></blockquote><h2 id="vue-初体验">5.2 Vue 初体验</h2><ol type="1"><li>第一步：将官方提供的 vue.js 文件放在专门存放 js 文件的 js目录下</li><li>第二步：编写 &lt;script&gt; 标签来引入 vue.js 文件，代码如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>第三步：在 js 代码区定义 Vue 对象,代码如下：<ul><li><strong>el:</strong> 用来指定哪些标签被 Vue 管理，类似 CSS标签选择器。</li><li><strong>data:</strong> 用来定义数据模型。</li><li><strong>methods:</strong> 用来定义函数。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-comment">//里面是一个对象，所以使用 &#123;&#125;</span><br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">// app 是受管理的标签的 id 属性值</span><br>    <span class="hljs-attr">data</span>:&#123;      <span class="hljs-comment">// 数据模型</span><br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello Vue&quot;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>第四步：编写视图，其中 <code>&#123;&#123;&#125;&#125;</code>是插值表达式，用来将 Vue 对象中定义的 data 展示到页面上的<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>       &#123;&#123;message&#125;&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>插值表达式：。 内容可以是：<strong>变量</strong>算术运算 三元运算符 函数调用</p></blockquote><p>以上代码实现的效果就是输入框输入什么，后面的元素就显示什么，Vue对象数据模型 data 中的 message 和视图中的 message双向绑定，互相影响。</p><h2 id="vue-指令">5.3 Vue 指令</h2><p>在上述 Vue 体验中有一个没有学过的属性 <code>v-model</code>，HTML标签上带有 v- 前缀的特殊属性，这个就是 Vue 的<strong>指令</strong>。在Vue 中通过大量的指令来实现数据绑定到视图的，所以接下来我们学习一些 Vue的常用指令，如下表所示：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>v-bind</td><td>为 HTML 标签绑定属性值，如设置 href , css 样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为 HTML 标签绑定事件</td></tr><tr><td>v-if</td><td>条件性的渲染某元素，判定为 true 时渲染,否则不渲染</td></tr><tr><td>v-else-if</td><td></td></tr><tr><td>v-else</td><td></td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是 display 属性的值</td></tr><tr><td>v-for</td><td>列表渲染，遍历容器的元素或者对象的属性</td></tr></tbody></table><ul><li><code>v-bind</code>：为 HTML 标签绑定属性值 语法使用<code>v-bind:属性名</code> 或者直接使用 <code>:属性名</code>，当 Vue对象中的数据模型发生变化时，标签的属性值会随之发生变化。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//两种写法都可以</span><br>&lt;a v-<span class="hljs-attr">bind</span>:href=<span class="hljs-string">&quot;url&quot;</span>&gt;链接<span class="hljs-number">1</span>&lt;/a&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//vue接管区域</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">           <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://www.baidu.com&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ul><li><code>v-model</code>：在表单元素上创建双向数据绑定<ul><li>Vue对象的 data 属性中的数据变化，视图展示会一起变化</li><li>视图数据发生变化，Vue 对象的 data 属性中的数据也会变化</li></ul></li></ul><p>data属性中数据变化，我们知道可以通过赋值来改变；但是视图数据为什么会发生变化呢？<strong>只有表单项标签！所以双向绑定一定是使用在表单项标签上的</strong>。在上述代码中添加以下代码，我们会发现，输入框中输入内容，会改变上述代码中超链接的地址，这就是数据双向绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;url&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>那么这个在企业开发的应用场景是什么？<strong>双向绑定的作用：可以获取表单的数据的值，然后提交给服务器</strong></p><blockquote><p>通过 v-bind 或者 v-model 绑定的变量，必须在数据模型中声明。</p></blockquote><ul><li><code>v-on</code>：为 HTML 标签绑定事件 类似 JS中的事件绑定，事件名相较于 JS 没有 on，有 <code>v-on:事件名</code> 或<code>@事件名</code> 两种写法，如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JS中</span><br>&lt;input onclick=<span class="hljs-string">&quot;demo()&quot;</span>&gt;<br><span class="hljs-comment">// Vue中，还有简写形式</span><br>&lt;input v-on:click=&quot;demo()&quot;&gt;<br>&lt;input @click=&quot;demo()&quot;&gt;<br></code></pre></td></tr></table></figure><p>接下来演示一个点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="hljs-comment">//两种写法都可以</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点我一下&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点我一下&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//vue接管区域</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">methods</span>: &#123;  <span class="hljs-comment">//函数声明</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">handle</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你点我了一下...&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>v-on 指令事件绑定的函数，需要在 Vue 对象 methods 中声明</p></blockquote><ul><li><code>v-if</code> <code>v-else-if</code> <code>v-else</code>根据条件渲染元素，判定为 true 时渲染，否则不渲染。</li></ul><p>定义 Vue 对象的代码省略，双向绑定 age属性，意味着我们可以通过表单输入框来改变age的值，下面演示代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">年龄&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;age&quot;</span>&gt;经判定,为:<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人(35及以下)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人(35-60)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span>老年人(60及以上)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>以上代码实现了当我们改变年龄时，动态判断年龄的值，呈现对应的年龄的文字描述。</p><ul><li><code>v-show</code> 根据条件展示元素，判定为 true时显示，否则不显示。</li></ul><p>和上述 v-if 的显示效果一样，区别在于上述判断为 false 时不渲染；而v-show 无论怎样都会渲染，只是决定是否显示。</p><blockquote><p>具体差别可以在 F12 开发者工具中查看，v-if指令中，不满足条件的标签代码直接没了，而 v-show指令中，不满足条件的代码依然存在，只是添加了 css 样式 display:none来控制标签不显示。</p></blockquote><ul><li><code>v-for</code>从名字我们就能看出，这个指令是用来遍历的。需要循环哪个标签，v-for指令就写在哪个标签上。其语法格式如下：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">标签</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;变量名 in 集合模型数据&quot;</span>&gt;</span><br>    &#123;&#123;变量名&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">标签</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有时我们遍历时需要使用索引，那么 v-for 指令遍历的语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;标签 v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(变量名,索引变量) in 集合模型数据&quot;</span>&gt;<br>    <span class="hljs-comment">//索引变量是从0开始，所以要表示序号的话，需要手动的加1</span><br>    <span class="hljs-comment">//在Vue初体验中介绍了插值表达式可以进行算术运算</span><br>   &#123;&#123;索引变量 + <span class="hljs-number">1</span>&#125;&#125; &#123;&#123;变量名&#125;&#125;<br>&lt;/标签&gt;<br></code></pre></td></tr></table></figure><p>接下来演示一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;addr in addrs&quot;</span>&gt;</span>&#123;&#123;addr&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     &lt;hr&gt;<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(addr,index) in addrs&quot;</span>&gt;</span>&#123;&#123;index + 1&#125;&#125; : &#123;&#123;addr&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//vue接管区域</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">           <span class="hljs-attr">addrs</span>:[<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>, <span class="hljs-string">&quot;成都&quot;</span>, <span class="hljs-string">&quot;深圳&quot;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="vue-生命周期">5.4 Vue 生命周期</h2><p>Vue 的生命周期：指的是 Vue 对象从创建到销毁的过程。 Vue的生命周期包含8个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。其完整的生命周期如下图所示：</p><table><thead><tr><th>状态</th><th>阶段周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td></tr><tr><td>created</td><td>创建后</td></tr><tr><td>beforeMount</td><td>挂载前</td></tr><tr><td><strong>mounted</strong></td><td><strong>挂载完成</strong></td></tr><tr><td>beforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>销毁前</td></tr><tr><td>destroyed</td><td>销毁后</td></tr></tbody></table><p>下图是 Vue 官网提供的从创建 Vue 到销毁 Vue对象的整个过程及各个阶段对应的钩子函数：</p><p><img src="5.4life.png" /></p><p>其中我们需要重点关注的是<strong>mounted</strong>，其他的我们了解即可。 mounted：挂载完成，Vue初始化成功，HTML 页面渲染成功。<strong>以后我们一般用于页面初始化自动的ajax 请求后台数据</strong>（发送请求到服务端，加载数据）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>       <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//vue接管区域</span><br>       <span class="hljs-attr">data</span>:&#123;  <br>       &#125;,<br>       <span class="hljs-attr">methods</span>: &#123;<br>       &#125;,<br>       <span class="hljs-comment">//与 methods 同级</span><br>       <span class="hljs-title function_">mounted</span> () &#123;<br>           <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;vue挂载完成,发送请求到服务端&quot;</span>)<br>       &#125;<br>   &#125;)<br></code></pre></td></tr></table></figure><h2 id="vue-路由">5.5 Vue 路由</h2><p>前端路由：URL 中的 hash(#号) 与组件之间的对应关系。</p><p><img src="5.5Vue.png" /></p><p>Vue Router 是 Vue 的官方路由。有以下组成部分：</p><ul><li><code>VueRouter</code>：路由器类，根据路由请求在路由视图中动态渲染选中的组件</li><li><code>&lt;router-link&gt;</code>：请求链接组件，浏览器会解析成<code>&lt;a&gt;</code></li><li><code>&lt;router-view&gt;</code>：动态视图组件，用来渲染展示与路由路径对应的组件</li></ul><p>首先 VueRouter 根据我们配置的 url 的 hash片段和路由的组件关系去维护一张路由表；然后页面提供一个<code>&lt;router-link&gt;</code> 组件，用户点击，发出路由请求；接着VueRouter 根据路由请求，在路由表中找到对应的 vue 组件；最后 VueRouter会切换 <code>&lt;router-view&gt;</code>中的组件，从而进行视图的更新。如下图所示：</p><p><img src="5.5Router.png" /></p><p>使用 VueRouter 需要先安装 vue-router 插件，可以通过如下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install vue-router@<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>或者在使用 vue-cli 创建项目时选择 VueRouter 插件。</p><p>使用大致有这样几步：</p><ol type="1"><li>在 src/router/index.js文件中定义路由表，根据其提供的模板代码进行修改。如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/emp&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;emp&#x27;</span>,<br>    <span class="hljs-attr">component</span>:  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/tlias/EmpView.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,  <span class="hljs-comment">//默认路径</span><br>    <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/emp&#x27;</span> <span class="hljs-comment">//可以重定向到/emp，防止默认路径没有页面显示</span><br>&#125;,<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在 main.js 中引入了router功能。</li><li>路由基本信息配置好了，路由表已经被加载，此时我们还缺少2个东西，就是<code>&lt;router-link&gt;</code> 和<code>router-view</code>，在需要跳转的位置添加如下代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//浏览器会解析成 &lt;a&gt; 标签 </span><br>&lt;router-link to=<span class="hljs-string">&quot;/dept&quot;</span>&gt;部门管理&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>在内容展示区域即 App.vue 中定义<code>route-view</code>，实现组件的切换，如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="ajax">6. Ajax</h1><h2 id="原生-ajax">6.1 原生 Ajax</h2><p>前端页面中的数据，不应该是在页面中写死的，而应该来自于后端，后端和前端是互不影响的程序，前端应该如何从后端获取数据？这必须涉及到2 个程序的交互，这就需要用到我们接下来学习的 Ajax 技术。</p><p>Ajax：全称 <strong>A</strong>synchronous <strong>J</strong>avaScript<strong>A</strong>nd <strong>X</strong>ML，异步的 JavaScrip t和XML。其作用如下：</p><ul><li>数据交换：通过 Ajax可以向服务器发送请求，并获取服务器响应的数据。</li><li>异步交互：可以在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并<strong>更新部分网页</strong>的技术，如：搜索联想、用户名是否可用的校验等等。</li></ul><p>针对上述 Ajax 的局部刷新功能是因为 Ajax请求是异步的，与之对应的有同步请求。接下来我们介绍一下异步请求和同步请求的区别。</p><ul><li>同步浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作，只能等待服务器响应结束，才能继续做其他的操作。</li></ul><p><img src="6.1tongbu.png" /></p><ul><li>异步浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</li></ul><p><img src="6.1yibu.png" /></p><p>Ajax 请求是基于客户端发送请求，服务器响应数据的技术。</p><ul><li>服务器端 这里我使用 SpringBoot，直接通过 Ajax请求访问该地址即可。后台服务器地址：http://localhost:8080/nav/selectAll</li></ul><blockquote><p>有一点要注意，CORS是浏览器的一种安全机制，用来防止网页请求来自不同域的资源。如果服务器没有正确配置CORS头，浏览器会拒绝访问响应数据。如果只是为了开发和测试，可以使用浏览器扩展来绕过CORS政策。这些扩展允许所有请求通过，但是请注意，这种方法不适用于生产环境。<ahref="https://chromewebstore.google.com/detail/allow-cors-access-control/lhobafahddgcelffkeicbaginigeejlf?hl=zh-CN">AllowCORS</a></p></blockquote><ul><li>客户端</li></ul><ol type="1"><li>第一步：创建 <code>XMLHttpRequest</code>对象，用于和服务器交换数据。也是原生 Ajax请求的核心对象，提供了各种方法。代码如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. 创建XMLHttpRequest </span><br><span class="hljs-keyword">var</span> xmlHttpRequest  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>第二步：调用 <code>open()</code>方法设置请求的参数信息，例如请求地址，请求方式；然后调用<code>send()</code>方法向服务器发送请求。代码如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//2. 发送请求</span><br>xmlHttpRequest.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;http://localhost:8080/nav/selectAll&#x27;</span>);<br>xmlHttpRequest.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>第三步：获取服务器响应数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3. 获取服务响应数据</span><br>xmlHttpRequest.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//此处判断 4表示浏览器已经完全接受到Ajax请求得到的响应，200表示这是一个正确的Http请求，没有错误</span><br>    <span class="hljs-keyword">if</span>(xmlHttpRequest.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xmlHttpRequest.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div1&#x27;</span>).<span class="hljs-property">innerHTML</span> = xmlHttpRequest.<span class="hljs-property">responseText</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="axios">6.2 Axios</h2><p>上述原生的 Ajax请求的代码编写起来还是比较繁琐的，所以接下来我们学习一门更加简单的发送Ajax 请求的技术 Axios 。Axios 对原生的 Ajax进行了封装，简化书写，快速开发。Axios 官网是：<ahref="https://www.axios-http.cn/">Axios中文文档</a></p><p>Axios 的使用非常简单，主要有两步：</p><ol type="1"><li>引入 Axios 的 js 文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用 Axios 发送请求，并获取响应结果，官方提供的 api很多，此处给出2种，如下：</li></ol><ul><li>发送 get 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;  <br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;get&quot;</span>,  <br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://localhost:8080/nav/add?nav_title=hhh&amp;nav_link=666&quot;</span>  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>)&#123;  <br>    <span class="hljs-title function_">alert</span>(result.<span class="hljs-property">data</span>);  <br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>发送 post 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;  <br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&quot;post&quot;</span>,  <br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:8080/nav/add&quot;</span>,<br>    <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;nav_title=hhh&amp;nav_link=666&quot;</span> <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;   <span class="hljs-comment">//可用箭头函数简写</span><br>    <span class="hljs-title function_">alert</span>(result.<span class="hljs-property">data</span>);  <br>&#125;);<br></code></pre></td></tr></table></figure><p>axios() 是用来发送异步请求的，小括号中使用 JSON对象传递请求相关的参数：</p><ul><li><code>method</code> 属性：用来设置请求方式的。取值为 get 或者post。</li><li><code>url</code> 属性：用来书写请求的资源路径。如果是 get请求，需要将请求参数拼接到路径的后面，格式为：url?参数名=参数值&amp;参数名2=参数值2。</li><li><code>data</code> 属性：作为请求体被发送的数据。也就是说如果是 post请求的话，数据需要作为 data 属性的值。</li></ul><p><code>then()</code> 需要传递一个匿名函数。我们将 <code>then()</code>中传递的匿名函数称为<strong>回调函数</strong>，意思是该匿名函数在发送请求时不会被调用，而是在<strong>成功响应后调用</strong>的函数。而该回调函数中的<code>result</code> 参数是对响应的数据进行封装的对象，通过<code>result.data</code> 可以获取到响应的数据。</p><p>Axios 还针对不同的请求，提供了别名方式的api，它们更简单易用，具体如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>axios.get(url [, config])</td><td>发送get请求</td></tr><tr><td>axios.post(url [, data[, config]])</td><td>发送post请求</td></tr><tr><td>axios.put(url [, data[, config]])</td><td>发送put请求</td></tr><tr><td>axios.delete(url [, config])</td><td>发送delete请求</td></tr></tbody></table><p>[] 中的内容表示可选项，我们目前只关注 get 和 post请求，所以在上述案例中，我们可以将代码改写成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:8080/nav/selectAll&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);  <span class="hljs-comment">// 箭头函数的()甚至也可以省略</span><br>&#125;)<br><br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;http://localhost:8080/nav/add&quot;</span>,<span class="hljs-string">&quot;nav_title=hhh&amp;nav_link=666&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">data</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="前后端分离开发">7. 前后端分离开发</h1><h2 id="开发方式简介">7.1 开发方式简介</h2><p>前面我们介绍过有两种开发方式：<strong>前后端混合开发</strong>和<strong>前后端分离开发</strong>。</p><p>前后端混合开发，顾名思义就是前后端代码混在一起开发。这种开发模式有如下缺点：</p><ul><li>沟通成本高：后端人员发现前端有问题，需要找前端人员修改，前端修改成功，再交给后台人员使用。</li><li>分工不明确：后端开发人员需要开发后端代码，也需要开发部分前端代码。</li><li>不便管理：所有的代码都在一个工程中。</li><li>不便维护和扩展：前端代码更新，和后端无关，但是需要整个工程包括后台一起重新打包部署。</li></ul><p>所以我们目前基本都是采用的前后端分离开发方式，如下图所示：</p><p><img src="7.1doc.png" /></p><p>我们将原先的工程分为前端工程和后端工程这两个工程，前端工程交给专业的前端人员开发，后端工程交给专业的后端人员开发。前端页面需要数据，可以通过发送异步请求，从后端工程获取。但是，我们前后端是分开开发的，前端人员怎么知道后端返回数据的格式呢？后端人员开发，怎么知道前端人员需要的数据格式呢？针对这个问题，我们为前后端开发统一指定一套规范，我们前后端开发人员只需遵循这套规范开发，就可以无缝衔接，这就是我们的<strong>接口文档</strong>，接口文档有离线版和在线版本。那么接口文档的内容怎么来的呢？是我们后端开发者根据产品经理提供的产品原型和需求文档所撰写出来的。</p><p>那么基于前后台分离开发的模式下，后端开发者开发一个功能的具体流程如何呢？</p><ol type="1"><li>需求分析：首先我们需要阅读需求文档，分析需求，理解需求。</li><li>接口定义：查询接口文档中关于需求的接口的定义，包括地址，参数，响应数据类型等等。</li><li>前后台并行开发：各自按照接口文档进行开发，实现需求。</li><li>测试：前后端开发完了，各自按照接口文档进行测试。</li><li>前后端联调测试：前端工程请求后端工程，测试功能。</li></ol><h2 id="yapi">7.2 YApi</h2><p>前后端分离开发中，我们前后端开发人员都需要遵循接口文档，所以接下来我们介绍一款撰写接口文档的平台。YApi是高效、易用、功能强大的 api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。官网地址：<ahref="https://yapi.pro/">YApiPro-高效、易用、功能强大的可视化接口管理平台</a></p><p>YApi 主要提供了2个功能：</p><ul><li>API接口管理：根据需求撰写接口，包括接口的地址，参数，响应等等信息。</li><li>Mock服务：模拟真实接口，生成接口的模拟测试数据，用于前端的测试。</li></ul><h2 id="前端工程化">7.3 前端工程化</h2><p>前端工程化是通过 Vue 官方提供的脚手架 Vue-cli来完成的，用于快速的生成一个 Vue 的项目模板。 Vue-cli主要提供了如下功能：</p><ul><li>统一的目录结构</li><li>本地调试</li><li>热部署</li><li>单元测试</li><li>集成打包上线</li></ul><p>运行 Vue-cli，需要依赖 NodeJS，NodeJS是前端工程化依赖的环境。所以我们需要先安装 NodeJS，然后才能安装Vue-cli。 <ahref="https://nodejs.org/zh-cn/download/package-manager">Node.js — 下载Node.js®</a></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br></code></pre></td></tr></table></figure><p>环境准备好了，接下来我们通过 Vue-cli 创建一个 Vue 项目，再学习一下Vue 项目的目录结构。Vue-cli 提供了如下2种方式创建 Vue 项目:</p><ul><li>命令行：直接通过命令行方式创建 Vue 项目</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">vue <span class="hljs-keyword">create</span> vue-project01<br></code></pre></td></tr></table></figure><ul><li>图形化界面：通过命令先进入到图形化界面，然后再进行 Vue工程的创建</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vue ui</span><br></code></pre></td></tr></table></figure><p>基于 Vue 脚手架创建出来的工程，有标准的目录结构，如下：</p><p><img src="7.3doc.png" /></p><p>创建好工程如何运行呢？有两种方式可供选择，首先可以通过 VSCode的图形化界面 npm 脚本启动，如下图：</p><p><img src="7.3run.png" /></p><p>还可以直接基于 cmd 命令窗口，在 Vue 目录下，执行输入命令<code>npm run serve</code> 即可。</p><p>对于8080端口，经常被占用，所以我们可以去修改默认的8080端口。我们修改<code>vue.config.js</code> 文件的内容，添加如下代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">7000</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们发现，index.html 的代码很简洁，但是浏览器所呈现的 index.html内容却很丰富，代码和内容不匹配，所以 Vue是如何做到的呢？接下来我们学习一下 Vue 项目的开发流程。</p><p><img src="7.3Vuedev.png" /></p><p>对于 Vue 项目，index.html 文件默认是引入了入口函数 main.js文件，我们找到 src/main.js 文件，其代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  router,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>​ 上述代码中，包括如下几个关键点：</p><ul><li><code>import</code>：导入指定文件，并且重新命名。例如上述代码<code>import App from './App.vue'</code>导入当前目录下的App.vue 并且命名为 App。</li><li><code>new Vue()</code>：创建 Vue 对象。</li><li><code>$mount('#app')</code>：将 Vue 对象创建的 dom 对象挂在到id=“app” 的这个标签区域中，作用和之前学习的 Vue 对象的 el属性一致。</li><li><code>router</code>：引入路由。</li><li><code>render</code>：主要使用视图的渲染的。</li></ul><p>此时我们知道了 Vue 创建的 dom 对象挂在到 id=app的标签区域，但是我们还是没有解决最开始的问题：首页内容如何呈现的？render 中的 App 是关键，头文件上显示导入来自 ./App.vue 的 App。这个 App对象怎么回事呢，我们打开 App.vue，注意 .vue 结尾的都是 vue 组件。而 vue的组件文件包含3个部分：</p><ul><li><code>template</code>：模板部分，主要是 HTML代码，用来展示页面主体结构的。</li><li><code>script</code>：js代码区域，主要是通过 js代码来控制模板的数据来源和行为的。</li><li><code>style</code>：css样式部分，主要通过 css样式控制模板的页面效果得。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 模板部分，由它生成HTML代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123;message&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 控制模板的数据来源和行为 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript"><span class="hljs-comment">//data之前直接指定对象，这里的data指定的是函数，函数返回对象</span></span><br><span class="language-javascript">    <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; </span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello vue&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"><span class="hljs-comment">//4.5.1.3中介绍过函数可以这样简写</span></span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;  </span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello vue&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- css样式部分 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="element">8. Element</h1><p>在 MVVM 开发模式下，前面介绍的 Vue 是侧重于 VM开发的，主要用于数据绑定到视图的，接下来介绍的 ElementUI 就是一款侧重于V 开发的前端框架，主要用于开发美观的页面的。Element：是饿了么公司前端开发团队提供的一套基于 Vue的网站组件库，用于快速构建网页。 Element提供了很多组件（组成网页的部件）供我们使用。例如超链接、按钮、图片、表格等等。</p><p>ElementUI 的学习方式和之前不太一样，对于ElementUI，作为一个后端开发者，只需要<strong>学会如何从ElementUI的官网复制组件到我们自己的页面中，并且做一些修改即可</strong>。其官网地址：<ahref="https://element.eleme.cn/#/zh-CN">Element -网站快速成型工具</a>。</p><ol type="1"><li>首先要安装 ElementUI 的组件库，打开VSCode，在命令行输入如下命令：</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install element-ui@<span class="hljs-number">2</span>.<span class="hljs-number">9</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>然后需要在 main.js 这个入口 js 文件中引入 ElementUI的组件库，其代码如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br></code></pre></td></tr></table></figure><p>按照 vue 项目的开发规范，在 src/views 目录下创建 vue组件文件，注意组件名称后缀是.vue，并且<strong>使用驼峰命名</strong>，并且在组件文件中编写之前介绍过的基本组件语法。</p><ol start="3" type="1"><li>最后我们只需要去ElementUI的官网，在组件库中找到对应的组件复制代码即可，需要注意的是，我们组件包括了3个部分，如果官方有除了template 部分之外的 style 和 script 都需要复制。</li></ol><p>还需要在默认访问的根组件 src/App.vue中引入我们自定义的组件，具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  //保留这个div标签</span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 这里根据提示引入element-view组件时会自动生成（必须使用驼峰命名） --&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- vue组件叫什么 xxxView.vue 这里就叫 xxx-view --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">element-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">element-view</span>&gt;</span> </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 这里根据提示引入element-view组件时会自动生成 --&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">import ElementView from &#x27;./views/Element/ElementView.vue&#x27;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">export default &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">  components: &#123; ElementView &#125;,</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">&#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="打包部署">9. 打包部署</h1><p>打包部署分为两步，第一步是打包，第二步是部署。 直接在 VScode 中点击build 就可以完成打包，打包完成生成一个 dist 目录。</p><p><img src="9build.png" /></p><p>部署可以使用 Nginx。 Nginx 是一款轻量级的 Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，在各大型互联网公司都有非常广泛的使用。Nginx 的功能十分强大，这里只是使用其中非常小的一部分功能。</p><p>Nginx 在 windows 中的安装非常方便，直接解压即可。官网：<ahref="https://nginx.org/en/download.html">nginx:download</a>下载稳定版。下图是 Nginx 的目录结构说明：</p><p><img src="9Nginx.png" /></p><p>将之前打包的前端工程 dist 目录下的<strong>内容</strong>拷贝到 nginx的 html 目录下，双击 nginx.exe 来启动nginx，点击之后没有任何反应，可以通过任务管理器的详细信息查看是否启动成功，通过名称找到nginx 则表示已经启动。</p><p>nginx 默认占用端口80，如果80端口被占用，可以在 cmd 通过<code>netstat -ano | findStr 80</code>查看哪个进程占用了80端口，返回的信息中有进程的 PID号，再去任务管理器中通过 PID 找到占用端口的进程。在 windows下80端口经常被系统占用，如果80端口被占用，我们可以通过 conf/nginx.conf配置文件来修改端口号。</p><p>启动成功后访问在浏览器访问 http://localhost:80即可，其中80端口可以省略。</p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Java常用集合</title>
    <link href="/2023/07/17/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/05_Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/05_Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <url>/2023/07/17/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/05_Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/05_Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一集合概述">一、集合概述</h1><ul><li>集合的长度可以<strong>自动伸缩</strong></li><li>集合只能存储<strong>引用数据类型</strong></li><li>使用<strong>泛型</strong> <code>&lt;E&gt;</code>约束集合中存储元素的数据类型</li></ul><p>如果要存储基本数据类型，可以使用对应的<strong>包装类</strong></p><div class="line-block">基本数据类型 | 包装类 |</div><p>|:————:|: ——— :| | byte | Byte | | short | Short | |<strong>char</strong> | <strong>Character</strong> | |<strong>int</strong> | <strong>Integer</strong> | | long | Long | |float | Float | | double | Double | | boolean | Boolean |</p><h1 id="二-arraylist-类">二、 ArrayList 类</h1><h2 id="arraylist-概述">1. ArrayList 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/ArrayList.html">ArrayList的 API 文档</a></p><ul><li><code>ArrayList</code>类是一个可以<strong>动态修改</strong>的数组，与普通数组的区别就是它没有固定大小的限制</li></ul><h2 id="arraylist-的构造方法">2. ArrayList 的构造方法</h2><blockquote><p><strong>ArrayList()</strong><br />构造一个初始容量为10的空</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个只能存储 String 的空列表</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h2 id="arraylist-的常用方法">3. ArrayList 的常用方法</h2><blockquote><p>boolean <strong>add​(E e)</strong><br />添加元素到末尾，返回值表示是否添加成功</p></blockquote><blockquote><p>void <strong>add​(int index, E element)</strong><br />将元素插入到指定索引</p></blockquote><blockquote><p>boolean <strong>remove​(Object o)</strong><br />删除首次出现的指定元素，返回值表示是否删除成功</p></blockquote><blockquote><p>E <strong>remove​(int index)</strong><br />删除指定索引的元素，返回被删除的元素</p></blockquote><blockquote><p>E <strong>set​(int index, E element)</strong><br />修改指定索引的元素，返回被替换的元素</p></blockquote><blockquote><p>E <strong>get​(int index)</strong><br />返回指定索引的元素</p></blockquote><blockquote><p>int <strong>size()</strong><br />返回此列表中元素的个数</p></blockquote><ul><li>直接打印 <code>ArrayList</code>，会使用 <code>,</code> 分割，使用<code>[]</code> 包裹</li><li>遍历只会获取到元素本身，没有分隔符 <em>因为 String 类是 Java写好的，做了特殊处理，所以打印的不是地址值；如果装的是自己写的类，直接打印得到的是地址值，需要调用对应的get 方法</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  遍历</span><br>System.out.println(list.get(list));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 使用小技巧</title>
    <link href="/2023/07/15/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/IDEA%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/07/15/coding/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/IDEA%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<ol type="1"><li><code>Ctrl</code> + <code>Alt</code> + <code>M</code>自动抽取方法</li><li><code>Ctrl</code> + <code>Alt</code> + <code>L</code>格式化代码</li><li>按住 <code>Alt</code> +<code>鼠标左键</code> 或 按住<code>鼠标中键</code> 可竖着多选</li><li><code>Alt</code> + <code>Insert</code> 自动生成 JavaBean 构造方法和getter、setter 方法</li><li><code>Alt</code> + <code>Insert</code> 自动重写 equals 方法</li><li>安装插件 <code>PTG</code> 可更快速地一键生成 JavaBean 并重写toString 方法</li><li>小括号上按住 <code>Ctrl</code> + <code>P</code> 显示参数</li><li><code>Ctrl</code> + <code>Alt</code> + <code>V</code>自动生成变量声明的左边</li><li><code>数字.fori</code> 快速生成循环数字次的循环</li><li><code>数组名.fori</code> 快速生成遍历数组的循环</li><li><code>字符串.length().fori</code> 快速生成遍历字符串的循环</li><li><code>forr</code> 可以生成逆序遍历</li><li><code>Shift</code> + <code>F6</code> 批量修改</li><li><code>Ctrl</code> + <code>B</code> 或 <code>Ctrl</code> +<code>鼠标左键</code> 查看源码</li><li><code>Ctrl</code> + <code>Alt</code> + <code>T</code>选择语句包裹代码块</li><li><code>Ctrl</code> + <code>N</code> 搜索类右上角默认在本项目，可选全部搜索 Java 内置类</li><li><code>Ctrl</code> + <code>F12</code> 在类中搜索方法</li><li><code>Alt</code> + <code>回车</code> 将表达式切割</li><li><code>Ctrl</code> + <code>+</code> 展开代码 <code>Ctrl</code> +<code>-</code> 收缩代码</li><li><code>Shift</code> +<code>Alt</code> + <code>↑</code> 或<code>↓</code> 移动单行代码</li><li><code>Ctrl</code> + <code>Shift</code> + <code>U</code>转换大小写</li></ol>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Java常用API</title>
    <link href="/2023/07/14/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/04_%E5%B8%B8%E7%94%A8API/04_Java%E5%B8%B8%E7%94%A8API/"/>
    <url>/2023/07/14/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/04_%E5%B8%B8%E7%94%A8API/04_Java%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="一api">一、API</h1><h2 id="api-概述">1. API 概述</h2><blockquote><p>API (Application Programming Interface) ：应用程序编程接口。 Java中的 API 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></blockquote><h2 id="如何使用-api-帮助文档">2. 如何使用 API 帮助文档</h2><p><a href="https://www.runoob.com/manual/jdk11api/index.html">Overview(Java SE 11 &amp; JDK 11 )</a></p><p><embed src="%5BJava参考文档%5D.JDK_API_1_6_zh_CN.chm" /></p><ol type="1"><li>打开 API 帮助文档</li><li>点击显示找到索引</li><li>在搜索框中输入类名回车</li><li>查看类所在的包</li><li>查看类的描述</li><li>查看构造方法</li><li>查看成员</li></ol><h1 id="二字符串">二、字符串</h1><h2 id="string-类">1. String 类</h2><h3 id="string-概述">1.1 String 概述</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">String的 API 文档</a></p><ul><li>所有字符串文字都被<strong>实例</strong>为此类的对象</li><li>字符串是<strong>常量</strong>，它们的值在创建之后不能更改</li></ul><h3 id="string-对象的创建">1.2 String 对象的创建</h3><ol type="1"><li>直接赋值当使用双引号直接赋值时，系统会检查<strong>字符串常量池</strong>中是否存在该字符串，如果存在则复用，不存在再创建新的，这种方式创建<code>String</code> 可节省内存</li></ol><p><img src="04_string1.jpg" /></p><ol start="2" type="1"><li>构造方法 new 出来都在堆中开辟一块新的空间，这种方式创建重复的<code>String</code> 不会复用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(); <br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>String()</strong><br />初始化新创建的 String 对象，使其表示空字符串</p></blockquote><blockquote><p><strong>String​(String original)</strong><br />初始化新创建的 String 对象，使其表示与参数相同的字符串</p></blockquote><blockquote><p><strong>String​(byte[] bytes)</strong><br />通过 ASCⅡ 编码字节数组构造新的 String</p></blockquote><blockquote><p><strong>String​(char[] value)</strong><br />分配新的 String ，使其表示当前包含在字符数组参数中的字符序列</p></blockquote><p><img src="04_string2.jpg" /></p><h3 id="字符串的比较">1.3 字符串的比较</h3><ol type="1"><li><code>=​=</code> 的作用： 只能比较基本数据类型，不能比较引用数据类型<ul><li>比较基本数据类型：比较的是<strong>具体的数据值</strong></li><li>比较引用数据类型：比较的是<strong>对象的地址值</strong></li></ul></li><li><code>equals()</code> 方法的作用</li></ol><blockquote><p>boolean <strong>equals(Object anObject)</strong>将此字符串与指定的对象比较</p></blockquote><blockquote><p>boolean <strong>equalsIgnoreCase(String anotherString)</strong> 将此String 与另一个 String 比较，不考虑大小写</p></blockquote><h3 id="字符串的遍历">1.4 字符串的遍历</h3><blockquote><p>char <strong>charAt(int index)</strong> 返回指定索引处的值</p></blockquote><blockquote><p>int <strong>length()</strong> 返回字符串的长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;  <br>    System.out.println(s.charAt(i));  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串的常用操作">1.5 字符串的常用操作</h3><h4 id="拼接和逆置">1.5.1 拼接和逆置</h4><ul><li>字符串的拼接可直接使用 <code>+</code></li><li>字符串逆置可以使用空字符串不断拼接倒序遍历的字符串 <em>后面的StringBuilder 类拼接和逆置更加方便</em></li></ul><h4 id="截取">1.5.2 截取</h4><blockquote><p>String <strong>substring(int beginIndex)</strong>返回一个新字符串，它是截取从 beginIndex 到末尾的子串</p></blockquote><blockquote><p>String <strong>substring(int beginIndex, int endIndex)</strong>返回一个新字符串，它是从 beginIndex 到 endIndex 的子串（包左不包右）</p></blockquote><h4 id="替换">1.5.3 替换</h4><blockquote><p>String <strong>replace(char oldChar, char newChar)</strong>返回一个新字符串，使用 newChar 替换此字符串中出现的所有 oldChar</p></blockquote><h4 id="转换为字符数组">1.5.4 转换为字符数组</h4><blockquote><p>char[] <strong>toCharArray()</strong>将此字符串转换为一个新的字符数组。</p></blockquote><h2 id="stringbuilder-类">2. StringBuilder 类</h2><h3 id="stringbuilder-概述">2.1 StringBuilder 概述</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html">StringBuilder的 API 文档</a></p><ul><li><code>StringBuilder</code>可以看成是一个容器，创建之后里面的内容是<strong>可变的</strong>，又叫<strong>可变字符串</strong></li><li>作用：提高字符串的操作效率，在<strong>拼接</strong>和<strong>反转</strong>中常用</li></ul><h3 id="stringbuilder-的构造方法">2.2 StringBuilder 的构造方法</h3><blockquote><p><strong>StringBuilder()</strong><br />构造一个空白可变字符串，其中不包含任何字符，初始容量为16个字符</p></blockquote><blockquote><p><strong>StringBuilder​(String str)</strong><br />构造一个初始化为指定字符串内容的可变字符串</p></blockquote><h3 id="stringbuilder-的常用方法">2.3 StringBuilder 的常用方法</h3><p>因为 <code>StringBuilder</code> 是可变的，所以不需要像<code>String</code> 一样去接收返回值，直接操作的是<code>StringBuilder</code> 本身</p><blockquote><p>StringBuilder <strong>append​(任意类型)</strong><br />添加数据，并返回对象本身</p></blockquote><blockquote><p>StringBuilder <strong>reverse()</strong><br />反转容器中的内容</p></blockquote><blockquote><p>int <strong>length()</strong><br />返回长度（字符数）</p></blockquote><p><code>StringBuilder</code> 是帮助处理字符串的工具，处理之后可用<code>toString()</code> 转换为 <code>String</code> 继续处理</p><blockquote><p>String <strong>toString()</strong> 将 StringBuilder 转换为 String</p></blockquote><h3 id="链式编程">2.4 链式编程</h3><p>调用方法时，不使用变量接收其返回值，直接调用其他方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;abcd&quot;</span>).reverse().toString();<br></code></pre></td></tr></table></figure></p><h2 id="stringjoiner-类">3. StringJoiner 类</h2><h3 id="stringjoiner-概述">3.1 StringJoiner 概述</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/StringJoiner.html">StringJoiner的 API 文档</a></p><ul><li><code>StringJoiner</code> 跟 <code>StringBuilder</code>一样，也可以看成是一个容器，创建之后里面的内容是<strong>可变的</strong></li><li>作用：构造有<strong>分隔符</strong>的字符序列，并且可以指定<strong>前缀开头</strong>和<strong>后缀结束</strong></li></ul><h3 id="stringjoiner-的构造方法">3.2 StringJoiner 的构造方法</h3><blockquote><p><strong>StringJoiner​(CharSequence delimiter)</strong><br />创建一个 StringJoiner 对象，指定拼接的间隔符号</p></blockquote><blockquote><p><strong>StringJoiner​(CharSequence delimiter, CharSequence prefix,CharSequence suffix)</strong><br />创建一个 StringJoiner 对象，指定拼接的间隔符号、开始符号、结束符号</p></blockquote><h3 id="stringjoiner-的常用方法">3.3 StringJoiner 的常用方法</h3><blockquote><p>StringJoiner <strong>add​(CharSequence newElement)</strong><br />添加数据，并返回对象本身</p></blockquote><blockquote><p>int <strong>length()</strong><br />返回长度（所有字符的个数）</p></blockquote><blockquote><p>String <strong>toString()</strong><br />返回拼接之后的字符串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sj.add(<span class="hljs-string">&quot;1&quot;</span>).add(<span class="hljs-string">&quot;2&quot;</span>).add(<span class="hljs-string">&quot;3&quot;</span>).toString();<br>System.out.println(s);  <span class="hljs-comment">//  [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h2 id="字符串相关类底层原理">4. 字符串相关类底层原理</h2><h3 id="使用-拼接字符串">4.1 使用 <code>+</code> 拼接字符串</h3><ol type="1"><li>拼接时没有变量：<ul><li>触发字符串的优化机制，在编译的时候已经是最终结果了，会复用字符串常量池中的字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;ccc&quot;</span>;<br><span class="hljs-comment">//编译的 class 文件中是 String s = &quot;aabccc&quot;;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>拼接时有变量：<ul><li>在 JDK8 之前，底层会创建一个 <code>StringBuilder</code>对象，然后调用其 <code>append​()</code> 方法进行拼接，拼接后再调用<code>toString()</code> 方法转换成 <code>String</code> 类型，而<code>toString()</code> 方法的底层是 <code>new</code>了一个字符串对象。因此每使用一次 <code>+</code> ，至少会创建一个<code>StringBuilder</code> 对象和一个 <code>String</code> 对象</li><li>在 JDK8之后，系统预估字符串拼接之后的总大小，把要拼接的内容都放在数组中，此时也是产生一个新的字符串</li></ul></li></ol><p>有变量参与字符串拼接时，在内存中创建很多对象，浪费空间和时间，浪费性能，建议使用<code>StringBuilder</code> 或 <code>StringJoiner</code></p><h3 id="使用-stringbuilder-拼接字符串">4.2 使用 StringBuilder拼接字符串</h3><ul><li>所有要拼接的内容都会往 <code>StringBuilder</code>中放，不会创建很多无用空间，节省内存，提高效率</li></ul><blockquote><p>int <strong>capacity()</strong><br />返回当前容量</p></blockquote><ul><li>长度：实际存多少</li><li>容量：最多存多少</li></ul><p><code>StringBuilder</code> 扩容机制：</p><ul><li>默认创建一个容量为 16 的字节数组</li><li>添加的内容小于容量，直接存储</li><li>添加的内容大于容量，扩容为 原来的容量 * 2 + 2</li><li>如果扩容后还不够，扩容到实际长度</li></ul><h2 id="正则表达式">5. 正则表达式</h2><h3 id="正则表达式基本规则">5.1 正则表达式基本规则</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/regex/Pattern.html#sum">Pattern的 API 文档</a></p><p><ahref="https://jex.im/regulex/#!flags=&amp;re=">Regulex：在线正则表达式可视化工具</a></p><blockquote><p>boolean <strong>matches​(String regex)</strong><br />判断此字符串是否与给定的正则表达式匹配</p></blockquote><p>IDEA 中 any-Rule 插件提供常用正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符类（只匹配一个字符）</span><br>[abc]          只能是 a，b 或 c<br>[^abc]         除了a，b，c之外的任何字符<br>[a-zA-Z]       a 到 z 或 A 到 Z<br>[a-z[A-Z]]     a 到 z 或 A 到 Z<br>[a-z&amp;&amp;[abc]]   a 到 z 且 只能是 a，b，c<br>[a-z&amp;&amp;[&amp;bc]]   a 到 z 且除了 b，c（等同于[ad-z]）<br>[a-z&amp;&amp;[^e-g]]  a 到 z 且除了 e 到 g（等同于[a-dh-z]）<br><br><span class="hljs-comment">//预定义字符（只匹配一个字符）</span><br>.     任何字符<br>\d    数字：[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br>\D    非数字：[^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<br>\s    空白字符：[\t\n\x0B\f\r]<br>\S    非空白字符：[^\s]<br>\w    英文字母、数字或下划线：[a-zA-Z_0-<span class="hljs-number">9</span>]<br>\W    非英文字母数字下划线：[^\w]<br><br><span class="hljs-comment">//数量词</span><br>X?       <span class="hljs-number">1</span> 个或<span class="hljs-number">0</span>个 X<br>X*       <span class="hljs-number">0</span> 个或多个 X<br>X+       <span class="hljs-number">1</span> 个或多个 X<br>X&#123;n&#125;     正好 n 个 X<br>X&#123;n,&#125;    至少 n 个 X<br>X&#123;n,m&#125;   n 到 m 个 X<br><br><span class="hljs-comment">//嵌入式标志表达式</span><br>(?i)X    忽略 X 的大小写<br><br><span class="hljs-comment">//善用 () 和 |</span><br><span class="hljs-number">0</span>(<span class="hljs-number">1</span>[<span class="hljs-number">12</span>]|<span class="hljs-number">22</span>|<span class="hljs-number">33</span>)  <span class="hljs-number">011</span> <span class="hljs-number">012</span> 或 <span class="hljs-number">022</span> 或 <span class="hljs-number">033</span><br></code></pre></td></tr></table></figure><h3 id="爬虫">5.2 爬虫</h3><h4 id="本地数据爬取">5.2.1 本地数据爬取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;标记：这是标记1，这是标记2，这是标记3&quot;</span>;<br><span class="hljs-comment">//1. 获取正则表达式对象</span><br><span class="hljs-comment">//通过 compile 方法获取正则表达式对象</span><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;标记\\d?&quot;</span>);<br><span class="hljs-comment">//2. 获取文本匹配器对象</span><br><span class="hljs-comment">//通过 matcher 方法在 str 中查找符合正则表达式 p 的子串</span><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(str);<br><span class="hljs-comment">//3. 调用 find 方法</span><br><span class="hljs-comment">//有符合规则的子串返回 true，否则返回 false </span><br><span class="hljs-keyword">while</span>(m.find()) &#123;<br>    <span class="hljs-comment">//4. 调用 group 方法</span><br>    <span class="hljs-comment">//方法底层根据 find 记录的索引进行 subString 截取</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.group();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="网络数据爬取">5.2.2 网络数据爬取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建 URL 对象</span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;https://www.csdn.net/&quot;</span>);<br><span class="hljs-comment">//2. 连接上这个网址</span><br><span class="hljs-type">URLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> url.openConnection();<br><span class="hljs-comment">//3. 创建 BufferedReader 对象去读取网络中的数据</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(conn.getInputStream()));<br><span class="hljs-comment">//4. 获取正则表达式对象 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpp|c++&quot;</span>;<br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><span class="hljs-comment">//5. 逐行读取网络数据</span><br>String line;<br><span class="hljs-keyword">while</span>((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//6. 获取文本匹配器对象 </span><br>    <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(line);<br>    <span class="hljs-comment">//7. 逐个匹配</span><br>    <span class="hljs-keyword">while</span>(m.find()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.group();<br>        System.out.println(s);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//8. 关闭</span><br>br.close();<br></code></pre></td></tr></table></figure><h3 id="爬取方法">5.3 爬取方法</h3><blockquote><p>String <strong>replaceAll​(String regex, Stringreplacement)</strong><br />将符合正则表达式 regex 的部分替换为 replacement</p></blockquote><blockquote><p>String[] <strong>split​(String regex)</strong><br />将字符串从符合正则表达式的部分进行切割</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪婪爬取：在爬取数据的时候尽可能多的获取数据</span><br><span class="hljs-comment">//非贪婪爬取：再爬取数据的时候尽可能少的获取数据</span><br><br>+ *    默认是贪婪爬取<br>+? *?  加 ? 是非贪婪爬取  <br><br>ab+     abbbbbbbbbb<br>ab+?    ab<br><br><span class="hljs-comment">//分组：从左边开始为 1，以此类推不间断</span><br><br><span class="hljs-comment">//捕获分组：后续还要使用本组的数据</span><br>\组号 把指定组的内容拿出来再用<br>ab12ab<br>(.&#123;<span class="hljs-number">2</span>&#125;)d&#123;<span class="hljs-number">2</span>&#125;\\<span class="hljs-number">1</span><br><br>$组号 在正则表达式外使用指定组<br>s.replaceAll​(<span class="hljs-string">&quot;(.&#123;2&#125;)d&#123;2&#125;\\1&quot;</span>,<span class="hljs-string">&quot;$1&quot;</span>)<br><br><span class="hljs-comment">//非捕获分组：分组后不需要再使用本组数据，只是括起来（不占用组号）</span><br>(?:正则)     : 后面跟随的数据匹配，获取的时候获取全部<br>(?=正则)     = 后面跟随的数据要匹配，但获取的时候只获取前半部分<br>(?!正则)     ! 后面不能有这些数据<br><br>Java(?:<span class="hljs-number">8</span>|<span class="hljs-number">11</span>)  匹配 Java8 或 Java11 并获取<br>Java(?=<span class="hljs-number">8</span>|<span class="hljs-number">11</span>)  匹配 Java8 或 Java11，但只获取 Java<br><span class="hljs-title function_">Java</span><span class="hljs-params">(?!<span class="hljs-number">8</span>|<span class="hljs-number">11</span>)</span>  匹配 Java 且后面不带 <span class="hljs-number">8</span> 或 <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h1 id="三math-类">三、Math 类</h1><h2 id="math-概述">1. Math 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Math.html">Math的 API 文档</a></p><ul><li><code>Math</code>不可实例化，方法都是静态的，可以直接通过<strong>类名调用</strong></li><li><code>Math</code> 包含<strong>基本数字运算</strong></li></ul><h2 id="math-的常用变量">2. Math 的常用变量</h2><blockquote><p>static double <strong>E</strong><br />比任何其他值更接近 e ，自然对数的基数</p></blockquote><blockquote><p>static double <strong>PI</strong><br />比任何其他值更接近 π，圆的圆周与其直径之比</p></blockquote><h2 id="math-的常用方法">3. Math 的常用方法</h2><blockquote><p>static int <strong>abs​(int a)</strong><br />返回参数的绝对值</p><p><em>没有正数与负数对应时返回值会出错，例如 int -2147483648 ~2147483647，abs(-2147483648)会出错</em></p></blockquote><blockquote><p>static double <strong>ceil​(double a)</strong><br />返回大于或等于参数的最小数学整数（向上取整）</p></blockquote><blockquote><p>static double <strong>floor​(double a)</strong><br />返回小于或等于参数的最大数学整数（向下取整）</p></blockquote><blockquote><p>static int <strong>round​(float a)</strong> 返回与参数最接近的 int（四舍五入）</p></blockquote><blockquote><p>static int <strong>max​/min(int a, int b)</strong><br />返回两个参数中的较大值/较小值</p></blockquote><blockquote><p>static double <strong>pow​(double a, double b)</strong><br />返回 a 的 b 次幂</p></blockquote><blockquote><p>static double <strong>sqrt​(double a)</strong><br />返回参数的正数平方根</p></blockquote><blockquote><p>static double <strong>cbrt​(double a)</strong><br />返回参数的立方根</p></blockquote><blockquote><p>static double <strong>random()</strong><br />返回 [0.0, 1.0) 的随机数</p></blockquote><h1 id="四system-类">四、System 类</h1><h2 id="system-概述">1. System 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/System.html">System的 API 文档</a></p><ul><li><code>System</code>不可实例化，方法都是静态的，可以直接通过<strong>类名调用</strong></li><li><code>System</code> 包含了<strong>系统操作</strong>的常用方法</li></ul><h2 id="system-常用方法">2. System 常用方法</h2><blockquote><p>static void <strong>exit​(int status)</strong><br />终止当前运行的Java虚拟机</p></blockquote><blockquote><p>static long <strong>currentTimeMillis()</strong><br />以毫秒为单位返回当前系统时间（可用来计算程序运行时间）</p><p><em>时间原点：1970年1月1日00:00:00 我国在东八区有8小时时差</em></p></blockquote><blockquote><p>static void <strong>arraycopy​(Object src, int srcPos, Object dest,int destPos, int length)</strong><br />从 src 数组的 srcPos 索引开始，复制到 dest 数组的 destPos 索引开始，复制length 个值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">arraycopy​(源数组, 起始索引, 目标数组, 起始索引, 拷贝个数);<br><span class="hljs-comment">//利用 arraycopy​ 删除元素3</span><br><span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//将 4 5 向前移</span><br>arraycopy​(arr, <span class="hljs-number">3</span>, arr, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">//结果为 1 2 4 5 5</span><br>arr[arr.length - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-comment">//再将最后一位设成 0 即可 1 2 4 5 0</span><br></code></pre></td></tr></table></figure><h1 id="五runtime-类">五、Runtime 类</h1><h2 id="runtime-概述">1. Runtime 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Runtime.html">Runtime的 API 文档</a></p><ul><li>每个 Java 程序都有一个 <code>Runtime</code>实例，它允许<strong>程序与运行程序的环境交互</strong></li><li>应用程序<strong>不能主动创建</strong>自己的运行时实例，可以从<code>getRuntime</code> 方法获得当前程序的运行时实例</li></ul><h2 id="runtime-常用方法">2. Runtime 常用方法</h2><blockquote><p>static Runtime <strong>getRuntime()</strong><br />返回与当前 Java 程序关联的 Runtime 对象</p></blockquote><blockquote><p>void <strong>exit​(int status)</strong><br />停止虚拟机</p></blockquote><blockquote><p>int <strong>availableProcessors()</strong><br />获取 CPU 线程数</p></blockquote><blockquote><p>long <strong>maxMemory()</strong><br />返回 JVM 能从系统中获取的总内存大小（单位 byte）</p></blockquote><blockquote><p>long <strong>totalMemory()</strong><br />返回 JVM 已经从系统中获取的总内存大小（单位 byte）</p></blockquote><blockquote><p>long <strong>freeMemory()</strong><br />返回 JVM 剩余内存大小（单位 byte）</p></blockquote><blockquote><p>Process <strong>exec​(String command)</strong><br />运行 cmd 命令</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">运行 cmd 命令<br>shutdown：关机<br>=====参数=====<br>-s：默认 <span class="hljs-number">1</span> 分钟后关机<br>-s -t 指定时间：指定关机时间<br>-a：取消关机指令<br>-r：关机并重启<br><br>Runtime.getRuntime.exec(<span class="hljs-string">&quot;shutdown -s -t 30&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="六object-类">六、Object 类</h1><h2 id="object-概述">1. Object 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Object.html">Object的 API 文档</a></p><ul><li><code>Object</code> 是 <code>Java</code>中的顶级父类，所有类都直接或间接的继承于 <code>Object</code> 类</li><li>很少创建 <code>Object</code> 类的对象，更多的是创建<code>Object</code> 类的<strong>子类对象</strong></li></ul><h2 id="object-的构造方法">2. Object 的构造方法</h2><blockquote><p><strong>Object()</strong> 构造一个新对象</p></blockquote><h2 id="object-的常用方法">3. Object 的常用方法</h2><blockquote><p>String <strong>toString()</strong><br />返回对象的字符串表示形式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br><span class="hljs-comment">//两种方法打印结果一样，sout 本质调用了 toString() 方法</span><br><span class="hljs-comment">//包名.类名@地址值 com.baoduo.util.Student@6c49835d</span><br>System.out.println(stu);<br>System.out.println(toString(stu));<br><br><span class="hljs-comment">//重写 toString() 方法使打印的时候显示属性值</span><br><span class="hljs-comment">//可以使用 ptg 插件自动生成</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name = &quot;</span> + name + <span class="hljs-string">&quot;, age = &quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>boolean <strong>equals​(Object obj)</strong><br />比较两个对象是否相等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//equals() 默认使用 == 比较地址值是否相等</span><br><span class="hljs-comment">//重写 equals() 方法比较属性值是否相等</span><br><span class="hljs-comment">//IDEA ALT + INSERT 可自动重写 equals() 方法</span><br></code></pre></td></tr></table></figure><blockquote><p>protected Object <strong>clone()</strong><br />创建并返回此对象的副本</p></blockquote><ul><li><p>对象克隆是把 A 对象的属性值完全拷贝给 B对象，也叫对象拷贝，对象复制</p></li><li><p>浅克隆：基本数据类型拷贝数值，<strong>引用数据类型拷贝地址</strong><img src="04_clone.jpg" /></p></li><li><p>深克隆：基本数据类型拷贝数值，<strong>字符串复用，引用数据类型重新创建新对象</strong><img src="04_deepclone.jpg" /></p></li></ul><ol type="1"><li>重写 <code>Object</code> 中的 <code>clone()</code> 方法</li><li>让 <code>JavaBean</code> 类实现 <code>Cloneable</code> 接口</li><li>创建对象并调用 <code>clone()</code> 强转赋值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Cloneable 接口里没有抽象方法，表示当前接口是一个标记性接口</span><br><span class="hljs-comment">//如果实现了表示当前类的对象可以被克隆，如果没实现就不能克隆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-comment">//Object 中 clone() 是用 protected 修饰的，不重写无法直接访问</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-comment">//clone 返回的是 Object 类型，需要强转成克隆对象的类型</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stuCpy</span> <span class="hljs-operator">=</span> (Student)stu.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Object</code> 中的 <code>clone()</code>默认是浅克隆，实现深克隆需要重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <br>    <span class="hljs-comment">//获取克隆对象的引用数据类型</span><br>    <span class="hljs-type">int</span>[] data = <span class="hljs-built_in">this</span>.data;  <br>    <span class="hljs-comment">//创建新的引用数据类型</span><br>    <span class="hljs-type">int</span>[] newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[data.length];  <br>    <span class="hljs-comment">//拷贝引用数据类型的内容</span><br>    System.arraycopy(data, <span class="hljs-number">0</span>, newData, <span class="hljs-number">0</span>, data.length);  <br>    <span class="hljs-comment">//调用父类的浅克隆方法</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> (Student) <span class="hljs-built_in">super</span>.clone();  <br>    <span class="hljs-comment">//替换克隆出来对象的引用数据类型地址</span><br>    stu.data = newData;  <br>    <span class="hljs-comment">//返回深克隆的对象</span><br>    <span class="hljs-keyword">return</span> stu;  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用第三方工具 <code>GSON</code> 可更方便地实现深克隆</p><ol type="1"><li>在模块中新建 lib 文件夹</li><li>将第三方 jar 包导入其中</li><li>右键选择 Add as Library</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">//创建 Gson 对象</span><br><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-comment">//将被克隆对象转换成一个 JSON 字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> gson.toJson(stu);<br><span class="hljs-comment">//再将字符串变回对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stuCpy</span> <span class="hljs-operator">=</span> gson.fromJson(s, Student.class);<br></code></pre></td></tr></table></figure><h1 id="七objects-类">七、Objects 类</h1><h2 id="objects-概述">1. Objects 概述</h2><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/Objects.html">Objects的 API 文档</a></p><ul><li><code>Objects</code>不可实例化，方法都是静态的，可以直接通过<strong>类名调用</strong></li><li><code>Objects</code>提供了一些<strong>对象常见操作</strong>的方法</li></ul><h2 id="object-的常用方法-1">2. Object 的常用方法</h2><blockquote><p>static boolean <strong>equals​(Object a, Object b)</strong><br />先做非空判断，再比较两个对象是否相等（默认还是比较地址值）</p></blockquote><blockquote><p>static boolean <strong>isNull​(Object obj)</strong><br />判断对象是否为 null，为 null 返回 true，否则返回 false</p></blockquote><blockquote><p>static boolean <strong>nonNull​(Object obj)</strong><br />判断对象是否为 null，非 null 返回 true，否则返回 false</p></blockquote><h1 id="八数值类">八、数值类</h1><h2 id="biginteger-类">1. BigInteger 类</h2><h3 id="biginteger-概述">1.1 BigInteger 概述</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigInteger.html">BigInteger的 API 文档</a></p><ul><li>可以使用 <code>BigInteger</code>进行<strong>大整数的计算</strong></li><li><code>BigInteger</code>对象一旦创建，<strong>值不能发生改变</strong></li><li>底层使用<strong>分段存储</strong>，每 32 bit 位分为一段存入<code>int</code> 数组</li></ul><h3 id="biginteger-的构造方法">1.2 BigInteger 的构造方法</h3><blockquote><p><strong>BigInteger​(int num, Random rnd)</strong><br />获取随机大整数，均匀分布在 [ 0 , 2 ^ num - 1 ] 的范围内</p></blockquote><blockquote><p><strong>BigInteger​(String val)</strong><br />将指定的十进制整数字符串转换为大整数</p></blockquote><blockquote><p><strong>BigInteger​(String val, int radix)</strong><br />将指定进制的整数字符串转换为大整数</p></blockquote><h3 id="biginteger-的常用方法">1.3 BigInteger 的常用方法</h3><blockquote><p>static BigInteger <strong>valueOf​(long val</strong>)<br />返回一个 BigInteger，其值等于指定的 long</p><p><em>BigInteger 内置了 -16~16的缓存数据，在此范围内会直接返回缓存池中数据的引用，而不是创建对象，超出范围再创建新的对象</em></p></blockquote><blockquote><p>BigInteger <strong>add​(BigInteger val)</strong><br />加法</p></blockquote><blockquote><p>BigInteger <strong>subtract​(BigInteger val)</strong><br />减法</p></blockquote><blockquote><p>BigInteger <strong>multiply​(BigInteger val)</strong><br />乘法</p></blockquote><blockquote><p>BigInteger <strong>divide​(BigInteger val)</strong><br />除法</p></blockquote><blockquote><p>BigInteger[] <strong>divideAndRemainder​(BigIntegerval)</strong><br />返回值 0 索引代表商，1 索引代表余数</p></blockquote><blockquote><p>BigInteger <strong>pow​(int exponent)</strong><br />次幂</p></blockquote><blockquote><p>boolean <strong>equals​(Object x)</strong><br />比较是否相等</p></blockquote><blockquote><p>BigInteger <strong>max/min​(BigInteger val)</strong><br />返回较大值/较小值的对象（不再创建新的对象）</p></blockquote><blockquote><p>int <strong>intValue()</strong><br />转换成 int 类型整数</p></blockquote><h2 id="bigdecima-类">2. BigDecima 类</h2><h3 id="bigdecima-概述">2.1 BigDecima 概述</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html">BigDecimal的 API 文档</a></p><ul><li>可以使用 <code>BigDecima</code><strong>表示很大的小数</strong>和进行<strong>小数的精确计算</strong></li><li><code>BigDecima</code>对象一旦创建，<strong>值不能发生改变</strong></li><li>底层使用 <strong>ASCII 码表</strong>将字符存入 <code>byte</code>数组</li></ul><h3 id="bigdecima-的构造方法">2.2 BigDecima 的构造方法</h3><blockquote><p><strong>BigDecimal​(double val)</strong><br />构造结果可能不可预测，不准确</p></blockquote><blockquote><p><strong>BigDecimal​(int val)</strong><br />将 int 转换为大小数</p></blockquote><blockquote><p><strong>BigDecimal​(String val)</strong><br />将字符串精确转换为大小数</p></blockquote><h3 id="bigdecima-的常用方法">2.3 BigDecima 的常用方法</h3><blockquote><p>static BigDecimal <strong>valueOf​(double val)</strong><br />返回一个 BigDecimal，其值等于指定的 double</p><p><em>BigDecimal 内置了 0~10的整型缓存数据，在此范围内会直接返回缓存池中数据的引用，而不是创建对象，超出范围再创建新的对象</em></p></blockquote><blockquote><p>BigDecimal <strong>add​(BigDecimal augend)</strong><br />加法</p></blockquote><blockquote><p>BigDecimal <strong>subtract​(BigDecimal subtrahend)</strong><br />减法</p></blockquote><blockquote><p>BigDecimal <strong>multiply​(BigDecimal multiplicand)</strong><br />乘法</p></blockquote><blockquote><p>BigDecimal <strong>divide​(BigDecimal divisor, MathContextmc)</strong><br />除法（除不尽要用下面的）</p></blockquote><blockquote><p>BigDecimal <strong>divide​(BigDecimal divisor, int scale, RoundingModeroundingMode)</strong><br />指定保留位数 scale 和舍入模式 roundingMode 的除法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">UP：向远离 <span class="hljs-number">0</span> 方向取整<br>DOWN：向靠近 <span class="hljs-number">0</span> 方向取整<br>CEILING：向正方向舍入<br>FLOOR：向负方向舍入<br>HALF_UP：四舍五入<br></code></pre></td></tr></table></figure><h1 id="九时间日期">九、时间日期</h1><ul><li>格林威治/格林尼治时间 GMT（Greenwich MeanTime）：皇家格林威治天文台的标准时间，因地球自转不均匀导致不准确，现已弃用</li><li>协调世界时 UTC（Coodinated UniversalTime）：使用原子钟确定时间，由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC</li></ul><p><em>tips:由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。</em></p><h2 id="时间类">1. 时间类</h2><h3 id="date-类">1.1 Date 类</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/Date.html">Date的 API 文档</a></p><ul><li><code>Date</code> 是 <code>JDK</code>写好的用来<strong>描述时间</strong>的 <code>JavaBean</code>类，精度为毫秒</li></ul><blockquote><p><strong>Date()</strong><br />从运行程序的此时此刻到时间原点经历的毫秒值，转换成 Date 对象</p></blockquote><blockquote><p><strong>Date(long date)</strong> 将距离时间原点指定的毫秒值，转换成Date 对象</p></blockquote><blockquote><p>long <strong>getTime()</strong> 返回日期对象对应的时间毫秒值</p></blockquote><blockquote><p>void <strong>setTime(long time)</strong>把指定毫秒值设置给日期对象</p></blockquote><h3 id="zoneid时区">1.2 ZoneId：时区</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/ZoneId.html">ZoneId的 API 文档</a></p><blockquote><p>static Set&lt;string&gt; <strong>getAvailableZoneIds()</strong> 获取Java 中支持的所有时区</p></blockquote><blockquote><p>static ZoneId <strong>systemDefault()</strong> 获取系统默认时区</p></blockquote><blockquote><p>static Zoneld <strong>of(string zoneld)</strong> 获取一个指定时区</p></blockquote><h3 id="instant时间戳">1.3 Instant：时间戳</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/Instant.html">Instant的 API 文档</a></p><blockquote><p>static Instant <strong>now()</strong> 获取当前时间的 Instant 对象</p></blockquote><blockquote><p>static Instant <strong>ofEpochMilli​(long epochMilli)</strong>根据毫秒获取 Instant 对象</p></blockquote><blockquote><p>static Instant <strong>ofEpochSecond​(long epochSecond)</strong>根据秒获取 Instant 对象</p></blockquote><blockquote><p>ZonedDateTime <strong>atZone(ZoneIdzone)</strong> 指定时区</p></blockquote><blockquote><p>boolean <strong>isAfter​(Instant otherInstant)</strong><br />检查此瞬间是否在指定的瞬间之后</p></blockquote><blockquote><p>boolean <strong>isBefore​(Instant otherInstant)</strong><br />检查此瞬间是否在指定的瞬间之前</p></blockquote><blockquote><p>Instant <strong>minusMillis​(long millisToSubtract)</strong>返回此瞬间的副本，并减去指定的时间（以毫秒为单位）</p></blockquote><blockquote><p>Instant <strong>plusMillis​(long millisToAdd)</strong><br />返回此瞬间的副本，并增加指定的时间（以毫秒为单位）</p></blockquote><h3 id="zonedatetime带时区的时间">1.4 ZoneDateTime：带时区的时间</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/ZonedDateTime.html">ZonedDateTime的 API 文档</a></p><blockquote><p>static ZonedDateTime <strong>now()</strong> 获取当前时间的ZonedDateTime 对象</p></blockquote><blockquote><p>static ZonedDateTime <strong>ofXxx(…)</strong> 获取各种指定时间的ZonedDateTime 对象</p></blockquote><blockquote><p>ZonedDateTime <strong>withXxx(时间)</strong> 各种修改时间的方法</p></blockquote><blockquote><p>ZonedDateTime <strong>minusXxx(时间)</strong> 各种减少时间的方法</p></blockquote><blockquote><p>ZonedDateTime <strong>plusXxx(时间)</strong> 各种增加时间的方法</p></blockquote><h2 id="格式化类">2. 格式化类</h2><h3 id="simpledateformat-类">2.1 SimpleDateFormat 类</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/text/SimpleDateFormat.html">SimpleDateFormat的 API 文档</a></p><ul><li><code>SimpleDateFormat</code> 定义在 <code>java.text</code>包下，使用的时候需要导包</li><li><code>SimpleDateFormat</code>是<strong>日期/时间格式化</strong>类，可以在 <code>Date</code> 和<code>String</code> 之间转换</li></ul><p>由于 <code>DateFormat</code>为抽象类，不能直接使用，所以需要常用的子类<code>SimpleDateFormat</code></p><blockquote><p><strong>SimpleDateFormat()</strong><br />构造一个使用默认模式和默认区域的 SimpleDateFormat</p></blockquote><blockquote><p><strong>SimpleDateFormat(String pattern)</strong>构造一个使用指定模式的 SimpleDateFormat</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">y  年     M  月     d  日<br>H  时     m  分     s  秒<br></code></pre></td></tr></table></figure><blockquote><p>String <strong>format​(Date date)</strong><br />将 Date 对象格式化为字符串</p></blockquote><blockquote><p>Date <strong>parse​(String source)</strong><br />将字符串解析为 Date 对象</p></blockquote><h3 id="datetimeformatter时间的格式化和解析">2.2DateTimeFormatter：时间的格式化和解析</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/format/DateTimeFormatter.html">DateTimeFormatter的 API 文档</a></p><blockquote><p>static DateTimeFormatter <strong>ofPattern​(Stringpattern)</strong><br />构造一个使用指定模式的 DateTimeFormatter</p></blockquote><blockquote><p>String <strong>format​(TemporalAccessor temporal)</strong><br />使用指定方式格式化日期时间对象</p></blockquote><h2 id="日历类">3. 日历类</h2><h3 id="calendar-类">3.1 Calendar 类</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/util/Calendar.html">Calendar的 API 文档</a></p><ul><li><code>Calendar</code> 定义在 <code>java.util</code>包下，使用的时候需要导包</li><li><code>Calendar</code>表示一个“日历类”，可以进行<strong>日期运算</strong></li></ul><p><code>Calendar</code>是一个抽象类，不能创建对象，<code>可以使用它的子类GregorianCalendar</code>类</p><p>有两种方式可以获取 <code>GregorianCalendar</code> 对象：</p><ul><li>直接创建 <code>GregorianCalendar</code> 对象</li><li>通过 <code>Calendar</code> 的静态方法 <code>getInstance()</code>方法获取</li></ul><blockquote><p>static Calendar <strong>getInstance()</strong> 获取一个GregorianCalendar 对象</p></blockquote><blockquote><p>int <strong>get​(int field)</strong><br />获取某个字段的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">field 可用常量表示：<br>Calendar.YEAR : 年 <br>Calendar.MONTH ：月    <span class="hljs-comment">//月份为 0 ~ 11</span><br>Calendar.DAY_OF_MONTH：日<br>Calendar.HOUR：时 <br>Calendar.MINUTE：分<br>Calendar.SECOND：秒 <br>Calendar.DAY_OF_WEEK：星期    <span class="hljs-comment">//星期日是第一天</span><br></code></pre></td></tr></table></figure><blockquote><p>void <strong>set(int field,int value)</strong> 设置某个字段的值</p></blockquote><blockquote><p>void <strong>add(int field,int amount)</strong>为某个字段增加/减少指定的值</p></blockquote><h3 id="localdate年月日">3.2 LocalDate：年月日</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/LocalDate.html">LocalDate的 API 文档</a> ### 3.3 LocalTime：时分秒 <ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/LocalTime.html">LocalTime的 API 文档</a> ### 3.4 LocalDateTime：年月日时分秒 <ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/LocalDateTime.html">LocalDateTime的 API 文档</a></p><blockquote><p>static 日历类 <strong>now()</strong><br />从系统时钟获取当前日历对象</p></blockquote><blockquote><p>static 日历类 <strong>ofXxx(…)</strong> 获取各种指定时间的 LocalDate对象</p></blockquote><blockquote><p>… <strong>getXxx()</strong><br />获取日历中某个属性值</p></blockquote><blockquote><p>boolean <strong>isXxx(…)</strong> 各种判断方法</p></blockquote><blockquote><p>日历类 <strong>withXxx(时间)</strong> 各种修改时间的方法</p></blockquote><blockquote><p>日历类 <strong>minusXxx(时间)</strong> 各种减少时间的方法</p></blockquote><blockquote><p>日历类 <strong>plusXxx(时间)</strong> 各种增加时间的方法</p></blockquote><h2 id="时间间隔工具类">4. 时间间隔工具类</h2><h3 id="duration秒纳秒">4.1 Duration：秒，纳秒</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/Duration.html">Duration的 API 文档</a> ### 4.2 Period：年月日 <ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/Period.html">Period的 API 文档</a></p><blockquote><p>static Duration <strong>between​(Temporal startInclusive, TemporalendExclusive)</strong><br />获取两个时间对象的时间间隔对象</p></blockquote><blockquote><p>… <strong>toXxx()</strong> 获取不同单位两个时间的差值</p></blockquote><blockquote><p>… <strong>getXxx()</strong> 获取不同单位两个时间具体属性的差值</p></blockquote><h3 id="chronounit所有单位">4.3 ChronoUnit：所有单位</h3><p><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/time/temporal/ChronoUnit.html">ChronoUnit的 API 文档</a></p><blockquote><p><strong>ChronoUnit.属性.between()</strong></p></blockquote><h1 id="十包装类">十、包装类</h1><h2 id="包装类概述">1. 包装类概述</h2><p>包装类：用一个对象把基本类型包起来如果想要<strong>基本类型像对象一样操作</strong>，就可以使用基本类型对应的包装类</p><table><thead><tr><th style="text-align: center;">基本类型</th><th style="text-align: center;">对应的包装类</th></tr></thead><tbody><tr><td style="text-align: center;">byte</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Byte.html">Byte</a></td></tr><tr><td style="text-align: center;">short</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Short.html">Short</a></td></tr><tr><td style="text-align: center;">int</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Integer.html">Integer</a></td></tr><tr><td style="text-align: center;">long</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Long.html">Long</a></td></tr><tr><td style="text-align: center;">float</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Float.html">Float</a></td></tr><tr><td style="text-align: center;">double</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Double.html">Double</a></td></tr><tr><td style="text-align: center;">char</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Character.html">Character</a></td></tr><tr><td style="text-align: center;">boolean</td><td style="text-align: center;"><ahref="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Boolean.html">Boolean</a></td></tr></tbody></table><h2 id="获取包装类对象">2. 获取包装类对象</h2><p>包装类使用方法大差不差，以 <code>Integer</code> 为例介绍</p><blockquote><p><strong>Integer(int value)</strong> 根据传递的整数创建一个 Integer对象</p></blockquote><blockquote><p><strong>Integer(int value)</strong> 根据传递的字符串创建一个 Integer对象</p></blockquote><p>以上两种构造方式现已过时</p><blockquote><p>static Integer <strong>valueOf(int i)</strong> 根据传递的整数创建一个Integer 对象</p></blockquote><blockquote><p>static Integer <strong>valueOf(String s)</strong>根据传递的字符串创建一个 Integer 对象</p></blockquote><blockquote><p>static Integer <strong>valueOf(String s, int radix)</strong>根据传递的字符串按照指定进制创建一个 Integer 对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">128</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">128</span>);<br><br>System.out.println(i1 == i2);  <span class="hljs-comment">//false</span><br>System.out.println(i3 == i4);  <span class="hljs-comment">//true</span><br>System.out.println(i5 == i6);  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>通过 <code>new</code> 创建的对象每次都会创建一个新的对象，通过<code>valueOf()</code> 创建的对象在底层也是调用构造方法，但对 -128 ~ 127之间的数据进行了缓存，提前创建对象，调用时直接返回，超出缓存范围的再创建新的对象</p><ul><li>装箱：从基本类型转换为对应的包装类对象</li><li>拆箱：从包装类对象转换为对应的基本类型</li></ul><p>从 <code>Java5</code>开始，基本类型与包装类实现了自动装箱和自动拆箱，可以直接将包装类当成基本类型使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><h2 id="包装类的常用方法">3. 包装类的常用方法</h2><blockquote><p>static String <strong>toBinaryString(int i)</strong>转成参数的无符号二进制表示形式</p></blockquote><blockquote><p>static String <strong>toOctalString(int i)</strong>转成参数的无符号八进制表示形式</p></blockquote><blockquote><p>static String <strong>toHexString(int i)</strong>转成参数的无符号十六进制表示形式</p></blockquote><blockquote><p>static int <strong>parseInt​(String s)</strong><br />将字符串参数解析为带符号的十进制整数</p></blockquote><p>8 中包装类中，除了 <code>Character</code> 都有对应的<code>parseXxx</code> 的方法进行类型转换</p>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Java接口和内部类</title>
    <link href="/2023/07/08/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/03_%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/03_Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2023/07/08/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/03_%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/03_Java%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一接口">一、接口</h1><h2 id="引入">0. 引入</h2><p>兔子：吃草 青蛙：吃虫子、蛙泳 狗：吃骨头、狗刨</p><p>在本案例中，兔子、青蛙和狗都有吃的行为，可以抽取到父类动物中；而兔子不会游泳，青蛙和狗会游泳，接口可以定义这个行为让类来实现</p><p><img src="03_interface.jpg" /></p><h2 id="接口概述">1. 接口概述</h2><p>接口是一种规则，是<strong>对行为的抽象</strong></p><h2 id="接口定义格式">2. 接口定义格式</h2><p>接口用关键字 <code>interface</code> 定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface 接口名 &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="接口成员">3. 接口成员</h2><h3 id="基本特征">3.1 基本特征</h3><ul><li>成员变量<ul><li>只能是<strong>常量</strong></li><li>默认修饰符：<code>public static final</code>（默认会加）</li></ul></li><li>没有构造方法，接口<strong>不能被实例化</strong></li><li>成员方法<ul><li>只能是<strong>抽象方法</strong></li><li>默认修饰符：<code>public abstract</code>（默认会加）</li></ul></li></ul><p><em>JDK7及以前：接口只能定义抽象方法JDK8新特性：接口中可以定义有方法体的方法（默认、静态）JDK9新特性：接口中可以定义私有的方法（私有）</em></p><h3 id="新特性">3.2 新特性</h3><h4 id="jdk8-以后">3.2.1 JDK8 以后</h4><ol type="1"><li>允许在接口中定义<strong>默认方法</strong>，需要使用<code>default</code> 修饰<ul><li>作用：接口升级时实现类不需要重写</li><li>默认方法不是抽象方法，<strong>不强制重写</strong>，但是如果被重写，重写时需要去掉<code>default</code> 关键字</li><li><code>default</code> 不能省略</li><li>如果实现了多个接口，多个接口中存在相同名字的默认方法，实现类必须对该方法重写，不然编译器不知道执行哪个方法</li></ul></li><li>允许在接口中定义<strong>静态方法</strong>，需要使用<code>static</code> 修饰<ul><li>静态方法<strong>不能被重写</strong></li><li>静态方法只能<strong>通过接口名调用</strong>，不能通过实现类名或者对象名调用</li><li><code>static</code> 不能省略</li></ul></li></ol><h4 id="jdk9-以后">3.2.2 JDK9 以后</h4><ul><li>接口中的<strong>共性代码</strong>抽取到私有方法中，不对外界使用</li></ul><ol type="1"><li><strong>普通的私有方法</strong>供普通方法调用</li><li><strong>静态的私有方法</strong>供静态方法调用</li></ol><h2 id="接口特征">4. 接口特征</h2><h3 id="接口与类的关系">4.1 接口与类的关系</h3><ul><li>类和类的关系：<ul><li>继承关系，只能单继承，不能多继承，但是可以多层继承</li></ul></li><li>类和接口的关系：<ul><li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li></ul></li><li>接口和接口的关系<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单实现</span><br><span class="hljs-keyword">public</span> class 类名 implements 接口名 &#123;&#125;<br><span class="hljs-comment">//多实现</span><br><span class="hljs-keyword">public</span> class 类名 implements 接口<span class="hljs-number">1</span>, 接口<span class="hljs-number">2</span> &#123;&#125;<br><span class="hljs-comment">//继承的同时实现</span><br><span class="hljs-keyword">public</span> class 类名 extends 父类 implements 接口<span class="hljs-number">1</span>, 接口<span class="hljs-number">2</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="接口的实现和意义">4.2 接口的实现和意义</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用<code>implements</code>关键字</p><p>接口的实现类（子类）：</p><ol type="1"><li>要么重写接口的<strong>所有抽象方法</strong></li><li>要么实现类也声明为<strong>抽象类</strong></li></ol><p><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束</strong></p><h3 id="接口多态">4.3 接口多态</h3><ul><li>当一个方法的<strong>参数是接口</strong>时，可以传递接口<strong>所有实现类的对象</strong></li><li>接口<strong>不能创建对象</strong>，但是可以<strong>声明接口变量</strong></li><li>接口变量必须<strong>引用实现了接口的类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口不能创建对象</span><br><span class="hljs-type">Swim</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>(); <span class="hljs-comment">//ERROR</span><br><span class="hljs-comment">//接口可以创建变量，必须指向实现该接口的对象</span><br><span class="hljs-type">Swim</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sportsman</span>();<br><br><span class="hljs-comment">//可以传入 Sportsman 和 Frog 等任意实现了 Swim 的类的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimSpeed</span><span class="hljs-params">(Swim s)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>如同用 <code>instanceof</code>检查一个对象是否指向某个类一样，也可以用来检查一个对象是否实现了某个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> Comparable) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="适配器设计模式">5. 适配器设计模式</h2><p>当一个接口中抽象方法过多，但是只需使用其中一部分的时候，重写大量不需要的方法非常繁琐，可以使用适配器设计模式解决</p><ol type="1"><li>编写中间类 <code>XXXAdapter</code> 实现对应接口</li><li>对接口中的抽象方法进行<strong>空实现</strong></li><li>让真正的实现类继承中间类，并<strong>重写需要使用的方法</strong></li><li>为了避免其他类创建适配器对象，适配器类用 <code>abstract</code>修饰</li></ol><h1 id="二内部类">二、内部类</h1><h2 id="内部类概述">1. 内部类概述</h2><p>在一个类的里面再定义一个类</p><ul><li>内部类表示的事物是<strong>外部类的一部分</strong></li><li>内部类<strong>单独出现没有任何意义</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;  <span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;  <span class="hljs-comment">//内部类</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景：一个事物内部还有一个独立的事物，内部事物脱离外部事物无法独立使用</p><ul><li>汽车的发动机</li><li>人的心脏</li></ul><h2 id="成员内部类">2. 成员内部类</h2><h3 id="成员内部类特点">2.1 成员内部类特点</h3><ul><li><strong>定义在成员位置</strong>，无 <code>static</code>修饰的内部类</li><li>成员内部类里面，<code>JDK16</code> 开始才可以定义静态变量</li></ul><h3 id="创建成员内部类对象">2.2 创建成员内部类对象</h3><ol type="1"><li>成员内部类非私有时<strong>直接创建对象</strong></li><li>外部类中<strong>编写方法</strong>，对外提供 <code>private</code>内部类对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类.内部类 对象名 = new 外部类().new 内部类();</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br><span class="hljs-comment">//编写方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>    Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> o.getInner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建内部类对象中，对象中隐含一个 <code>外部类.this</code>记录外部类对象的地址值</p><p><img src="03_inner_class.jpg" /></p><h2 id="静态内部类">3. 静态内部类</h2><h3 id="静态内部类特点">3.1 静态内部类特点</h3><ul><li><strong>定义在成员位置</strong>，有 <code>static</code>修饰的内部类</li><li>静态内部类是<strong>特殊的内部成员类</strong></li></ul><h3 id="创建静态内部类对象">3.2 创建静态内部类对象</h3><p>静态内部类只能访问外部类中的静态变量和静态方法，如果要访问非静态的需要创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类.内部类 对象名 = new 外部类.内部类();</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br></code></pre></td></tr></table></figure><h3 id="调用静态内部类方法">3.3 调用静态内部类方法</h3><ul><li>非静态方法：先创建对象，用对象调用</li><li>静态方法：<code>外部类.内部类.方法名()</code></li></ul><h2 id="局部内部类">4. 局部内部类</h2><ul><li><strong>定义在方法中</strong>的类，类似方法里的局部变量</li><li>外界无法直接使用，需要在方法内部创建对象使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul><h2 id="匿名内部类">5. ☆匿名内部类☆</h2><h3 id="匿名内部类特点">5.1 匿名内部类特点</h3><ul><li>隐藏了名字的内部类</li><li>可以写在成员位置，也可以写在局部位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或者接口名() &#123;  <span class="hljs-comment">//创建对象  继承/实现</span><br>    重写方法;  <span class="hljs-comment">//方法重写</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类使用场景">5.2 匿名内部类使用场景</h3><ol type="1"><li>如果类<strong>只需要使用一次</strong>，就可以使用匿名内部类</li><li>当一个方法的参数是<strong>接口或类</strong>时，可以传递匿名内部类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swim</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] agrs)</span> &#123;<br>        <span class="hljs-comment">//new 这里是创建匿名内部类的对象</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;  <span class="hljs-comment">//Swim 这里是实现的接口名或继承的类名</span><br>            <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//括号里面才是这个匿名内部类</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>            &#125;<br>        &#125;;  <span class="hljs-comment">//结尾有分号  整个一坨是一个匿名内部类的对象</span><br><br>        <span class="hljs-comment">//  1.类只使用一次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span> <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>            &#125; <br>        &#125;.swimming();  <span class="hljs-comment">//直接调用类中方法</span><br><br>        <span class="hljs-comment">// 2.方法传递参数</span><br>        <span class="hljs-type">Swim</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span> <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>            &#125; <br>        &#125;; <br>        s.swimming();<br>        goSwim(s);<br><br>        <span class="hljs-comment">//  一步到位</span><br>        goSwim(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>            <span class="hljs-meta">@Override</span> <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;游泳&quot;</span>);<br>            &#125; <br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goSwim</span><span class="hljs-params">(Swim s)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Java面向对象</title>
    <link href="/2023/07/05/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/02_Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02_Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/07/05/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/02_Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02_Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一类和对象">一、类和对象</h1><h2 id="基本概念">1. 基本概念</h2><ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类由<strong>属性</strong>和<strong>行为</strong>组成<ul><li>属性：事物的特征。例如：学生姓名，年龄，性别</li><li>行为：事物能执行的操作。例如：上课，运动，打游戏</li></ul></li><li>类是对事物的一种描述，对象是啥事物的具体存在。例如：学生类和具体的某个学生对象</li><li>类是对象的数据类型，类是具有共同属性和行为的一组对象的集合</li><li><strong>类是对象的模板，对象是类的实例，模板决定了实体</strong></li></ul><h2 id="类和对象的定义">2. 类和对象的定义</h2><h3 id="类">2.1 类</h3><ul><li>属性：在类中通过<strong>成员变量</strong>来体现（类中方法外的变量）</li><li>行为：在类中通过<strong>成员方法</strong>来体现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 class 类名 &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    数据类型 变量；<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// 成员方法</span><br>    方法<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> study&#123;&#125;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> 类名()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象">2.2 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建对象</span><br>类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-comment">//调用成员</span><br>对象名.成员变量<br>stu.age;<br>对象名.成员方法();<br>stu.study();<br></code></pre></td></tr></table></figure><h3 id="类定义补充">2.3 类定义补充</h3><ul><li>类名使用<strong>大驼峰命名法</strong>，见名知意</li><li>一个 java 文件中可以定义多个 class 类，但是只能一个类是<code>public</code> 修饰的，<code>public</code>修饰的类名必须与文件名相同 <em>实际开发建议一个文件定义一个 class类</em></li></ul><h4 id="测试类">2.3.1 测试类</h4><p>用来检查其他类是否书写正确，带有 <code>main</code>方法的类，是<strong>程序的入口</strong></p><ol type="1"><li>可以在测试类中创建 <code>JavaBean</code> 类的对象使用</li><li>可以在测试类中直接使用工具类的方法完成一些功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>&#125;<br><span class="hljs-comment">//public：被JVM调用，访问权限足够大</span><br><span class="hljs-comment">//static：被JVM调用，不用创建对象，直接类名访问，因为main方法是静态的，所以测试类方法也需要是静态的</span><br><span class="hljs-comment">//void：被JVM调用，不需要给JVM返回值</span><br><span class="hljs-comment">//main：一个通用的名称，虽然不是关键字，但是被JVM识别</span><br><span class="hljs-comment">//String[] args：以前用于接收键盘录入数据的，为了向下兼容所以保留</span><br></code></pre></td></tr></table></figure><h4 id="javabean-类">2.3.2 JavaBean 类</h4><p>用来<strong>描述一类事物</strong>的类，叫做 <code>JavaBean</code>类</p><ol type="1"><li>类名需要见名知意，大驼峰命名</li><li>所有成员变量都是私有的，使用 <code>private</code> 修饰</li><li>提供至少两个公共的构造方法<ul><li>无参构造方法</li><li>带全部参数构造方法</li></ul></li><li>对每个成员变量提供两个公共方法<ul><li><code>setXxx()</code> ：用来设置属性 Xxx 的值</li><li><code>getXxx()</code> ：用来获取属性 Xxx 的值（若属性类型为<code>boolean</code>，则方法名为 <code>isXxx()</code>）</li></ul></li></ol><h4 id="工具类">2.3.3 工具类</h4><p>工具类是<strong>实现一些功能</strong>的类</p><ol type="1"><li>类名需要见名知意，大驼峰命名</li><li>私有化构造方法</li><li>方法定义为静态</li></ol><h2 id="封装">3. 封装</h2><h3 id="引入">3.0 引入</h3><p>当传参数很多的时候很麻烦，有了封装只需要传一个对象就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//没有封装</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(id, name, age, sex, school)</span> &#123;&#125;<br><span class="hljs-comment">//有封装</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(student)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="封装思想">3.1 封装思想</h3><p>是面向对象三大特征之一（封装，继承，多态）<strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong></p><h3 id="权限修饰符">3.2 权限修饰符</h3><p>作用：使用权限修饰符控制成员能<strong>被访问的范围</strong></p><p>实际开发中，一般只用 <code>private</code> 和 <code>public</code></p><ul><li><strong>成员变量私有</strong></li><li><strong>成员方法公开</strong></li></ul><p>特例：如果方法是抽取其他方法中的共性代码，这个方法一般也私有</p><h4 id="private-关键字">3.2.1 private 关键字</h4><ul><li><code>private</code>将类的某些信息隐藏在类内部，只允许在<strong>本类中访问</strong></li><li>针对 <code>private</code>修饰的成员变量，如果需要被其他类使用，提供相应的操作<ul><li>提供 <code>getXxx()</code> 方法，用于获取成员变量的值，方法用<code>public</code> 修饰</li><li>提供 <code>setXxx(参数)</code> 方法，用于设置成员变量的值，方法用<code>public</code> 修饰 #### 3.2.2 default 关键字</li></ul></li><li><code>default</code>即默认/缺省，什么也不写，在<strong>同一包内可访问</strong>，不使用任何修饰符。</li></ul><h4 id="protected-关键字">3.2.4 protected 关键字</h4><ul><li><code>protected</code><strong>同一包内</strong>和<strong>不同包下的子类</strong>可访问</li></ul><h4 id="public-关键字">3.2.3 public 关键字</h4><ul><li><code>public</code> 对<strong>所有类</strong>可见</li></ul><h3 id="成员变量与局部变量">3.3 成员变量与局部变量</h3><ol type="1"><li>类中位置不同<ul><li>成员变量在<strong>类中方法外</strong></li><li>局部变量在<strong>方法内部</strong>或<strong>方法声明上</strong></li></ul></li><li>内存中位置不同<ul><li>成员变量在<strong>堆内存</strong>中（堆中对象里）</li><li>局部变量在<strong>栈内存</strong>中（栈中方法内）</li></ul></li><li>生命周期不同<ul><li><p>成员变量在<strong>对象</strong>创建的时候创建，在对象被销毁的时候销毁<em>引用数据类型没有被指向时空间会被释放</em></p></li><li><p>局部变量随着<strong>方法</strong>的调用而存在，随着方法调用完毕而消失</p></li></ul></li><li>初始化值不同<ul><li>成员变量<strong>有默认初始化值</strong></li><li>局部变量<strong>无默认初始化值</strong>，使用之前需要赋值</li></ul></li><li>作用域不同<ul><li>成员变量在<strong>整个类</strong>中有效</li><li>局部变量在<strong>当前方法</strong>有效</li></ul></li></ol><h3 id="static-关键字">3.4 static 关键字</h3><h4 id="实例成员与静态成员">3.4.1 实例成员与静态成员</h4><ol type="1"><li>静态成员：<ul><li>被 <code>static</code>修饰的成员是<strong>属于类</strong>的，放在静态区中，叫<strong>类变量/方法</strong>或<strong>静态变量/方法</strong></li><li>随着<strong>类的加载而加载</strong>，只加载一次，只存储一份，<strong>优先于对象存在</strong></li><li>所有对象<strong>共享</strong>，可以直接通过类访问</li></ul></li><li>实例成员：<ul><li>没有 <code>static</code>修饰的成员是<strong>属于对象</strong>的，叫<strong>实例变量/方法</strong></li><li>随着<strong>对象的创建而创建</strong>，每创建一个对象就存储一份</li><li>必须创建<strong>具体对象</strong>才能使用，通过对象访问</li></ul></li></ol><p><img src="02_static.jpg" /></p><h4 id="静态变量">3.4.2 静态变量</h4><ul><li>被 <code>static</code>修饰的成员变量叫做<strong>静态变量</strong></li><li>直接用 <code>类名.静态变量</code> 访问</li></ul><h4 id="静态方法">3.4.3 静态方法</h4><ul><li>被 <code>static</code>修饰的成员方法叫做<strong>静态方法</strong></li><li>直接用 <code>类名.静态方法</code> 访问</li><li>常用在<strong>测试类</strong>和<strong>工具类</strong>中</li><li>静态方法没有 <code>this</code> 关键字</li><li>静态方法<strong>只能</strong>访问静态变量和静态方法，<strong>不能</strong>访问非静态成员<em>静态方法属于类，不属于具体对象，而 this指代对象，非静态成员属于某个具体对象</em></li></ul><h3 id="this-关键字">3.5 this 关键字</h3><p>成员变量和局部变量名字冲突时，遵循就近原则，使用局部变量。使用<code>this</code>修饰的变量用于指代<strong>成员变量</strong>，可以区分成员变量和局部变量的重名方法的形参和成员变量同名时，带 <code>this</code> 的指成员变量，不带<code>this</code> 的指形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>this</code>的作用：区分<strong>局部变量</strong>和<strong>成员变量</strong>，用于普通的<code>getter</code>、<code>setter</code> 方法和构造方法</li><li><code>this</code>的本质：代表<strong>方法调用者的地址值</strong>，即代表<strong>当前对象</strong><em>s.method()，method 由 s 调用，this 代表 s 的地址值</em></li></ul><p><img src="02_this_mem.jpg" /></p><h2 id="包">4. 包</h2><h3 id="包的作用">4.1 包的作用</h3><p><strong>包就是文件夹</strong>，是用来<strong>分门别类</strong>的管理技术，不同的技术类放在不同的包下，方便管理和维护</p><h3 id="包的规则">4.2 包的规则</h3><ul><li><strong>公司域名反写.技术名称</strong>，需要全部<strong>英文小写</strong>，见名知意</li><li>包名每个路径必须是<strong>合法标识符</strong>，而且不能是<code>Java</code> 关键字</li></ul><p><code>com.baoduo.search</code></p><h3 id="导包">4.3 导包</h3><p>全类名：包名.类名 <code>com.baoduo.search.Student</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> com.baoduo.search.Student;<br></code></pre></td></tr></table></figure><ul><li>使用同一个包里的类时，不需要导包</li><li>使用 <code>java.lang</code> 包中的类时，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中的同名类，需要使用全类名</li></ul><h2 id="构造方法">5. 构造方法</h2><p>构造方法也叫构造器、构造函数，在创建对象的时候给成员变量进行<strong>初始化</strong>的，是一种特殊的方法### 5.1 构造方法的格式</p><ul><li><strong>方法名与类名相同</strong>，大小写也要一致</li><li>没有返回值类型，连 <code>void</code> 都没有</li><li>没有具体的返回值，不能由 <code>return</code> 带回结果数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 类名(参数) &#123;<br>    方法体;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法的注意事项">5.2 构造方法的注意事项</h3><ol type="1"><li>构造方法的定义<ul><li>如果没有定义构造方法，系统会给出一个<strong>默认的无参构造方法</strong></li><li>如果定义了构造方法，系统不再提供默认构造方法</li></ul></li><li>构造方法的重载<ul><li>带参构造方法和无参构造方法，二者方法名相同，但是<strong>参数不同</strong></li></ul></li><li><strong>推荐</strong>无论是否使用，都手写无参和带全部参数的构造方法</li></ol><h2 id="代码块">6. 代码块</h2><h3 id="局部代码块"><del>6.1 局部代码块</del></h3><p>提前结束变量的生命周期，节约内存（已淘汰）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造代码块"><del>6.2 构造代码块</del></h3><p>抽取构造方法中的重复代码（不够灵活，已淘汰）创建对象时先执行构造代码块再执行构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    System.out.println(<span class="hljs-string">&quot;开始创建对象了&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态代码块">6.3 静态代码块</h3><ul><li>随着类的加载而加载，并且<strong>只加载一次</strong></li><li>常用来完成对<strong>数据的初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象在内存">7. 对象在内存</h2><ol type="1"><li>加载 <code>class</code> 文件到<strong>方法区</strong></li><li>在<strong>栈内存</strong>声明<strong>局部变量</strong></li><li>在<strong>堆内存</strong>中开辟空间</li><li>默认初始化</li><li>显示初始化</li><li>构造方法初始化</li><li>将<strong>堆内存</strong>中的地址值赋给<strong>局部变量</strong></li></ol><h3 id="单个对象">7.1 单个对象</h3><ul><li><strong>局部变量</strong>（对象名）在<strong>栈内存</strong>中，存储<strong>堆内存</strong>中<strong>对象的地址</strong></li><li><strong>堆内存</strong>中存储对象的<strong>成员变量</strong>和<strong>成员方法的地址</strong></li></ul><p><img src="02_one_object.jpg" /></p><h3 id="多个对象">7.2 多个对象</h3><ul><li><code>class</code>加载进入<strong>方法区</strong>后可直接使用，无需再次加载</li></ul><p><img src="02_two_object.jpg" /></p><h3 id="两个引用指向同一对象">7.3 两个引用指向同一对象</h3><ul><li>将对象名赋给对象名实际赋的是<strong>地址值</strong></li><li>当没有指向<strong>堆内存</strong>中对象的变量时，<strong>堆内存</strong>中的对象会被释放</li></ul><p><img src="02_two_ref.jpg" /></p><h1 id="二继承">二、继承</h1><h2 id="继承概述">1. 继承概述</h2><h3 id="引入-1">1.0 引入</h3><p>很多类具有很多相同的属性和方法，代码复用性差，维护麻烦有了继承可以把相同的属性和方法抽取到父类当中，提高代码复用性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//没有继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//有继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是继承">1.1 什么是继承</h3><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类的属性和行为。继承描述的是事物之间的<strong>所属关系</strong>，例如，兔子属于食草动物，食草动物属于动物</p><ul><li>继承者称为<strong>子类</strong>（派生类）</li><li>被继承者称为<strong>父类</strong>（基类或超类）</li></ul><h3 id="继承的好处">1.2 继承的好处</h3><ul><li>可以把多个子类中重复的代码抽取到父类中，<strong>提高代码的复用性</strong></li><li>子类可以在父类基础上增加其他的功能，使<strong>子类更强大</strong></li><li>使类与类之间<strong>产生了关系</strong></li></ul><h3 id="什么时候使用继承">1.3 什么时候使用继承</h3><ol type="1"><li>类与类之间存在<strong>共性</strong>的内容</li><li>子类是父类中的<strong>一种</strong></li></ol><h2 id="继承的格式">2. 继承的格式</h2><p>通过 <code>extends</code>关键字，可以声明一个子类继承另外一个父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 子类 extends 父类 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Java只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，但支持<strong>多层继承</strong></li><li>所有的类都直接或间接地继承于 <code>Object</code> 类</li></ul><h2 id="继承的特点">3. 继承的特点</h2><h3 id="构造方法-1">3.1 构造方法</h3><ul><li>子类不能继承父类的<strong>构造方法</strong>，但是可以通过<code>super()</code> 调用</li><li>子类初始化之前一定要<strong>先调用父类构造方法</strong>完成父类的初始化</li><li>子类构造方法第一行语句必须为<code>super()</code>，不写也默认存在</li><li>如果想调用父类有参构造，必须手写 <code>super(参数)</code> 调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用父类有参构造</span><br><span class="hljs-keyword">public</span> 子类(参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">super</span>(参数<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">this</span>.参数<span class="hljs-number">2</span> = 参数<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员变量">3.2 成员变量</h3><ul><li>所有的<strong>成员变量</strong>都能继承，但 <code>private</code>的无法访问，可以通过 <code>getter/setter</code> 方法访问</li><li>就近原则：先在局部位置找，找不到再去本类成员位置找，找不到再去父类成员位置找，逐级向上<ul><li>什么都不加：从局部位置开始找</li><li><code>this</code> ：从本类成员位置开始找</li><li><code>super</code> ：从父类成员位置开始找</li></ul></li></ul><p><img src="02_member_attribute.jpg" /></p><h3 id="成员方法">3.3 成员方法</h3><ul><li>只有父类中虚方法表中的<strong>成员方法</strong>才能被子类继承</li><li><strong>虚方法表</strong>：父类把虚方法表继承给子类，子类加上自己的虚方法，一层一层向下继承<ul><li>非 <code>private</code></li><li>非 <code>static</code></li><li>非 <code>final</code></li></ul></li><li>就近原则：先在虚方法表中找，找不到再去父类成员位置找，逐级向上<ul><li><code>this</code> ：从本类成员位置开始找</li><li><code>super</code> ：从父类成员位置开始找</li></ul></li></ul><p><img src="02_member_method.jpg" /></p><h3 id="方法的重写">3.4 方法的重写</h3><p>当父类的方法不能满足子类的需求时，需要进行方法的重写</p><ol type="1"><li><strong>重写的方法尽量和父类保持一致</strong><ol type="1"><li>重写方法的名称、形参列表必须与父类的一致</li><li>子类重写分类方法时，访问权限必须要大于等于父类（<code>public</code>&gt; <code>protected</code> &gt; 空着不写）</li><li>子类重写父类方法时，返回值必须小于等于父类</li></ol></li><li><strong>只有被添加到虚方法表中的方法才能被重写</strong><ol type="1"><li>私有方法不能被重写</li><li>静态方法不能被重写</li></ol></li></ol><p>方法重写的本质：<strong>覆盖</strong>方法表中的方法</p><p><code>@Override</code>重写注解：放在重写的方法上，可以<strong>检验重写的语法</strong>是否正确，代码安全优雅，可读性强</p><h2 id="this-和-super-使用总结">4. this 和 super 使用总结</h2><ul><li><code>this</code>：理解为一个局部变量，表示当前方法调用者的地址值</li><li><code>super</code> ：表示父类对象的存储空间</li></ul><ol type="1"><li>访问成员变量<ul><li><code>this.成员变量</code> 访问本类成员变量</li><li><code>super.成员变量</code> 访问父类成员变量</li></ul></li><li>访问成员方法<ul><li><code>this.成员方法()</code> 访问本类成员方法</li><li><code>super.成员方法()</code> 访问父类成员方法</li></ul></li><li>访问构造方法<ul><li><code>this()</code> 访问本类构造方法</li><li><code>super()</code> 访问父类构造方法</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//this访问本类构造方法设置默认值</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">18</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final-关键字">5. final 关键字</h2><h3 id="final-的作用">5.1 final 的作用</h3><ol type="1"><li><p>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong><em>方法中是某种规则，只让使用，不想让变其内容</em></p></li><li><p>修饰类：表明该类是最终类，<strong>不能被继承</strong><em>整个类中的方法都不想被改变内容</em></p></li><li><p>修饰变量：叫做常量，<strong>只能被赋值一次</strong></p></li></ol><h3 id="常量">5.2 常量</h3><p>实际开发中，常量一般作为系统的配置信息，方便维护，增强可读性常量的命名规范：单词<strong>全部大写</strong>，单词词之间用<strong>下划线隔开</strong></p><ul><li><code>fianl</code>修饰基本变量：变量存储的<strong>数据值</strong>不能发生改变</li><li><code>final</code>修饰引用类型：变量存储的<strong>地址值</strong>不能发生改变，对象内部可以发生改变<em>String 不能改变的原因就是使用了 private final</em></li></ul><h2 id="抽象类">6. 抽象类</h2><h3 id="概述">6.1 概述</h3><ul><li>抽象方法：将<strong>共性方法</strong>抽取到父类之后，由于每个子类执行的具体内容不同，所以在父类中<strong>不能确定具体的方法体</strong>，该对象就可以定义为抽象方法</li><li>抽象类：如果一个类中存在抽象方法，那么该类<strong>必须声明为抽象类</strong></li></ul><h3 id="定义格式">6.2 定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象方法的定义格式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回值类型 方法名(参数列表);<br><span class="hljs-comment">//抽象类的定义格式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class 类名 &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="特征和意义">6.3 特征和意义</h3><ul><li><p>抽象类拥有了<strong>抽象方法</strong>的能力，失去了<strong>创建对象</strong>的能力，不能<strong>实例化</strong>&gt;<em>假设抽象类对象调用抽象方法，抽象方法无方法体，无意义</em></p></li><li><p>抽象类中<strong>不一定有抽象方法</strong>，有抽象方法的类<strong>一定是抽象类</strong>&gt;<em>没有抽象方法的抽象类目的就是不让创建该类对象</em></p></li><li><p>可以有<strong>构造方法</strong> &gt;<em>创建子类对象时给属性赋值</em></p></li><li><p>抽象类的存在是为了<strong>被子类继承</strong>&gt;<em>抽象类确定了成员，不确定如何实现的抽象方法交给子类去实现</em></p></li><li><p>继承抽象类的子类：</p><ol type="1"><li>要么重写抽象类的<strong>所有抽象方法</strong></li><li>要么子类也声明为<strong>抽象类</strong> &gt;<em>假设不重写，调用抽象方法没有意义</em></li></ol></li></ul><p>意义：强制让子类<strong>按照某种格式重写</strong>，在多人开发过程中提高代码规范</p><h1 id="三多态">三、多态</h1><h2 id="引入-2">0. 引入</h2><p>以学校教务系统为例，学生和老师都需要登录，而登录方法只能接收一种类型的对象，需要写两个逻辑一样的方法，代码非常冗余多态使一个方法可以接收他的所有子类，只需写一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//没有多态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(Student stu)</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(Teacher tc)</span> &#123;&#125;<br><span class="hljs-comment">//有多态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(Person p)</span> &#123;&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多态概述">1. 多态概述</h2><p>定义：同类型的对象，表现出的<strong>多种形态</strong></p><ul><li>有<strong>继承关系</strong></li><li><strong>父类引用指向子类对象</strong>「格式体现」</li><li><strong>方法重写</strong>「意义体现，不重写无意义」</li></ul><h2 id="多态的格式和运行特点">2. 多态的格式和运行特点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多态的格式</span><br>父类类型 对象名称 = 子类类型;<br><span class="hljs-type">Anima</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><ol type="1"><li>调用<strong>成员变量</strong>时：<strong>编译看左边，运行也看左边</strong><ul><li><code>javac</code>编译代码时，看左边父类中有没有这个变量，如果有编译成功，没有则编译失败</li><li><code>java</code>运行代码时，实际获取的是左边父类中成员变量的值</li></ul></li><li>调用<strong>成员方法</strong>时：<strong>编译看左边，运行看右边</strong><ul><li><code>javac</code>编译代码时，看左边父类中有没有这个方法，如果有编译成功，没有则编译失败</li><li><code>java</code> 运行代码时，实际运行的是右边子类中重写的方法<em>实质还是虚方法表的覆盖</em></li></ul></li></ol><p><img src="02_polymorphism.jpg" /></p><h2 id="多态的优势和弊端">3. 多态的优势和弊端</h2><ul><li>优势：方法中使用<strong>父类型作为参数</strong>，可以<strong>接收所有子类对象</strong>，还可以根据传递的对象来<strong>调用不同类中的方法</strong></li><li>弊端：由于多态编译看左边父类类型，所以不能使用<strong>子类的独有功能</strong></li></ul><p>弊端的解决：强制类型转换</p><ul><li>转换成真正的子类类型，可以调用子类的独有功能</li><li>转换类型与真实对象类型不一样会出现<strong>类型转换异常</strong></li><li>转换的时候使用 <code>instanceof</code>关键字判断可避免类型转换异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Anima</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a; <span class="hljs-comment">// Cat c = (Cat)a; 不能乱转换，类型不同会报错</span><br><br><span class="hljs-comment">//判断 a 是否指向 Dog 类型，返回 boolean 类型</span><br><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;<br>&#125;<br><br><span class="hljs-comment">//jdk14 新特性，判断和强转合并成一行</span><br><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d) &#123;<br>    d.lookHome();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Java基本语法结构</title>
    <link href="/2023/07/03/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/01_Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/01_Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/"/>
    <url>/2023/07/03/coding/Java%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/01_Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/01_Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一前置准备">一、前置准备</h1><h2 id="cmd">1. CMD</h2><h3 id="如何打开cmd">1.1 如何打开cmd</h3><ol type="1"><li><code>win</code> + <code>r</code>打开运行窗口</li><li>输入<code>cmd</code>回车</li></ol><h3 id="常用cmd命令">1.2 常用cmd命令</h3><table><thead><tr><th style="text-align: center;">操作</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">盘符名词:</td><td style="text-align: center;">切换到该盘符</td></tr><tr><td style="text-align: center;">dir</td><td style="text-align: center;">列出当前路径下的所有内容</td></tr><tr><td style="text-align: center;">cd 目录</td><td style="text-align: center;">进入单级目录</td></tr><tr><td style="text-align: center;">cd..</td><td style="text-align: center;">回退到上一级目录</td></tr><tr><td style="text-align: center;">cd 目录1…</td><td style="text-align: center;">进入多级目录</td></tr><tr><td style="text-align: center;">cd \</td><td style="text-align: center;">回退到盘符目录</td></tr><tr><td style="text-align: center;">cls</td><td style="text-align: center;">清屏</td></tr><tr><td style="text-align: center;">exit</td><td style="text-align: center;">退出cmd</td></tr></tbody></table><p><em>在windows操作系统当中，文件名或者文件夹名是忽略大小写的。</em></p><h2 id="java概述">2. Java概述</h2><h3 id="java是什么">2.1 Java是什么</h3><p>人与计算机进行信息交流沟通的一种编程语言</p><p><strong>1）Java版本：</strong></p><ul><li>Java5.0：Java第一个大版本更新（前面是1.1、1.2、1.3、1.4）</li><li>Oracle收购之后分为过渡版本和长期支持版本（LTS），以下是常用LTS<ul><li>Java8.0：目前绝大数公司正在使用的版本，因为这个版本最稳定</li><li>Java17.0：目前最新的稳定版本 <em>版本向下兼容</em></li></ul></li></ul><p><strong>2）Java的三大平台</strong></p><ul><li>JavaSE：SE即标准版，主要用来开发桌面应用。<em>C/C++加载速度快，更有优势</em></li><li><del>JavaME：ME即微缩版，主要用来做移动类、嵌入式开发。<em>已经被Android和iOS替代了</em></del></li><li>JavaEE：EE即企业版，主要从事后台服务器的开发。<em>也是Java的主要应用方向</em></li></ul><p><strong>3）Java的主要特性</strong></p><ul><li>面向对象</li><li>安全性</li><li>多线程</li><li>简单易用</li><li>开源</li><li>跨平台<ul><li>针对于不同的操作系统，Java提供了不同的虚拟机</li><li>虚拟机会把Java语言翻译成操作系统能看得懂的语言</li></ul></li></ul><p><strong>4）JDK和JRE</strong> JDK包括JRE，JRE包括JVM</p><ol type="1"><li>JDK（Java Development Kit）：Java开发工具，包含了JRE和开发工具<ul><li>JVM</li><li>核心类库（Java API）</li><li>开发工具（javac、java、jdb、jhat…）</li></ul></li><li>JRE（Java Runtime Environment）：Java运行环境<ul><li>JVM</li><li>核心类库（Java API）</li><li>运行工具（删去了一些开发才会用到的工具）</li></ul></li><li>JVM（Java Virtual Machine）：Java虚拟机，Java程序运行的地方</li></ol><h3 id="下载与安装">2.2 下载与安装</h3><ol type="1"><li><ahref="https://www.oracle.com/cn/java/technologies/downloads/#jdk17-windows">Oracle</a>官网下载jdk</li><li>安装一路下一步，注意路径不要有中文<em>建议专门建一个文件夹，以后所有的开发工具都放到里面，方便管理</em></li></ol><h3 id="jdk安装目录">2.3 jdk安装目录</h3><table><thead><tr><th style="text-align: left;">目录名称</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr><td style="text-align: left;">bin（最常用）</td><tdstyle="text-align: left;">存放JDK的各种工具命令。javac和java就放在这个目录</td></tr><tr><td style="text-align: left;">conf</td><td style="text-align: left;">存放JDK的相关配置文件</td></tr><tr><td style="text-align: left;">include</td><td style="text-align: left;">存放一些平台特定的头文件</td></tr><tr><td style="text-align: left;">jmods</td><td style="text-align: left;">存放JDK的各种模块</td></tr><tr><td style="text-align: left;">legal</td><td style="text-align: left;">存放JDK各模块的授权文档</td></tr><tr><td style="text-align: left;">lib</td><td style="text-align: left;">存放了JDK工具的一些补充JAR包</td></tr></tbody></table><h3 id="环境变量">2.4 环境变量</h3><p>作用：在 <code>cmd</code> 的任意目录下都可以启动某个程序<em>在启动软件时，操作系统会先在当前路径下找，如果找不到再到环境变量的路径中去找，如果都找不到就提示无法启动。</em></p><p>步骤：</p><ol type="1"><li>右键我的电脑点击属性</li><li>找到高级系统设置</li><li>选择高级，点击环境变量</li><li>在系统变量中找到 <code>PATH</code>，点击编辑</li><li>新建输入程序的完整路径</li><li>可上移到最上面（更快） <em><code>cmd</code>在环境变量中从上往下查找，上面的路径打开更快</em></li></ol><p><em>最新从官网上下载的 JDK 安装时会自动配置 javac、java的环境变量</em> ① <code>JAVA_HOME</code> ：告诉操作系统 JDK安装在了哪个位置（未来其他技术要通过这个找 JDK） <imgsrc="01_env_path.png" /></p><p>② <code>Path</code> ：告诉操作系统 JDK 提供的javac（编译）、java（执行） 命令安装到了哪个<imgsrc="01_java_path.png" /></p><h3 id="java运行流程">2.5 Java运行流程</h3><ol type="1"><li>编写程序</li><li>编译程序：编译后会产生一个.class后缀的字节码文件<ul><li><code>.java</code> 文件：自己编写的代码</li><li><code>.class</code> 文件：计算机执行的文件</li></ul></li><li>运行程序：运行的是编译之后的class文件<ul><li>javac + 文件名.java （编译java文件）</li><li>java + 文件名（运行编译之后的class文件）</li></ul></li></ol><h2 id="高级记事本">3. 高级记事本</h2><p>常用的有 Editplus、Notepad++、Sublime，支持语法 <ahref="https://notepad-plus-plus.org/">Notepad++</a>官网下载 设置=&gt;首选项 =&gt; 左侧选择新建 =&gt; 语言选择 Java 编码选择ANSI，否则可能出现中文乱码</p><h1 id="二基本概念">二、基本概念</h1><h2 id="注释">1. 注释</h2><p>注释的内容不参与编译和运行，仅仅是对代码的解释说明而已。<del>最讨厌写注释，和不写注释的人</del></p><ul><li><p>单行注释 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单行注释</span><br></code></pre></td></tr></table></figure></p></li><li><p>多行注释 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p></li><li><p>文档注释（暂时用不上） <em>javadoc工具根据文档注释生成文档</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">文档注释 </span><br><span class="hljs-comment">文档注释 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="关键字">2. 关键字</h2><h3 id="关键字概念及特点">2.1 关键字概念及特点</h3><p>被 Java 赋予了特定含义的英文单词</p><ul><li>关键字字母全部小写</li><li>常用的代码编辑器会有高亮显示</li></ul><table style="width:100%;"><thead><tr><th style="text-align: center;"><strong>abstract</strong></th><th style="text-align: center;"><strong>assert</strong></th><th style="text-align: center;"><strong>boolean</strong></th><th style="text-align: center;"><strong>break</strong></th><th style="text-align: center;"><strong>byte</strong></th></tr></thead><tbody><tr><td style="text-align: center;"><strong>case</strong></td><td style="text-align: center;"><strong>catch</strong></td><td style="text-align: center;"><strong>char</strong></td><td style="text-align: center;"><strong>class</strong></td><td style="text-align: center;"><strong>const</strong></td></tr><tr><td style="text-align: center;"><strong>continue</strong></td><td style="text-align: center;"><strong>default</strong></td><td style="text-align: center;"><strong>do</strong></td><td style="text-align: center;"><strong>double</strong></td><td style="text-align: center;"><strong>else</strong></td></tr><tr><td style="text-align: center;"><strong>enum</strong></td><td style="text-align: center;"><strong>extends</strong></td><td style="text-align: center;"><strong>final</strong></td><td style="text-align: center;"><strong>finally</strong></td><td style="text-align: center;"><strong>float</strong></td></tr><tr><td style="text-align: center;"><strong>for</strong></td><td style="text-align: center;"><strong>goto</strong></td><td style="text-align: center;"><strong>if</strong></td><td style="text-align: center;"><strong>implements</strong></td><td style="text-align: center;"><strong>import</strong></td></tr><tr><td style="text-align: center;"><strong>instanceof</strong></td><td style="text-align: center;"><strong>int</strong></td><td style="text-align: center;"><strong>interface</strong></td><td style="text-align: center;"><strong>long</strong></td><td style="text-align: center;"><strong>native</strong></td></tr><tr><td style="text-align: center;"><strong>new</strong></td><td style="text-align: center;"><strong>package</strong></td><td style="text-align: center;"><strong>private</strong></td><td style="text-align: center;"><strong>protected</strong></td><td style="text-align: center;"><strong>public</strong></td></tr><tr><td style="text-align: center;"><strong>return</strong></td><td style="text-align: center;"><strong>strictfp</strong></td><td style="text-align: center;"><strong>short</strong></td><td style="text-align: center;"><strong>static</strong></td><td style="text-align: center;"><strong>super</strong></td></tr><tr><td style="text-align: center;"><strong>switch</strong></td><td style="text-align: center;"><strong>synchronized</strong></td><td style="text-align: center;"><strong>this</strong></td><td style="text-align: center;"><strong>throw</strong></td><td style="text-align: center;"><strong>throws</strong></td></tr><tr><td style="text-align: center;"><strong>transient</strong></td><td style="text-align: center;"><strong>try</strong></td><td style="text-align: center;"><strong>void</strong></td><td style="text-align: center;"><strong>volatile</strong></td><td style="text-align: center;"><strong>while</strong></td></tr></tbody></table><h3 id="class">2.2 class</h3><p>作用：定义一个类 类：Java 项目中最基本的组成单元，一个完整的 Java项目可能有成千上万个类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123; <span class="hljs-comment">//class后面跟的是类名</span><br><span class="hljs-comment">//类名后面有一对大括号，是类的内容</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="字面量">3. 字面量</h2><p>作用：告诉程序员数据在程序中的书写格式</p><table><thead><tr><th style="text-align: left;"><strong>字面量类型</strong></th><th style="text-align: left;"><strong>说明</strong></th><th style="text-align: left;"><strong>程序中的写法</strong></th></tr></thead><tbody><tr><td style="text-align: left;">整数</td><td style="text-align: left;">不带小数的数字</td><td style="text-align: left;">666，-88</td></tr><tr><td style="text-align: left;">小数</td><td style="text-align: left;">带小数的数字</td><td style="text-align: left;">13.14，-5.21</td></tr><tr><td style="text-align: left;">字符</td><td style="text-align: left;">必须使用单引号，有且仅能一个字符</td><td style="text-align: left;">‘A’，‘0’， ‘我’</td></tr><tr><td style="text-align: left;">字符串</td><td style="text-align: left;">必须使用双引号，内容可有可无</td><td style="text-align: left;">“HelloWorld”，“世界”</td></tr><tr><td style="text-align: left;">布尔值</td><tdstyle="text-align: left;">布尔值，表示真假，只有两个值：true，false</td><td style="text-align: left;">true 、false</td></tr><tr><td style="text-align: left;">空值</td><td style="text-align: left;">一个特殊的值，空值</td><td style="text-align: left;">null</td></tr></tbody></table><p>扩展：</p><ul><li>制表符\t：在打印的时候把前面字符串的长度补齐到8或8的整数倍（最少补1个空格，。最多补8个）</li><li><code>null</code>：不能直接打印，如果要打印需用字符串类型“null”</li></ul><h2 id="变量">4. 变量</h2><p>变量是值的容器，定义变量可以存放值，变量可以输出打印、参与计算<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型 变量名 = 数据值;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure></p><p><strong>注意事项：</strong></p><ul><li>变量名不能重复</li><li>变量在使用前必须赋值</li><li>在一条语句中，可以定义多个变量 <em>可续性差</em></li></ul><h2 id="数据类型">5. 数据类型</h2><h3 id="进制">5.1 进制</h3><p>二进制：逢二进一，借一当二 不同进制的表示形式：</p><ul><li>二进制：以 <code>0b</code> 开头</li><li>十进制：默认</li><li>八进制：以 <code>0</code> 开头</li><li>十六进制：以 <code>0x</code> 开头</li></ul><p>任意进制转十进制： 系数 * 基数的权次幂 相加十进制转任意进制：除基取余（不断除基数到商为0，余数倒着拼起来）</p><h3 id="java数据类型的分类">5.2 Java数据类型的分类</h3><ul><li>基本数据类型</li><li>引用数据类型 <em>数组和面向对象再深入学习</em></li></ul><h3 id="基本数据类型-四类八种">5.3 基本数据类型 （四类八种）</h3><p>数值取值范围大小：<code>double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用（字节）</th><th>取值范围</th></tr></thead><tbody><tr><td>整数</td><td>byte</td><td>1</td><td>-2^7 ~ 2^7-1 <strong><em>(-128~127)</em></strong></td></tr><tr><td></td><td>short</td><td>2</td><td>-2^15 ~ 2^15-1 (-32768~32767)</td></tr><tr><td></td><td><strong>int</strong></td><td>4</td><td>-2^31 ~ 2^31-1（10的9次方）</td></tr><tr><td></td><td>long</td><td>8</td><td>-2^63 ~ 2^63-1（10的18次方）</td></tr><tr><td>浮点数</td><td>float</td><td>4</td><td>1.401298e-45 ~ 3.402823e+38</td></tr><tr><td></td><td><strong>double</strong></td><td>8</td><td>4.9000000e-324 ~ 1.797693e+308</td></tr><tr><td>字符</td><td>char</td><td>2</td><td>0-65535</td></tr><tr><td>布尔</td><td>boolean</td><td>1</td><td>true，false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000000L</span>;  <span class="hljs-comment">//L后缀</span><br><span class="hljs-type">float</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">52.1f</span>;   <span class="hljs-comment">//f后缀</span><br><span class="hljs-type">double</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">46.4561</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;你&#x27;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>定义 <code>long</code> 类型变量时，在数据值的后面加上 <code>L</code>后缀（大小写都可以，建议大写区分1和l）</li><li>定义 <code>float</code> 类型变量时，在数据值的后面加上<code>F</code> 后缀（大小写都可以）</li></ul><h2 id="标识符">6. 标识符</h2><p>标识符：给类、方法、变量等起的名字</p><h3 id="命名规则">6.1 命名规则：</h3><ol type="1"><li>硬性要求：否则代码会报错</li></ol><ul><li>只能由数字、字母、下划线_、美元符号$组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>区分大小写</li></ul><ol start="2" type="1"><li>软性建议： 代码不会报错，但是会让代码显得比较low</li></ol><ul><li><strong>小驼峰命名法</strong>：方法、变量名<ul><li>一个单词时全部小写</li><li>多个单词时第一个单词首字母小写，其他单词首字母大写</li></ul></li><li><strong>大驼峰命名法</strong>：类名<ul><li>一个单词时首字母大写</li><li>多个单词时每个单词首字母大写</li></ul></li></ul><h3 id="阿里巴巴命名规范">6.2 阿里巴巴命名规范</h3><p><ahref="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C(%E9%BB%84%E5%B1%B1%E7%89%88).pdf">Java开发手册(黄山版).pdf</a></p><h2 id="键盘录入和输出">7. 键盘录入和输出</h2><h3 id="scanner-类">7.1 Scanner 类</h3><p>Java 帮我们写好一个类叫 <code>Scanner</code>,这个类可以接收键盘输入的数字，我们只要使用 <code>Scanner</code>这个类就可以了</p><ol type="1"><li><p>导包：告诉编译器 <code>Scanner</code> 这个类在哪<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br></code></pre></td></tr></table></figure></p></li><li><p>创建对象： 创建一个 <code>Scanner</code> 类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure></p></li><li><p>接收数据： 将键盘录入的数据存起来 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="输入格式">7.2 输入格式</h3><ol type="1"><li>遇到空格、回车、制表符停止<ul><li><code>nextInt ()</code> ：接收整数并返回</li><li><code>nextDouble()</code>：接收浮点数，也能接收整数，但都当做浮点数返回</li><li><code>next()</code> ：接收任意数据，返回一个字符串</li></ul></li><li>可以接收空格和制表符，遇到回车停止<ul><li><code>nextLine()</code> ：接收一行数据，返回一个字符串</li></ul></li></ol><p>两套体系不能混用，如果先使用 <code>1.</code> 中输入再使用<code>nextLine</code> 会导致 <code>nextLine</code> 接收不到数据</p><h3 id="输出格式">7.3 输出格式</h3><ol type="1"><li><code>println</code> 输出并换行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>printf</code> 格式化输出 类似 C 语言中的<code>printf</code>，<code>%s</code>表示占位符，输出默认无换行，可在后面加上 <code>\n</code> 或<code>sout</code> 实现换行效果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>System.out.printf(<span class="hljs-string">&quot;第%s条&quot;</span>, n);  <span class="hljs-comment">//第一条</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="idea">8.IDEA</h2><h3 id="idea概述">8.1 IDEA概述</h3><p>IDEA 全称 Intellij IDEA, 是用于 Java语言的集成开发环境，它是目前业界公认的用于 Java 程序开发最好的工具集成开发环境：把代码编写，编译，执行，调试等多种功能综合到一起的开发工具</p><h3 id="idea下载和安装">8.2 IDEA下载和安装</h3><ol type="1"><li>下载： <ahref="https://www.jetbrains.com/idea/download/?section=windows">IDEA下载</a></li><li>安装： 一路下一步，默认设置即可（建议修改安装目录）</li></ol><h3 id="idea层级结构介绍">8.3 IDEA层级结构介绍</h3><p>这些结构的划分，是为了方便管理类文件</p><ul><li><code>project</code>（项目、工程）<ul><li>淘宝、京东、贴吧属于一个个项目</li></ul></li><li><code>module</code>（模块）<ul><li>一个项目中存在许多模块，不同模块存放不同模块的业务功能代码，例如论坛模块</li></ul></li><li><code>package</code>（包）<ul><li>一个模块中还有许多业务，存放在不同的包里，例如发帖、评论</li></ul></li><li><code>class</code>（类）<ul><li>一个业务中还有很多类，具体写代码实现的地方</li></ul></li></ul><h3 id="idea操作步骤">8.4 IDEA操作步骤</h3><ol type="1"><li><p>创建 <code>project</code> 项目</p></li><li><p>创建 <code>module</code> 模块</p></li><li><p>创建 <code>class</code> 类</p></li><li><p><del>创建 <code>package</code> 包</del> 暂时不需要 <em>package一般用企业域名倒写加功能 com.baidu.search 实际是多级目录</em></p></li><li><p>在类中编写代码</p></li><li><p>完成编译运行</p></li></ol><h3 id="idea一些好用设置">8.5 IDEA一些好用设置</h3><p>有些 IDEA设置十分方便，能使编码效率倍增，但建议新手暂时不要开启，前期多自己敲，待养成良好编程习惯之后开启节省时间</p><ul><li>智能提示忽略大小写： Settings -&gt; Editor -&gt; General -&gt; CodeCompletion -&gt; Match case 取消勾选</li><li>自动导包： Settings -&gt; Editor -&gt; General -&gt; Auto Import-&gt; Add unambiguous imports on the fly 和 Optimize imports on the fly(for current project) 勾选</li><li>字体： Settings -&gt; Editor -&gt; Font -&gt; 个人喜欢 Consolas字体</li><li>背景： Settings -&gt; Appearance &amp; Behavior -&gt; Appearance-&gt; Background Image… -&gt; 选择自己喜欢的图片，还可以设置透明度</li></ul><h1 id="三运算符">三、运算符</h1><h2 id="运算符与表达式">1. 运算符与表达式</h2><h3 id="概念">1.0 概念</h3><ul><li>运算符： 对字面量或者变量进行操作的符号</li><li>表达式：用运算符把字面量或者变量连接起来符合Java语法的式子</li></ul><h3 id="算术运算符">1.1 算术运算符</h3><p><strong>1）<code>/</code> 除法</strong></p><ul><li>整数相除得到的也是整数（整除的商），如果想要得到精确结果，必须有浮点数参与运算</li><li>浮点数直接参与运算，得到的结果可能是不精确的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>);   <span class="hljs-comment">//3</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>);  <span class="hljs-comment">//3.3333333333333335</span><br></code></pre></td></tr></table></figure><p><strong>2） <code>%</code> 取模</strong></p><ul><li>整数才能取模，得到的是相除的余数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">2</span>);  <span class="hljs-comment">//0</span><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>);  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p><strong>3）<code>+</code> 加法</strong></p><ul><li>当 +操作中出现字符串时，作用是将字符串从左至右依次拼接为一个新字符串</li><li>当 + 操作中出现了字符时，会将 char 转换成 ASCⅡ码表中对应的数字计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">//3abc21</span><br>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>)  <span class="hljs-comment">//98</span><br></code></pre></td></tr></table></figure><p><strong>4）<code>-</code> 减法 和 <code>*</code> 乘法</strong></p><ul><li>与小学数学一样</li></ul><p><strong>5）自增自减运算符</strong></p><ul><li><code>++</code> 自增运算法：在变量前先加再用，再变量后先用再加</li><li><code>--</code> 自减运算法：在变量前先减再用，再变量后先用再减</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>System.out.println(a++);  <span class="hljs-comment">//输出1，但a已经是2了</span><br>a = <span class="hljs-number">1</span>;<br>System.out.println(++a);  <span class="hljs-comment">//输出2，a也是2</span><br></code></pre></td></tr></table></figure><h3 id="赋值运算符">1.2 赋值运算符</h3><ul><li><code>=</code> 把等号右边的计算结果赋值给左边的变量</li><li><code>+= -= /= *= %=</code>把左边和右边计算的结果赋给左边，底层都隐藏了一个<strong>强制类型转换</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>; <br>a += d;   <span class="hljs-comment">//等价于 a = (int)(a + d); 对应的强制类型转换</span><br>System.out.println(a);  <span class="hljs-comment">//结果是10 a是整型</span><br>System.out.println(a/<span class="hljs-number">3</span>); <span class="hljs-comment">//结果是3 a是整型</span><br></code></pre></td></tr></table></figure><h3 id="关系运算符">1.3 关系运算符</h3><p>又叫比较运算符，左边和右边比较进行判断，运算结果一定是<code>boolean</code> 类型，如果成立就返回<code>true</code>，如果不成立就返回 <code>false</code></p><table><thead><tr><th style="text-align: center;">符号</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">==</td><td style="text-align: center;">判断左边跟右边是否相等</td></tr><tr><td style="text-align: center;">!=</td><td style="text-align: center;">判断左边跟右边是否不相等</td></tr><tr><td style="text-align: center;">&gt;</td><td style="text-align: center;">判断左边是否大于右边</td></tr><tr><td style="text-align: center;">&gt;=</td><td style="text-align: center;">判断左边是否大于等于右边</td></tr><tr><td style="text-align: center;">&lt;</td><td style="text-align: center;">判断左边是否小于右边</td></tr><tr><td style="text-align: center;">&lt;=</td><td style="text-align: center;">判断左边是否小于等于右边</td></tr></tbody></table><h3 id="逻辑运算符">1.4 逻辑运算符</h3><p><strong>1）逻辑运算符</strong> 逻辑运算符两侧的值只能是<code>boolean</code> 类型</p><table><thead><tr><th style="text-align: center;">符号</th><th style="text-align: center;">名字</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">&amp;</td><td style="text-align: center;">逻辑与（且）</td><tdstyle="text-align: center;"><strong>并且</strong>，两边都为true，结果才为true</td></tr><tr><td style="text-align: center;">|</td><td style="text-align: center;">逻辑或</td><tdstyle="text-align: center;"><strong>或者</strong>，两边都为false，结果才为false</td></tr><tr><td style="text-align: center;">^</td><td style="text-align: center;">逻辑异或</td><td style="text-align: center;">相同为false，不同为true</td></tr><tr><td style="text-align: center;">!</td><td style="text-align: center;">逻辑非</td><td style="text-align: center;"><strong>取反</strong></td></tr></tbody></table><p><strong>2）短路逻辑运算符</strong> （常用这个）如果左边能确定整个表达式的结果，右边不执行，提高了代码的执行效率</p><table><thead><tr><th style="text-align: center;">符号</th><th style="text-align: center;">名字</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: center;">&amp;&amp;</td><td style="text-align: center;">短路与</td><td style="text-align: center;">结果和 &amp; 相同，但具有短路效果</td></tr><tr><td style="text-align: center;">||</td><td style="text-align: center;">短路或</td><td style="text-align: center;">结果和 | 相同，但具有短路效果</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>;  <br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> x++ &lt; <span class="hljs-number">1</span> &amp;&amp; y++ &lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//短路，右面不执行</span><br>System.out.println(result);   <span class="hljs-comment">//false 结果与 &amp; 一样</span><br>System.out.println(x + <span class="hljs-string">&quot; &quot;</span> + y);  <span class="hljs-comment">//11 10</span><br>  <br>x = <span class="hljs-number">10</span>;  y = <span class="hljs-number">10</span>;  <br>result = x++ &lt; <span class="hljs-number">1</span> &amp; y++ &lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//两边都执行</span><br>System.out.println(result); <span class="hljs-comment">//false </span><br>System.out.println(x + <span class="hljs-string">&quot; &quot;</span> + y);  <span class="hljs-comment">//11 11</span><br></code></pre></td></tr></table></figure><h3 id="三元运算符">1.5 三元运算符</h3><p>又叫三元表达式或问号冒号表达式，三元运算符的运算结果<strong>一定要被使用</strong>，要么赋值给变量赋值，要么打印出来，否则语法错误</p><p>格式： <code>关系表达式 ？ 表达式1 ：表达式2 ；</code></p><ul><li>计算关系表达式的值</li><li>如果关系表达式的值为 <code>true</code>，那么执行<code>表达式1</code></li><li>如果关系表达式的值为 <code>false</code>，那么执行<code>表达式2</code></li></ul><h3 id="位运算符">1.6 位运算符</h3><p>位运算符作用在所有的位上，并且按位运算</p><table><thead><tr><th style="text-align: center;">符号</th><th style="text-align: center;">含义</th><th style="text-align: center;">规则</th></tr></thead><tbody><tr><td style="text-align: center;">&amp;</td><td style="text-align: center;">按位与</td><td style="text-align: center;">对应位都是1，则结果为1，否则为0</td></tr><tr><td style="text-align: center;">|</td><td style="text-align: center;">按位或</td><td style="text-align: center;">对应位都是1，则结果为0，否则为1</td></tr><tr><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">左移</td><tdstyle="text-align: center;">向左移动，低位补0（移动一位相当于乘2）</td></tr><tr><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">右移</td><tdstyle="text-align: center;">向右移动，高位按正负补0或1（移动一位相当于除2）</td></tr><tr><td style="text-align: center;">&gt;&gt;&gt;</td><td style="text-align: center;">无符号右移</td><tdstyle="text-align: center;">向右移动，不管正负高位都补0，也就是结果都是正数</td></tr></tbody></table><p>此外还有按位异或、按位取反</p><h3 id="运算符的优先级">1.7 运算符的优先级</h3><p><strong>小括号优于一切！！！</strong></p><h2 id="类型转换">2. 类型转换</h2><h3 id="隐式类型转换">2.1 隐式类型转换</h3><p>也叫自动类型提升，赋值给精度更高的类型时，程序自动将低精度提升到高精度精度从高到低：<code>double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></p><p><strong>两种规则：</strong></p><ul><li>低精度和高精度运算时，低精度的先提升为大精度再进行运算</li><li><code>byte、short、char</code>三种类型的数据在运算的时候，都会直接先提升为<code>int</code> 再进行运算</li></ul><h3 id="强制类型转换">2.2 强制类型转换</h3><p>如果要把高精度值赋给低精度类型时，需要使用强制类型转换（数据会丢失精度）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标数据类型 变量名 = （目标数据类型）被强转的数据；</span><br><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.111</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)a;<br></code></pre></td></tr></table></figure><h1 id="四流程控制语句">四、流程控制语句</h1><h2 id="顺序结构">1. 顺序结构</h2><p>顺序结构是程序中最基本最简单的执行流程，按照代码的先后顺序，从上往下执行</p><h2 id="分支结构">2. 分支结构</h2><h3 id="if-else-语句">2.1 if-else 语句</h3><ol type="1"><li>计算关系表达式 （ 关系表达式的值只能是 <code>boolean</code>类型的）</li><li>如果关系表达式值为 <code>true</code> 执行 <code>语句体1</code></li><li>如果关系表达式值为 <code>false</code> 执行 <code>语句体2</code></li><li>继续顺序执行大括号后面的语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (关系表达式) &#123;<br>    语句体<span class="hljs-number">1</span>;    <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    语句体<span class="hljs-number">2</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>if-else 还可以有级联和嵌套</p><h3 id="switch-case-语句">2.2 switch-case 语句</h3><ol type="1"><li>计算表达式 （取值为<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>、<code>String</code>、<code>枚举</code>）</li><li>表达式的值和 <code>case</code>的值从上至下顺次比较，遇到相同的值就从对应 <code>case</code>开始执行，直至整个 <code>switch</code> 语句结束或者遇到<code>break</code> （<code>case</code>后的值只能为字面量，不能为变量）</li><li>如果所有 <code>case</code> 的值与 <code>表达式</code>的值都不匹配，就会执行 <code>default</code> 对应的语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        语句体<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        语句体<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        语句体n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>default</code> 可省略，位置可不放在最后 （但不建议）</li><li><code>case</code> 下如果没写 <code>break</code>，会出现<code>case</code> 穿透</li><li><code>switch</code> 语句在 jdk12 之后的新特性可简化语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; &#123;<br>        语句体<span class="hljs-number">1</span>;  <span class="hljs-comment">//相当于省略了break</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; 语句<span class="hljs-number">2</span>;  <span class="hljs-comment">//如果只有一句还可省略括号</span><br>    <span class="hljs-keyword">default</span> -&gt; 语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环结构">3. 循环结构</h2><h3 id="for-循环">3.1 for 循环</h3><h4 id="传统-for-循环">3.1.1 传统 for 循环</h4><ol type="1"><li>执行初始化语句</li><li>执行条件判断语句<ul><li>值为 <code>false</code>，跳出循环</li><li>值为 <code>true</code>，进入循环<ol type="1"><li>执行循环体语句</li><li>执行条件控制语句</li><li>回到 2 继续判断</li></ol></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (初始化语句; 条件判断语句; 条件控制语句) &#123;<br>    循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for-each-循环">3.1.2 for-each 循环</h4><p><code>for-each</code> 循环也称为增强型 <code>for</code>循环，可以简化对数组的遍历操作。在这种循环中，每次迭代都会将数组中的下一个元素<strong>赋值</strong>给声明的<code>迭代变量</code>，<code>迭代变量</code>是一个<strong>局部变量</strong>，它只是一个在每次迭代中指向数组元素的<strong>临时引用</strong>，并不影响原始数组的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (数组元素类型 迭代变量 : 数组) &#123; <br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>for-each</code>循环只能<strong>遍历访问</strong>数组的元素，而不能用于修改</li><li><code>for-each</code>循环在循环过程中会自动处理数组越界的情况，因此不需要担心索引越界的问题</li></ol><h3 id="while-循环">3.2 while 循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">while</span>(条件判断语句)&#123;  <span class="hljs-comment">//小括号里用 true 实现无限循环</span><br>    循环体;<br>    条件控制语句;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-while-循环">3.3 do-while 循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">do</span>&#123;<br>    循环体;<br>    条件控制语句;<br>&#125;<span class="hljs-keyword">while</span>(条件判断语句);<br></code></pre></td></tr></table></figure><h3 id="三种循环的区别和使用">3.4 三种循环的区别和使用</h3><ul><li><code>for</code> 和 <code>while</code> 是先判断再执行循环体<ul><li>当知道循环次数或循环范围时，常用 <code>for</code> 循环</li><li>不知道循环的次数和范围，只知道循环的结束条件时，常用<code>while</code> 循环</li></ul></li><li><code>do-while</code> 是先执行再判断</li></ul><h3 id="跳转控制语句">3.5 跳转控制语句</h3><p><strong>1）<code>break</code></strong></p><ul><li>结束整个循环</li><li>用于 <code>switch</code> 和循环中</li></ul><p><strong>2）<code>continue</code></strong></p><ul><li>结束本次循环，继续执行下次循环</li><li>用于循环中</li></ul><h1 id="五数组">五、数组</h1><h2 id="数组介绍">1. 数组介绍</h2><p>数组是一种容器，可以存取多个<strong>同种类型</strong>的值<em>存在隐式转换，比如 <code>byte</code> 和 <code>short</code> 可以存到<code>int</code>型的数组中，但建议容器类型和存储的数据类型保持一致</em></p><h2 id="数组的定义和初始化">2. 数组的定义和初始化</h2><h3 id="数组的定义">2.1 数组的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[] 数组名;</span><br><span class="hljs-type">int</span>[] arrary;   <span class="hljs-comment">//平时习惯性使用这种定义格式</span><br><span class="hljs-comment">//数据类型 数组名[];</span><br><span class="hljs-type">int</span> arrary[];<br></code></pre></td></tr></table></figure><h3 id="数组的初始化">2.2 数组的初始化</h3><p>初始化：就是在内存中为数组开辟空间，并将数据存入容器的过程</p><ul><li>等号两边的数据类型必须保持一致</li><li>数组一旦创建，长度不能发生改变</li></ul><h4 id="静态初始化">2.2.1 静态初始化</h4><p>静态初始化时需要指明每个数组元素，系统根据元素个数计算数组长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[] 数组名 = new 数据类型[]&#123;元素1，元素2...&#125;;</span><br><span class="hljs-type">int</span>[] arrary1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">//new 数据类型[]可省略</span><br><span class="hljs-type">int</span>[] arrary1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">//平时使用这种</span><br></code></pre></td></tr></table></figure><h4 id="动态初始化">2.2.2 动态初始化</h4><p>动态初始化时只需指明数组的长度，由系统为数组分配初始值</p><ul><li>整数类型：默认初始化值 <code>0</code></li><li>浮点数类型：默认初始化值 <code>0.0</code></li><li>字符类型：默认初始化值 <code>'/u0000'</code> 空格</li><li>布尔类型：默认初始化值 <code>false</code></li><li>引用数据类型：默认初始化值 <code>null</code><em>除了四类八种数据类型都是引用数据类型</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[] 数组名 = new 数据类型[数组的长度];</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="数组的元素访问">3. 数组的元素访问</h2><h3 id="数组的地址">3.1 数组的地址</h3><p>直接访问数组名时，得到的是数组的地址值，也就是数组在内存中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(arr);  <span class="hljs-comment">//[I@6d03e736</span><br><span class="hljs-comment">// [表示数组 I表示int @间隔符 6d03e736表示内存地址，是十六进制的</span><br><span class="hljs-type">double</span>[] arr2 = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>&#125;;<br>System.out.println(arr2);  <span class="hljs-comment">//[D@568db2f2</span><br></code></pre></td></tr></table></figure><h3 id="访问数组元素">3.2 访问数组元素</h3><p>要想访问或修改数组中某位具体的值，需要用到索引索引：也叫角标、下标，从 0 开始连续不间断<em>当访问了数组中不存在的索引就会出现索引越界异常，数组的有效索引是 0到 数组的长度减 1</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组名[]</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//输出1</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//输出5</span><br></code></pre></td></tr></table></figure><h3 id="数组的遍历">3.3 数组的遍历</h3><p>访问数组的每一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组名.lengh 数组的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.lengh; i++) &#123;<br>    System.out.println(arr[i]); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维数组">4. 二维数组</h2><p>二维数组就是在数组里面存数组，将数组分组管理</p><h3 id="初始化">4.1 初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">int</span>[][] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2.</span>..&#125;, &#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2.</span>..&#125;&#125;;<br><span class="hljs-type">int</span>[][] arr2 = &#123;<br>    &#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2.</span>..&#125;, <br>    &#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2.</span>..&#125;<br>&#125;;  <span class="hljs-comment">//建议使用这种</span><br><br><span class="hljs-comment">//动态初始化</span><br><span class="hljs-type">int</span>[][] arr3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];  <span class="hljs-comment">//m个一维数组，每个一维数组存n个元素</span><br></code></pre></td></tr></table></figure><h3 id="元素访问">4.2 元素访问</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <br>    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>&#125;;<br>System.out.println(arr[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//输出第一个一维数组的地址值</span><br>System.out.println(arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]); <span class="hljs-comment">//输出2</span><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.lengh; i++) &#123; <span class="hljs-comment">//遍历二维数组得到每个一维数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].lengh; j++) &#123; <span class="hljs-comment">//遍历一维数组</span><br>        System.out.print(arr[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组在内存">5. 数组在内存</h2><h3 id="java内存分配">5.1 Java内存分配</h3><ul><li>本地方法栈： JVM 在使用操作系统功能时使用，与开发无关</li><li>寄存器： 给 CPU 使用，与开发无关</li><li>栈： 方法运行时使用的内存，比如 <code>main</code>方法运行是进入方法栈中执行</li><li>堆： 存储对象或数组，<code>new</code> 创建的都存储在堆空间</li><li>方法区： 存储可运行的 class 文件 <em>从 jdk8开始取消了方法区，新增元空间，原方法区的功能一部分放到堆中，一部分放到元空间中</em></li></ul><p><img src="01_stack_mem.jpg" /></p><h3 id="数组在内存中的存储">5.2 数组在内存中的存储</h3><ul><li>方法进入栈中执行，变量定义在栈中，变量的数据也存储在栈中</li><li><code>new</code> 出来的都在堆中开辟空间并产生地址</li><li>数组名在栈内存中存储的是堆中数组对应的地址，数组元素实际存储在堆中，通过数组名加索引去访问堆中的数组元素</li></ul><p><img src="01_arr_mem.jpg" /></p><p>数组赋值给数组时，实际是将数组的地址赋值，并没有在堆中开辟新的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">//简写省略了 new</span><br><span class="hljs-type">int</span>[] arr2 = arr1;  <span class="hljs-comment">//没有 new，实际将 arr1 所指的地址赋给了 arr2</span><br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;  <span class="hljs-comment">//arr1 和 arr2 共享一块堆空间</span><br>System.out.println(arr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//输出 2，对 arr1 的修改也是对 arr2 的修改</span><br></code></pre></td></tr></table></figure><h3 id="二维数组在内存中的存储">5.3 二维数组在内存中的存储</h3><ul><li>栈内存中存的是二维数组在堆内存中的地址值</li><li>堆内存中二维数组存的是每个一维数组的地址值</li><li>一维数组中存储的是真正的数据元素</li></ul><p><img src="01_2dim_arr_mem.jpg" /></p><h1 id="六方法">六、方法</h1><h2 id="方法介绍">1. 方法介绍</h2><p>方法（method）是程序中最小的执行单元，将一些重复具有独立功能的代码打包到方法中<em>(相当于 C 语言中的函数)</em></p><p>作用：</p><ul><li>提高代码的复用性</li><li>提高代码的可维护性</li></ul><h2 id="方法的定义和调用">2. 方法的定义和调用</h2><h3 id="基本概念">2.1 基本概念</h3><ul><li>方法定义：把代码打包的过程（创建方法）</li><li>方法调用：方法定义之后需要手动使用才会运行（使用方法）</li><li>形参：方法定义中的参数</li><li>实参：方法调用中的参数</li></ul><h3 id="格式和注意事项">2.2 格式和注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名 (参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2.</span>..) &#123; <br>    方法体...<br>    <span class="hljs-keyword">return</span> 返回值; <br>&#125;<br><span class="hljs-comment">//方法的调用</span><br>方法名 (参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2.</span>..);<br></code></pre></td></tr></table></figure><ul><li><code>参数</code> 是<code>数据类型 变量名</code>，可以没有，也可以有多个</li><li>返回值类型为 <code>void</code> 时，可省略<code>return</code>，或者只写 <code>return</code> 无<code>返回值</code>，表示结束方法</li><li>返回值类型不为 <code>void</code> 时，<code>返回值</code> 和<code>返回值类型</code> 必须对应</li><li>方法需要先定义才能调用，调用时 <code>形参</code> 和<code>实参</code> 必须一一对应</li></ul><h2 id="方法的重载">3. 方法的重载</h2><p>在<strong>同一个类</strong>中多个<strong>方法名相同</strong>而<strong>参数不同</strong>的方法</p><ul><li>重载对应方法的定义，与方法的调用无关</li><li>重载根据方法名和参数（数量，类型，顺序）进行识别，与返回值无关</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        方法体;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        方法体;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span>  <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        方法体;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法在内存">4. 方法在内存</h2><p>方法运行时使用栈内存，进栈运行，运行完毕就出栈，先进后出 <imgsrc="01_method_mem.jpg" /></p><ul><li>基本数据类型：数据值存储在自己空间中<ul><li>传参时传递的是<strong>真实的数据</strong>，形参的改变不会影响实参的值</li></ul></li><li>引用数据类型：数据值存储在其他空间中，自己空间中存储的是地址值<ul><li>传参时传递的是<strong>地址值</strong>，通过地址值修改形参会影响实参的值</li></ul></li></ul><blockquote><p><strong>一、 在方法中声明的变量，即该变量是局部变量</strong>每当程序调用方法时，系统都会为该方法建立一个方法栈，局部变量就存放在方法栈中，当方法结束系统会释放方法栈，该方法中声明的变量随着栈的销毁而销毁，这就是局部变量只能在方法中使用的原因。在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量（1）基本类型： 变量名和值（变量名和值是两个概念）存放在方法栈中（2）引用类型：所声明的变量（实际存储的是地址值）存放在方法栈中，该变量所指的对象放在堆内存中<strong>二、 在类中声明的成员变量，也叫全局变量</strong>全局变量在堆中存放（所以全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量既可是基本类型的变量，也可以是引用类型的变量（1）基本类型：变量名及其值都放在堆内存中（2）引用类型：变量名和值都存在堆中，但变量存储的仍是地址值，该内存地址值指向所引用的对象</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要有原码、反码、补码？</title>
    <link href="/2023/07/01/coding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%EF%BC%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%EF%BC%9F/"/>
    <url>/2023/07/01/coding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%EF%BC%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="原码">1、原码</h3><blockquote><p>原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</p></blockquote><p>一个字节 8 个bit，第 1 位是符号位, 0 为正, 1 为负，后 7 位表示数值。那么最大值应该为符号位是 0 表示正数，其他位都为 1，为 <strong>01111111</strong>，为十进制的 <strong>127</strong>；最小值应该是符号位是 1表示负数， 其他位都为 1，为 <strong>1111 1111</strong>，为十进制的<strong>-127</strong>。</p><p>原码已经可以表示正数和负数，为什么还需要反码和补码？</p><table><thead><tr><th style="text-align: center;">十进制</th><th style="text-align: center;">原码</th></tr></thead><tbody><tr><td style="text-align: center;">3</td><td style="text-align: center;">0000 0011</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">0000 0010</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0000 0001</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0000 0000</td></tr><tr><td style="text-align: center;">-1</td><td style="text-align: center;">1000 0001</td></tr><tr><td style="text-align: center;">-2</td><td style="text-align: center;">1000 0010</td></tr><tr><td style="text-align: center;">-3</td><td style="text-align: center;">1000 0011</td></tr></tbody></table><p>在原码的计算过程中， <code>2 + 1 = 3</code> &lt;==&gt;<code>0000 0010 + 0000 0001 = 0000 0011</code> 二进制计算的结果与 2 + 1= 3 完全一致，正数是完全没有问题的 <strong>But</strong><code>-2 + 1 = -1</code> &lt;==&gt;<code>1000 0010 + 0000 0001 = 1000 0011</code> 二进制计算的结果 -2 + 1结果是 -3，而正确结果应该是 -1 <code>-2 - 1 = -3</code> &lt;==&gt;<code>1000 0010 - 0000 0001 = 1000 0001</code> 二进制计算的结果 -2 - 1结果是 -1，而正确结果应该是 -3</p><p>由此可见负数计算会出现错误，计算结果与预期结果是<strong>相反的</strong>，为了解决负数运算的问题，因此发明了反码</p><h3 id="反码">2、反码</h3><p>负数的原码在计算时总是往相反的方向走，因为有第一位符号位负的存在，加的时候变小，减的时候变大，所以干脆把负数的数据位全部取反，0变 1、1 变0，而正数原码计算没有问题，所以正数的反码和原码一样，也就引出了反码的概念</p><blockquote><p>反码：正数的反码是其本身，负数的反码是符号位保持不变，其余位取反</p></blockquote><table><thead><tr><th style="text-align: center;">十进制</th><th style="text-align: center;">原码</th><th style="text-align: center;">反码</th></tr></thead><tbody><tr><td style="text-align: center;">3</td><td style="text-align: center;">0000 0011</td><td style="text-align: center;">0000 0011</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">0000 0010</td><td style="text-align: center;">0000 0010</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0000 0001</td><td style="text-align: center;">0000 0001</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0000 0000</td><td style="text-align: center;">0000 0000</td></tr><tr><td style="text-align: center;">-0</td><td style="text-align: center;">1000 0000</td><td style="text-align: center;">1111 1111</td></tr><tr><td style="text-align: center;">-1</td><td style="text-align: center;">1000 0001</td><td style="text-align: center;">1111 1110</td></tr><tr><td style="text-align: center;">-2</td><td style="text-align: center;">1000 0010</td><td style="text-align: center;">1111 1101</td></tr><tr><td style="text-align: center;">-3</td><td style="text-align: center;">1000 0011</td><td style="text-align: center;">1111 1100</td></tr></tbody></table><p><code>-2 + 1 = -1</code> &lt;==&gt;<code>1111 1101 + 0000 0001 = 1111 1110</code> 计算结果 1111 1110对应的是 -1 的反码，与实际结果相符 <code>-2 - 1 = -3</code> &lt;==&gt;<code>1111 1101 - 0000 0001 = 1111 1100</code> 计算结果 1111 1100对应的是 -3 的反码，两个负数的运算也与结果相符 <strong>But</strong><code>-1 + 3 = 2</code> &lt;==&gt;<code>1111 1110 + 0000 0011 = 0000 0001</code> 计算结果 0000 0001 是 1的反码，而预期结果是 2，再试试别的数值 <code>-2 + 5 = 3</code>&lt;==&gt; <code>1111 1101 + 0000 0101 = 0000 0010</code> 计算结果 00000010 是 2 的反码，而预期结果是 3</p><p>这些出错的例子都有一些共同的特点，它们都<strong>跨越 0</strong>了，这是因为存在 0 和 -0，而 0 和 -0是一样的，但占据了一位反码的空间，为解决这个问题，引出了补码的概念</p><h3 id="补码">3、补码</h3><p>反码跨 0 计算总是会和预期结果存在 1 的偏差，这个偏差是由于反码多一个-0 而导致的，解决方法其实很简单，把整个反码向下移一位，也就是消除 -0这一位， 规定 -1 的补码为 11111111，也就是常说的<strong>负数的补码是反码加1</strong><del>（所以这个加1并不是无厘头规定非要加1）</del>，而正数原码没有任何计算问题，所以正数的补码依然和原码相同</p><blockquote><p>补码：正数的补码是其本身，负数的补码是在其反码的基础上加 1</p></blockquote><table><thead><tr><th style="text-align: center;">十进制</th><th style="text-align: center;">原码</th><th style="text-align: center;">反码</th><th style="text-align: center;">补码</th></tr></thead><tbody><tr><td style="text-align: center;">127</td><td style="text-align: center;">0111 1111</td><td style="text-align: center;">0111 1111</td><td style="text-align: center;">0111 1111</td></tr><tr><td style="text-align: center;">…</td><td style="text-align: center;">…</td><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">0000 0011</td><td style="text-align: center;">0000 0011</td><td style="text-align: center;">0000 0011</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">0000 0010</td><td style="text-align: center;">0000 0010</td><td style="text-align: center;">0000 0010</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0000 0001</td><td style="text-align: center;">0000 0001</td><td style="text-align: center;">0000 0001</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0000 0000</td><td style="text-align: center;">0000 0000</td><td style="text-align: center;">0000 0000</td></tr><tr><td style="text-align: center;">-0</td><td style="text-align: center;">1000 0000</td><td style="text-align: center;">1111 1111</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">-1</td><td style="text-align: center;">1000 0001</td><td style="text-align: center;">1111 1110</td><td style="text-align: center;">1111 1111</td></tr><tr><td style="text-align: center;">-2</td><td style="text-align: center;">1000 0010</td><td style="text-align: center;">1111 1101</td><td style="text-align: center;">1111 1110</td></tr><tr><td style="text-align: center;">-3</td><td style="text-align: center;">1000 0011</td><td style="text-align: center;">1111 1100</td><td style="text-align: center;">1111 1101</td></tr><tr><td style="text-align: center;">…</td><td style="text-align: center;">…</td><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr><tr><td style="text-align: center;">-127</td><td style="text-align: center;">1111 1111</td><td style="text-align: center;">1000 0000</td><td style="text-align: center;">1000 0001</td></tr><tr><td style="text-align: center;">-128</td><td style="text-align: center;">无</td><td style="text-align: center;">无</td><td style="text-align: center;">1000 0000</td></tr></tbody></table><p>再来计算 <code>-1 + 3 = 2</code> &lt;==&gt;<code>1111 1111 + 0000 0011 = 0000 0010</code> 结果 0000 0010 为2，完美匹配预期，跨 0 问题完美解决 <code>-2 - 1 = -3</code> &lt;==&gt;<code>1111 1110 - 0000 0001 = 1111 1101</code> 结果 1111 1101 是十进制的-3，负数计算问题完美解决</p><p>补码成功解决了所有问题，而因为加 1 向下移动一位，多出来一位<code>1000 0000</code>，所以规定它为特殊的-128，没有反码，也没有原码，这就是为什么一个字节的范围正数到<strong>127</strong>，而负数可以到 <strong>-128</strong></p><h3 id="类型转换的底层原理">4. 类型转换的底层原理</h3><ul><li>byte：1 个字节</li><li>short：2 个字节</li><li>int：4 个字节</li><li>long：8 个字节</li></ul><p><img src="Pasted%20image%2020251101184449.png" /></p><p><strong>1）隐式转换</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//0000 1010</span><br><span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">//转化为0000 0000 0000 1010</span><br></code></pre></td></tr></table></figure><strong>2）强制类型转换</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;  <span class="hljs-comment">//0000 0000 0000 0000 0000 0001 0010 1100</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)a; <span class="hljs-comment">//前面直接抹掉 0010 1100</span><br>System.out.println(b); <span class="hljs-comment">//输出 0010 1100 对应的 44</span><br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;      <span class="hljs-comment">//0000 0000 0000 0000 0000 0000 1100 1000</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)a;  <span class="hljs-comment">//前面直接抹掉 1100 1000</span><br>System.out.println(b); <br><span class="hljs-comment">//1100 1000 对应的反码是 1100 0111，原码是 1011 1000，输出对应的 -56 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「计算机科学」</title>
    <link href="/2023/06/29/coding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    <url>/2023/06/29/coding/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="课程链接">课程链接：</h2><p><ahref="https://www.bilibili.com/video/BV1EW411u7th">https://www.bilibili.com/video/BV1EW411u7th</a></p><h2 id="第一课-计算机早期历史">第一课 计算机早期历史</h2><h4 id="计算机的实质">1、 计算机的实质</h4><p>极其简单的组件，通过一层层的抽象，来做出复杂的操作。</p><h4 id="计算的历史">2、计算的历史</h4><p>这些设备让原先很费力的事情变得更快，更简单，更精确</p><ol type="1"><li>公元前2500年：公认最早的计算设备<ahref="https://zh.wikipedia.org/wiki/%E7%AE%97%E7%9B%98">算盘</a>发明于”美索不达米亚”，它是手动计算器，用来帮助加减数字，它存储着当前的计算状态，类似于如今的硬盘。</li><li>公元前2500年-公元1500年：<ahref="https://zh.wikipedia.org/wiki/%E6%98%9F%E7%9B%98">星盘</a>让船只在海上计算纬度，<ahref="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%B0%BA">计算尺</a>帮助计算乘法和除法，<ahref="https://zh.wikipedia.org/wiki/%E6%99%82%E9%90%98">时钟</a>计算日出、潮汐、天体位置、计时。</li><li>公元1613年：<strong>computer</strong>的概念出现，当时是指专门做计算的职业。</li><li>1694年：德国博学家 <em>戈特弗里德·莱布尼茨</em>建造的<strong>步进计算器</strong>是世界上第一台能自动完成加减乘除的计算器，步进计算器有点像汽车里的里程表，不断累加里程数。</li><li>1694-1900年：预先算好的<strong>计算表</strong>类似字典，可用于查找各种庞大的计算值。</li><li>1823年：<ahref="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87">查尔斯·巴贝奇</a>提出的<ahref="https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86%E6%A9%9F">差分机</a>，可以做函数计算，不幸的是，该项目最终放弃了。但在1991年，历史学家根据查尔斯·巴贝奇的草稿做了一个差分机，而且它还管用。</li><li>差分机建造期间：<ahref="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87">查尔斯·巴贝奇</a>提出了更复杂的<ahref="https://zh.wikipedia.org/wiki/%E5%88%86%E6%9E%90%E6%A9%9F">分析机</a>，分析机是“通用计算机”，它可以做很多事情，不只是一种特定运算，就像差分机，这台机器太超前了，所以没有建成。然而这种“自动计算机”的概念，是个跨时代的概念，预示着计算机程序的诞生。英国数学家 <ahref="https://zh.wikipedia.org/wiki/%E6%84%9B%E9%81%94%C2%B7%E5%8B%92%E8%8A%99%E8%95%BE%E7%B5%B2">埃达·洛夫莱斯</a>给分析机写了假想的程序，她说：“未来会诞生一门全新的，强大的，专为分析所用的语言”，因此Ada 被认为是世上第一位程序员。</li><li>1890年美国人口普查：<ahref="https://zh.wikipedia.org/zh-cn/%E8%B5%AB%E7%88%BE%E6%9B%BC%C2%B7%E4%BD%95%E6%A8%82%E7%A6%AE">赫尔曼·何乐礼</a>发明了<strong>打孔卡片制表机</strong>，创办制表机器公司，这家公司后来在1924 年与其它机械制造商合并，成为了 “国际商业机器公司”，简称 <ahref="https://zh.wikipedia.org/wiki/IBM">IBM</a>（International BusinessMachines）</li></ol><h2 id="第二课-电子计算机">第二课 电子计算机</h2><p><strong>继电器</strong> → <strong>真空管</strong> →<strong>晶体管</strong></p><ol type="1"><li><p>1944年： 最大的机电计算机是<ahref="https://zh.wikipedia.org/wiki/IBM">IBM</a>给二战同盟国制造的<ahref="https://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E4%B8%80%E5%9E%8B">哈佛马克一号</a>给“曼哈顿计划”跑模拟，使用<strong>继电器</strong>，利用电磁效应控制机械开光，开关速度慢，机械磨损严重，故障率高。<em>最早因虫子进入继电器导致故障，电脑出问题就说出了bug（虫子）</em></p></li><li><p>1904年：英国物理学家<ahref="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%BC%97%E8%8E%B1%E6%98%8E">约翰·弗莱明</a>开发的新的电子组件叫“热电子管”，这是世界上第一个<strong>真空管</strong>。</p></li><li><p>1906年：美国发明家<ahref="https://zh.wikipedia.org/wiki/%E6%9D%8E%C2%B7%E5%BE%B7%E5%AF%8C%E9%9B%B7%E6%96%AF%E7%89%B9">李·德富雷斯特</a>加入第三个控制电极改进<strong>真空管</strong>，可以断开或闭合电路，每秒闭合可以上千次，且没有机械磨损，但造价昂贵，十分脆弱，像灯泡一样会烧坏。</p></li><li><p>1940年代：<strong>真空管</strong>成本和可靠性得到改进，标志计算机从机电转向电子。</p></li><li><p>1943年：第一次大规模使用<strong>真空管</strong>的计算机是<ahref="https://zh.wikipedia.org/wiki/%E5%B7%A8%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA">巨人计算机</a>，用来破解纳粹通信，巨人被认为是第一个可编程的电子计算机，编程的方法是把几百根电线插入插板，虽然”可编程”，但还是要配置它。</p></li><li><p>1946年：在”宾夕法尼亚大学”完成建造电子数值积分计算机 <ahref="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%95%B8%E5%80%BC%E7%A9%8D%E5%88%86%E8%A8%88%E7%AE%97%E6%A9%9F">ENIAC</a>,这是世上第一个真正的通用可编程的电子计算机，因为真空管很多，所以故障很常见，<strong>ENIAC</strong>运行半天左右就会出一次故障。</p></li><li><p>1955年：美国空军的 AN/FSQ-7计算机，真空管计算机都达到了极限，为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。</p></li><li><p>1947年：<ahref="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4">贝尔实验室</a>发明了<strong>晶体管</strong>，一个全新的计算机时代诞生了。第一个晶体管每秒可以开关10000次，而且比起玻璃制成，小心易碎的真空管，晶体管是固态的，晶体管可以远远小于继电器或真空管，导致更小更便宜的计算机出现。</p></li><li><p>1957年：<strong>IBM608</strong>：第一个完全用<strong>晶体管</strong>，而且消费者也可以买到的计算机，IBM很快把所有产品都转向了晶体管，把晶体管计算机带入办公室，最终引入家庭</p></li></ol><h2 id="第三课-布尔逻辑和逻辑门">第三课 布尔逻辑和逻辑门</h2><h4 id="计算机使用二进制的原因">1、计算机使用二进制的原因</h4><ol type="1"><li>计算机的元器件晶体管只有2种状态，闭合（True）&amp;&amp;断开（False），用二进制可直接根据元器件的状态表示数值。</li><li>有一整个数学分支“布尔代数”存在，专门处理”真”和”假”，它已经解决了所有法则和运算。</li><li>状态越多，越难区分信号，容易混淆。</li></ol><h4 id="布尔代数的基本操作">2、布尔代数的基本操作</h4><p><strong>1）非运算</strong> 命名：NOT门/非门 作用：反转输入值</p><table><thead><tr><th style="text-align: center;">输入</th><th style="text-align: center;">输出</th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr></tbody></table><p>实现： 半导体通电输入True，则线路接地，无输出电流，为False半导体不通电输入False，则输出电流从右边输出，为True <imgsrc="not_gate.jpg" /></p><p><strong>2)与运算</strong> 命名：AND门/与门 作用：输入都为真才为真</p><table><thead><tr><th style="text-align: center;">输入1</th><th style="text-align: center;">输入2</th><th style="text-align: center;">输出</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><p>实现：串联两个晶体管，当2个晶体管都通电时，输出才有电流，为True <imgsrc="and_gate.jpg" /></p><p><strong>3)或运算</strong> 命名：OR门/或门 作用：输入有真就为真</p><table><thead><tr><th style="text-align: center;">输入1</th><th style="text-align: center;">输入2</th><th style="text-align: center;">输出</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><p>实现：并联两个晶体管，任一晶体管通电，输出就有电流，为True <imgsrc="or_gate.jpg" /></p><p><strong>4)异或运算</strong> 命名：XOR门/异或门作用：两个输入不同为真</p><table><thead><tr><th style="text-align: center;">输入1</th><th style="text-align: center;">输入2</th><th style="text-align: center;">输出</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>实现：先用一个OR门，将其与AND门并联，AND门与NOT门串联，最后让NOT与AND门并联，获得输出。<img src="union_and_or_not_and.jpg" /></p><h4 id="逻辑门的符号表示">3、逻辑门的符号表示</h4><p>抽象作用：将逻辑门简化，将逻辑门用于构建更大的组件，而不至于太复杂。</p><ul><li>非门：用三角形+圆圈表示</li><li>与门：用D型图案表示</li><li>或门：用类似D向右弯曲的小飞船表示</li><li>异或门：用或门+一个笑脸表示</li></ul><p><img src="not_and_or_xor.jpg" /></p><h2 id="第四课-二进制">第四课 二进制</h2><h4 id="二进制原理和存储单位">1、二进制原理和存储单位</h4><ol type="1"><li>计算机中的二进制表示：单个数字1或0</li><li>十进制与二进制的区别：<ul><li>十进制有10个数字，0-9，逢10进1（不存在10这个数字），则每向左进一位，数字大10倍。</li><li>二进制有2个数字，0-1，逢2进1,（不存在2这个数字），则每向左进一位，数字大2倍。</li></ul></li><li>存储单位含义及换算：<ul><li>比特（bit）：一个二进制位</li><li>字节（Byte）：1 Byte = 8 bit<em>最早期的电脑是八位的，即以八位为单位处理数据。</em></li><li>千字节（KB）:1 KB = 2^10 Byte = 1024 Byte</li><li>百万字节（MB）：1 MB = 1024 KB</li><li>十亿字节（GB）：1 GB = 1024 MB</li><li>万亿字节（TB）：1 TB = 1024 GB</li></ul></li><li>32位计算机与64位计算机 计算机一次处理数据的能力，是 32 位或 64位</li></ol><h4 id="正数负数正数浮点数的表示">2、正数、负数、正数、浮点数的表示</h4><p>IEEE754标准</p><ul><li><strong>整数</strong><ul><li>第一位表示正负 1为负 0为正（补码）</li><li>剩下32位表示数值</li></ul></li><li><strong>浮点数</strong><ul><li>小数点在数字间浮动，用类似科学计数法的方式存储 浮点数 = 有效位数 *10^指数</li><li>第一位表示正负 1为负 0为正</li><li>第2-9位存指数</li><li>剩下23位存有效位数 <em>eg.625.9=0.6259（有效位数）*10^3（指数）</em></li></ul></li></ul><h4 id="字符标准">3、字符标准</h4><ol type="1"><li><p><strong>ASCⅡ</strong> 美国信息交换标准代码 用7位编码表示128个字符<img src="ascii.jpg" /></p></li><li><p><strong>UNICODE编码</strong>随着计算机在亚洲兴起，需要解决ASCⅡ不够表达所有语言的问题。为提高代码的互用性，而诞生的编码标准。UNICODE分为17个平面，每个平面有16位编码，总共有超过100万个位置，可满足所有语言的字符需求。</p></li></ol><h2 id="第五课-算术逻辑单元">第五课 算术逻辑单元</h2><h4 id="什么是算术逻辑单元">1、什么是算术逻辑单元</h4><p>命名：算术逻辑单元（Arithmetic&amp;Logic Unit），简称ALU组成：ALU有2个单元，算术单元（Arithmetic Unit）和逻辑单元（LogicUnit），算术单元负责计算机里的所有数字操作作用：计算机中负责运算的组件，处理数字/逻辑的最基本单元</p><h4 id="算术单元">2、算术单元</h4><p><strong>1）半加器</strong> 作用：处理一位数值计算 输入：A,B输出：总和（SUM），进位（CARRY）</p><table><thead><tr><th style="text-align: center;">输入A</th><th style="text-align: center;">输入B</th><th style="text-align: center;">进位</th><th style="text-align: center;">总和</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p><img src="ab_sum_carry.jpg" /></p><p>抽象： <img src="halg_adder.jpg" /></p><p><strong>2)全加器</strong> 作用：处理超过1位的计算 输入：A,B,C输出：总和（SUM），进位（CARRY)</p><table><thead><tr><th style="text-align: center;">输入A</th><th style="text-align: center;">输入B</th><th style="text-align: center;">进位1(A+B)</th><th style="text-align: center;">总和1(A+B)</th><th style="text-align: center;">输入C</th><th style="text-align: center;">进位2(总和1+C)</th><th style="text-align: center;">进位(进位1 OR 进位2)</th><th style="text-align: center;">总和(总和1+C)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><p>原理：A+B通过半加器的结果和C进入下一个半加器，再用OR门判断是否进位<img src="abc_sum_carry.jpg" /> 抽象： <img src="full_adder.jpg" /><strong>3）使用半加器和全加器制作8位加法器</strong> 8位行波进位加法器：<img src="a0_a7_fulladder_sum.jpg" /></p><p>过程说明：</p><ol type="1"><li>用半加器处理第一位数（个位）的加法，得到的sum为第1位，进位参与下一个全加器的计算</li><li>第二位的两个加数和第一位的进位输入到全加器中，得到的sum为第2位，进位参与下一个全加器的计算</li><li>循环此过程，如果第8位的进位为1，说明两个数字的和超过了8位，会导致错误和不可预期的结果，所以应该尽量避免溢出。<em>现在电脑使用的加法器叫“超前进位加法器”</em></li></ol><p><strong>4）ALU的其他数学运算</strong></p><ul><li>加法</li><li>带进位的加法</li><li>减法</li><li>带借位的减法</li><li>取反</li><li>增量（+1）</li><li>减量（-1）</li><li>数字无法通过</li></ul><p><img src="add_sub_neg_dec.jpg" /></p><h4 id="逻辑单元">3、逻辑单元</h4><p>逻辑单元执行逻辑操作，比如AND，OR 和 NOT操作，也能做简单的数值测试</p><hr /><p>例如检验数字是不是0 <img src="a0_a7_out.jpg" /></p><p>用一堆 OR 门检查其中一位是否为 1,哪怕只有一个 Bit (位)是1，就能确定这个数字不是0，再用 NOT 门取反，只有输入的数字是0，输出才为 1</p><h4 id="符号表示">4、符号表示</h4><ul><li>两个输入（INTPUT） A 和 B <em>8位</em></li><li>操作代码（OPERATION CODE）告诉 ALU 执行什么操作（加法减法…）<em>4位</em></li><li>输出结果（OUTPUT） <em>8位</em></li><li>一堆输出标志 <em>1位</em><ul><li>溢出标志(OVERFLOW)</li><li>零标志(ZERO)</li><li>负标志(NEGATIVE)</li></ul></li></ul><p><img src="v_output.jpg" /></p><h2 id="第六课-寄存器和内存">第六课 寄存器和内存</h2><h4 id="为什么需要内存">1、为什么需要内存</h4><p>如果ALU计算出来的数据直接扔掉就没有意义了，有些操作还需要连续计算，需要一种方法把他们存起来，就用到了内存</p><h4 id="锁存器">2、锁存器</h4><p><strong>1）回路门</strong></p><ol type="1"><li><p>OR 门 作用：记录 1 原理：A不管输入 0 还是 1，输出始终为 1 <imgsrc="ab_or_output.jpg" /></p></li><li><p>AND 门 作用：记录 0 原理：A不管输入 0 还是 1，输出始终为 0 <imgsrc="ab_and_output.jpg" /></p></li></ol><p><strong>2）AND-OR锁存器</strong> 作用：存储 1 bit 数据原理：将两种电路组合起来</p><ul><li>设置（SET）输入，输出变为 1</li><li>重置（RESET）输入，输出变为 0</li><li>SET和RESET都是 0，电路会输出最后放入的内容</li></ul><p><img src="set_reset_output.jpg" /></p><p><strong>3）门锁</strong> AND-OR锁存器用两条线输入，麻烦难以理解</p><ul><li>一条输入线（DATA INPUT） （<em>设 0 或 1 存储数据</em>）</li><li>一条允许写入线（WRITE ENABLE）（<em>启用时允许写入，没启用时锁定</em>）</li></ul><p><img src="input_enable_output.jpg" /></p><p>抽象：</p><ul><li>允许写入线关闭（0）时，数据写入线无论是 0 或 1，输出都不会改变</li><li>允许写入线开启（1）时<ul><li>数据写入线写入 1，输出变为1；此时关闭允许写入线，写入线无论输入什么，输出都为 1，值被存起来了</li><li>数据写入线写入 0，输出变为0；此时关闭允许写入线，写入线无论输入什么，输出都为 0，值被存起来了</li></ul></li></ul><p><img src="gated_latch.jpg" /></p><h4 id="寄存器">3、寄存器</h4><p>概念：<strong>并排</strong>使用一组<strong>锁存器</strong>叫<strong>寄存器</strong>，寄存器能存多少bit叫<strong>位宽</strong><em>并排放 8 个锁存器，可以存放 8 位信息，就是早期电脑用的 8位寄存器，后来16位，到如今32位、64位</em> 8 位寄存器：</p><ol type="1"><li>写入寄存器前，用一根线连接所有允许写入线，设为 1启用所有的锁存器</li><li>用 8 条数据线发数据，然后将允许写入线设回 0</li><li>8 bit 的值就被存起来了</li></ol><p><img src="datain_writeenable_dataout.jpg" /></p><h4 id="内存">4、内存</h4><p><strong>1）门锁矩阵</strong> <em>对于很少的存储bit，并排放锁存器勉强够用，但 64 位寄存器需要 64 条数据输入线，64条输出线和 1 条允许写入线，加起来需要 129条线，因此使用矩阵可以大大降低成本</em>16×16的锁存器组成的门锁矩阵便可存储256位，要启用某个锁存器就打开相应的行线和列线<img src="16latches.jpg" /></p><p>内部构造：</p><ul><li>通过行列选择某一个寄存器，行线和列线均为 1 时，左边的AND门才输出为1</li><li>所有寄存器共享一条允许写入线（WRITE ENABLE）</li><li>为了使某个寄存器进入允许写入的状态，允许写入线和行线、列线都必须是1，上面的AND门才输出为 1</li><li>每次只有一个锁存器启用，可以共享使用一条数据线（DATAIN/OUT）传数据</li><li>使用类似允许写入线的允许读取线（READENABLE）从特定锁存器获取数据</li></ul><p><em>256位的寄存器只需 1 条允许写入线，1 条允许读取线，1 条数据线和 16+ 16 的行列线，加起来只有 35 条线</em> <imgsrc="select_test_read_enable.jpg" /></p><p><strong>2）256 位内存</strong>为了将地址转换成行和列，需要用到多路复用器 原理：</p><ul><li>为列编号，16列只需4位二进制编码（0000代表第一列，0001代表第二列，以此类推）</li><li>输入0000，多路复用器选择第一列，输入0001，多路复用器选择第二列</li><li>一个多路复用器处理行（row），另一个多路复用器处理列（column）</li></ul><p><img src="column_address4bit.jpg" /></p><p>抽象：</p><ul><li>8 bit地址（4 bit代表哪一行，4 bit代表哪一列）</li><li>允许写入线</li><li>允许读取线</li><li>数据线 <em>读取内容</em></li></ul><p><img src="256bit_memory.jpg" /></p><p><strong>3）RAM</strong>内存的一个重要特性是：可以随时访问任何位置，因此叫 “随机存取存储器”，简称 RAM 8 个 256 位的内存并排放置</p><ul><li>一行 8 个，可以存一个 8 bit数字，也就是一个字节</li><li>为了存一个 8 bit的数字，同时给 8 个 256 位内存一样的地址</li><li>每个存 1 bit，意味着可以在 256 个地址 存 256 个字节</li></ul><p><img src="8bit_256bit_memory.jpg" /></p><p>不看作一堆单独的存储和电路，看做一个统一的可寻址的内存</p><ul><li>一共有 256 个地址</li><li>每个地址可以读写一个 8 bit（也就是 1 字节）的值</li></ul><p><img src="8bit_ram.jpg" /></p><blockquote><p>现代计算机的内存扩展到上兆字节（MB）和千兆字节（GB）的方式，和这里一样不断把内存打包到更大规模，随着内存地址增多，内存地址也必须增长，8位最多能代表 256 个内存地址（1111 1111 是255，0~255 一共 256个数字）,要给千兆或十亿字节的内存寻址，需要 32 位的地址</p><p>这是一条真实的内存，上面焊了8个内存模块 <imgsrc="ture_mem.jpg" /></p><p>打开其中一个放大看到32个内存方块 <img src="true_mem_big.jpg" /></p><p>放大其中一个方块，可以看到由 4 个小块组成 <imgsrc="true_mem_bbig.jpg" /></p><p>再放大可以看到存单个bit的矩阵，这是一个 128×64 bit的矩阵，总共 8192bit <img src="true_mem_bbbig.jpg" /> 32 个内存方块每个都有 4个矩阵，所以一个方格有 32768 个位 （8192 x 4 = 32768），而一共 32个方格，一个芯片大约存 800 万位，一共 8 个芯片，所以总共有 800万位，也就是 1 兆字节（1 MB），这是1980年代的RAM</p></blockquote><h2 id="第七课-中央处理器cpu">第七课 中央处理器（CPU）</h2><h4 id="基本概念">1、基本概念</h4><ul><li>CPU（Central ProcessingUnit）：中央处理单元，是计算机的“心脏”，负责执行程序。</li><li>时钟速度：CPU “取指令→解码→执行” 的速度叫“时钟速度”，单位是赫兹（Hz），表示频率<ul><li>超频：修改时钟速度，加快CPU的速度，超频过多会让CPU过热或产生乱码</li><li>降频：降低时钟速度，达到省电的效果，对笔记本/手机很重要。<em>现代处理器可以按需求加快或减慢时钟速度，这叫“动态调整频率”</em></li></ul></li><li>指令：程序由一系列指令组成，指示计算机要做什么<ul><li>数学指令，CPU 会让 ALU 进行数学运算</li><li>内存指令，CPU 会和内存通信，然后读/写值</li></ul></li><li>指令表给CPU支持的所有指令分配一个ID,前 4 位存操作码（OPCODE），后 4位代表数据来自哪里，可以是寄存器或内存地址</li></ul><p><img src="instruction_table.jpg" /></p><h4 id="cpu工作原理">2、CPU工作原理</h4><p><em>重点放在功能，而不是一根根线具体怎么连，当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫“微体系架构”。</em> <img src="cpu_chip_ori.jpg" /></p><p><strong>CPU</strong>和<strong>RAM</strong>通过数据线，地址线和允许读/写线通信##### 1）必备组件</p><ul><li><strong>内存</strong>（RAM)，程序可以存储在内存中</li><li><strong>CPU</strong><ul><li><strong>数据寄存器</strong>（REGISTERA/B/C/D）来临时存数据和操作数据</li><li><strong>控制单元</strong>（CONTROL UNIT）指挥CPU内的所有组件<ul><li>1 个追踪程序运行到哪的<strong>指令地址寄存器</strong>（INSTRUCTIONREGISTER），存当前指令的内存地址</li><li>1个存当前指令的<strong>指令寄存器</strong>（INST.ADDR.REGISTER）</li><li>一堆<strong>指令解码逻辑电路</strong></li></ul></li><li><strong>算术逻辑单元</strong>（ALU）负责处理运算</li><li><strong>时钟</strong>负责管理CPU运行的节奏，以精确地间隔触发电信号，控制单元用这个信号推动CPU的内部操作</li></ul></li></ul><h5 id="运行过程">2）运行过程</h5><ol type="1"><li><p>取指令阶段<strong>指令地址寄存器</strong>发送地址给<strong>RAM</strong> →<strong>RAM</strong>将对应地址的指令返回给<strong>指令寄存器</strong> →<strong>指令寄存器</strong>取到指令</p></li><li><p>解码阶段<strong>指令寄存器</strong>发送指令给<strong>指令解码逻辑电路</strong> →<strong>指令解码逻辑电路</strong>根据指令表解码（逻辑门确认操作码）</p></li><li><p>执行阶段</p></li></ol><ul><li><strong>控制单元</strong>根据指令需要打开<strong>RAM</strong>和<strong>数据寄存器</strong>的允许写入/读取线→将在<strong>RAM/数据寄存器</strong>读到的值写入<strong>数据寄存器/RAM</strong>→ 让<strong>指令地址寄存器</strong>的值加1，又到取地址阶段执行下一条指令</li><li>涉及计算时，<strong>控制单元</strong>启用相应<strong>数据寄存器</strong>作为<strong>ALU</strong>的输入，传递操作码告诉<strong>ALU</strong>要做什么→<strong>ALU</strong>的输出结果暂时存储到<strong>控制单元自己的寄存器</strong>中→关闭<strong>ALU</strong>，<strong>控制单元</strong>把值写到相应的<strong>数据寄存器</strong>中→ <strong>指令地址寄存器</strong>的值加 1</li></ul><h4 id="第一个cpu">3、第一个CPU</h4><p>Intel 4004 <img src="intel_4004_cpu.jpg" /></p><h2 id="第八课-指令和程序">第八课 指令和程序</h2><p>CPU之所以强大是因为它是可编程的，如果写入不同指令就会执行不同任务，CPU是一块硬件，可以被软件控制</p><h4 id="一些指令集">1）一些指令集</h4><p><img src="laod_a_load_b.jpg" /></p><ul><li><p>JUMP：让程序跳转到新位置，在底层的实现方式是把指令后 4位代表的内存地址的值覆盖掉指令地址寄存器里的值<em>如果无条件JUMP到前面，程序会陷入死循环，无限JUMP</em></p></li><li><p>JUMP_NEGATIVE：它只在 ALU 的负标志（NEGATIVE）为真时，进行JUMP</p></li><li><p>HALT：指令结束标志，很重要，能区分指令和数据<em>指令和数据都是存在同一个内存里的，它们在根本层面上毫无区别，都是二进制数</em></p></li></ul><p>利用JUMP和HALT实现除法求余（循环减法） <imgsrc="cpu_chip_blue.jpg" /></p><h4 id="指令长度">2）指令长度</h4><p>这颗假设的CPU所有指令都是 8 位，操作码和地址只占 4 位，只能代表 16个指令和操作 16 个地址 现代 CPU 用两种策略：</p><ul><li>最直接的方法是用更多位来代表指令，比如 32 位或 64位，这叫指令长度</li><li>可变指令长度，例如遇到HALT不需要额外数据会立即执行，遇到JUMP得知道JUMP后的位置值，这叫立即值<em>这样设计，指令可以是任意长度，但会让读取阶段变复杂</em></li></ul><h2 id="第九课-高级cpu设计">第九课 高级CPU设计</h2><h4 id="cpu如何提升性能">1、CPU如何提升性能</h4><ul><li>早期计算机的提速方式是减少晶体管的切换时间，但这种提速方法最终会碰到瓶颈</li><li>现代处理器在硬件层面设计除法等，可以直接给ALU除法指令；设计专门电路来处理，图形操作、视频解码、加密文档等</li><li>CPU超高的时钟速度使RAM成了瓶颈，RAM需要找地址取数据输出数据，还要通过总线传输，CPU空等数据</li></ul><h4 id="缓存">2、缓存</h4><p>解决延迟的方法之一是给CPU加一点RAM，叫做<strong>缓存</strong>（CACHE），缓存离CPU 近, 一个时钟周期就能给数据，CPU 不用空等。<em>因为CPU里空间不大，一般缓存只有KB或MB</em> <imgsrc="cpu_cache.jpg" /></p><ul><li>CPU从RAM拿数据时，RAM 不用传一个，可以传一批存入缓存中</li><li>CPU取数据先去缓存取，缓存中取不到再去RAM取<ul><li>如果想要的数据已经在缓存，叫缓存命中</li><li>如果想要的数据不在缓存，叫缓存未命中</li></ul></li><li>缓存也可以当临时空间，存一些中间值，适合长/复杂的运算<em>这样会出现导致缓存与RAM不一致的问题，解决方法是缓存里每块空间设置一个特殊标记“脏位”来记录这种不一致，当缓存满了而CPU又要缓存时，清理缓存之前会检查“脏”位，如果是“脏”的，加载新内容之前会把数据写回RAM来保持同步</em></li></ul><h4 id="指令流水线">3、指令流水线</h4><p>另一种提升性能的方法叫 “<strong>指令流水线</strong>”“取指令→解码→执行”不断重复，但每个阶段用的是 CPU的不同部分，意味着可以并行处理，不同任务重叠进行，同时用上 CPU里所有部分 <img src="fetch_edcode_execute.jpg" /></p><p>这样做会遇到一些问题：</p><ol type="1"><li>指令之间的依赖关系：比如在读数据时正在执行的指令会改这个数据，因此流水线处理器要先弄清数据依赖性，必要时停止流水线，避免出问题<ul><li>处理方法：高端CPU会更进一步动态排序有依赖关系的指令，最小化流水线的停工时间，这叫“乱序执行”</li></ul></li><li>条件跳转：简单的流水线处理器看到 JUMP指令会停下等待条件值确定，空等会造成延迟<ul><li>高端 CPU 会猜哪条路的可能性大一些，提前把指令放进流水线，这叫“推测执行”<ul><li>如果 CPU 猜对了，流水线已经塞满正确指令，可以马上运行</li><li>如果 CPU 猜错了，就要清空流水线<em>为了尽可能减少清空流水线的次数，CPU厂商开发了复杂的方法来猜测哪条分支更有可能，这叫”分支预测”，现代 CPU的正确率超过 90%</em></li></ul></li></ul></li></ol><h4 id="一次性处理多条指令">4、一次性处理多条指令</h4><p>即便有流水线设计，在指令执行阶段处理器里有些区域还是可能会空闲，比如执行一个“从内存取值”指令期间ALU会闲置，所以<strong>一次性处理多条指令</strong>（取指令+解码）会更好，如果多条指令要 ALU 的不同部分，就多条同时执行 <imgsrc="double_fetch_decode_execute.jpg" /></p><p>再进一步<strong>多加几个相同的电路</strong>执行出现频次很高的指令，很多CPU 有四个, 八个甚至更多 完全相同的ALU，可以同时执行多个数学运算</p><h4 id="同时运行多个指令流多核cpu">5、同时运行多个指令流（多核CPU）</h4><p>以上方法都是优化 1条指令流，用<strong>多核处理器</strong>可以同时运行多个指令流 一个 CPU芯片里有多个独立处理单元，因为它们整合紧密，可以共享一些资源，比如缓存，使得多核可以合作运算<img src="fetch_decode_execute_tol.jpg" /></p><h4 id="超级计算机多个cpu">6、超级计算机（多个CPU）</h4><p>当多核不够时可以用<strong>多个 CPU</strong>为了做怪兽级的复杂运算（如模拟宇宙形成），人类制造了<strong>超级计算机</strong>，它由非常非常多的CPU组成，算力惊人&gt;目前世上最快的计算机在中国无锡的国家超算中心，神威·太湖之光有 40960个CPU，每个 CPU 有 256 个核心，总共超过1千万个核心，每个核心的频率是1.45GHz，每秒可以进行 9.3 亿亿次浮点数运算，也叫每秒浮点运算次数(FLOPS)</p><p>CPU的进步是在榨干每个时钟周期，做尽可能多运算，<strong>编程</strong>就是为了最大限度的利用这些算力</p><h2 id="第十课-早期的编程方式">第十课 早期的编程方式</h2><h4 id="早期编程方式史">1、早期编程方式史</h4><ol type="1"><li><p>给机器编程这个需求，早在计算机出现之前就有了，最著名的例子来自纺织业，特定位置有没有穿孔决定了线是高是低，很多人认为<ahref="https://zh.wikipedia.org/wiki/%E9%9B%85%E5%8D%A1%E5%B0%94%E7%BB%87%E5%B8%83%E6%9C%BA">雅卡尔织布机</a>是最早的编程，<strong>穿孔纸卡</strong>便宜、可靠、易懂</p></li><li><p>一个世纪后，<strong>穿孔纸卡</strong>用于1890年美国人口普查，卡片插入汇总机，孔会让对应总和值+1，早期汇总机不算计算机，只能汇总数据，操作是固定的，不能编程，穿孔纸卡存的是数据，不是程序</p></li><li><p>早期程序员在控制面板上插拔电线进行编程，因此也叫<strong>插线板</strong>，运行不同程序要重新接线；到1920年代，控制面板变成了可插拔，让编程变得更简单，可以给机器插入不同程序的插线板<em>用插线板编程不只在机电计算机流行，1946年诞生的第一台通用电子计算机ENIAC也用了一大堆插线板</em></p></li><li><p>1940 年代晚期 1950 年代初，内存价格下降,容量上升，把程序存在<strong>内存</strong>里变得可行，这样程序易于修改、方便CPU 快速读取，这类机器叫 “存储程序计算机”<em>程序和数据都存在一个地方，叫 “冯诺依曼结构”</em></p></li><li><p>第一台冯<strong>诺依曼架构</strong>的”储存程序计算机”由曼彻斯特大学于1948 年建造完成，绰号”宝宝”</p></li><li><p>到1980年代，几乎所有的计算机都有<strong>穿孔纸卡读取器</strong>，放一叠卡片，读取器会一个个写进内存，一旦程序和数据写入完毕，电脑会开始执行<em>用纸卡的最大型程序是美国空军的 SAGE 防空系统，于 1955年完成，据称顶峰时期雇佣了世上 20% 程序员，主控制程序用了 62500张穿孔纸卡，等同于大约 5MB 的数据</em></p></li><li><p>在 1980年代前，还有一种常见编程方式，<strong>面板编程</strong>，与其插一堆线到插线板，可以用一大堆开关和按钮做到一样的效果，面板上有指示灯代表各种函数的状态和内存中的值<em>早期针对计算机爱好者的家用计算机大量使用了开关，第一款取得商业成功的家用计算机是Altair8800，输入二进制操作码，按存储按钮，推进至下一个内存位，直至操作完内存，按运行键执行程序</em></p></li></ol><h4 id="冯诺依曼计算机">2、冯诺依曼计算机</h4><p>冯诺依曼计算机是现代计算机基础结构，他的标志是：</p><ul><li>一个处理器(有算术逻辑单元)</li><li>数据寄存器</li><li>指令寄存器</li><li>指令地址寄存器</li><li>内存（负责存数据和指令)</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机通识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机通识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径</title>
    <link href="/2022/08/03/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/08/03/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra-算法">1 Dijkstra 算法</h1><p>Dijkstra（迪杰斯特拉）算法适用于<strong>单源最短路径</strong>问题，即从一个起点出发，计算到所有其他点的最短路径。它只能用于<strong>边权非负</strong>的图（所有边的权重≥ 0），无法解決<strong>带负权的图</strong>的最短路问题。</p><p>Dijkstra算法的核心思想是<strong>贪心算法</strong>，将所有节点分为<strong>已确定</strong>最短路径的节点和<strong>未确定</strong>最短路径的节点:</p><ol type="1"><li>初始时，将所有顶点的最短距离设为∞，源点的距离设为0</li><li>每次从未确定节点中选择距离最小的节点，作为当前节点，将其标记为已确定</li><li>遍历当前节点的所有邻居，更新该节点的所有邻居节点的距离（<strong>松弛</strong>操作）</li><li>重复上述过程，直到所有节点都被加入已确定集合</li></ol><blockquote><p>“松弛”就是检查当前路径是否更短，如果是，就更新最短距离。</p></blockquote><ul><li>邻接矩阵+迭代</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点 边 起始点 图 距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">// 未确定节点的距离设为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始节点距离设为0</span><br><br>    <span class="hljs-comment">// 一次确定一个节点的最短路，n个节点需要n次循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;  <span class="hljs-comment">// id标记当前节点，初始化为0，距离为无穷大</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <span class="hljs-comment">// 在未确定节点中寻找距离最小的节点</span><br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; dis[id]) id = j;  <br>  <br>        vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 将当前节点标记为已确定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <br>            <span class="hljs-comment">// 松弛，当前节点的邻居，从当前节点出发路径更短</span><br>            <span class="hljs-keyword">if</span> (mp[id][j] != INT_MAX &amp;&amp; dis[id] + mp[id][j] &lt; dis[j])  <br>                dis[j] = dis[id] + mp[id][j];  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归实现（数据稍大会栈溢出）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点  边  起始点  图  距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 当前节点</span><br>    <span class="hljs-type">int</span> mini = INT_MAX, ni = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未确定节点中的最短距离和节点编号</span><br>    vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为已确定</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-keyword">if</span>(!vis[i]) &#123;  <span class="hljs-comment">// 遍历还未确定的节点</span><br>            <span class="hljs-comment">// 当前节点能访问到的邻居 并且 从当前节点出发的路径更短</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != INT_MAX &amp;&amp; dis[id] + mp[id][i] &lt; dis[i])  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>            <span class="hljs-comment">// 在所有还未确定的节点中寻距离最短的</span><br>            <span class="hljs-keyword">if</span>(dis[i] &lt; mini) &#123; <br>                mini = dis[i];  <span class="hljs-comment">// 更新最短距离</span><br>                ni = i;  <span class="hljs-comment">// 更新节点编号</span><br>            &#125;  <br>        &#125;    <br>    &#125;  <br>    <span class="hljs-comment">// 如果找到了未确定节点中的最短距离节点，作为当前节点传入dij</span><br>    <span class="hljs-keyword">if</span>(ni != <span class="hljs-number">-1</span>) <span class="hljs-built_in">dij</span>(ni);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;  <br>    <span class="hljs-built_in">fill</span>(mp[<span class="hljs-number">0</span>], mp[<span class="hljs-number">0</span>] + N * N, INT_MAX);  <span class="hljs-comment">// 边初始化为无穷大</span><br>    <span class="hljs-keyword">while</span>(m--) &#123;  <br>        <span class="hljs-type">int</span> u, v, w;  <br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  <br>        mp[u][v] = <span class="hljs-built_in">min</span>(mp[u][v], w);  <span class="hljs-comment">// 处理重边  </span><br>    &#125;  <br>  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">//  距离初始化为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//  起始点距离初始化为0</span><br>    <span class="hljs-built_in">dij</span>(s);  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <br>        <span class="hljs-keyword">if</span>(dis[i] != INT_MAX) cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bellman-ford-算法">2 Bellman-Ford 算法</h1><p>Bellman-Ford（贝尔曼-福特）算法是用于解决<strong>单源最短路径</strong>问题的经典算法，它可以处理图中包含负权边的情况，并能检测出图中是否存在负环。</p><p>Bellman-Ford算法的核心是“<strong>不断松弛边</strong>”。对所有边进行<code>n - 1</code> 次松弛（n为顶点个数），之后再跑一次检测负环。</p><ol type="1"><li>初始化：将所有顶点的最短距离估计值设为∞，源点的距离设为0</li><li>松弛操作：重复 n-1 次松弛，每次遍历所有边，对每条边进行松弛操作</li><li>检查负环：再进行一次松弛操作，如果还能更新则说明存在负环</li></ol><blockquote><p>为什么进行 n-1 次松弛，因为进行一次Bellman-Ford，距离起点一条边的点的最短路确定，进行两次，距离起点两条边的点的最短路确定， 总共n个点，最短路最多经过 n-1条边，所以进行 n-1 次松弛即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N];  <span class="hljs-comment">// 节点数 边数 起始点 目标点 距离</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> u;  <br>    <span class="hljs-type">int</span> v;  <br>    <span class="hljs-type">int</span> w;  <br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight) : <span class="hljs-built_in">u</span>(from), <span class="hljs-built_in">v</span>(to), <span class="hljs-built_in">w</span>(weight) &#123;&#125;  <br>&#125;;  <br>vector&lt;Edge&gt; egs;   <span class="hljs-comment">// 使用边集数组进行存储，方便对每一条</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bf</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 除起始点之外的距离设为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// n-1 次操作，每次确定距离为 i 的节点最短路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;  <span class="hljs-comment">// 每次操作对所有边进行</span><br>            <span class="hljs-comment">// 当前边的起始点 当前边的到达点 当前边的权值</span><br>            <span class="hljs-type">int</span> from = egs[j].u, to = egs[j].v, weight = egs[j].w;  <br>            <span class="hljs-keyword">if</span>(dis[from] + weight &lt; dis[to])  <span class="hljs-comment">// 松弛操作</span><br>                dis[to] = dis[from] + weight;  <br>        &#125;  <br>    &#125;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;  <br>    egs.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 占位 vector 的 0 号位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        <span class="hljs-type">int</span> x, y, z;  <br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;  <br>        <span class="hljs-comment">// 直接将 Edge(x,y,z) push_back 进 vector</span><br>        egs.<span class="hljs-built_in">emplace_back</span>(x, y, z);  <br>    &#125;  <br>  <br>    <span class="hljs-built_in">bf</span>();  <br>  <br>    cout &lt;&lt; dis[t];  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="spfa-算法">3 SPFA 算法</h1><p>SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford算法的队列优化版本，用于求<strong>单源最短路径</strong>，减少了不必要的冗余运算，同样可以处理存在负权边的情况。</p><p>与 Bellman-Ford 每次都遍历所有边不同，SPFA 利用队列优化了Bellman-Ford算法中不必要的松弛操作，只对发生了松弛操作的结点的邻接结点进行松弛。</p><ol type="1"><li>初始化所有节点到起始点的距离为 ∞，源点为 0</li><li>将源点入队，并标记为在队列中</li><li>当队列不为空时：<ul><li>取出队首节点作为当前节点，弹出并标记为不在队列中</li><li>遍历从当前节点的所有临接边，尝试松弛操作</li><li>如果松弛成功，判断这个邻居节点是否在队列中，如果不在则入队</li></ul></li><li>重复以上操作直到队列为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N], mp[N][N];  <span class="hljs-comment">// 节点 边 源点 终点 距离 图 </span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// 辅助队列</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 标记节点是否在队列</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 除源点外的其他节点距离初始化为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 源点入队</span><br>    vis[s] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 并把源点标记为在队列</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <br>        <span class="hljs-type">int</span> id = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>        q.<span class="hljs-built_in">pop</span>();  <br>        vis[id] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为不在队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 遍历所有邻居节点</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != <span class="hljs-number">1e9</span> &amp;&amp; dis[id] + mp[id][i] &lt; dis[i]) &#123;  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>                <span class="hljs-comment">// 如果不在队列则入队，并标记为在队列</span><br>                <span class="hljs-keyword">if</span>(!vis[i]) &#123; <br>                    q.<span class="hljs-built_in">push</span>(i);  <br>                    vis[i] = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125;       <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SPFA 每轮更新中将“更近一层”的节点的最短路径传递出去，这个过程和 BFS逐层访问节点的方式有点相似。</p></blockquote><h1 id="floyd-算法">4 Floyd 算法</h1>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>SPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/06/26/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%9B%BE/"/>
    <url>/2022/06/26/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图的概念">1 图的概念</h1><p>图是一种由<strong>结点</strong>和<strong>边</strong>组成的数据结构，其中结点表示图中的<strong>对象</strong>，边表示这些对象之间的<strong>关系</strong>。</p><ul><li>结点(Vertex)：也称为顶点，是图中的基本单元，表示一个实体或一个抽象概念。</li><li>边(Edge)：结点之间的连线，表示结点之间的关系。</li></ul><hr /><ul><li>无向图：由没有方向的边组成的图，也称为无向网络或无向图形。<ul><li>无向边表示两个结点之间的双向关系。</li></ul></li><li>有向图：由有方向的边组成的图，也称为有向网络或有向图形。<ul><li>有向边从一个结点指向另一个结点，表示一个方向的关系。</li><li>在有向图中结点也称为起点或终点。</li></ul></li><li>带权图：边上带有权值的图。<ul><li>权值：可以形象地理解为通过这条边的花费的时间、距离、金额等等。</li></ul></li></ul><p><img src="Pasted%20image%2020250717153210%201.png" /></p><hr /><ul><li>无向完全图：图中任意两个顶点之间都存在边。<ul><li>一个 n 阶的完全无向图含有n ×（n－1) / 2 条边</li></ul></li><li>有向完全图：图中任意两个顶点之间都存在方向相反的两条边。<ul><li>一个 n 阶的完全有向图含有n ×（n－1）条边</li></ul></li></ul><p><img src="Pasted%20image%2020250717155915%201.png" /></p><hr /><ul><li>自环：一个结点连接到自身的边</li><li>重边：两个结点之间存在多条边</li></ul><p><img src="Pasted%20image%2020250717153349%201.png" /></p><ul><li>简单图(SimpleGraph)：一种无向图或有向图，其中不存在自环和重边。</li><li>多重图(Multigraph)：一种有向图或无向图，其中存在自环或重边。</li></ul><hr /><ul><li>稀疏图：图中的边很少，边之间的连接相对稀疏。</li><li>稠密图：图中的边很多，边之间的连接非常密集。</li></ul><p><img src="Pasted%20image%2020250717160209%201.png" /></p><h1 id="图的简单性质">2 图的简单性质</h1><h2 id="度数">2.1 度数</h2><p>度数：指与一个结点相连的边的数量。</p><ul><li>在无向图中，一个结点的度数就是它的连接数。</li><li>在有向图中，一个结点的入度是指指向该结点的边的数量，出度是指从该结点出发的边的数量。</li></ul><p><img src="Pasted%20image%2020250717160748%201.png" /></p><h2 id="路径">2.2 路径</h2><ul><li>路径：指从一个结点到另一个结点的连续边构成的序列，路径的长度是指该路径中边的数量。如果两个结点之间存在路径，则这两个结点是连通的。</li><li>简单路径：指从一个结点到另一个结点的连续边构成的序列，序列中的结点不可以重复，即同一条边最多经过一次。</li></ul><p><img src="Pasted%20image%2020250717161538%201.png" /></p><ul><li>环路：一个路径，它的起点和终点相同，且路径上的每个结点可以重复，即同一条边可以多次经过。</li><li>简单环路：一个路径，它的起点和终点相同，且路径上的每个结点都不重复（除了起点和终点，即同一条边不可以多次经过）。一个图如果不包括任何环它就是无环图。</li></ul><p><img src="Pasted%20image%2020250717161242%201.png" /></p><h2 id="连通性">2.3 连通性</h2><ul><li>连通性：如果对于任意两个结点之间都存在路径，这个图是连通的。如果一个图不是连通的，则可以分为多个连通分量。</li><li>对于有向图，存在强连通和弱连通之分：<ul><li>强连通：任意两个结点 u 和 v 之间存在一条从 u 到 v的有向路径，同时存在一条从 v 到 u 的有向路径。</li><li>弱连通：将有向图中的所有边都看作无向边后得到的连通图。</li></ul></li></ul><p><img src="Pasted%20image%2020250717161902%201.png" /></p><ul><li>连通分量：一个无向图的极大连通子图<ul><li>首先，它是这个无向图的一个连通子图(保证了连通)</li><li>其次，它不是这个无向图的其他连通子图的子图 (保证了极大)</li></ul></li><li>强连通分量：一个有向图的极大强连通子图</li></ul><p><img src="Pasted%20image%2020250717162039%201.png" /></p><h1 id="图的存储">3 图的存储</h1><h2 id="邻接矩阵">3.1 邻接矩阵</h2><p>邻接矩阵：一种二维数组其中每个元素表示两个结点之间的边。</p><h3 id="无向图">3.1.1 无向图</h3><p>无向图的邻接矩阵存储：如果两个结点之间存在边，则数组中对应的元素为1，否则为0。</p><p>在无向图中，邻接矩阵是一个对称矩阵，且主对角线一定为0。</p><p><img src="Pasted%20image%2020250717162713%201.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 是否相连</span><br>mp[x][y］= mp[y][x] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="有向图">3.1.2 有向图</h3><p>有向图的邻接矩阵存储：如果结点 x 有一条指向结点 y 的边，那么 mp[x][y]就标记为 1。</p><p>与无向图不同，有向图不一定满足<code>mp[x][y］= mp[y][x]</code></p><p><img src="Pasted%20image%2020250717162954%201.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 是否指向 结点 y</span><br>mp[x][y] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="带权图">3.1.3 带权图</h3><p>带权图的邻接矩阵存储：<code>mp[x][y]</code> 表示结点 x 到结点 y边的权值。</p><p>在边不存在的情况下，会适当地取较大的常数，与普通权值进行区分。带权图输入<strong>注意重边！注意重边！注意重边！</strong></p><p><img src="Pasted%20image%2020250717163306%201.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 之间的权值</span><br>mp[x][y] = len;<br></code></pre></td></tr></table></figure><ul><li>邻接矩阵的优点：查询两个结点之间是否存在边的时间复杂度为O(1)，适用于稠密图。</li><li>邻接矩阵的缺点：占用空间较大，尤其是对于稀疏图时，浪费大量的空间。</li></ul><h2 id="边集数组">3.2 边集数组</h2><h2 id="邻接表">3.3 邻接表</h2><h1 id="特殊图">4 特殊图</h1><h2 id="欧拉路与欧拉回路">4.1 欧拉路与欧拉回路</h2><ul><li>欧拉路：是一种在图中经过每条边恰好一次的路径，但<strong>不要求回到起点</strong>。</li><li>欧拉回路：是一种从起点开始、经过所有边恰好一次、最终<strong>回到起点</strong>的回路。</li></ul><p>欧拉图：存在一条路径可以经过图上所有边恰好一次，并且最终回到起点的图。也就是说，如果一个图存在欧拉回路，那么这个图就是<strong>欧拉图</strong>。</p><ul><li>欧拉图/欧拉回路的判断：<ul><li>无向图：所有顶点的度数必须都是偶数</li><li>有向图：所有顶点的度数必须都是偶数，并且入度和出度必须相等</li></ul></li><li>欧拉路的判断：<ul><li>无向图：恰好有两个顶点的度数是奇数，其余顶点的度数都是偶数</li><li>有向图：至多一个顶点的出度与入度之差为1，至多一个顶点的入度与出度之差为1，其他顶点的入度和出度相等</li></ul></li></ul><p>如果一个图不存在欧拉路，则称该图是<strong>非欧拉图</strong>。</p><h2 id="负权回路">4.2 负权回路</h2><p>如果存在一个环，而这个环上所有权值之和是负数，那这就是个<strong>负权环</strong>，也叫<strong>负权回路</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2022/06/18/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91/"/>
    <url>/2022/06/18/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树的概念">1 树的概念</h1><p>树作为一种非线性的数据结构，是由<spanclass="math inline"><em>n</em>(<em>n</em> ≥ 0)</span>个结点组成的有限集合。如果 <span class="math inline"><em>n</em> = 0</span> 称为空树，如果<spanclass="math inline"><em>n</em> &gt; 0</span>，树有且仅有一个特定的结点——根结点。除根结点外的其他结点划分为互不相交的有限集，每个集合又是一棵树，称为根结点的子树。</p><p><img src="Pasted%20image%2020250718155005%201.png" /></p><hr /><ul><li>树的度：结点拥有的子树的数量为结点的度，树的度定义为树的所有结点中度的最大值。</li><li>度为 0 的结点为<strong>叶子结点</strong>，度不为 0的结点为分支结点。</li></ul><p><img src="Pasted%20image%2020250718155659%201.png" /></p><hr /><p>树的前驱和后继：</p><ul><li>除根结点没有前驱外，其余每个结点都有唯一的一个<strong>前驱结点</strong>。</li><li>除叶子结点没有后继外，每个结点都可以有多个<strong>后继结点</strong>。</li><li>结点的直接后继称为结点的<strong>孩子</strong>，结点的直接前驱称为结点的<strong>父亲</strong>，同一个双亲的不同结点互称<strong>兄弟</strong>。</li></ul><p><img src="Pasted%20image%2020250718160119%201.png" /></p><hr /><p>树中结点的层次：树中根结点为第 1 层，根结点的孩子为第2层，依次类推。树的深度（高度）：树中结点的最大层次。（部分题目中根结点为第 0 层）</p><p><img src="Pasted%20image%2020250718160402%201.png" /></p><hr /><ul><li><span class="math inline"><em>n</em></span> 个结点的树，有且仅有<span class="math inline"><em>n</em>－1</span> 条边</li><li>树中任意两个结点之间有且仅有一条简单路径（路径上的结点都不相同的路径）</li></ul><h1 id="树的存储">2 树的存储</h1><h2 id="双亲表示法">2.1 双亲表示法</h2><p>对父节点进行存储</p><p><img src="Pasted%20image%2020250718161156%201.png" /></p><p>第一行一个整数 <spanclass="math inline"><em>n</em></span>，表示结点个数 第二行 <spanclass="math inline"><em>n</em>－1</span> 个数，第 <spanclass="math inline"><em>i</em></span> 个数是结点 <spanclass="math inline"><em>i</em> + 1</span> 的父节点编号（第 1 个数的值是2 号结点的父结点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, tree[N];<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) cin &gt;&gt; tree[i];<br></code></pre></td></tr></table></figure><h2 id="孩子表示法">2.2 孩子表示法</h2><p>对孩子节点进行存储</p><p><img src="Pasted%20image%2020250718161351%201.png" /></p><p>第一行一个整数 <spanclass="math inline"><em>n</em></span>，表示结点个数 第二行 <spanclass="math inline"><em>n</em>－1</span> 个数，第 <spanclass="math inline"><em>i</em></span> 个数是结点 <spanclass="math inline"><em>i</em> + 1</span> 的父节点编号（第 1 个数的值是2 号结点的父结点）</p><p>使用 <code>vector</code>存储每一个结点的所有孩子，因此<code>tree[i]</code> 里存储的是 i结点的所有孩子结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    tree[x].<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树">3 二叉树</h1><h2 id="二叉树的概念">3.1 二叉树的概念</h2><p>二叉树（Binary Tree，简称BT）是一种度数 <strong>最大为 2</strong>的树，即二叉树的每个结点<strong>最多</strong>有两个子结点。每个结点的子结点分别称为左孩子、右孩子，它的两棵子树称为左子树、右子树。</p><p><img src="Pasted%20image%2020250718162657%201.png" /></p><hr /><p>一棵深度为 <span class="math inline"><em>k</em></span> 且有 <spanclass="math inline">2<sup><em>k</em></sup>－1</span>个结点的二叉树称为<strong>满二叉树</strong>。</p><p><img src="Pasted%20image%2020250718165447%201.png" /></p><hr /><p>若二叉树的高度为 <span class="math inline"><em>k</em></span>，除第<span class="math inline"><em>k</em></span> 层外，其它各层 <spanclass="math inline">1～<em>k</em>－1</span>的结点数都达到<strong>最大个数</strong>，且第<span class="math inline"><em>k</em></span>层缺少的结点是从右到左并连续的，这就是<strong>完全二叉树</strong>。</p><p><img src="Pasted%20image%2020250718165830%201.png" /></p><h2 id="二叉树的性质">3.2 二叉树的性质</h2><ul><li><strong>「性质一」</strong> 在二叉树的第 <spanclass="math inline"><em>i</em></span> 层上最多有<spanclass="math inline">2<sup><em>i</em> − 1</sup></span>个结点（i&gt;=1）。第 1 层最多 1 个结点，第 2 层最多 2个结点，第 3 层最多 4个结点。（像二进制位权）</li></ul><p><img src="Pasted%20image%2020250718163730%201.png" /></p><ul><li><strong>「性质二」</strong> 深度为 <spanclass="math inline"><em>k</em></span> 的二叉树至多有 <spanclass="math inline">2<sup><em>k</em></sup> − 1</span> 个结点（<spanclass="math inline"><em>k</em> &gt;  = 1</span>)（像二进制全 1的情况）</li></ul><p><img src="Pasted%20image%2020250718163900%201.png" /></p><ul><li><strong>「性质三」</strong> 对任意一棵二叉树，如果其叶子结点的数量为<span class="math inline"><em>n</em><sub>0</sub></span>，度为 <spanclass="math inline">2</span> 的结点数为 <spanclass="math inline"><em>n</em><sub>2</sub></span>，则一定满足<spanclass="math inline"><em>n</em><sub>0</sub> = <em>n</em><sub>2</sub> + 1</span>。</li></ul><blockquote><p>证明： 结点总数 <span class="math inline"><em>n</em></span> 等于<span class="math inline">0</span> 度结点 <spanclass="math inline"><em>n</em><sub>0</sub></span>、<spanclass="math inline">1</span> 度结点 <spanclass="math inline"><em>n</em><sub>1</sub></span>，<spanclass="math inline">2</span> 度结点 <spanclass="math inline"><em>n</em><sub>2</sub></span> 之和。即 <spanclass="math inline">$\textcolor{red}{n = n_0 + n_1 + n_2}$</span>(式子1) 1 度结点有 1 个孩子，2 度结点有 2个孩子，树中只有根结点不是任何结点的孩子，故二叉树中结点总数又可以表示为<span class="math inline">$\textcolor{red}{n = n_1 + 2n_2 + 1}$</span>(式子2) 由式子1和式子2得到 <spanclass="math inline">$\textcolor{red}{n_0 = n_2 + 1}$</span>。</p></blockquote><ul><li><strong>「性质四」</strong> 具有 <spanclass="math inline"><em>n</em>(<em>n</em> ≥ 0)</span>个结点的完全二叉树的深度为 <spanclass="math inline">⌊<em>l</em><em>o</em><em>g</em><sub>2</sub><em>n</em>⌋ + 1</span>。（<spanclass="math inline">⌊⌋</span>表示下取整）<ul><li>其实就是最多把最后一层填满，为<spanclass="math inline">2<sup><em>k</em></sup> − 1</span>，对于61来说，不足64，<spanclass="math inline">2<sup>6</sup> = 64</span>，6层就够了。</li></ul></li></ul><blockquote><p>证明： 深度为 <span class="math inline"><em>k</em></span>的完全二叉树，前面 <span class="math inline"><em>k</em>－1</span>层一定是满的，所以 <spanclass="math inline"><em>n</em> &gt; 2<sup><em>k</em> − 1</sup>－1</span>，同时<spanclass="math inline"><em>n</em> ≤ 2<sup><em>k</em></sup> − 1</span>，得到<span class="math inline">$\textcolor{red}{2^{k-1}－ 1 &lt; n ≤2^k－1}$</span>，所以 <spanclass="math inline"><em>k</em> = ⌊<em>l</em><em>o</em><em>g</em><sub>2</sub><em>n</em>⌋ + 1</span>。</p></blockquote><ul><li><strong>「性质五」</strong> 如将一棵有 <spanclass="math inline"><em>n</em></span>个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号1，2，…，n，则有以下关系：<ul><li>若 <span class="math inline"><em>i</em> = 1</span>，则结点 <spanclass="math inline"><em>i</em></span> 为根，无父结点</li><li>若 <span class="math inline"><em>i</em> &gt; 1</span>，则 <spanclass="math inline"><em>i</em></span> 的父结点编号为 <spanclass="math inline">⌊<em>i</em>/2⌋</span></li><li>若 <spanclass="math inline">2 × <em>i</em> &gt; <em>n</em></span>，则 <spanclass="math inline"><em>i</em></span> 无左孩子，否则其左孩子编号为 <spanclass="math inline">2 × <em>i</em></span></li><li>若 <spanclass="math inline">2 × <em>i</em> + 1 &gt; <em>n</em></span>，则 <spanclass="math inline"><em>i</em></span> 无右孩子，否则其右孩子编号为<spanclass="math inline">２ × <em>ｉ</em> + 1</span></li></ul></li></ul><p><img src="Pasted%20image%2020250718174304%201.png" /></p><h1 id="二叉树遍历">4 二叉树遍历</h1><p>先中后由<strong>根的位置决定</strong> ## 4.1 先序遍历先序遍历也叫做先根遍历。 顺序：<strong>根 → 左 → 右</strong>首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树，如果二叉树为空则返回。<img src="Pasted%20image%2020250719104738%201.png" /></p><ol type="1"><li>输出当前结点的值</li><li>递归去处理左子树</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">int</span> left;<br>    <span class="hljs-type">int</span> right;<br>&#125; t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    cout &lt;&lt; t[id].value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点的值</span><br>    <span class="hljs-keyword">if</span>(t[id].left) <span class="hljs-built_in">pre_order</span>(t[id].left); <span class="hljs-comment">// 有左孩子访问左孩子</span><br>    <span class="hljs-keyword">if</span>(t[id].right) <span class="hljs-built_in">pre_order</span>(t[id].right);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br><br><span class="hljs-comment">// 完全二叉树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中序遍历">4.2 中序遍历</h2><p>中序遍历也叫做中根遍历。 顺序：<strong>左 → 根 → 右</strong>首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树，若二叉树为空则结束返回。<img src="Pasted%20image%2020250719105039%201.png" /></p><ol type="1"><li>递归去处理左子树</li><li>输出当前结点的值</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后序遍历">4.3 后序遍历</h2><p>后序遍历也叫做后根遍历。 顺序：<strong>左 → 右 → 根</strong>首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点，若二叉树为空则结束返回。<img src="Pasted%20image%2020250719105326%201.png" /></p><ol type="1"><li>递归去处理左子树</li><li>递归去处理右子树</li><li>输出当前结点的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 有右孩子访问右孩子</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层次遍历">4.4 层次遍历</h2><p>二叉树的层次遍历，就是指从二叉树的第一层（根结点）开始，从上至下逐层遍历，在同一层中，则按照从左到右的顺序对结点逐个访问。<img src="Pasted%20image%2020250719113102%201.png" /></p><h1 id="二叉树重建">5 二叉树重建</h1><h2 id="重建思路">5.1 重建思路</h2><p>二叉树有三种不同的遍历方式：先序遍历，中序遍历和后序遍历。中序遍历+另外任意一种遍历方式，可以<strong>唯一确定一颗二叉树</strong>。先序遍历与后序遍历<strong>不一定</strong>能唯一确定一个二叉树。</p><p>操作步骤：</p><ol type="1"><li>通过先序/后序，判断<strong>根结点</strong></li><li>通过根结点在中序里判断<strong>左右子树</strong></li><li>在先序/后序中找到左右节点，重复操作，画出树的结构。</li></ol><p><img src="重建二叉树%201.gif" /></p><h2 id="重建代码">5.2 重建代码</h2><h3 id="求先序">5.2.1 求先序</h3><p>已知中序和后序，求先序。后序遍历的最后一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求先序序列，所以是先输出，再递归左子树，再递归右子树。</p><ul><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>后序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="11_clear_compress%201.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_pre</span><span class="hljs-params">(string in, string post)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(post.<span class="hljs-built_in">back</span>());  <br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 先序，先输出根节点，再递归左子树和右子树</span><br>    string in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id), post_left = post.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), post_right = post.<span class="hljs-built_in">substr</span>(id, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_pre</span>(in_left, post_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_pre</span>(in_right, post_right);  <span class="hljs-comment">// 递归右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求后序">5.2.2 求后序</h3><p>已知先序和中序，求后序。先序遍历的第一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求后序序列，所以是先递归左子树，再递归右子树，再输出。</p><ul><li>先序<ul><li>左子树：1 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="Pasted%20image%2020250719184128%201.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_post</span><span class="hljs-params">(string pre, string in)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(pre.<span class="hljs-built_in">front</span>());  <br>    string pre_left = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, id), in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string pre_right = pre.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_post</span>(pre_left, in_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_post</span>(pre_right, in_right);  <span class="hljs-comment">// 递归右子树</span><br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 后序，先递归左子树和右子树，再输出根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树">6 二叉搜索树</h1><p>二叉搜索树（Binary SearchTree，BST）是一种应用非常广泛的二叉树，又称二叉查找树，二叉排序树，可以用二叉树进行组织。一般用亲子结构表示一个结点，即一个树结点中，除了数据<code>data</code> 以外，还包含 <code>left</code>，<code>right</code> 和<code>parent</code>。 <strong>二叉搜索树</strong>具有的性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于它根结点的值。</li><li>左右子树也是一棵二叉搜索树。</li></ul><p>搜索过程总结：</p><ul><li>比根结点数据大，且右子树不空，则向右子树搜索，若右子树空则数据不存在。</li><li>比根结点数据小，且左子树不空，则向左子树搜索，若左子树空则数据不存在。</li></ul><p><img src="Pasted%20image%2020250719192504%201.png" /></p><p>根据二叉搜索树的性质和图示，可以得出二叉搜索树中的<strong>最大值在树的最右侧</strong>，<strong>最小值在树的最左侧</strong>。</p><blockquote><p>由于二叉搜索树可以用二叉树进行组织，因此，该搜索的过程可以用二叉树递归遍历实现。搜索效率平均<spanclass="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><sub>2</sub><em>N</em>)</span>。但存在这样的一种特殊情况，此时的二叉搜索树退化为一条单链，搜索效率降为<span class="math inline"><em>O</em>(<em>n</em>)</span>。 <imgsrc="Pasted%20image%2020250719193119%201.png" /></p></blockquote><h1 id="哈夫曼树">7 哈夫曼树</h1><h2 id="基本概念">7.1 基本概念</h2><p>哈夫曼树（HuffmanTree），又称<strong>最优二叉树</strong>，是一种<strong>带权路径长度最短</strong>的二叉树，广泛应用于<strong>数据压缩</strong>（如ZIP、JPEG、MP3 等编码技术）。它由 David A. Huffman 在 1952年提出，权值越大的节点越靠近根结点，越小的节点就越远离根节点，是贪心算法（GreedyAlgorithm）的经典应用。</p><ul><li>权值（Weight）：每个叶子节点可以赋予一个权值（Weight），通常表示字符出现的频率或概率。</li><li>路径长度（Path Length）：从根节点到某个节点所经过的边的数量。</li><li>带权路径长度（Weighted PathLength）：树中所有叶子节点的权值乘以其路径长度的总和。</li></ul><p>哈夫曼树的目标：构造 <strong>WPL</strong>最小的二叉树，以提高编码效率。</p><h2 id="构建步骤">7.2 构建步骤</h2><ol type="1"><li>初始化：将所有节点视为独立的树，每个树仅含一个节点。</li><li>选择最小权值的两棵树：从森林中选出<strong>权值最小</strong>的两棵树（节点）。</li><li>合并两棵树：把这两棵树作为左右子树构成一个新节点，其权值为两个子树的权值之和。</li><li>重复步骤2~3，直到森林中只剩一棵树，即为<strong>哈夫曼树</strong>。</li></ol><p><img src="PixPin_2025-07-19_23-08-34%201.gif" /></p><p>在判别树中，若带权路径长度越小，说明判别次数越少，在底层的执行效率上也会相应更高，这也是体现最优二叉树“优”的地方之一。</p><h2 id="哈夫曼编码">7.3 哈夫曼编码</h2><p>哈夫曼编码是从哈夫曼树中生成的一种<strong>变长编码</strong>：</p><ul><li>高频字符用短编码，低频字符用长编码。</li><li><strong>无前缀冲突</strong>（任何编码都不是另一个编码的前缀）。</li><li>从根节点出发，<strong>左边编码为0，右边编码为1</strong>。</li><li>从根节点到叶子节点的路径就是该字符的编码。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度加减</title>
    <link href="/2022/05/14/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/"/>
    <url>/2022/05/14/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度加法">1 高精度加法</h1><p>主要有以下几步：</p><ol type="1"><li><strong>输入处理</strong>：使用字符串来存储大整数，避免数值范围限制。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相加</strong>：从最低位开始，逐位相加并处理进位。</li><li><strong>最高进位</strong>：在最后检查是否有剩余进位。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N], b[N], c[N];  <span class="hljs-comment">// 方便进位和数位对齐的逆序整型数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();<br>    <span class="hljs-comment">// 逆序存储到整型数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) a[i] = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) b[i] = num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    <span class="hljs-comment">// 循环较长数字的位数</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        c[i] += a[i] + b[i];  <span class="hljs-comment">// 这一位加上两个数的和</span><br>        c[i + <span class="hljs-number">1</span>] += c[i] / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10进位到下一位</span><br>        c[i] %= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10要取余</span><br>    &#125; <br><br>    <span class="hljs-keyword">if</span>(c[len]) len++;  <span class="hljs-comment">// 如果最高位有进位，长度加1</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; c[i];  <span class="hljs-comment">// 逆序输出</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-comment">// 分别计算两数的最后一位数下标，并初始化进位</span><br>    <span class="hljs-type">int</span> i = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br><br>    string res;<br>    <span class="hljs-comment">// 只要有数字没加完 或 有进位没处理就继续运算</span><br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>        <span class="hljs-type">int</span> sum = carry;  <span class="hljs-comment">// 这一位的结果先赋为进位值</span><br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>) sum += num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第一个数没加完就加</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span>) sum += num2[j--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第二个数没加完就加</span><br><br>        carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 计算是否有进位</span><br>        res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 对10取余处理进位</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 翻转答案</span><br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-comment">// 确保 num1 是较长的数字</span><br>    <span class="hljs-keyword">if</span>(num<span class="hljs-number">1.l</span>ength() &lt; num<span class="hljs-number">2.l</span>ength()) <span class="hljs-built_in">swap</span>(num1, num2);<br><br>    string res;  <span class="hljs-comment">// 最终答案</span><br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位，初始为0</span><br>    <span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();  <span class="hljs-comment">// 长度</span><br><br>    <span class="hljs-comment">// 从最低位开始相加，加到较长数字的位数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <br>        <span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br>        <span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br>        <span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这一位的总和等于：两数相加并加上进位</span><br>        <span class="hljs-type">int</span> sum = digit1 + digit2 + carry;<br>        carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 下一位的进位等于这一位总和对10整除</span><br>        res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 最终这一位的结果要对10取余，并且恢复为字符串</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果还有进位，说明最高位也发生了进位，超出了原有最长位数，要单独处理</span><br>    <span class="hljs-keyword">if</span>(carry) res += carry + <span class="hljs-string">&#x27;0&#x27;</span>; <br><br>    <span class="hljs-comment">// 由于前面是从最低位开始加的，这里要对结果进行翻转</span><br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度减法">2 高精度减法</h1><p>主要有以下几步</p><ol type="1"><li><strong>比较大小</strong>：比较两个数字字符串的大小，确定减数和被减数，并标记负号。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相减</strong>：从最低位开始，逐位相减并处理借位。</li><li><strong>结果处理</strong>：移除结果中的前导零，判断是否添加负号。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">subBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-type">char</span> op = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 记录符号</span><br>    <span class="hljs-comment">// 确保 num1 &gt; num2，否则记录负号并交换</span><br>    <span class="hljs-keyword">if</span>(num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() || num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() == num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &amp;&amp; num1 &lt; num2) &#123;<br>        op = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        <span class="hljs-built_in">swap</span>(num1, num2);<br>    &#125;<br><br>    string res;  <span class="hljs-comment">// 最终答案</span><br>    <span class="hljs-type">int</span> borrow = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 借位，初始为0</span><br>    <span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), len2 = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 长度</span><br><br>    <span class="hljs-comment">// 运算按较长数字的长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<br>        <span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br>        <span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br>        <span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这一位的结果等于：两数相减并减去借位</span><br>        <span class="hljs-type">int</span> dif = digit1 - digit2 - borrow;<br>        <span class="hljs-comment">// 判断是否需要借位</span><br>        <span class="hljs-keyword">if</span>(dif &lt; <span class="hljs-number">0</span>) borrow = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> borrow = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 这一位的结果先加10再取余，可以处理需要借位的负数，并 + &#x27;0&#x27; 转字符</span><br>        res += (dif + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理前导0，但注意保留一个，因为结果可能为0</span><br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;0&#x27;</span>) res.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-comment">// 处理负号</span><br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) res += <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-comment">// 翻转字符串</span><br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索</title>
    <link href="/2022/05/04/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/05/04/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>广度优先搜索</strong>（Breadth FirstSearch)：英文缩写为（BFS），是一种用于搜索树或图的算法。从起始节点开始逐层扩展搜索，直到达到目标节点。它以广度的方式探索图中的节点，即先访问离起始节点最近的节点，然后逐渐扩展到距离更远的节点。</p><p>广度优先搜索的实现：</p><ol type="1"><li>将起始节点放入队列中，并将其标记为已访问。</li><li>从队首取出一个节点作为当前节点。</li><li>遍历当前节点的所有邻居节点：如果邻居节点没有被访问过，则将其放入队列中并标记为已访问。</li><li>重复步骤2和3，直到队列为空或找到目标节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br>step step[N][N];  <span class="hljs-comment">// 记录到达某点的最短步数</span><br>queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">// 辅助广搜的队列</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 步数初始化为-1，在记录步数的同时也可以记录哪些点走过</span><br><span class="hljs-built_in">fill</span>(step[<span class="hljs-number">0</span>], step[<span class="hljs-number">0</span>] + N * N, <span class="hljs-number">-1</span>)<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">bfs</span>(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy) &#123;<br>    q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);  <span class="hljs-comment">// 起始节点入队</span><br>    step[sx][sy] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点设为0步，也可能是1步，并且达到了标记已访问的作用</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 队列不为空，就要继续搜</span><br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;  <span class="hljs-comment">// 当前节点的x坐标        </span><br>        <span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;  <span class="hljs-comment">// 当前节点的y坐标</span><br>        q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 取出当前节点</span><br><br>        <span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br>            <span class="hljs-comment">// 遇到终点做一些事情，比如最短步数、判断能否到达终点</span><br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 结束</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br>            <span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br>            <span class="hljs-comment">// 如果下一个点越界了 不能走</span><br>            <span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br>            <span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br>            <span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || step[nx][ny] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <br>            q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);  <span class="hljs-comment">// 能走的点就入队</span><br>            <span class="hljs-comment">// 走到下一个点的步数等于这个点的步数+1</span><br>            step[nx][ny] = step[x][y] + <span class="hljs-number">1</span>;  <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特别注意：要在<strong>入队时就对节点进行标记</strong>，如果在出队时标记，两个点都指向某个未访问的节点时，它会被<strong>重复入队</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索</title>
    <link href="/2022/05/02/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/05/02/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>深度优先搜索算法</strong>（Depth First Search）：英文缩写为DFS，是一种用于搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。深度优先搜索采用了回溯思想，该算法沿着树的深度遍历树的节点，会尽可能深的搜索树的分支。</p><ul><li>回溯：会搜出每一种可能的路线（求路径，通常N&lt;20）</li><li>不回溯：会搜出每一个能走的点（求能否到达）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br><span class="hljs-type">bool</span> mp[N][N];  <span class="hljs-comment">// 到过位置的标记</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;  <span class="hljs-comment">// 当前访问的点是(x, y)</span><br>    <span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br>        <span class="hljs-comment">// 遇到终点做一些事情，比如打印路径、路径数、判断能否到达终点</span><br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 返回</span><br>    &#125;<br><br>    vis[x][y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记此点被访问</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;  <span class="hljs-comment">// 分别搜索四个方向</span><br>        <span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br>        <span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br>        <span class="hljs-comment">// 如果下一个点越界了 不能走</span><br>        <span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br>        <span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br>        <span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || vis[nx][ny]) <span class="hljs-keyword">continue</span>; <br>        <span class="hljs-built_in">dfs</span>(nx, ny);  <span class="hljs-comment">// 开始搜索下一个合法的节点</span><br>    &#125;<br>    <span class="hljs-comment">// 这个点的上下左右都搜完了，回溯到上一个节点，此点标记为未访问</span><br>    vis[x][y] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 根据需求选择是否要回溯</span><br>    <span class="hljs-comment">// 回溯 会搜出每一种可能的路线</span><br>    <span class="hljs-comment">// 不回溯 会搜出每一个能走的点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录路径</span><br><span class="hljs-type">int</span> path[N * N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pathsize;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> 终点 &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pathsize; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)-&gt;&quot;</span>, path[i][<span class="hljs-number">0</span>], path[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        cout &lt;&lt; 终点 &lt;&lt; endl;<br>    &#125;<br>    <br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    path[pathsize][<span class="hljs-number">0</span>] = x;  <span class="hljs-comment">// 添加路径</span><br>    path[pathsize++][<span class="hljs-number">1</span>] = y;<br>    <br>    <span class="hljs-keyword">for</span>() 搜索下一个点<br>    <br>    vis[x][y] = <span class="hljs-literal">false</span>;<br>    pathsize--;  <span class="hljs-comment">// 删除路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于连通块问题，可以在main函数中遍历地图，遇到能构成连通块的符号即可进入dfs，对于进入dfs的点，将其设置为不可构成连通块的符号，并不断搜索其周边连通的符号。在main函数中每次进入dfs相当于遇到一个新的连通块并标记，可以进行计数。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clion刷题攻略-配置Cmake</title>
    <link href="/2022/04/29/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/Clion%E5%88%B7%E9%A2%98%E6%94%BB%E7%95%A5-%E9%85%8D%E7%BD%AECmake/"/>
    <url>/2022/04/29/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/Clion%E5%88%B7%E9%A2%98%E6%94%BB%E7%95%A5-%E9%85%8D%E7%BD%AECmake/</url>
    
    <content type="html"><![CDATA[<p>使用Clion刷题，在一个项目中创建多个main函数，每一个文件对应一道题目，将Clion作为题目管理系统使用，并且cpp文件允许使用中文名，exe文件统一输出到runtime目录，防止污染根目录，CmakeLists文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.29</span>)<br><span class="hljs-built_in">project</span>(CppProject)<br><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br>#设定构建运行路径，避免污染根目录<br><span class="hljs-built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/archive)<br><span class="hljs-built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/library)<br><span class="hljs-built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/runtime)<br><span class="hljs-built_in">set</span>(LIBRARY_OUTPUT_PATH $&#123;CMAKE_SOURCE_DIR&#125;/path)<br><span class="hljs-built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG   $&#123;CMAKE_SOURCE_DIR&#125;/runtime)<br><span class="hljs-built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE $&#123;CMAKE_SOURCE_DIR&#125;/runtime)<br><span class="hljs-built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO $&#123;CMAKE_SOURCE_DIR&#125;/runtime)<br><span class="hljs-built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL $&#123;CMAKE_SOURCE_DIR&#125;/runtime)<br><br><br>#遍历项目根目录下所有的.C文件，自动添加<br><span class="hljs-built_in">file</span>(GLOB_RECURSE files *.c *<span class="hljs-comment">/*.c *.cpp */</span>*.cpp)<br>foreach(file $&#123;files&#125;)<br>    # 获取文件名（不带扩展名），可能包含中文<br>    <span class="hljs-built_in">get_filename_component</span>(fullname $&#123;file&#125; NAME_WE)<br>    # 去除非法字符，仅保留字母、数字和下划线<br>    <span class="hljs-built_in">string</span>(REGEX REPLACE <span class="hljs-string">&quot;[^A-Za-z0-9_]&quot;</span> <span class="hljs-string">&quot;&quot;</span> base_name $&#123;fullname&#125;)<br>    # 将文件的绝对路径转为 CMake 格式的路径（保证唯一性）<br>    <span class="hljs-built_in">file</span>(TO_CMAKE_PATH <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span> filePath)<br>    # 利用文件路径生成 MD5 哈希值<br>    <span class="hljs-built_in">string</span>(MD5 hash $&#123;filePath&#125;)<br>    # 取哈希值的前<span class="hljs-number">4</span>个字符作为后缀<br>    <span class="hljs-built_in">string</span>(SUBSTRING $&#123;hash&#125; <span class="hljs-number">0</span> <span class="hljs-number">4</span> uniqueSuffix)<br>    # 构造合法且唯一的 target 名称<br>    <span class="hljs-built_in">set</span>(target_name <span class="hljs-string">&quot;$&#123;base_name&#125;_$&#123;uniqueSuffix&#125;&quot;</span>)<br>    <span class="hljs-built_in">add_executable</span>($&#123;target_name&#125; $&#123;file&#125;)<br>    # 如果希望最终生成的 exe 文件名保留原文件名（包含中文），可设置 OUTPUT_NAME 属性<br>    <span class="hljs-built_in">set_target_properties</span>($&#123;target_name&#125; PROPERTIES OUTPUT_NAME $&#123;fullname&#125;)<br>    <span class="hljs-built_in">message</span>(<span class="hljs-string">&quot;    -- $&#123;file&#125; will be compiled to runtime/$&#123;fullname&#125;&quot;</span>)<br><span class="hljs-built_in">endforeach</span>()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clion</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器填充函数</title>
    <link href="/2022/04/27/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/27/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="fill-按元素填充">1 fill() 按元素填充</h1><ul><li>用于将容器或数组的指定范围内的元素赋值为指定值（按元素类型填充）。</li><li>属于 C++ STL 算法（<code>&lt;algorithm&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址到结束地址的下一位置全部赋为目标值</span><br><span class="hljs-built_in">fill</span>(起始地址, 结束地址下一位, 值);<br><br><span class="hljs-built_in">fill</span>(a, a + n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 一维数组</span><br><span class="hljs-built_in">fill</span>(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>] + n * n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 二维数组</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 动态数组</span><br></code></pre></td></tr></table></figure><h1 id="memset-按字节填充">2 memset() 按字节填充</h1><ul><li>用于将一块内存的每个字节设置为指定的值（按字节填充）。</li><li>属于 C 标准库函数（<code>&lt;cstring&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址将要填充的字节数都填充为目标值</span><br><span class="hljs-built_in">memset</span>(起始地址, 值， 要填充的字节数);<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-comment">// 所有元素初始化为0</span><br><br><span class="hljs-type">char</span> c[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(c, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-built_in">sizeof</span>(c));  <span class="hljs-comment">// 所有元素初始化为A</span><br></code></pre></td></tr></table></figure><blockquote><p>不能直接用于非字节类型，比如 <code>int a[5]; memset(a, 1, sizeof(a));</code> 并不会将每个 <code>int</code> 设为 <code>1</code>，而是每个字节设为 <code>0x01</code>，导致每个 <code>int</code> 的实际值为 <code>0x01010101</code>（16843009）。</p></blockquote><h1 id="对比">3 对比</h1><table><thead><tr><th>特性</th><th><code>memset</code></th><th><code>fill</code></th></tr></thead><tbody><tr><td><strong>填充单位</strong></td><td>字节</td><td>元素</td></tr><tr><td><strong>头文件</strong></td><td><code>&lt;cstring&gt;</code></td><td><code>&lt;algorithm&gt;</code></td></tr><tr><td><strong>效率</strong></td><td>极高（硬件优化）</td><td>较高（通用循环赋值）</td></tr><tr><td><strong>适用类型</strong></td><td><code>char</code>、内存块</td><td>任意类型（如 <code>int</code>、<code>double</code>）</td></tr><tr><td><strong>安全性</strong></td><td>低（易误用导致数据错误）</td><td>高（类型安全）</td></tr><tr><td><strong>典型用途</strong></td><td>清零内存、初始化字符数组</td><td>初始化 STL 容器、非字节类型数组</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>fill</tag>
      
      <tag>memset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL学习指北</title>
    <link href="/2022/04/22/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    <url>/2022/04/22/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="stl-概述">1 STL 概述</h1><h2 id="简介">1.1 简介</h2><p><strong>STL</strong>是Standard TemplateLibrary的简称，中文名<strong>标准模板库</strong>，惠普实验室开发的一系列软件的统称。它是由AlexanderStepanov、Meng Lee和David RMusser在惠普实验室工作时所开发出来的。从根本上说，<strong>STL</strong>是一些“<strong>容器</strong>”的集合，这些“<strong>容器</strong>”有<code>list</code>,<code>vector</code>,<code>set</code>,<code>map</code>等，<strong>STL</strong>也是<strong>算法</strong>和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。<strong>STL</strong>的目的是<strong>标准化组件</strong>，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。在C++标准中，<strong>STL</strong>被组织为下面的13个<strong>头文件</strong>：<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator &gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;memory.h&gt;</code>、<code>&lt;numeric&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt; stack&gt;</code>和</p><hr /><p>STL容器包括<strong>顺序式容器</strong>和<strong>关联式容器</strong>。</p><ul><li>关联容器中的元素按关键字保存和访问；顺序容器中的元素按它们在容器中的位置和顺序保存和访问</li><li>关联容器不支持顺序容器位置相关的操作，因为关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义；关联容器也不支持构造函数或插入操作这些接收一个元素值和一个数量值的操作。</li><li>关联容器支持高效的关键字查找和访问，两个主要的关联容器类型是<code>map</code> 和 <code>set</code>：<ul><li><code>map</code>中的元素是键值对（key–value）：关键字起到索引的作用，值则表示与索引相关联的数据。</li><li><code>set</code> 中的元素只包含关键字：<code>set</code>支持高效的关键字查询操作，检查给定关键字是否在 <code>set</code>中。</li></ul></li></ul><h2 id="顺序式容器">1.2 顺序式容器</h2><p><code>vector</code>：动态数组，从末尾能快速插入与删除，直接访问任何元素。<code>list</code>：双链表，从任何地方快速插入与删除。<code>queue</code>：队列，先进先出。<code>deque</code>：双向队列，从前面或后面快速插入与删除，直接访问任何元素。<code>priority_queue</code>：优先队列，最高优先级元素总是第一个出列。<code>stack</code>：栈，先进后出。</p><p>它们之所以被称为<strong>顺序容器</strong>，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p><h2 id="关联式容器">1.3 关联式容器</h2><p>元素位置取决于特定的排序准则，和插入顺序无关。<code>set</code>：集合，快速查找，不允许重复值。<code>multiset</code>：允许有两个次序相同的元素的集合。<code>map</code>：由键值对组成。<code>multimap</code>：允许键对有相等次序的映射。</p><h2 id="容器特点">1.4 容器特点</h2><blockquote><p>任何两个容器对象，只要它们的类型相同，就可以用 <strong>&gt; &gt;=&lt; &lt;= == !=</strong> 进行比较运算。</p></blockquote><p>假设a、b是两个类型相同的容器对象，其规则如下： <strong>a ==b</strong>：若 a 和 b 中的元素个数相同，且对应元素均相等，则a == b的值为true，否则值为 false。元素是否相等是用<code>==</code>运算符进行判断的。<strong>a &lt;b</strong>：依次比较，若a中元素少于b则判断成立，或者a中每个元素都大于b中对应的元素成立，为true，否则为false。<strong>a != b</strong>：等价于 !(a == b)。 <strong>a &gt;b</strong>：等价于 b &lt; a。 <strong>a &lt;= b</strong>：等价于 !(b&lt; a)。 <strong>a &gt;= b</strong>：等价于 !(a &lt; b)。</p><p><strong>所有容器</strong>都有以下两个成员函数：<code>size()</code>：返回容器对象中元素的个数。<code>empty()</code>：判断容器对象是否为空。</p><p><strong>顺序容器</strong>和<strong>关联容器</strong>都有以下成员函数：<code>begin()</code>：返回指向容器中第一个元素的迭代器。<code>end()</code>：返回指向容器中最后一个元素后面的位置的迭代器。<code>rbegin()</code>：返回指向容器中最后一个元素的反向迭代器（reverse_iterator）。<code>rend()</code>：返回指向容器中第一个元素前面的位置的反向迭代器。<code>erase()</code>：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。<code>clear()</code>：从容器中删除所有元素。 如果一个容器是空的，则<code>begin()</code> 和 <code>end()</code>的返回值相等，<code>rbegin()</code> 和 <code>rend()</code>的返回值也相等。</p><p><strong>顺序容器</strong>还有以下常用成员函数：<code>front()</code>：返回容器中第一个元素的引用。<code>back()</code>：返回容器中最后一个元素的引用。<code>push_back()</code>：在容器末尾增加新元素。<code>pop_back()</code>：删除容器末尾的元素。<code>insert()</code>：插入一个或多个元素。</p><p>对于所有容器基本都有的<code>size()</code>、<code>empty()</code>、<code>clear()</code>，下面不再赘述</p><h1 id="vector">2 vector</h1><h2 id="基础概念">2.1 基础概念</h2><p>在 <code>#include &lt;vector&gt;</code> 中使用</p><blockquote><p><code>vector</code>是STL的<strong>动态数组</strong>，在运行时能根据情况改变数组的大小。由于它是以<strong>数组</strong>形式存储，也就是说它的<strong>内存空间是连续的</strong>，所以索引可以在常数时间内完成，但是在中间进行<strong>插入</strong>和<strong>删除</strong>会造成内存块的复制。另外，如果数组后面的内存空间不够，需要申请一块足够大的内存，会影响<code>vector</code>的效率,同时使迭代器失效。</p></blockquote><p><img src="c_vector.png" /></p><p><strong>vector扩容</strong>示意图: <imgsrc="c_vector_expand.gif" /></p><p><strong>函数</strong>基本功能目录如下! <imgsrc="c_vector_fun.png" /></p><hr /><h2 id="声明">2.2 声明</h2><table><thead><tr><th>功能</th><th style="text-align: left;">例子</th><th>说明</th></tr></thead><tbody><tr><td>定义<strong>int</strong>型数组</td><td style="text-align: left;">vecotr&lt;int&gt; a;</td><td>默认初始化,a为空</td></tr><tr><td></td><td style="text-align: left;">vector&lt;int&gt; b(a);</td><td>用a定义b</td></tr><tr><td></td><td style="text-align: left;">vector&lt;int&gt; a(100);</td><td>a有100个值为0的元素</td></tr><tr><td></td><td style="text-align: left;">vector&lt;int&gt; a(100, 6);</td><td>100个值为6的元素</td></tr><tr><td>定义<strong>string</strong>型数组</td><td style="text-align: left;">vetor&lt;string&gt; a(10, “null”);</td><td>10个值为null的元素</td></tr><tr><td></td><td style="text-align: left;">vector&lt;string&gt; vec(10,“hello”);</td><td>10个值为hello的元素</td></tr><tr><td></td><td style="text-align: left;">vector&lt;string&gt; b(a.begin(),a.end());</td><td>b是a的复制</td></tr><tr><td>定义<strong>结构体</strong>型数组</td><td style="text-align: left;">struct point { int x, y;};vector&lt;point&gt; a;</td><td>a用来存坐标</td></tr></tbody></table><ul><li>定义<strong>int</strong>型</li><li>定义<strong>string</strong>型</li><li>定义<strong>结构体</strong>型</li><li>定义<strong>多维数组</strong>,例如定义一个二维数组:<code>vector&lt;int&gt; a[233];</code>第一维是固定的长度为233,第二维是动态的</li></ul><p>要注意，它和数组类似但不同一旦声明出来后，<code>vector</code>容器还是空的没有下标，因此无法直接<code>cin</code>，需要借助<code>push_back()</code>，访问数据和普通数组一样通过下标访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空的vector 不能输入输出 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 三个元素均为 0 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 三个元素均为1 </span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec3</span><span class="hljs-params">(vec2)</span></span>;<span class="hljs-comment">// 将vec2的元素初始化给vec3</span><br><span class="hljs-comment">// 参数类型要相同 </span><br><br><span class="hljs-comment">// 用迭代器初始化 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite = vec<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 指向vec2的头 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = vec<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 指向vec2的尾 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec4</span><span class="hljs-params">(ite, ite1)</span></span>;<br></code></pre></td></tr></table></figure><p>虽然 <code>vector</code> 可以动态扩展，但需要确保在使用下标访问时，<code>vector</code>已经<strong>分配足够的空间</strong>，否则会出现段错误，如果<code>vector</code> 还没有分配空间，可以使用 <code>push_back()</code>插入元素。</p><h2 id="迭代器">2.3 迭代器</h2><p>迭代器就像<strong>STL</strong>容器的“指针”，可以用星号”<code>*</code>“操作符解除引用。一个保存<strong>int</strong>的<strong>vector</strong>的迭代器声明方法为：<code>vector&lt;int&gt;::iterator it;</code><strong>vector</strong>的迭代器是“随机访问迭代器”，可以把<strong>vector</strong>的迭代器与一个整数相加减，其行为和<strong>指针</strong>的移动类似。可以把<strong>vector</strong>的两个迭代器相减，其结果也和<strong>指针</strong>相减类似，得到两个迭代器对应下标之间的距离。</p><h2 id="遍历">2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(vecor&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); it++) <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">// auto 代替 vecor&lt;int&gt;::iterator</span><br><br><span class="hljs-comment">// 逆序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); it++)<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>; it != vec.begin - <span class="hljs-number">1</span>; it--)<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : vec) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="常用函数">2.5 常用函数</h2><h3 id="push_back-在尾部添加一个元素"><code>push_back()</code><strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>vec.push_back(value);</strong><strong>添加</strong>值为value的元素到当前vector的末尾。</p></blockquote><hr /><h3 id="pop_back-删除最后一个元素"><code>pop_back()</code><strong>删除最后一个元素</strong></h3><blockquote><p><strong>vec.pop_back();</strong><strong>删除</strong>当前vector最后一个元素。</p></blockquote><hr /><h3 id="begin-返回起始位置的迭代器"><code>begin()</code><strong>返回起始位置的迭代器</strong></h3><blockquote><p><strong>vec.begin();</strong>返回指向当前vector<strong>起始元素的迭代器</strong>。</p></blockquote><hr /><h3 id="end-返回末尾元素下一位置的迭代器"><code>end()</code><strong>返回末尾元素下一位置的迭代器</strong></h3><blockquote><p><strong>vec.end();</strong>返回指向当前vector<strong>末尾元素的下一位置的迭代器</strong>。</p></blockquote><hr /><h3 id="front-返回起始元素"><code>front()</code><strong>返回起始元素</strong></h3><blockquote><p><strong>vec.front();</strong>返回当前vector<strong>起始元素</strong>。 等同于 <code>vec[0]</code> 和<code>*vec.begin()</code></p></blockquote><hr /><h3 id="back-返回末尾元素"><code>back()</code><strong>返回末尾元素</strong></h3><blockquote><p><strong>vec.back();</strong>返回当前vector<strong>末尾元素</strong>。 等同于<code>vec[vec.size() - 1]</code> 和 <code>*(vec.end() - 1)</code></p></blockquote><h2 id="二维vector">2.6 二维vector</h2><p><code>vector</code>可以替代一维数组，并且还可以灵活的自动扩充，当然也可以替代二维数组！，如下声明中的v准确来说是变量的声明格式，只不过这个容器神通广大类似于数组，因此叫“一维数组”，但本质是变量。这个变量里面可以塞很多东西，模样像个数组。既然是一个变量，我们可以把它变成一维数组，但很像“二维”，不过每一行都不一定一样长。添加数据的时候要注意，必须找到某一行，然后它是一个变量v[？],通过方法<code>push_back</code>将数据保存到这一行的末尾就可以了。访问数据和二维数组一样通过行下标和列下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">// vector 的“二维”</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec[<span class="hljs-number">100</span>];<br><span class="hljs-comment">//添加元素到第0行</span><br>vec[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><img src="c_vector_array.png" /></p><h1 id="stack">3 stack</h1><h2 id="基础概念-1">3.1 基础概念</h2><p>在 <code>#include &lt;stack&gt;</code> 中使用</p><blockquote><p>栈(<code>stack</code>)是一种<strong>先进后出</strong>的数据结构,栈中只能通过<code>top()</code>来访问<strong>栈顶元素</strong>,元素的<strong>插入</strong>和<strong>删除</strong>都只能<strong>栈顶</strong>进行。</p></blockquote><p><img src="c_stack.png" /></p><h2 id="声明-1">3.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>stack&lt;<span class="hljs-type">double</span>&gt; st2;<br>stack&lt;<span class="hljs-type">char</span>&gt; st3;<br></code></pre></td></tr></table></figure><h2 id="遍历-1">3.3 遍历</h2><p><strong>堆栈中的数据是不允许随机访问的，也就是说不能通过下标访问，且堆栈内的元素是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将stack中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就需要弹出这个元素，因此该方法只能读取一遍stack中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; st.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    st.<span class="hljs-built_in">pop</span>();<br>&#125;    <br></code></pre></td></tr></table></figure><h2 id="常用函数-1">3.4 常用函数</h2><h3 id="push-栈顶插入元素"><code>push()</code><strong>栈顶插入元素</strong></h3><blockquote><p><strong>st.push(value);</strong>在<strong>栈顶</strong>插入一个元素value。</p></blockquote><hr /><h3 id="pop-删除栈顶元素"><code>pop()</code><strong>删除栈顶元素</strong></h3><blockquote><p><strong>st.pop();</strong> 在<strong>栈顶</strong>删除一个元素。</p></blockquote><hr /><h3 id="top-返回栈顶元素"><code>top()</code><strong>返回栈顶元素</strong></h3><blockquote><p><strong>st.top()</strong> 访问<strong>栈顶</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code>函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="queue">4 queue</h1><h2 id="基础概念-2">4.1 基础概念</h2><p>在 <code>#include &lt;queue&gt;</code> 中使用</p><blockquote><p>队列(<code>queue</code>)是一种<strong>先进先出</strong>的限制性数据结构，对数据的<strong>存</strong>和<strong>取</strong>有严格要求。它只能通过<code>front()</code>进行访问<strong>队首</strong>元素，通过<code>back()</code>访问<strong>队尾</strong>元素。队列中只有<strong>队头</strong>和<strong>队尾</strong>才可以被外界使用，因此队列<strong>不允许</strong>有<strong>遍历</strong>行为。与<strong>栈</strong>结构不同的是，<strong>队列</strong>的<strong>两端</strong>都”开口”，要求数据只能从<strong>一端进</strong>，从<strong>另一端出</strong>，通常，称进数据的一端为<strong>队尾</strong>，出数据的一端为<strong>队头</strong>，数据元素进队列的过程称为<strong>入队</strong>，出队列的过程称为<strong>出队</strong>。</p></blockquote><p><img src="c_queue.png" /></p><h2 id="声明-2">4.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>queue&lt;<span class="hljs-type">double</span>&gt; q2;<br>queue&lt;<span class="hljs-type">char</span>&gt; q3;<br></code></pre></td></tr></table></figure><h2 id="遍历-2">4.3 遍历</h2><p><strong>和<code>stack</code>类似，不能通过下标访问，是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将queue中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就要让该元素出队，因此该方法只能读取一遍queue中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出队首</span><br>    q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 队首出队</span><br>&#125;    <br></code></pre></td></tr></table></figure><h2 id="常用函数-2">4.4 常用函数</h2><h3 id="push-队尾插入元素"><code>push()</code><strong>队尾插入元素</strong></h3><blockquote><p><strong>q.push(value)</strong>在<strong>队尾</strong>插入一个元素value。</p></blockquote><hr /><h3 id="pop-删除队头元素"><code>pop()</code><strong>删除队头元素</strong></h3><blockquote><p><strong>q.pop()</strong> 在<strong>队头</strong>删除一个元素。</p></blockquote><hr /><h3 id="front-返回队头元素"><code>front()</code><strong>返回队头元素</strong></h3><blockquote><p><strong>q.front()</strong> 返回<strong>队头</strong>元素。</p></blockquote><hr /><h3 id="back-返回队尾元素"><code>back()</code><strong>返回队尾元素</strong></h3><blockquote><p><strong>q.back()</strong> 返回<strong>队尾</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>front()</code> 和<code>pop()</code> 函数之前，必须用 <code>empty()</code>判断是否为空。</p><h1 id="priority_queue">5 priority_queue</h1><h2 id="基础概念-3">5.1 基础概念</h2><p>在 <code>#inlcude &lt;queue&gt;</code> 中使用</p><blockquote><p>优先队列(priority_queue)，<strong>底层通常使用堆（heap）</strong>实现。元素被赋予优先级，最高优先级的元素会作为队首元素，有<strong>最高优先级先出</strong>的特征，当访问元素时，只能访问具有最高优先级的元素，可以在任何时候往优先队列里面加入元素，而优先队列底层的数据结构堆（heap）会随时调整结构，使得每次的队首元素都是优先级最高的。priority_queue可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p></blockquote><h2 id="声明-3">5.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 默认把最大的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br>priority_queue&lt;<span class="hljs-type">double</span>&gt; pq2;<br>priority_queue&lt;<span class="hljs-type">char</span>&gt; pq3;<br><span class="hljs-comment">// 把最小的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>，vector&lt;<span class="hljs-type">int</span>&gt;，greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq4;<br></code></pre></td></tr></table></figure><h2 id="优先级设置">5.3 优先级设置</h2><h3 id="基本数据类型">5.3.1 基本数据类型</h3><p>优先队列对基本数据类型的优先级设置一般是数字越大的优先级越高，如果是char 类型，则是字典序最大的。</p><p>以 <code>int</code> 型为例下面两种是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; pq2;<br></code></pre></td></tr></table></figure><ul><li><p>第二个参数<code>vector&lt;int&gt;</code>填写的是承载底层数据结构堆（heap）的容器，如果是其他类型可写为<code>vector&lt;char&gt;</code>或<code>vector&lt;double&gt;</code></p></li><li><p>第三个参数 <code>less&lt;int&gt;</code>则是对第一个参数的比较类，<strong>控制优先级</strong>是大是小，<code>less&lt;int&gt;</code>表示数字大的优先级越大，而 <code>greater&lt;int&gt;</code>表示数字小的优先级越大。</p></li></ul><h3 id="结构体类型">5.3.2 结构体类型</h3><p><strong>方法一</strong>：重载 <code>operator&lt;</code>重载（overload）小于号“&lt;”，重载是指对已有的运算符进行重新定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 重载小于运算符，定义优先级</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">// 优先级由 age 实现大堆优先</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &lt; other.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法二</strong>：使用友元<code>friend</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// friend bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法三</strong>：使用 cmp 仿函数</p><p><code>priority_queue</code> 不直接支持使用普通函数（如<code>cmp</code>）作为比较器，因为 <code>priority_queue</code>需要一个<strong>类型</strong>而不是一个普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>        <span class="hljs-comment">// 优先级由 age 的大小决定</span><br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义仿函数 cmp 作为比较器</span><br>priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;<br></code></pre></td></tr></table></figure><blockquote><p>只能对小于号进行重载，重载大于号会编译错误，因为从数学上来讲只需要重载小于号即f1&gt;f2&lt;==&gt;f2&lt;f1。</p></blockquote><h2 id="遍历-3">5.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出队首</span><br>    pq.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//队首出队</span><br>&#125;    <br></code></pre></td></tr></table></figure><h2 id="常用函数-3">5.5 常用函数</h2><h3 id="push-插入元素"><code>push()</code><strong>插入元素</strong></h3><blockquote><p><strong>pq.push(value)</strong>将元素value入队，每次调用排序算法按照优先级排序。</p></blockquote><hr /><h3 id="pop-删除队首元素"><code>pop()</code><strong>删除队首元素</strong></h3><blockquote><p><strong>q.pop()</strong>删除<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><hr /><h3 id="top-返回队首元素"><code>top()</code><strong>返回队首元素</strong></h3><blockquote><p><strong>pq.top()</strong>访问<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code>函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="deque">6 deque</h1><h2 id="基础概念-4">6.1 基础概念</h2><p>在 <code>#inlcude &lt;deque&gt;</code> 中使用</p><blockquote><p>双端队列(<code>deque</code>)，全名double-endedqueue是一种具有<strong>队列</strong>和<strong>栈</strong>的性质的数据结构，它就像是vector和queue的结合。与vector相比，<code>deque</code>在头部增删元素仅需要O(1)的时间；与queue相比，<code>deque</code>像数组一样支持随机访问。双端队列中的元素可以从<strong>两端弹出</strong>，其限定<strong>插入</strong>和<strong>删除</strong>操作在<strong>两端</strong>进行，是一个支持在<strong>两端高效插入或删除元素</strong>的<strong>连续线性存储空间</strong>。</p></blockquote><p><img src="c_deque.png" /></p><h2 id="deque与vectorlist">6.2<code>deque</code>与<code>vector</code>、<code>list</code></h2><p><code>deque</code>的结构是一段一段的空间，每段空间都是一样大的，通过一个中控数组（指针数组）进行连接起来。想要扩容就在连接一块空间即可。当指针数组满了，就中控数组扩容即可。这样以来扩容的代价就很低。不需要拷贝原来的数组。对于头插尾插也很简单，就用专门的两个空间进行头插尾插即可，相比<code>vector</code>极大的缓解了扩容、头插头删问题。但是它的[]运算符不够极致。它的[]需要计算在哪个buff数组，在哪个buff数组的第几个。</p><ol type="1"><li><strong>内存比较</strong><ul><li><code>vector</code>：连续空间</li><li><code>list</code>：不连续空间</li><li><code>deque</code>：段连续空间</li></ul></li></ol><p><img src="c_deque_mem.png" /></p><ol start="2" type="1"><li>功能比较<ul><li><code>vector</code><ul><li>随机位置的插入和删除效率比较低</li><li>随机访问的效率高（下标运算）</li><li>不支持头添加，支持尾添加</li></ul></li><li><code>list</code><ul><li>随机位置的插入和删除效率高</li><li>不支持随机访问</li><li>支持头添加，支持尾添加</li></ul></li><li><code>deque</code><ul><li>随机位置的插入和删除效率不高（以512个字节为一个单位量）</li><li>支持随机访问（比<code>vector</code>慢，因为要做堆跳转），迭代器的结构较为复杂，会降低访问效率</li><li>支持头添加，支持尾添加</li></ul></li></ul></li><li><strong>使用选择</strong><ul><li>随机访问操作频率高，就选用<code>vector</code></li><li>插入删除频率高，头尾添加，就选用<code>list</code></li><li>随机访问+头添加，就选<code>deque</code></li></ul></li></ol><p><strong>函数</strong>基本功能目录如下 <imgsrc="c_deque_fun.png" /></p><hr /><h2 id="声明-4">6.3 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deque&lt;<span class="hljs-type">int</span>&gt; dq;       <span class="hljs-comment">// 空的队列，不能输出 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;   <span class="hljs-comment">// 大小为 3 的空队列 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">12</span>)</span></span>;<span class="hljs-comment">// 三个元素均为12 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq3</span><span class="hljs-params">(dq2)</span></span>; <span class="hljs-comment">// 复制dq2//参数类型要相同 </span><br></code></pre></td></tr></table></figure><h2 id="常用函数-4">6.4 常用函数</h2><h3 id="front-返回头部元素"><code>front()</code><strong>返回头部元素</strong></h3><blockquote><p><strong>dq.front()</strong> 返回第一个元素的引用。</p></blockquote><hr /><h3 id="back-返回尾部元素"><code>back()</code><strong>返回尾部元素</strong></h3><blockquote><p><strong>dq.back()</strong> 返回最后一个元素的引用。</p></blockquote><hr /><h3 id="push_back-在尾部添加一个元素-1"><code>push_back()</code><strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>dq.push_back(value)</strong><strong>添加</strong>值为value的元素到末尾。</p></blockquote><hr /><h3 id="pop_back-在尾部删除一个元素"><code>pop_back()</code><strong>在尾部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><strong>删除</strong>尾部第一个元素。</p></blockquote><hr /><h3 id="push_front-在头部添加一个元素"><code>push_front()</code><strong>在头部添加一个元素</strong></h3><blockquote><p><strong>dq.push_front(value);</strong><strong>添加</strong>值为value的元素到头部。</p></blockquote><hr /><h3 id="pop_front-在头部删除一个元素"><code>pop_front()</code><strong>在头部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><strong>删除</strong>头部第一个元素。</p></blockquote><hr /><h3 id="insert-插入元素"><code>insert()</code><strong>插入元素</strong></h3><blockquote><p><strong>dq.insert(iterator, value)</strong>;向iterator迭代器指向元素的前边添加一个元素value，并返回一个迭代器指向新插入的元素。</p></blockquote><hr /><h3 id="erase-删除元素"><code>erase()</code><strong>删除元素</strong></h3><blockquote><p><strong>dq.erase(iterator);</strong></p><p><strong>dq.erase(iterator1, iterator2)</strong></p><p>参数为一个迭代器，只删除迭代器指向的元素；参数为两个迭代器，删除两个迭代器之间的元素。</p></blockquote><h1 id="set">7 set</h1><h2 id="基础概念-5">7.1 基础概念</h2><p>在 <code>#include &lt;set&gt;</code> 中使用</p><blockquote><p>集合(<code>set</code>)用于存储<strong>不重复</strong>的元素，并且会自动根据元素的值进行<strong>排序</strong>。</p></blockquote><ul><li><strong>不重复元素</strong>：<code>set</code>中的元素不能重复。如果尝试插入相同的元素，它会被忽略。</li><li><strong>自动排序</strong>：<code>set</code>会根据元素的大小自动进行排序，默认是按升序排序。如果想使用自定义的排序规则，也可以提供比较函数。</li><li><strong>高效的查找、插入和删除</strong>：<code>set</code>通常使用红黑树或类似的平衡树结构实现，所以查找、插入和删除操作的时间复杂度是O(log N)，其中 N 是集合中的元素个数。</li></ul><h2 id="声明-5">7.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s;    <br>set&lt;<span class="hljs-type">double</span>&gt; s;    <br>set&lt;<span class="hljs-type">char</span>&gt; s;    <br>set&lt;<span class="hljs-keyword">struct</span> node&gt; s;    <br>set&lt;set&lt;<span class="hljs-type">int</span>&gt; &gt; s;<br></code></pre></td></tr></table></figure><h2 id="遍历-4">7.3 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">//  auto 可以代替 set&lt;int&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="set-排序">7.4 set 排序</h2><p>对于基本数据类型可以直接使用 <code>greater&lt;&gt;</code>实现降序排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; s; <span class="hljs-comment">// &gt;&gt; 可能会被识别为流运算符，中间可以加一个空格&gt; &gt;</span><br></code></pre></td></tr></table></figure><p>结构体类型的自定义排序可以使用如下方法： <strong>方法一：</strong>重载 <code>operator&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Person&amp; p) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> age &lt; p.age;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>set&lt;Person&gt; person;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong> 使用 cmp 仿函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// bool operator()(Person const&amp; a, Person const&amp; b)&#123;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person a, Person b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义比较器来排序 </span><br>set&lt;Person, cmp&gt; s;<br></code></pre></td></tr></table></figure><h2 id="常用函数-5">7.5 常用函数</h2><h3 id="insert-插入"><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>s.insert(value)</strong>插入元素到集合中，插入之后集合会自动排序。</p></blockquote><hr /><h3 id="find-查找"><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>s.find(value)</strong>查找元素返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向<code>set.end()</code>。</p></blockquote><hr /><h3 id="count-计数"><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>s.count(value)</strong>返回指定元素的数量，set中元素是唯一的，如果存在则返回1，不存在则返回0。</p></blockquote><hr /><h3 id="erase-删除"><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>s.erase(value)</strong>删除指定的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="map">8 map</h1><h2 id="基础概念-6">8.1 基础概念</h2><p>在 <code>#inlcude &lt;map&gt;</code> 中使用 <code>map</code>就是一种存储<strong>键值对</strong>的数据结构，由键和值构成，一个键对应一个值，我们可以通过键获取到该键所对应的值。</p><ul><li>第一个可以称为关键字(<code>key</code>)，每个关键字只能在<code>map</code> 中出现一次；</li><li>第二个可能称为该关键字的值(<code>value</code>)；</li></ul><blockquote><p><code>map</code> 相当于一个通讯录，<code>map</code>中记录的每一个昵称和对应的号码，就好比是一个键值对。<strong>注意每个key只能出现一次</strong>，就像我们的通讯录，如果有了两个小明，那我们就搞不清楚哪个才是小明，所以<code>key</code> 不能重复。</p></blockquote><p><code>map</code>主要用于资料一对一映射(one-to-one)的情況，<code>map</code>內部的实现自建一颗红黑树，这颗树具有对数据<strong>自动排序</strong>的功能，也就是说在<code>map</code> 内部所有的数据都是有序的。</p><h2 id="声明-6">8.2 声明</h2><p><code>key</code> 和 <code>value</code>可以是任意你需要的类型，包括自定义类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp1;<br>map&lt;string, string&gt; mp2;<br></code></pre></td></tr></table></figure></p><h2 id="遍历-5">8.3 遍历</h2><p><code>it-&gt;first</code> 和 <code>(*it).first</code> 等价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br><span class="hljs-comment">//  auto 可以代替 map&lt;int, string&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="插入元素的区别">8.4 插入元素的区别</h2><p>以下三种方法虽然都可以实现数据的插入，但是它们是有区别的（第一种和第二种在效果上是完成一样的）</p><ul><li>用 <code>insert</code>函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当<code>map</code> 中有这个关键字时，<code>insert</code>操作是不能在插入数据的</li><li>数组方式插入时可以覆盖以前该关键字对应的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp;<br> <br><span class="hljs-comment">// 第一种 用insert函數插入pair</span><br>mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">000</span>, <span class="hljs-string">&quot;zhu&quot;</span>));<br> <br><span class="hljs-comment">// 第二种 用insert函数插入value_type数据</span><br>mp.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">001</span>, <span class="hljs-string">&quot;zhuzhu&quot;</span>));<br> <br><span class="hljs-comment">// 第三种 用&quot;array&quot;方式插入</span><br>mp[<span class="hljs-number">111</span>] = <span class="hljs-string">&quot;og&quot;</span>;<br>mp[<span class="hljs-number">222</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="常用函数-6">8.5 常用函数</h2><h3 id="insert-插入-1"><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>mp.insert(pair&lt;类型1, 类型2&gt;(key, value))</strong>将pair作为整个元素插入</p></blockquote><hr /><h3 id="find-查找-1"><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>mp.find(key)</strong> 查找关键 <code>key</code>返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向<code>map.end()</code>。</p></blockquote><hr /><h3 id="count-计数-1"><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>mp.count(key)</strong> 返回指定元素的数量，因为<code>key</code>值不会重复，所以只有0和1，如果存在则返回1，不存在则返回0。</p></blockquote><hr /><h3 id="erase-删除-1"><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>mp.erase(key)</strong>删除指定关键字的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="pair">9 pair</h1><p><code>pair</code>本质上就是一个内部有两个名字固定的成员变量的结构体，这两个成员变量为：<code>first</code>成员和 <code>second</code>成员。使用之前要添加头文件:<code>#include &lt;utility&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//两者是等价的</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    string first;<br>    <span class="hljs-type">int</span> second;<br>&#125; p;<br><span class="hljs-comment">//定义的同时初始化</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zhuzhu&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//pair的访问</span><br>p.first = <span class="hljs-string">&quot;hhhhh&#x27;</span><br><span class="hljs-string">p.second = 15;</span><br></code></pre></td></tr></table></figure><p>两个 <code>pair</code>类型数据可以直接使用<code>=、!=、&lt;、&lt;=、&gt;、&gt;=</code>比较</p><ol type="1"><li>先以 <code>first</code> 的大小来比较</li><li>当 <code>first</code> 相等时，比较 <code>second</code> 的大小</li></ol><p><code>pair</code>能够存储两个值，并且值的类型可以不同。可以用在很多标准容器中，特别是需要存储一对<strong>相关联</strong>的值时，比如说x和y坐标，<code>pair</code>是一种非常好用的模板类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt; s;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; v;<br><br>set.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;) <span class="hljs-comment">// 使用&#123;&#125;表示元素</span><br></code></pre></td></tr></table></figure><blockquote><p>其实<code>map</code>中的每个元素就是一个<code>pair&lt;const Key, T&gt;</code>，其中 <code>Key</code>是键，<code>T</code>是值。<code>map</code>像一个对<code>Key</code>值自动排序的<code>pair</code>数组。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/04/18/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/18/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表">1 单链表</h1><p>链表是一种物理存储单元上<strong>非连续、非顺序的存储结构</strong>，插入和删除速度快，并且不需要像数组一样预先开辟空间链表结构可以充分利用计算机内存空间，实现灵活地内存动态管理。</p><figure><img src="c_linklist_info%201.png"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><p>链表由一系列结点组成，每个结点包括两个部分：</p><ul><li>存储数据元素的数据域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="链表的创建">1.1 链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>    node *next;  /存储下一个结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><ul><li>使用 <code>new</code> 运算符来动态申请空间</li><li>使用 <code>-&gt;</code> 结构体指针运算符来访问内部成员</li><li>头结点数据域通常不做存储（删除结点只能通过它前一个结点指向它后一个结点，头结点没有前一个结点）</li></ul><p><code>*head.data</code> 和 <code>head-&gt;data</code>效果是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>    node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>    p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>    p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>    tail-&gt;next = p;  <span class="hljs-comment">//连到尾结点后面</span><br>    tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表的遍历">1.2 链表的遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *p = head;  <span class="hljs-comment">//使用p作为当前结点，从头开始遍历</span><br><span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//判断下一个结点是否为空</span><br>    cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出下一个结点的数据，因为头结点无数据</span><br>    p = p-&gt;next;  <span class="hljs-comment">//p更新为下一个结点</span><br>&#125; <br></code></pre></td></tr></table></figure><h2 id="链表的删除">1.3 链表的删除</h2><p>删除单链表中p结点的下一个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;next = p-&gt;next-&gt;next;  <span class="hljs-comment">//将p所指的下一个结点修改为下一个结点的下一个结点</span><br></code></pre></td></tr></table></figure><figure><img src="c_link_delete%201.gif"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><h2 id="链表的插入">1.4 链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//先将新结点的指针域指向p的下一个结点</span><br>p-&gt;next = s;  <span class="hljs-comment">//再将p的下一个结点修改为s</span><br></code></pre></td></tr></table></figure><figure><img src="c_link_insert%201.gif"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><h2 id="链表和数组">1.5 链表和数组</h2><p><strong>数组：</strong></p><ul><li><p>优点： 随机访问性强，查找速度快。</p></li><li><p>缺点：插入和删除效率低，，可能浪费内存，，内存空间要求高，数组大小固定，不能动态拓展。</p></li></ul><p><strong>链表：</strong></p><ul><li><p>优点：插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</p></li><li><p>缺点： 不能随机查找，必须从第一个开始遍历，查找效率低。</p></li></ul><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td style="text-align: center;">数组</td><td style="text-align: center;">O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td style="text-align: center;">链表</td><td style="text-align: center;">O(n)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h1 id="双向链表">2 双向链表</h1><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有<strong>两个指针</strong>，分别指向<strong>直接后继</strong>和<strong>直接前驱</strong>，所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的<strong>前驱结点</strong>和<strong>后继结点</strong>。</p><figure><img src="c_double_link%201.png"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><p>双向链表每个节点有三个部分：</p><ul><li>存储数据元素的数据域</li><li>存储上一个节点地址的指针域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="双链表的创建">2.1 双链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>    node *pre, *next;  /存储前驱和后继结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;pre = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//前驱指针初始化为空</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>    node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>    p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>    p-&gt;pre = tail;  <span class="hljs-comment">//前驱指针指向前驱节点tail</span><br>    p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>    tail-&gt;next = p;  <span class="hljs-comment">//尾结点的后继指针指向p</span><br>    tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表的删除">2.2 双链表的删除</h2><p>删除双链表中p结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;pre-&gt;next = p-&gt;next;  <span class="hljs-comment">//将p上一个结点的后继指针指向p的下一个结点</span><br>p-&gt;next-&gt;pre = p-&gt;pre;  <span class="hljs-comment">//将p下一个结点的前驱指针指向p的上一个结点</span><br></code></pre></td></tr></table></figure><figure><img src="c_double_delete%201.gif"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><h2 id="双链表的插入">2.3 双链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//新结点的后继指针域指向p的下一个结点</span><br>s-&gt;pre = p;  <span class="hljs-comment">//新结点的前驱指针指向p</span><br>p-&gt;next-&gt;pre = s;  <span class="hljs-comment">// p的下一个结点的前驱指针指向s</span><br>p-&gt;next = s;  <span class="hljs-comment">//p的后继指针指向s</span><br></code></pre></td></tr></table></figure><figure><img src="c_double_insert%201.gif"alt="Pasted-image-2025040117473344f072a03e24e176.png" /><figcaptionaria-hidden="true">Pasted-image-2025040117473344f072a03e24e176.png</figcaption></figure><h2 id="双向循环链表">2.4 双向循环链表</h2><p>双向循环链表：最后一个结点的后继指针指向头结点，且头结点的前驱指针指向最后一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">head-&gt;pre = tail;<br>tail-&gt;next = head;<br></code></pre></td></tr></table></figure><h2 id="双链表优缺点">2.5 双链表优缺点</h2><ul><li><p><strong>优点：</strong>从双向链表中的任意一个结点开始，都可以很方便地访问前驱结点和后继结点</p></li><li><p><strong>缺点：</strong>增加删除节点复杂，需要多分配一个指针存储空间</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找（唯一值）</title>
    <link href="/2022/04/05/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/"/>
    <url>/2022/04/05/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="思路">思路</h1><p>在 n 个元素有序的（升序）整型数组 nums中查找目标值 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li><strong>数组为有序数组</strong></li><li><strong>数组中无重复元素</strong>一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的</li></ul><p>根据<strong>循环不变量</strong>规则，二分查找的过程中，想清楚区间的定义，区间的定义就是不变量，保持不变量，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分区间的定义一般为两种，左闭右闭[left,right]，或者左闭右开[left, right)。</p><h1 id="左闭右开">左闭右开</h1><ul><li>左闭右开，左初始边界 <code>left = 0</code>，右初始边界<code>right = nums.size()</code></li><li><code>while(left &lt; right)</code>，因为左闭右开，右边取不到，left== right 没有意义</li><li><code>right</code> 更新为 <code>mid</code>，因为当前<code>target&lt;nums[mid]</code>，下一个区间不会再去比较nums[mid]，target 一定在 mid 左边，又因为右开取不到右区间，所以 right更新为 mid</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为<code>target&gt;nums[mid]</code>，target 一定在 mid右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;  <br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size();  <br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;  <br>        <span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  //防止溢出<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="左闭右闭">左闭右闭</h1><ul><li>左闭右闭，左初始边界 <code>left = 0</code>，右初始边界<code>right = nums.size() - 1</code></li><li><code>while(left &lt;= right)</code>，因为左闭右闭，left == right有意义可以取到</li><li><code>right</code> 更新为 <code>mid - 1</code>，因为当前<code>target&lt;nums[mid]</code>，target 一定在 mid左边，又因为右闭可以取到，所以 right 更新为 mid - 1</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为<code>target&gt;nums[mid]</code>，target 一定在 mid右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;<br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>埃氏筛质数判定</title>
    <link href="/2022/03/24/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%8C%87%E6%95%B0%E5%88%A4%E5%AE%9A/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/"/>
    <url>/2022/03/24/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%8C%87%E6%95%B0%E5%88%A4%E5%AE%9A/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>从 2开始，将每个质数的倍数都标记为非质数，最终剩下未被标记的就是质数。举例说明（筛选 2~30 的质数）：</p><ol type="1"><li>初始时，默认 2~30 全部为质数。</li><li>2 是质数，标记 2 的所有倍数（4, 6, 8…）不是质数。</li><li>找到下一个未被标记的数：3，是质数，标记 3 的倍数（6, 9,12…）不是质数。</li><li>接着是 5、7……依此类推，直到 <spanclass="math inline">$\sqrt30$</span> ≈ 5 为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> not_prime[N];  <span class="hljs-comment">// true表示不是质数，false表示质数，默认全是质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// 埃氏筛标记 0~n</span><br>    not_prime[<span class="hljs-number">0</span>] = not_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++)  <br>        <span class="hljs-keyword">if</span>(!not_prime[i])  <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt;= n; j += i)  <br>                not_prime[j] = <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dns">正式课：<span class="hljs-number">51*24=1224</span><br>直播课：<span class="hljs-number">7*180=1260</span><br>正常补课：<span class="hljs-number">4*100+2*24</span>+<span class="hljs-number">2*24=496</span><br>插班补课：<span class="hljs-number">2*100=200</span><br>集训补课：<span class="hljs-number">1</span>*<span class="hljs-number">300=300</span><br>预热课：<span class="hljs-number">6*96=576</span><br>体验课：<span class="hljs-number">5*100=500</span><br>清华附：<span class="hljs-number">1</span>*<span class="hljs-number">400=400</span><br><span class="hljs-number">1224+1260</span>+<span class="hljs-number">496+200</span>+<span class="hljs-number">300+576</span>+<span class="hljs-number">500+400</span>=<span class="hljs-number">4956</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>埃氏筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础算法</title>
    <link href="/2022/03/13/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/13/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟枚举">1 模拟枚举</h1><p>枚举算法是我们在日常中使用到的最多的一个算法，枚举算法的核心思想就是：<strong>枚举所有的可能</strong>。枚举算法简单粗暴，暴力的枚举所有可能速度可能比较慢，但是总能得出正确答案。</p><p>枚举算法的三要素：<strong>枚举对象</strong>、<strong>枚举范围</strong>和<strong>判定条件</strong></p><blockquote><p>比如密码锁，枚举 000～999 的情况 枚举对象：密码 枚举范围：000～999判定条件：否密码是否正确(能否打开锁)</p></blockquote><h1 id="递归算法">2 递归算法</h1><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……</p></blockquote><p>这就是语言上的递归，在程序设计领域，递归是指函数(或方法)<strong>直接</strong>或<strong>间接</strong>调用自身的一种操作，如下图所示。<img src="c_recursion.png"alt="Pasted-image-202503062344352c9c59d453412a7c.png" /></p><p>递归的两大要素</p><ul><li>具有递归边界条件：所描述问题的最简单情况，它本身不再使用递归的定义。</li><li>递归定义：使问题向边界条件转化的规则！</li></ul><p>递归执行的过程中遇到调用函数，程序就先记住当前执行的位置，然后将值拷贝过去，遇到函数就故技重施重复以上操作，直到到达递归边界，再一层一层的回去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在递归函数前面的正序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br>    cout &lt;&lt; n;<br>    <span class="hljs-built_in">funcA</span>(n + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//在递归函数后面的逆序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">funcB</span>(n + <span class="hljs-number">1</span>);<br>    cout &lt;&lt; n;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong>否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p></blockquote><h1 id="递推算法">3 递推算法</h1><p>递推算法是一种用<strong>若干步可重复运算</strong>来描述复杂问题的方法。通常是通过计算前面的一些项来得出序列中的指定项的值。 比如斐波那契数列： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//f[i]记录第i项斐波那契数列是多少</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++） <br>    f[i] = f[i - <span class="hljs-number">2</span>] + f[i - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//a[i]记录i条直线分割平面有几个部分</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 原有的 ＋ 新的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    a[i] = a[i - <span class="hljs-number">1</span>] + i; <br></code></pre></td></tr></table></figure><h1 id="贪心算法">4 贪心算法</h1><p>贪心算法（greedyalgorithm），又称贪婪算法，在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，算法得到的是在某种意义上的<strong>局部最优解</strong>。在解决贪心算法的问题时，需要保证每一步所作的贪心选择，能够最终导致问题的整体最优解。</p><h1 id="前缀和与差分">5 前缀和与差分</h1><h2 id="前缀和">5.1 前缀和</h2><p>前缀和是一个常见的算法技巧，用于<strong>快速计算数组中某个区间内元素的和</strong>它的基本思想是<strong>预处理</strong>出数组的前缀和数组，然后利用前缀和数组来快速计算任意区间的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></td></tr></table></figure><h2 id="差分">5.2 差分</h2><p>差分是一种数学运算方法，一维差分是指数列中<strong>相邻两项之间的差值</strong></p><p>对原数组［l,r］整体增加 c 时，差分数组只需要修改第 l 项和第 r+1 项<img src="c_dif.png"alt="Pasted-image-202503062344352c9c59d453412a7c.png" /></p><p>因为差分数组只是与前面项的差值，所以从第一项累加到第 i项即可得到原数组第 i 项的数值，可以结合前缀和快速计算</p><h1 id="其他">6 其他</h1><h2 id="常用数学函数">6.1 常用数学函数</h2><ul><li><code>max(a, b)</code> 求同类型两者的较大者</li><li><code>min(a, b)</code> 求同类型两者的较小者</li><li><code>pow(a, b)</code> 求a的b次方</li><li><code>sqrt(x)</code> 求x的开方根</li><li><code>abs(x)</code> 求整数x的绝对值</li><li><code>fabs(x)</code> 求浮点数x的绝对值</li><li><code>round(x)</code> 四舍五入取整</li><li><code>floor(x)</code> 向下取整</li><li><code>ceil(x)</code> 向上取整</li></ul><h2 id="for-each-注意事项">6.2 for each 注意事项</h2><p><code>for(auto i : arr)</code>i是每一个元素的副本，可以用来遍历容器，但不能修改元素<code>for(auto &amp; i : arr)</code>i的引用可以直接修改arr中的实际元素</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++文件读取</title>
    <link href="/2022/03/07/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/C++%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2022/03/07/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/C++%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>如果需要从文件读入数据，并把输出数据保存为文件，需要使用文件读取。</p><ul><li><code>freopen</code>为<code>file reopen</code>，意为文件重新打开，实现重定向标准输入输出</li><li>第一个参数为文件名可以修改，输入文件为<code>.in</code>，输出文件为<code>.out</code></li><li>第二个参数，<code>r</code>代表读(read)，<code>w</code>代表写(write)</li><li>第三个参数，<code>stdin</code>标准输入，<code>stdout</code>标准输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br></code></pre></td></tr></table></figure><p><code>main</code>函数开头加上这两行，程序会打开与编译器同目录下的<code>test.in</code>文件，从中读取输入数据，代码部分不需要修改，运行结果会保存到编译器同目录下的<code>test.out</code>文件，没有此命名文件则会自动创建此文件。</p><p>文件使用完成之后需要关闭文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fclose</span>(stdin);  <span class="hljs-comment">// 关闭输入文件</span><br><span class="hljs-built_in">fclose</span>(stdout);  <span class="hljs-comment">// 关闭输出文件</span><br></code></pre></td></tr></table></figure><p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><br>    <span class="hljs-type">int</span> a;<br>    cin &gt;&gt; a;<br>    cout &lt;&lt; a;<br><br>    <span class="hljs-built_in">fclose</span>(stdin); <br>    <span class="hljs-built_in">fclose</span>(stdout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>文件目录关系默认如下： <img src="c_dir.png"alt="Pasted-image-2025043021535005a39c529573ea8f.png" /></p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序总结</title>
    <link href="/2022/03/02/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/02/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序">1 冒泡排序</h1><p>从左往右相邻的数两两比较，如果左边大于右边则交换，每一轮冒泡会选出一个未排序数字中的最大值放到最后，每一轮确定一个数字的最终位置，排序完n个数字需要n-1轮。</p><ul><li><p>外层循环通过 <code>i</code> 控制遍历次数，最大到<code>n-1</code>。每轮比较中最大的元素都会被“冒泡”到数组的末尾，因此内层循环的范围是<code>n - i - 1</code>。</p></li><li><p><code>swapped</code>用于记录当前轮次是否有元素交换。如果某轮中没有发生交换，意味着数组已经有序，可以提前退出循环，避免不必要的比较。</p></li><li><p>冒泡排序在最差情况下的时间复杂度是O(n²)，但在最佳情况下（数组已经有序时），通过 <code>swapped</code>变量，时间复杂度可以优化为 O(n)。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 每次循环开始时重置标志位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;  <span class="hljs-comment">//排好的放在后面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 比较相邻元素</span><br>                <span class="hljs-built_in">swap</span>(a[j], a[j + <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 交换元素</span><br>                swapped = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 记录交换发生</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果没有发生交换，数组已经有序，提前退出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序">2 选择排序</h1><p>从左往右扫描，每一轮选出一个当前未排序数字中的最小值，放到前面，每一轮确定一个数字的最终位置，排完n个数字需要n-1轮。</p><ul><li><p><strong>外层循环</strong>通过 <code>i</code> 控制遍历次数，最大到<code>n-1</code>，每次遍历选择数组中未排序部分的第一个元素。</p></li><li><p><strong>内层循环</strong>通过 <code>j</code> 遍历未排序的部分，从<code>i + 1</code> 开始到<code>n</code>。内层循环的目的是找到当前未排序部分的最小元素，并记录其索引<code>minIndex</code>。</p></li><li><p>在每轮结束时，将当前元素 <code>a[i]</code> 与找到的最小元素<code>a[minIndex]</code> 进行交换。</p></li><li><p>即使数组已经有序，选择排序也仍然需要 O(n²)的比较次数，因为每次都需要遍历未排序部分。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">int</span> minIndex = i;  <span class="hljs-comment">// 假设当前元素为最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)  <span class="hljs-comment">// 排好的放在前面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[minIndex]) minIndex = j;  <span class="hljs-comment">// 找到更小的元素，更新最小值索引</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[minIndex]);  <span class="hljs-comment">// 交换最小值到当前排序位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序">3 插入排序</h1><p><strong>外层循环</strong>(<code>for (int i = 1; i &lt; n; i++)</code>)：从第二个元素开始遍历，作为当前要插入的元素<code>x</code>。</p><p><strong><code>x</code>变量</strong>：存储当前要插入的元素，以便在内层循环中进行比较和插入操作。</p><p><strong>已排序部分的下标 <code>j</code></strong>：<code>j</code>初始化为 <code>i - 1</code>，表示已排序部分的最后一个元素。</p><p><strong>内层循环</strong>(<code>while (j &gt;= 0 &amp;&amp; x &lt; a[j])</code>)：</p><ul><li>在已排序部分中查找 <code>x</code> 的插入位置。</li><li><strong>越界检查</strong>：首先判断 <code>j &gt;= 0</code>，确保访问<code>a[j]</code> 不会越界。</li><li>如果 <code>a[j]</code> 大于 <code>x</code>，则将 <code>a[j]</code>向右移动，腾出 <code>j + 1</code> 的位置来插入 <code>x</code>。</li></ul><p><strong>插入操作</strong>(<code>a[j + 1] = x</code>)：当找到合适位置后，将 <code>x</code> 插入到<code>j + 1</code> 的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 从第二个元素遍历要插入的元素</span><br>        <span class="hljs-type">int</span> x = a[i];  <span class="hljs-comment">// 当前要插入的元素</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 已排序的最后一个元素下标</span><br>        <span class="hljs-comment">// 在已排序部分中找到 x 的插入位置</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[j]) &#123;  <span class="hljs-comment">// 先判断j&gt;=0，防止越界错误</span><br>            a[j + <span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 元素向右移动，为x空出位置</span><br>            j--;  <span class="hljs-comment">// 移动到前一个元素</span><br>        &#125;<br>        a[j + <span class="hljs-number">1</span>] = x;  <span class="hljs-comment">// 将 x 插入到找到的位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="桶排序">4 桶排序</h1><p><strong><code>cnt[N] = &#123;0&#125;</code></strong>：定义一个大小为<code>N</code> 的数组<code>cnt</code>，用于统计每个元素的出现次数，初始化为 0。</p><p><strong>输入读取和计数</strong>：使用 <code>for</code> 循环读取<code>n</code> 个整数输入，检查 <code>x</code> 是否在合法范围内<code>[0, N)</code>，并通过 <code>cnt[x]++</code> 对每个 <code>x</code>的出现次数进行统计。</p><p><strong>输出</strong>：第二个 <code>for</code> 循环遍历<code>cnt</code> 数组，通过嵌套循环输出每个数 <code>i</code>的值，输出的次数取决于 <code>cnt[i]</code> 的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> cnt[N] = &#123;<span class="hljs-number">0</span>&#125;, n;<br>cin &gt;&gt; n;  <span class="hljs-comment">// 读取元素个数</span><br><span class="hljs-comment">// 读取每个元素并进行计数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; N) cnt[x]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt[i]; ++j)<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 按照计数输出数字 i</span><br></code></pre></td></tr></table></figure><h1 id="快速排序">5 快速排序</h1><ol type="1"><li>选取一个数作为<strong>基准数</strong></li><li>小于基准数的值放左半区，大于基准数的值放右半区</li><li>再对左右区间重复1、2步，直到各区间只剩一个数</li></ol><p>通过<strong>分治法</strong>，每次递归时选取一个基准值，然后通过双指针将数组划分成两部分，使得左边部分的值小于等于基准值，右边部分的值大于等于基准值。然后递归地对两部分进行排序，直到数组被完全排序。</p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p>递归终止的条件是 <code>l &gt;= r</code>，也就是说当前区间长度为 0 或1 时，不需要继续排序。</p><p><strong>基准值</strong>：<code>x = a[(l + r) &gt;&gt; 1]</code> 通过<code>(l + r) &gt;&gt; 1</code> 计算出中间元素的下标，并将它作为基准值<code>x</code>。</p><p><strong>双指针初始化</strong>：</p><ul><li><code>i = l - 1</code>，指向比基准值小的区域。</li><li><code>j = r + 1</code>，指向比基准值大的区域。</li></ul><p><strong>主循环条件</strong>：<code>while (i &lt; j)</code>，保证左右指针在数组内并且没有交错。</p><p><strong>内循环（左指针<code>i</code>）</strong>：<code>do i++; while (a[i] &lt; x);</code>从左向右找到第一个大于等于基准值的元素。</p><p><strong>内循环（右指针<code>j</code>）</strong>：<code>do j--; while (a[j] &gt; x);</code>从右向左找到第一个小于等于基准值的元素。</p><blockquote><p>此处必须使用严格的<code>&gt;</code><code>&lt;</code>，如果使用<code>&gt;=</code><code>&lt;=</code>选取的基准值是最大值，指针<code>i</code>不会停止，会一直<code>++</code>直到越界</p></blockquote><p><strong>元素交换</strong>：当 <code>i &lt; j</code> 时，交换<code>a[i]</code> 和<code>a[j]</code>，确保基准值左边的元素都小于等于它，右边的元素都大于等于它。</p><p><strong>左半部分递归</strong>：对 <code>l</code> 到 <code>j</code>的部分继续执行快速排序。此时 <code>j</code>是划分完成后，左半部分的最大值位置。</p><p><strong>右半部分递归</strong>：对 <code>j + 1</code> 到<code>r</code> 的部分继续执行快速排序。</p><p><strong>注意：</strong> 因为<code>do-while</code>的存在，退出<code>while</code> 时，j 最终会停在 <strong>（1+r）/2</strong>的位置，也就是 <strong>i = j 或 i = j + 1</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归结束条件：当区间元素只有1个元素或者没有元素时</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br>    <br>    <span class="hljs-comment">// 初始化双指针i和j，</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">//后面会先++或--，所以指向边界的前一个或后一个元素</span><br>    <span class="hljs-type">int</span> pivot = a[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 选择中间位置的值作为基准值</span><br>    <br>    <span class="hljs-comment">// 双指针划分过程</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-comment">// 左指针向右移动，指针左侧都是小于基准值的，找到第一个大于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot);<br>        <span class="hljs-comment">// 右指针向左移动，指针右侧都是大于基准值的，找到第一个小于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot);<br>        <span class="hljs-comment">// 如果i和j两个指针还没有相遇，交换a[i]和a[j]</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不重不漏</span><br>    <span class="hljs-built_in">quick_sort</span>(a, l, j);  <span class="hljs-comment">// 递归调用，对左半部分（l到j）进行快速排序</span><br>    <span class="hljs-built_in">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 递归调用，对右半部分（j+1到r）进行快速排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果每次选的<code>pivot</code>能让左右两段近似等分，会生成一颗有 logn层的均衡的二叉树，每层 i, j两指针将会遍历所有 n 个元素，时间复杂度为O(nlogn)。 如果每次选的<code>pivot</code>只能分离出一个元素，会退化成有n 层的链，i, j两指针走的总步数= n+(n－1)+…+1，时间复杂度退化为 O(n²)。<img src="c_quick_sort.png"alt="Pasted-image-20250310154403c0d33279d726e024.png" /></p><p>在快速排序和快速选择算法中，<strong>分区方法</strong> 是最核心的步骤。它们的核心目标都是将数组划分为两个部分，但实现方式和性能特点不同。</p><h2 id="hoare-分区法">5.1 Hoare 分区法</h2><p>由快速排序的发明者 Tony Hoare 提出，是最原始的分区方案。</p><ul><li><strong>双向指针扫描</strong><ul><li>左指针 <code>i</code> 从数组左端向右移动</li><li>右指针 <code>j</code> 从数组右端向左移动</li><li>直到找到需要交换的元素对</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组被划分为：<code>[ &lt;= pivot ]</code> + <code>[ &gt;= pivot ]</code></li><li>注意：<strong>不保证枢轴值在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hoare_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = a[l + (r - l) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 选择中间元素作为枢轴</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 因为可能把两个和 pivot 相等的值交换，所以不稳定</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot); <span class="hljs-comment">// 找左边第一个 &gt;= pivot 的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot); <span class="hljs-comment">// 找右边第一个 &lt;= pivot 的元素</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">return</span> j;         <span class="hljs-comment">// 返回分界点</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设数组为 <code>[3, 1, 4, 2, 5]</code>，选择中间元素 <code>4</code> 为枢轴：</p><ol type="1"><li><code>i</code> 找到 <code>4</code>（位置2），<code>j</code> 找到 <code>2</code>（位置3）→ 交换 → <code>[3,1,2,4,5]</code></li><li><code>i</code> 移动到 <code>4</code>（位置3），<code>j</code> 移动到 <code>2</code>（位置2）→ <code>i &gt;= j</code> → 返回 <code>j=2</code></li></ol><h2 id="填坑法">5.2 填坑法</h2><p> 填坑法，左右指针交替覆盖，是快速排序中一种常见的分区实现方式，可以看作是 Lomuto分区法的变体。</p><ul><li><strong>枢轴选择</strong>：固定选择左端点 <code>a[l]</code> 作为枢轴值 <code>pivot</code>。</li><li><strong>填坑操作</strong>：<ul><li><strong>右指针扫描</strong>：从右向左找到第一个 <code>&lt; pivot</code> 的元素，将其值覆盖到左指针位置（填左坑）。</li><li><strong>左指针扫描</strong>：从左向右找到第一个 <code>&gt; pivot</code> 的元素，将其值覆盖到右指针位置（填右坑）。</li><li>循环直到左右指针相遇，最后将枢轴值 <code>pivot</code> 放入相遇点。</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组结构：<code>[ &lt;= pivot ]</code> + <code>pivot</code> + <code>[ &gt;= pivot ]</code></li><li><strong>枢轴值一定在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <br>    <span class="hljs-type">int</span> pivot = a[l]; <span class="hljs-comment">//枢轴 </span><br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123; <br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= pivot) r--; <br>        a[l] = a[r]; <br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= pivot) l++; <br>        a[r] = a[l]; <br>    &#125; <br>    a[l] = pivot; <br>    <span class="hljs-keyword">return</span> l; <span class="hljs-comment">//返回枢轴位置 </span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序">6 归并排序</h1><p>归并排序主要使用了分治思想，字面上的解释是“<strong>分而治之</strong>”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>“分”而“治”之，先“分”后“治”</p><ul><li>“分”：将问题划分成若干子问题然后递归求解</li><li>“治”：将子问题的答案整合在一起</li></ul><figure><img src="c_merge_sort.png"alt="Pasted-image-202503071129090c2390f01aa20eb3.png" /><figcaptionaria-hidden="true">Pasted-image-202503071129090c2390f01aa20eb3.png</figcaption></figure><p>归并排序将待排序序列划分成若干个子序列，将子序列合并为一个有序序列。具体来说通过递归将数组分成两半，分别排序，递归到最后，实际是把单个元素看作一个有序序列，开始<strong>两两归并</strong>，形成一个两个元素的有序序列，再两两归并，形成一个四个元素的有序序列，不断合并两个有序的子数组来达到排序的效果。<img src="c_merge_sort_tree.png"alt="Pasted-image-202503310022534718d6a70a594701.png" /></p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p><strong>终止条件</strong>：如果<code>l &gt;= r</code>（即数组只剩一个或没有元素时），直接返回。</p><ul><li><code>mid = (l + r) &gt;&gt; 1</code>：通过取中间位置<code>mid</code> 将当前区间 <code>[l, r]</code> 分为两个子区间<code>[l, mid]</code> 和 <code>[mid + 1, r]</code>。</li><li>递归调用 <code>merge_sort(a, l, mid)</code>对左半部分排序，<code>merge_sort(a, mid + 1, r)</code>对右半部分排序。</li></ul><p><strong>合并两个有序部分</strong>：</p><ul><li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向左半部分<code>[l, mid]</code> 和右半部分 <code>[mid + 1, r]</code>的起始位置。通过比较 <code>a[i]</code> 和 <code>a[j]</code>的值，将较小的值放入临时数组<code>tmp[]</code>（因为是<code>&lt;=</code>，相等的时候把左边元素放入临时数组，所以稳定）。</li><li>如果左半部分未遍历完，将剩余部分加入 <code>tmp[]</code>。</li><li>如果右半部分未遍历完，也将其加入 <code>tmp[]</code>。</li><li>最后，将临时数组 <code>tmp[]</code> 中的元素复制回原数组<code>a[]</code>，完成本次合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归终止条件：如果子序列中只有1个元素或0个元素，返回</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算中间索引，将数组一分为二</span><br>    <span class="hljs-comment">// l + (r - l) / 2  防止溢出</span><br>    <br>    <span class="hljs-built_in">merge_sort</span>(a, l, mid); <span class="hljs-comment">// 递归排序左半部分</span><br>    <span class="hljs-built_in">merge_sort</span>(a, mid + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// 递归排序右半部分</span><br><br>    <span class="hljs-comment">// 合并两个已排序的部分</span><br>    <span class="hljs-type">int</span> k = l; <span class="hljs-comment">// 临时数组的索引</span><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左半部分和右半部分的指针</span><br>     <br>    <span class="hljs-comment">// 合并过程：将较小的元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-comment">// 如果左半部分当前元素小于等于右半部分，加入临时数组</span><br>        <span class="hljs-comment">// 正是因为这里是 &lt;= ，如果元素相等先取前面的，所以稳定</span><br>        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) tmp[k++] = a[i++]; <br>        <span class="hljs-comment">// 否则，加入右半部分的当前元素</span><br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++]; <br>    &#125;<br>    <br>    <span class="hljs-comment">// 将左半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++]; <br>    <span class="hljs-comment">// 将右半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = a[j++]; <br><br>    <span class="hljs-comment">// 将临时数组的内容复制回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= r; i++) a[i] = tmp[i]; <br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">快速排序</th><th style="text-align: center;">归并排序</th></tr></thead><tbody><tr><td style="text-align: center;">分治</td><td style="text-align: center;">先交换，后拆分</td><td style="text-align: center;">先拆分，后合并</td></tr><tr><td style="text-align: center;">稳定性</td><td style="text-align: center;">不稳定</td><td style="text-align: center;">稳定</td></tr></tbody></table><h1 id="sort排序">7 sort()排序</h1><h2 id="概述">7.1 概述</h2><p><code>sort()</code>函数是一个比较<strong>灵活</strong>的函数。很多解释是：<code>sort()</code>函数是类似于快速排序的方法，时间复杂度为n*log2(n)，执行效率较高。</p><blockquote><p>STL中的<code>sort()</code>并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p></blockquote><h2 id="sort的使用方法">7.2 sort()的使用方法</h2><p>在C++中使用<code>sort()</code>函数需要使用<code>#include &lt;algorithm&gt;</code>头文件，algorithm意为”算法”，是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(begin, end, cmp);<br></code></pre></td></tr></table></figure><p><code>sort()</code>函数可以对给定区间的元素进行排序，它有三个参数：</p><ul><li>其中<code>begin</code>为待排序数组的起始地址</li><li><code>end</code>为指向待排序数组结束地址下一个位置的指针</li><li><code>cmp</code>参数为排序准则，如果不写，<strong>默认从小到大</strong>进行排序。如果我们想从大到小排序可以将<code>cmp</code>参数写为<code>greater&lt;int&gt;()</code>，<code>&lt;&gt;</code>中表示排序数组的类型，C++11中可以透明比较器<code>greater&lt;&gt;()</code>。如果需要按照其他的排序准则，那么需要我们自己定义一个<code>bool</code>类型的函数来传入。</li></ul><p>使用<code>sort()</code>不仅仅可以从大到小或者从小到大排，还可以按照一定的准则进行排序，编写<code>cmp</code>函数传入<code>sort()</code>函数。比如按照个位从小到大比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a % <span class="hljs-number">10</span> &gt; b % <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对<strong>结构体</strong>进行排序，比如定义一个结构体包含学生的姓名和年龄，按照年龄从小到大排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a, Student b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上的代码示例中使用了<strong>值传递</strong>，每次调用函数都会创建<code>Student</code>对象的副本，增加额外的开销，降低排序的效率，使用<strong>引用传递</strong>可以避免拷贝开销，更加高效。值传递会创建参数的副本，对于大型对象或复杂数据结构，可能涉及大量的内存分配和数据复制，引用传递避免了这些操作，因为它直接操作原始对象。</p><table><thead><tr><th>特性</th><th>值传递</th><th>引用传递</th></tr></thead><tbody><tr><td>数据传递方式</td><td>副本传递，函数操作的是实参的副本</td><td>引用传递，函数操作的是实参的原数据</td></tr><tr><td>内存开销</td><td>需要创建副本，开销较大，尤其对于大型对象</td><td>无需创建副本，内存开销小</td></tr><tr><td>是否修改实参</td><td>函数内部的修改不会影响实参</td><td>函数内部的修改会直接影响实参</td></tr><tr><td>安全性</td><td>相对更安全，因为函数无法修改外部数据</td><td>可能产生副作用，修改不应修改的数据</td></tr><tr><td>适用场景</td><td>当不希望修改外部数据，或数据结构比较简单时使用</td><td>当需要修改实参，或数据结构较大时使用</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a,<span class="hljs-type">const</span> Student&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用参数</strong>：<code>const Student&amp; a</code> 和<code>const Student&amp; b</code> 表示对 <code>Student</code>类型的常量引用，这样函数内部无法修改 <code>Student</code>的内容，同时避免了复制带来的性能损失。</p><p><strong>const 关键字</strong>：使用 <code>const</code>关键字表明函数不会修改传入的对象，这也是一个良好的编码习惯。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准输入输出</title>
    <link href="/2022/02/12/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/02/12/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><code>cin &gt;&gt;</code> <code>cout &lt;&lt;</code></p><p><code>scanf()</code> <code>printf()</code></p><p><code>getchar(c)</code> 字符输入 <code>putchar(c)</code> 字符输出</p><p><code>gets(str)</code>读取一整行，回车或EOF停止，不会判断上限，不安全</p><p><code>fgets(str, 100, stdin)</code>读取一整行，读取最多100个字符存到str中</p><p><code>cin.getline(str, 100)</code> <code>getline(cin, str)</code>读取一整行，读取最多100个字符存到str中</p><p><strong>注意</strong>：当同时使用<code>cin&gt;&gt;</code>,<code>getline()</code>时，在<code>cin&gt;&gt;</code>之后，<code>getline()</code>之前，需要将回车符作为输入流cin以清除缓存，在<code>cin</code>和<code>getline()</code>中间插入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; <br>...<br>str=<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">getline</span>(cin,str);<br>...<br><span class="hljs-built_in">getline</span>()<br></code></pre></td></tr></table></figure><p>如果不这样做的话，在控制台上就不会出现<code>getline()</code>的输入提示，而是直接跳过，因为程序默认将之前的变量作为输入流。</p><table><thead><tr><th style="text-align: center;">数据类型</th><th style="text-align: center;">占位符</th></tr></thead><tbody><tr><td style="text-align: center;">int</td><td style="text-align: center;">%d</td></tr><tr><td style="text-align: center;">long long</td><td style="text-align: center;">%lld</td></tr><tr><td style="text-align: center;">float</td><td style="text-align: center;">%f</td></tr><tr><td style="text-align: center;">double</td><td style="text-align: center;">scanf 用 %lf，printf 用 %f</td></tr><tr><td style="text-align: center;">char</td><td style="text-align: center;">%c</td></tr></tbody></table><ul><li><p>无论单双精度，<code>printf</code>都会将浮点数提升为双精度，所以在输出时不区分单双精度</p></li><li><p><code>printf()</code> 特殊输出格式</p><ul><li><p><code>%md</code> 右对齐m位输出，高位用空格补齐</p></li><li><p><code>%0md</code> 右对齐m位输出，高位用0补齐</p></li><li><p><code>%.mf</code> 浮点数保留m位小数</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>stdio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符数组与字符串</title>
    <link href="/2022/02/03/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/02/03/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符数组">1 字符数组</h1><ul><li><code>strlen(charr)</code> 返回字符串的长度，不包含结束符\0</li><li><code>strcpy(charr1, charr2)</code>复制字符串，字符串charr2复制给charr1，返回charr1</li><li><code>strncpy(charr1, charr2)</code>将charr2前n个字符复制给charr1</li><li><code>strcat(charr1, charr2)</code>拼接字符串，字符串charr2拼接在charr1后面，返回charr1</li><li><code>strncat(charr1, charr2)</code>将字符串charr2前n个字符拼接到charr1<ul><li><strong>注</strong>：如果添加或者复制后的charr1数组越界则会报错</li></ul></li><li><code>strcmp(charr1,charr2)</code> 比较字符串，如果charr1&gt;charr2返回正整数，charr1=charr2 返回0，charr1&lt;charr2 返回负整数</li><li><code>strncmp(charr1,charr2)</code>比较charr1和charr2的前n个字符</li></ul><p>字符数组转 <code>int</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">atoi</span>(a);<br></code></pre></td></tr></table></figure></p><p>字符数组转 `string</p><ul><li><p>直接赋值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s = a;<br></code></pre></td></tr></table></figure></p></li><li><p>构造函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;  <br><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(a)</span></span>;  <span class="hljs-comment">// 全部转换</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(a, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 指定长度转换</span><br></code></pre></td></tr></table></figure></p></li></ul><h1 id="string类">2 string类</h1><h2 id="基础概念">2.1 基础概念</h2><p>在 <code>#inlcude &lt;string&gt;</code> 中使用</p><blockquote><p><code>string</code>不是<strong>基本数据类型</strong>，是C++中对<strong>char</strong>封装成的<strong>类</strong>。主要用于<strong>字符串</strong>处理，可以使用<strong>输入输出流</strong>方式直接进行<code>string</code>操作，也可以通过<strong>文件</strong>等手段进行<code>string</code>操作。</p></blockquote><p><img src="c_string.png" /></p><h2 id="声明">2.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <span class="hljs-comment">//空字符串</span><br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>; <span class="hljs-comment">//5个a</span><br>string s2 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//s2为123456</span><br></code></pre></td></tr></table></figure><h2 id="输入输出">2.3 输入输出</h2><ul><li><p><code>cin &gt;&gt; s;</code>读到空格、回车、文件结束符停止</p></li><li><p><code>getline(cin, s);</code> 读入一整行</p></li><li><p><code>cout &lt;&lt; s;</code> 输出整个字符串</p></li><li><p><code>cout &lt;&lt; s[2];</code> 按下标输出</p></li></ul><h2 id="遍历">2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="常用函数">2.5 常用函数</h2><ul><li><code>str.length()</code>/<code>str.size()</code>返回字符串真实长度，不包含结束符\0</li><li><code>sizeof(type)</code>数据类型用括号 <code>sizeof var_name</code>变量名可以不用括号</li><li><code>str.empty()</code>字符串判空，空串返回<code>true</code>，非空返回<code>false</code></li><li><code>str1.insert(pos, str2)</code> 在str1下标pos处插入str2</li><li><code>str.substr(pos,len)</code>返回一个从下标pos开始截取长度为len的字符串</li><li><code>str.erase(pos, len)</code> 删除从下标pos开始的len个字符</li><li><code>str1.replace(pos, len, str2)</code>将str1中下标为pos开始的len个元素替换为str2</li><li><code>str.find(s, pos)</code>从str中下标为pos的位置开始查找，返回s第一次出现的下标，查找不到返回<code>string::npos</code></li><li><code>str.clear()</code> 清空str中的内容</li><li>string的拼接复制比较可以直接使用<code>+</code> <code>=</code><code>&gt; &lt; &gt;= &lt;= != ==</code></li></ul><h4 id="size-获取大小"><code>size()</code><strong>获取大小</strong></h4><p>语法: &gt; <strong>s.size()</strong> &gt;返回<strong>元素数目</strong></p><hr /><h4 id="length-获取长度"><code>length()</code><strong>获取长度</strong></h4><p>语法: &gt; <strong>s.length()</strong> &gt;返回<strong>字符串长度</strong>,与<strong>size()</strong>返回的数字相同</p><hr /><h4 id="empty-判空"><code>empty()</code> <strong>判空</strong></h4><p>语法: &gt; <strong>s.empty()</strong> &gt; 若为空,返回<strong>true</strong>, 非空返回<strong>false</strong></p><hr /><h4 id="clear-清空"><code>clear()</code> <strong>清空</strong></h4><p>语法: &gt; <strong>s.clear</strong>() &gt;<strong>清空所有元素</strong></p><hr /><h4 id="push_back-尾部插入"><code>push_back()</code><strong>尾部插入</strong></h4><p>语法: &gt; <strong>s.push_back(c)</strong> &gt;<strong>尾部插入一个字符</strong>，可用+=代替</p><hr /><h4 id="pop_back-尾部删除"><code>pop_back()</code><strong>尾部删除</strong></h4><p>语法: &gt; <strong>s.pop_back()</strong> &gt;<strong>尾部删除一个元素</strong></p><hr /><h4 id="back-访问尾部"><code>back()</code><strong>访问尾部</strong></h4><p>语法: &gt; <strong>s.back()</strong> &gt;<strong>访问尾部元素</strong></p><hr /><h4 id="front-访问头部"><code>front()</code><strong>访问头部</strong></h4><p>语法: &gt; <strong>s.front()</strong> &gt;<strong>访问头部第一个元素</strong>，可用s[0]代替</p><hr /><h4 id="insert-插入"><code>insert()</code> <strong>插入</strong></h4><p>语法: &gt; <strong>s1.insert(pos, s2)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bd&quot;</span>); <span class="hljs-comment">//在下标2处插入bd</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span> (<span class="hljs-number">4</span>, s2); <span class="hljs-comment">//在下标4处插入s2</span><br></code></pre></td></tr></table></figure><hr /><h4 id="erase-删除"><code>erase()</code> <strong>删除</strong></h4><p>语法: &gt; <strong>s.erase(pos, num)</strong> &gt;<strong>s.erase(pos)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//从下标2开始删除4个字符</span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//从下标3开始删除后面所有字符</span><br></code></pre></td></tr></table></figure><hr /><h4 id="substr-截取"><code>substr()</code> <strong>截取</strong></h4><p>语法: &gt; <strong>s.substr(pos, num)</strong> &gt;<strong>s.substr(pos)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标1开始截取3个字符</span><br>s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始截取整个s2</span><br></code></pre></td></tr></table></figure><hr /><h4 id="find-查找"><code>find()</code> <strong>查找</strong></h4><p>语法: &gt; <strong>s1.find(s2, pos)</strong> &gt;<strong>s1.find(s2)</strong> &gt; 查到返回<strong>下标</strong>,查不到返回 <strong>string::npos</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向后查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向后查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr /><h4 id="rfind-逆序查找"><code>rfind</code><strong>逆序查找</strong></h4><p>语法: &gt; <strong>s1.rfind(s2, pos)</strong> &gt;<strong>s1.rfind(s2)</strong> &gt; 查到返回<strong>下标</strong>,查不到返回 <strong>string::npos</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//逆序查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向前查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向前查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr /><h4 id="reverse-逆置"><code>reverse()</code> <strong>逆置</strong></h4><p>语法: &gt; <strong>reverse(s.begin, s.end)</strong>//包含在&lt;algorithm&gt;中 &gt; <strong>字符串逆置</strong></p><hr /><h4 id="to_string-int-转-string"><code>to_string()</code> <strong>int 转string</strong></h4><p>语法 &gt; <strong>to_string(int)</strong> &gt;返回一个<strong>string</strong></p><hr /><h4 id="stoi-string-转-int"><code>stoi()</code> <strong>string 转int</strong></h4><p>语法: &gt; <strong>stoi(string)</strong> &gt;返回一个<strong>int</strong></p><hr /><h4 id="copy-复制"><code>copy()</code> <strong>复制</strong></h4><p>语法: &gt; <strong>s.copy(a, num, pos)</strong> &gt;<strong>s.copy(a, num)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];<br>s.<span class="hljs-built_in">copy</span>(a, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始复制5个字符到字符数组a</span><br>s.<span class="hljs-built_in">copy</span>(a,<span class="hljs-number">6</span>); <span class="hljs-comment">//从下标0开始复制6个字符到字符数组a</span><br></code></pre></td></tr></table></figure><h1 id="字符数组和string类的区别">3 字符数组和string类的区别</h1><ul><li><code>string</code>是一个类，<code>string s="abcd";</code>中的s是一个对象</li><li>初始化方式不同<ul><li>字符数组后面有 [] ，string类型后面没有[]</li><li>初始化的关键字一个是<code>char</code> 一个是<code>string</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> charr2[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>string str1;<br>string str2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>都可以使用<code>cin cout</code>的方式进行输入输出，<code>getline</code>使用有区别</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>]; <br>cin.<span class="hljs-built_in">getline</span>(charr1,<span class="hljs-number">20</span>);<br>string str;<br><span class="hljs-built_in">getline</span>(cin,str);<br></code></pre></td></tr></table></figure><ul><li>都可以使用下标来访问元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2022/01/19/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E9%80%9A%E7%94%A8%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/"/>
    <url>/2022/01/19/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E9%80%9A%E7%94%A8%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="整数二分">1 整数二分</h1><ol type="1"><li>指针的跳跃次数 <code>logn</code></li><li><code>l + 1 = r</code> 时结束，也就是 <code>l</code> 和<code>r</code> 紧挨的时候</li><li>可行区的指针最后一定指向答案</li><li>开区间可以正确处理边界（<code>l</code>和<code>r</code>初始化在数组的两侧）</li></ol><p><strong>注意：</strong>访问<code>a[l]</code>或<code>a[r]</code>的时候注意边界问题</p><p>例如目标值在左侧，需要判断<code>a[l] == x</code>，<code>l</code>有可能一直是-1，此时访问<code>a[l]</code>会出现下标越界</p><h2 id="最大化查找">1.1 最大化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &lt;= q) l = mid;  <span class="hljs-comment">// l 一直在可行区内</span><br>        <span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// r 一直在不可行区内</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="c_binary1.png"alt="Pasted-image-202503311343047ead4742bd8a0a4a.png" /><figcaptionaria-hidden="true">Pasted-image-202503311343047ead4742bd8a0a4a.png</figcaption></figure><h2 id="最小化查找">1.2 最小化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid] &gt;= x) r = mid;  <span class="hljs-comment">// r 一直在可行区内</span><br>        <span class="hljs-keyword">else</span> l = mid;  <span class="hljs-comment">// l 一直在不可行区内</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="c_binary2.png"alt="Pasted-image-202503311343047ead4742bd8a0a4a.png" /><figcaptionaria-hidden="true">Pasted-image-202503311343047ead4742bd8a0a4a.png</figcaption></figure><h2 id="二分函数">1.3 二分函数</h2><h3 id="lower_boundbegin-end-x-第一个-x">1.3.1 lower_bound(begin, end,x) 第一个 &gt;=x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于等于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置（由于r一直在右边界未发生移动）</li></ul><figure><img src="c_binary_fun1.png"alt="Pasted-image-202503311343047ead4742bd8a0a4a.png" /><figcaptionaria-hidden="true">Pasted-image-202503311343047ead4742bd8a0a4a.png</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回值为地址，减去起始地址a为下标值</span><br><span class="hljs-type">int</span> index = <span class="hljs-built_in">lower_bound</span>(a, a + n, x) - a;<br></code></pre></td></tr></table></figure><h3 id="upper_boundbegin-end-x-第一个-x">1.3.2 upper_bound(begin, end,x) 第一个 &gt;x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置</li></ul><figure><img src="c_binary_fun2.png"alt="Pasted-image-202503311343047ead4742bd8a0a4a.png" /><figcaptionaria-hidden="true">Pasted-image-202503311343047ead4742bd8a0a4a.png</figcaption></figure><blockquote><p>用<code>upper_bound</code>返回值 - a - 1就是最后一个小于等于x的下标</p></blockquote><h1 id="浮点数二分">2 浮点数二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;  <span class="hljs-comment">// eps表示精度，比题目要求小数位多两位即可</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分答案">3 二分答案</h1><p>二分答案与二分查找类似，要求满足条件的<strong>答案是单调有序的</strong>。原理：在答案可能的范围<code>(L, R)</code>内二分查找答案，不断检查当前答案是否满足题目的要求，根据检查结果更新查找的区间，最终取得最符合题目要求的答案。</p><p>同样可以使用以下板子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> ans)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据题意，符合条件返回true，否则false</span><br>&#125;<br><br><span class="hljs-comment">// 假设这里分析得出答案最小值为min，最大值为max</span><br><br><span class="hljs-type">int</span> l = min - <span class="hljs-number">1</span>, r = max + <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 根据题目答案范围设置 l 和 r，注意初始值要在边界两侧，开区间</span><br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 下面 l 和 r 的顺序根据题目进行调整</span><br>    <span class="hljs-keyword">if</span>(check[mid]) l = mid;  <span class="hljs-comment">// 满足题意</span><br>    <span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// 不满足题意</span><br>&#125;<br><span class="hljs-keyword">return</span> l;  <span class="hljs-comment">// 根据题意进行调整</span><br></code></pre></td></tr></table></figure></p><blockquote><p>关于开区间，由于最终<code>l</code>和<code>r</code>一定会停在相邻的位置，左边是<code>l</code>，右边是<code>r</code>。最终返回的答案，不论使用的是<code>l</code>还是<code>r</code>，只要作为答案的指针能够在整个答案的闭区间内移动即可。比如：最终答案返回<code>r</code>，<code>r</code>的初始值可以是<code>max</code>，而不用取外侧的<code>max + 1</code>，因为最终<code>r</code>可以取到<code>max</code>；但<code>l</code>必须取到<code>min - 1</code>，因为最终答案有可能是<code>min</code>，而<code>l</code>如果占到<code>min</code>，则会出现<code>r</code>取不到最终答案的情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2022/01/15/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/01/15/coding/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型">1 数据类型</h1><p>字节：数据类型占用的空间大小<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a; <span class="hljs-comment">// 整数类型 4字节  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l; <span class="hljs-comment">// 长整数类型 8字节  </span><br><span class="hljs-type">char</span> c; <span class="hljs-comment">// 字符类型 1字节  </span><br><span class="hljs-type">double</span> d; <span class="hljs-comment">// 浮点数类型 8字节  </span><br></code></pre></td></tr></table></figure></p><h1 id="基本运算">2 基本运算</h1><p><code>+ - * /</code><br />对于 <code>/</code> 除： 整数/整数 = 整数 10 / 3 = 3如果其中有浮点数，则结果有小数，如 10 / 3.0 = 3.3333 <code>%</code>取余，如 10 % 3 = 1 15 % 4 =3<br /><strong>类型自动转换</strong>：在运算过程中，如果数据类型不一致，自动将低精度转化为高精度<br /><code>char &lt; int &lt; long long &lt; double</code></p><h1 id="输入输出">3 输入输出</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; a;  <span class="hljs-comment">// 输入  </span><br>cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// 输出 endl 换行  </span><br><span class="hljs-comment">// 格式化输出  </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a的值为%d&quot;</span>, a); <span class="hljs-comment">// %d叫做占位符  </span><br><span class="hljs-comment">// %d 整数 %c 字符 %f 浮点数  </span><br></code></pre></td></tr></table></figure><h1 id="分支结构">4 分支结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>) &#123;  <br>    代码块<span class="hljs-number">1</span>  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>) &#123;  <br>    代码块<span class="hljs-number">2</span>  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>    代码块<span class="hljs-number">3</span>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>如果条件1成立则执行代码块1，否则如果条件2成立则执行代码块2，如果前面都不成立，则执行代码块3<br /><strong>注意</strong>：任何一个条件成立就停止判断<br />条件里可以用什么运算？</p><ul><li>关系运算符 <code>==  !=  &gt;=  &lt;=  &gt;  &lt;</code></li><li>逻辑运算符 <code>&amp;&amp;</code>且（两个都满足才满足）<code>||</code>或（只要一个满足就满足） <code>!</code>非（相反）</li></ul><h1 id="循环结构">5 循环结构</h1><p><code>for</code> 循环 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(初始化; 条件; 步长) &#123;<br>    循环体;<br>&#125;<br><span class="hljs-comment">//第一次循环先执行初始化语句，之后判断是否满足条件，满足则进入循环执行循环体，不满足则跳出循环，执行循环体之后执行步长语句</span><br></code></pre></td></tr></table></figure> 常见的两种n遍循环的写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从0开始，到 &lt; n，取不到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>&#125;<br><span class="hljs-comment">// 从1开始，到 &lt;= n,能取到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>&#125;<br></code></pre></td></tr></table></figure> <code>while</code> 循环 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(条件) &#123;<br>    循环体;<br>&#125;<br><span class="hljs-comment">// 条件满足则进入循环体，不满足则跳出</span><br></code></pre></td></tr></table></figure><code>do-while</code>循环 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>    循环体;<br>&#125; <span class="hljs-keyword">while</span>(条件);<br><span class="hljs-comment">// 不管是否满足条件，至少先执行一次循环体，然后再判断条件，决定是否继续循环</span><br></code></pre></td></tr></table></figure></p><p>三种循环通用：</p><ul><li><code>break</code>：终止当前的循环</li><li><code>continue</code>：跳过本轮循环</li></ul><h1 id="数组">6 数组</h1><p>需要存储很多相同类型的变量，可以使用数组。</p><p>声明格式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[数组长度];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-type">double</span> d[<span class="hljs-number">10000</span>];<br></code></pre></td></tr></table></figure></p><blockquote><p>数组访问通过下标（索引）完成，下标从0开始，不能越界。</p></blockquote><p>数组的遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>二维数组</strong>可以理解为数组里面的元素还是一个数组，或者理解为一个矩阵，里面都是相同类型的元素。声明格式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[行数][列数]; <span class="hljs-comment">// 先行后列</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure> <imgsrc="Pasted%20image%2020250612193944.png" /></p><p>对于二维数组的访问，也是通过下标，先行后列。二维数组遍历，借助循环嵌套完成。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n行m列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; a[i][j];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 内层循环整个结束之后，外层循环才会执行一次</span><br></code></pre></td></tr></table></figure></p><h1 id="函数">7 函数</h1><p>把常用功能进行封装，把相同的功能提取出来，不同的地方作为参数。</p><p>声明格式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回值类型 函数名(参数<span class="hljs-number">1</span>类型 参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>类型 参数<span class="hljs-number">2</span>) &#123;<br>    函数体;<br>    返回;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在主函数调用自定义函数</span><br>    <span class="hljs-type">int</span> max_num = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="结构体">8 结构体</h1><p>把不同类型的变量封装成一个自定义类型，就叫结构体。比如自己创造一个学生类型。 声明格式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> 结构体类型名 &#123;<br>    类型<span class="hljs-number">1</span> 变量<span class="hljs-number">1</span>;<br>    类型<span class="hljs-number">2</span> 变量<span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>上述代码写完，是我们自己创造了一个类型为<code>student</code>的数据类型，但还没有创建变量，格式和正常的<code>int</code>一样，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stu中包括name和age</span><br>student stu;<br><span class="hljs-comment">// 也可以创建数组，数组中的每一个元素都是一个结构体</span><br>student s[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure></p><p>创建结构体变量还有一种简便方法，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125; stu;<br></code></pre></td></tr></table></figure></p><p>结构体成员的访问：使用<code>.</code>来访问结构体变量里面的成员，对于每个成员都像一个普通变量一样使用，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; stu.name &gt;&gt; stu.age;<br><span class="hljs-comment">// 结构体数组使用如下</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; s[i].name &gt;&gt; s[i].age;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
