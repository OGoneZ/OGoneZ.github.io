<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>02_机器学习基本理论</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-机器学习三要素"><a href="#1-机器学习三要素" class="headerlink" title="1 机器学习三要素"></a>1 机器学习三要素</h1><p><strong>机器学习方法 &#x3D; 模型 + 策略 + 算法</strong></p><ul><li>模型(model)：总结数据的内在规律，用数学语言描述的参数系统</li><li>策略(strategy)：选取最优模型的评价准则</li><li>算法(algorithm)：选取最优模型的具体方法</li></ul><h1 id="2-机器学习方法分类"><a href="#2-机器学习方法分类" class="headerlink" title="2 机器学习方法分类"></a>2 机器学习方法分类</h1><p><img src="/../../../ai_assets/02_algorithm_sum.png"></p><h1 id="3-建模流程"><a href="#3-建模流程" class="headerlink" title="3 建模流程"></a>3 建模流程</h1><ol><li><strong>收集数据</strong>：收集用于训练和测试的数据集，确保数据代表实际问题的不同方面</li><li><strong>数据清洗</strong>：对数据进行清洗，去除掉脏数据和不可用的数据</li><li><strong>特征工程</strong>：对数据进行转换和格式化，确保适合用于机器学习模型训练</li><li><strong>选择算法</strong>：选择适合任务类型(分类、回归、聚类等)和数据特征的机器学习算法</li><li><strong>模型训练</strong>：使用训练集数据训练模型，让模型从数据中学习规律</li><li><strong>模型评估</strong>：使用测试集评估模型性能，确认是否达到预期效果</li><li><strong>模型优化</strong>：确保模型有较好性能的基础上进一步提高模型效果</li><li><strong>模型部署</strong>：将训练好的模型部署到生产环境，实时监控其表现</li></ol><h1 id="4-特征工程"><a href="#4-特征工程" class="headerlink" title="4 特征工程"></a>4 特征工程</h1><h2 id="4-1-特征工程概述"><a href="#4-1-特征工程概述" class="headerlink" title="4.1 特征工程概述"></a>4.1 特征工程概述</h2><p>特征工程 (Feature Engineering)是机器学习过程中非常重要的一步，通过对原始数据的处理、转换和构造，生成新的特征或选择有效的特征，从而提高模型的性能。优秀的特征工程可以显著提高模型的表现，忽视特征工程可能导致模型性能欠佳。</p><blockquote><p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</p></blockquote><h2 id="4-2-特征工程内容"><a href="#4-2-特征工程内容" class="headerlink" title="4.2 特征工程内容"></a>4.2 特征工程内容</h2><h3 id="4-2-1-特征选择"><a href="#4-2-1-特征选择" class="headerlink" title="4.2.1 特征选择"></a>4.2.1 特征选择</h3><p>从原始特征中挑选出<strong>与目标变量关系最密切的特征</strong>，剔除冗余、无关或噪声特征。减少模型的复杂度、加速训练过程、并减少过拟合的风险。</p><p>特征选择不会创建新特征，也不会改变数据结构。</p><ul><li>过滤法(Filter Method)：基于统计测试(如卡方检验、相关系数、信息增益等)来评估特征与目标变量之间的关系，选择最相关的特征。</li><li>包裹法(Wrapper Method)：使用模型(如递归特征消除 RFE)来评估特征的重要性，并根据模型的表现进行特征选择。</li><li>嵌入法(Embedded Method)：使用模型本身的特征选择机制(如决策树的特征重要性，L1 正则化的特征选择)来选择最重要的特征。</li></ul><h3 id="4-2-2-特征转换"><a href="#4-2-2-特征转换" class="headerlink" title="4.2.2 特征转换"></a>4.2.2 特征转换</h3><p>对数据进行数学或统计处理，使其变得更加适合模型的输入要求。</p><ul><li>**归一化(Normalization)**：将特征缩放到特定的范围(通常是 0 到 1 之间)。适用于对尺度敏感的模型(如 KNN、SVM)。</li><li>**标准化(Standardization)**：通过减去均值并除以标准差，使特征的分布具有均值 0，标准差 1。</li><li><strong>对数变换</strong>：对于有偏态的分布(如收入、价格等)，对数变换可以将其转化为更接近正态分布的形式。</li><li>类别(category)变量的编码<ul><li><strong>独热编码 (One-Hot Encoding)</strong> ：将类别型变量转换为二进制列，常用于无序类别特征，如红色、绿色、蓝色。</li><li>**标签编码(Label Encoding)**：将类别型变量映射为整数，常用于有序类别特征，如高、中、低。</li><li>**目标编码(Target Encoding)**：将类别变量的每个类别替换为其对应目标变量的平均值或其他统计量。</li><li>**频率编码(Frequency Encoding)**：将类别变量的每个类别替换为该类别在数据集中的出现频率。</li></ul></li></ul><h3 id="4-2-3-特征构造"><a href="#4-2-3-特征构造" class="headerlink" title="4.2.3 特征构造"></a>4.2.3 特征构造</h3><p>特征构造是基于现有的特征创造出新的、更有代表性的特征。通过组合、转换、或者聚合现有的特征，形成能够更好反映数据规律的特征。</p><ul><li><strong>交互特征</strong>：将两个特征组合起来，形成新的特征。例如，两个特征的乘积、和或差等。<br>例如，将年龄与收入结合创建新的特征，可能能更好地反映某些模式。</li><li><strong>统计特征</strong>：从原始特征中提取统计值，例如求某个时间窗口的平均值、最大值、最小值、标准差等。<br>例如，在时间序列数据中，从原始数据中提取每个小时、每日的平均值。</li><li><strong>日期和时间特征</strong>：从日期时间数据中提取如星期几、月份、年份、季度等特征。<br>例如，将“2000-01-01”转换为“星期几”、“是否节假日”、“月初或月末”等特征。</li></ul><h3 id="4-2-4-特征降维"><a href="#4-2-4-特征降维" class="headerlink" title="4.2.4 特征降维"></a>4.2.4 特征降维</h3><p>当数据集的特征数量非常大时，特征降维可以帮助减少计算复杂度并避免过拟合。通过降维方法，可以在保持数据本质的情况下减少特征的数量。</p><ul><li>**主成分分析(PCA)**：通过线性变换将原始特征映射到一个新的空间，使得新的特征(主成分)尽可能地保留数据的方差。</li><li>**线性判别分析(LDA)**：一种监督学习的降维方法，通过最大化类间距离与类内距离的比率来降维。</li><li>**t 分布随机近邻嵌入(t-Distributed Stochastic Neighbor Embedding，t-SNE)**：一种非线性的降维技术，特别适合可视化高维数据。</li><li>**自编码器(Auto Encoder)**：一种神经网络模型，通过压缩编码器来实现数据的降维。</li></ul><h2 id="4-3-常用方法"><a href="#4-3-常用方法" class="headerlink" title="4.3 常用方法"></a>4.3 常用方法</h2><p>对于一个模型来说，有些特征可能很关键，而有些特征可能用处不大。因此<strong>特征选择</strong>是最基本的操作。有时也会遇到维度灾难，即特征数量过多，在确保不丢失重要特征的前提下减少维度的数量，经常会用到<strong>特征降维</strong>。</p><h3 id="4-3-1-低方差过滤法"><a href="#4-3-1-低方差过滤法" class="headerlink" title="4.3.1 低方差过滤法"></a>4.3.1 低方差过滤法</h3><p>低方差意味着该特征的样本值几乎都一样，对预测影响很小，可以直接去掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> VarianceThreshold<br><br><span class="hljs-comment"># 过滤掉方差低于 0.1 的特征</span><br>var_thresh = VarianceThreshold(threshold=<span class="hljs-number">0.1</span>)<br>X_filtered = var_thresh.fit_transform(X)<br></code></pre></td></tr></table></figure><h3 id="4-3-2-相关系数法"><a href="#4-3-2-相关系数法" class="headerlink" title="4.3.2 相关系数法"></a>4.3.2 相关系数法</h3><p>通过计算特征与目标变量或特征之间的相关性，筛选出高相关性特征(与目标相关)或剔除冗余特征(特征间高度相关)。</p><ol><li><strong>皮尔逊相关系数 (Pearson Correlation)<strong>：用于衡量两个变量的</strong>线性相关性</strong>，考察的是变量之间沿着一条直线的相似程度。</li></ol><p>$$<br>r&#x3D;\frac{\sum_{i&#x3D;1}^n(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\sum_{i&#x3D;1}^n(x_i-\bar{x})^2}\sqrt{\sum_{i&#x3D;1}^n(y_i-\bar{y})^2}}<br>$$</p><p>适用于<strong>连续变量</strong>，且这些变量近似服从<strong>正态分布</strong>。如果数据不符合正态分布，或者关系不是线性的，皮尔逊相关系数可能无法准确反映变量间的关系。</p><p>取值范围[-1, 1]：</p><ul><li>+1 表示完全正相关(一个变量增加，另一个也增加)</li><li>-1 表示完全负相关(一个变量增加，另一个减少)</li><li>0 表示没有线性相关性</li></ul><p>使用<code>pandas.DataFrame.corrwith(method=&quot;pearson&quot;)</code>可以计算各个特征与标签间的皮尔逊相关系数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">X.corrwith(y, method=<span class="hljs-string">&#x27;pearson&#x27;</span>)<br><span class="hljs-comment"># sepal length (cm) 0.798078 </span><br><span class="hljs-comment"># sepal width (cm) -0.440290 </span><br><span class="hljs-comment"># petal length (cm) 0.935431 </span><br><span class="hljs-comment"># petal width (cm) 0.938179 </span><br><span class="hljs-comment"># dtype: float64</span><br></code></pre></td></tr></table></figure><p>使用 <code>pandas.DataFrame.corr(method=&quot;pearson&quot;)</code> 计算皮尔逊相关系数矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">corr_matrix = X.corr(method=<span class="hljs-string">&#x27;pearson&#x27;</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>sepal length (cm)</th><th>sepal width (cm)</th><th>petal length (cm)</th><th>petal width (cm)</th><th>label</th></tr></thead><tbody><tr><td>sepal length (cm)</td><td>1.000000</td><td>-0.117570</td><td>0.871754</td><td>0.817941</td><td>0.782561</td></tr><tr><td>sepal width (cm)</td><td>-0.117570</td><td>1.000000</td><td>-0.428440</td><td>-0.366126</td><td>-0.426658</td></tr><tr><td>petal length (cm)</td><td>0.871754</td><td>-0.428440</td><td>1.000000</td><td>0.962865</td><td>0.949035</td></tr><tr><td>petal width (cm)</td><td>0.817941</td><td>-0.366126</td><td>0.962865</td><td>1.000000</td><td>0.956547</td></tr><tr><td>label</td><td>0.782561</td><td>-0.426658</td><td>0.949035</td><td>0.956547</td><td>1.000000</td></tr></tbody></table><p>使用热力图将皮尔逊矩阵可视化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.heatmap(corr_matrix, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;.2f)</span><br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/02_heatmap.png"></p><ol start="2"><li><strong>斯皮尔曼相关系数(Spearman’s Rank Correlation Coefficient)<strong>：用于衡量两个变量之间的</strong>单调关系</strong>，考察的是一个变量增加时，另一个变量也倾向于增加或减少的程度，不一定是线性关系。其中 $d_i$ 是两个变量在排名时的差异，$n$ 是样本大小。<br>$$<br>ρ&#x3D;1−\frac{6\sum_{i&#x3D;1}^n​d_i^2​}{n(n^2−1)}​<br>$$</li></ol><p>取值范围 [-1, 1]：</p><ul><li>+1 表示完全单调递增关系</li><li>-1 表示完全单调递减关系</li><li>0 表示没有单调关系</li></ul><p>适用于<strong>连续变量或离散变量</strong>。对数据的分布没有严格要求，即使数据不服从正态分布也可以使用。 特别适合于处理顺序数据(例如，排名)。</p><p>使用 <code>pandas.DataFrame.corrwith(method=&quot;spearman&quot;)</code> 计算斯皮尔曼相关系数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">X.corrwith(y, method=<span class="hljs-string">&#x27;spearman&#x27;</span>)<br><span class="hljs-comment"># sepal length (cm)    0.798078</span><br><span class="hljs-comment"># sepal width (cm)    -0.440290</span><br><span class="hljs-comment"># petal length (cm)    0.935431</span><br><span class="hljs-comment"># petal width (cm)     0.938179</span><br><span class="hljs-comment"># dtype: float64</span><br></code></pre></td></tr></table></figure><p>同样可以使用 <code>pandas.DataFrame.corr(method=&quot;spearman&quot;)</code> 来计算斯皮尔曼相关系数矩阵。</p><h3 id="4-3-3-主成分分析-PCA"><a href="#4-3-3-主成分分析-PCA" class="headerlink" title="4.3.3 主成分分析(PCA)"></a>4.3.3 主成分分析(PCA)</h3><p>主成分分析(Principal Component Analysis， PCA)是一种常用的降维技术，通过线性变换将高维数据投影到低维空间，同时保留数据的主要变化模式。</p><p>使用 <code>sklearn.decomposition.PCA(n_components=2)</code> 进行主成分分析。<br>参数<code>n_components</code> ：</p><ul><li>小数：表示保留多少比例的信息</li><li>整数：表示保留多少个维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><br><span class="hljs-comment"># 保留两个维度的特征</span><br>pca = PCA(n_components=<span class="hljs-number">2</span>)<br>X_pca = pca.fit_transform(X)<br></code></pre></td></tr></table></figure><p>可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># 转换前的三维可视化</span><br>ax1 = fig.add_subplot(<span class="hljs-number">121</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>ax1.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], X[:, <span class="hljs-number">2</span>])<br>ax1.set_title(<span class="hljs-string">&#x27;Before PCA(3D)&#x27;</span>)<br>ax1.set_xlabel(<span class="hljs-string">&quot;Feature 1&quot;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&quot;Feature 2&quot;</span>)<br>ax1.set_zlabel(<span class="hljs-string">&quot;Feature 3&quot;</span>)<br><br><span class="hljs-comment"># 转换后的二维可视化</span><br>ax2 = fig.add_subplot(<span class="hljs-number">122</span>)<br>ax2.scatter(X_pca[:, <span class="hljs-number">0</span>], X_pca[:, <span class="hljs-number">1</span>])<br>ax2.set_title(<span class="hljs-string">&#x27;After PCA(2D)&#x27;</span>)<br>ax2.set_xlabel(<span class="hljs-string">&quot;Principal Component 1&quot;</span>)<br>ax2.set_ylabel(<span class="hljs-string">&quot;Principal Component 2&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/02_pca.png"></p><h1 id="5-模型评估和选择"><a href="#5-模型评估和选择" class="headerlink" title="5 模型评估和选择"></a>5 模型评估和选择</h1><h2 id="5-1-损失函数"><a href="#5-1-损失函数" class="headerlink" title="5.1 损失函数"></a>5.1 损失函数</h2><p>预测结果 $f(X)$ 和真实值 $y$ 之间的存在偏差，我们使用损失函数(loss function)来度量预测偏差的程度，记作 $L(y,f(X))$，损失函数是非负实值函数，损失函数值越小，模型越好。</p><p>常见损失函数：</p><ul><li><p>0-1损失函数<br>$$<br>L(y,f(X))&#x3D;\begin{cases} 1,\quad y≠f(X) \ 0,\quad y&#x3D;f(X) )\end{cases}<br>$$</p></li><li><p>平方损失函数<br>$$<br>L(y,f(X))&#x3D;(y-f(X))^2<br>$$</p></li><li><p>绝对损失函数<br>$$<br>L(y,f(X))&#x3D;|y-f(X)|<br>$$</p></li><li><p>对数似然损失函数<br>$$<br>L(y, F(X)) &#x3D; -[y,\log,p_x + (1 - y),\log,(1 - p_x)]<br>$$<br>${y}$ 是实际标签（ ${y \in \lbrace 0, 1 \rbrace}$ ，表示类别 0 或 1）， ${p_x}$ 是模型预测的样本 ${x}$ 属于类别 1 的概率。</p></li></ul><h2 id="5-2-经验误差"><a href="#5-2-经验误差" class="headerlink" title="5.2 经验误差"></a>5.2 经验误差</h2><p>根据选取的损失函数，就可以计算出模型 $f(X)$ 在训练集上的平均误差，称为训练误差，也被称作 <strong>经验误差(empirical error)</strong> 或 经验风险(empirical risk)。<br>$$<br>R_{emp}&#x3D; \frac{1}{n}\sum _{i&#x3D;1}^nL(y_i, f(x_i))<br>$$<br>类似地，在测试集上的平均误差，被称为测试误差或者 **泛化误差 (generalization error)**。</p><p>一般情况下对模型评估的策略，就是考察经验误差；当经验风险最小时，就认为取到了最优的模型。这种策略被称为 **经验风险最小化(empirical risk minimization，ERM)**。</p><h2 id="5-3-欠拟合和过拟合"><a href="#5-3-欠拟合和过拟合" class="headerlink" title="5.3 欠拟合和过拟合"></a>5.3 欠拟合和过拟合</h2><p>拟合(Fitting)是指机器学习模型在训练数据上学习到规律并生成预测结果的过程。<br><img src="/../../../ai_assets/02_fitting_model.png"></p><p>**过拟合(overfitting)**：模型在训练集上学得太好，甚至记住了噪声或偶然特征，导致在训练集表现好、测试集表现差。<br>**欠拟合(underfitting)**：模型对训练数据学习不足，连训练集都拟合不好，模型太简单、能力不够，无法捕捉数据中的真实规律。</p><p>欠拟合通过增加模型复杂度、增加特征或改进特征工程、增加训练时间、减少正则化强度即可，一般来说更容易遇到、并且不易解决的问题是过拟合。</p><ul><li>过拟合产生原因：<ul><li>模型复杂度过高：模型过于复杂，参数过多</li><li>训练数据不足：数据集太小，模型学到的细节无法泛化到新数据</li><li>特征过多：模型记住了数据的噪声，而不是规律</li><li>训练时间过长：模型学会了数据中的噪声，而不是规律</li></ul></li><li>过拟合解决方案：<ul><li>减少模型复杂度：降低模型参数数量，使用简化的模型或降维</li><li>增加训练数据：收集更多数据增强数据多样性</li><li><strong>使用正则化：引入 L1 、L2 正则化</strong></li><li>早停：模型验证损失不再下降时，提前停止训练</li></ul></li></ul><h2 id="5-4-正则化"><a href="#5-4-正则化" class="headerlink" title="5.4 正则化"></a>5.4 正则化</h2><p>正则化(Regularization)通过在损失函数中添加额外项，<strong>惩罚过大的参数</strong>，进而限制模型复杂度、避免过拟合，提高模型泛化能力。</p><p>如在平方损失函数中加入正则化：<br>$$<br>Loss&#x3D;\frac{1}{n}{\left(\sum_{i&#x3D;1}^n(f(x_i)-y_i)^2+\lambda\sum_{i&#x3D;1}^k{w_i}^2\right)}<br>$$<br>𝜆 是<strong>正则化系数</strong>，用来表示<strong>惩罚项的权重</strong>。正则化系数需在模型训练开始之前手动设置，是“超参数”。</p><ul><li>𝜆 过大：可能使模型太简单，导致欠拟合</li><li>𝜆 过小：可能使模型太复杂，导致过拟合</li></ul><p>原损失函数和正则化项相互平衡，在模型的拟合能力和复杂度之间找到最佳折中。</p><ul><li>原损失函数的目的：更好的拟合数据集</li><li>正则化项的目的：减小参数的大小，从而降低模型复杂度</li></ul><p>常见的正则化技术有 L1 正则化和 L2 正则化。</p><h3 id="5-4-1-L1-正则化-Lasso回归"><a href="#5-4-1-L1-正则化-Lasso回归" class="headerlink" title="5.4.1 L1 正则化(Lasso回归)"></a>5.4.1 L1 正则化(Lasso回归)</h3><p>L1 正则化在损失函数中加入参数的绝对值之和：<br>$$Loss_{L1}&#x3D;\text{原}Loss+\lambda\sum_{i&#x3D;1}^k|w_i|$$<br>L1 正则化通过惩罚模型参数的绝对值，使得部分权重<strong>趋近 0 甚至变为 0</strong>。这会导致<strong>特</strong><br><strong>征选择</strong>，即模型会自动“丢弃”一些不重要的特征。</p><blockquote><p>在解决回归问题时，使用 L1 正则化也被称为“Lasso 回归”。</p></blockquote><h3 id="5-4-2-L2-正则化-Ridge回归"><a href="#5-4-2-L2-正则化-Ridge回归" class="headerlink" title="5.4.2 L2 正则化(Ridge回归)"></a>5.4.2 L2 正则化(Ridge回归)</h3><p>L2 正则化在损失函数中加入参数的平方之和：<br>$$Loss_{L2}&#x3D;\text{原}Loss+\lambda\sum_{i&#x3D;1}^kw_i{}^2$$<br>L2 正则化通过惩罚模型参数的平方，使得所有参数都变得更小，但不会将参数强行压<br>缩为 0。它会使得模型<strong>尽量平滑</strong>，从而防止过拟合。</p><p>由于 L2 正则化平方的存在，虽然在 $w_i$ 绝对值大于 1 时，惩罚力度更大，但是当 $w_i$ 绝对值小于 1 时，惩罚力度变小，所以即使某个特征对模型影响很小，也不会将其权重压缩为 0。<br><img src="/../../../ai_assets/02_L1_L2.png"></p><blockquote><p>在解决回归问题时，使用 L2 正则化也被称为“岭回归”。</p></blockquote><h3 id="5-4-3-ElasticNet-正则化-弹性网格回归"><a href="#5-4-3-ElasticNet-正则化-弹性网格回归" class="headerlink" title="5.4.3 ElasticNet 正则化(弹性网格回归)"></a>5.4.3 ElasticNet 正则化(弹性网格回归)</h3><p>ElasticNet 正则化结合了 L1 和 L2 正则化，通过调整两个正则化项的比例来取得平衡，从而同时具备稀疏性和稳定性的优点。<br>$$<br>Loss_{ElasticNet}&#x3D;\text{原}Loss+\lambda\left(\alpha\sum_{i&#x3D;1}^n|\omega_i|+(1-\alpha)\sum_{i&#x3D;1}^n\omega_i^2\right)<br>$$<br>其中 $\alpha$ 是控制 L1 和 L2 正则化的比例。</p><h2 id="5-5-评估方法"><a href="#5-5-评估方法" class="headerlink" title="5.5 评估方法"></a>5.5 评估方法</h2><h3 id="5-5-1-留出法-Hold-Out"><a href="#5-5-1-留出法-Hold-Out" class="headerlink" title="5.5.1 留出法(Hold-Out)"></a>5.5.1 留出法(Hold-Out)</h3><p>留出法(Hold-Out Validation)将数据划分为训练集、验证集和测试集(如 70%训练，30%测试)。结果受单次划分影响较大，可能高估或低估模型性能。</p><h3 id="5-5-2-k-折交叉验证-k-Fold-CV"><a href="#5-5-2-k-折交叉验证-k-Fold-CV" class="headerlink" title="5.5.2 k 折交叉验证(k-Fold CV)"></a>5.5.2 k 折交叉验证(k-Fold CV)</h3><p>交叉验证(Cross-Validation)是一种评估模型泛化能力的方法，通过将数据集划分为多个子集，反复进行训练和验证，以减少因单次数据划分带来的随机性误差。 </p><p>k 折交叉验证(k-Fold Cross-Validation)将数据均匀分为 k 个子集(称为“折”)，每次用 k−1 折训练，剩余 1 折验证，重复 k 次后取平均性能。充分利用数据，结果更稳定。k 一般取 10、5。<br><img src="/../../../ai_assets/02_kfold.png"></p><h3 id="5-5-3-留一法-Leave-One-Out"><a href="#5-5-3-留一法-Leave-One-Out" class="headerlink" title="5.5.3 留一法(Leave-One-Out)"></a>5.5.3 留一法(Leave-One-Out)</h3><p>留一法(Leave-One-Out, LOO) 是 k-Fold 的特殊形式，每次仅留一个样本作为验证集，其余全部用于训练，重复直到所有样本都被验证一次。适用于小数据集，计算成本极高。</p><h1 id="6-模型求解算法"><a href="#6-模型求解算法" class="headerlink" title="6 模型求解算法"></a>6 模型求解算法</h1><p>模型求解其实就是寻找最优参数，让增加了正则化之后的损失函数最小化，称为结构风险最小化(Structural Risk Minimization，SRM)。<br>$$\min\frac{1}{n}(\sum_{i&#x3D;1}^nL(y_i,f(x_i))+\lambda J(\theta))$$<br>这其实就是求解一个 <strong>最优化问题</strong>。代入训练集所有数据 (𝑥𝑖,𝑦𝑖)，要求最小值的目标函数就是模型中参数 𝜃 的函数。</p><p>具体求解的算法，可以利用数学公式直接计算解析解，也可以使用<strong>迭代算法</strong>。</p><h2 id="6-1-解析解"><a href="#6-1-解析解" class="headerlink" title="6.1 解析解"></a>6.1 解析解</h2><p>通过数学公式进行严格推导得到解析解，那么就直接得到了最优模型的全部参数，这种方法称作解析法。</p><ul><li>优点：直接通过计算得到最优值，精确迅速</li><li>缺点：适用条件苛刻，目标函数必须可导，且导数方程有解析解；特征维度较大时，计算复杂度极高</li></ul><p>例如线性回归问题：通过最小二乘法得到解析解<br>$$\begin{gathered}<br>Loss_{MSE}&#x3D;\frac{1}{n}(X\beta-y)^T(X\beta-y) \<br>\nabla Loss_{MSE}&#x3D;\frac{2}{n}X^T(X\beta-y)&#x3D;0 \<br>\boldsymbol{\beta}&#x3D;(\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}<br>\end{gathered}$$</p><h2 id="6-2-梯度下降法"><a href="#6-2-梯度下降法" class="headerlink" title="6.2 梯度下降法"></a>6.2 梯度下降法</h2><h3 id="6-2-1-梯度下降思想"><a href="#6-2-1-梯度下降思想" class="headerlink" title="6.2.1 梯度下降思想"></a>6.2.1 梯度下降思想</h3><p>梯度下降法(gradient descent)是迭代算法，基本思路就是先选取一个适当的初始值 $𝜃_0$，然后沿着负梯度方向，不停地更新参数，最终取到极小值。</p><p>(1)初始化参数：随机选择初始参数<br>(2)计算梯度：在当前参数下，计算损失函数的梯度<br>(3)更新参数：沿负梯度方向调整参数<br>(4)重复迭代：直到满足停止条件(如梯度接近零、达到最大迭代次数等)</p><ul><li>梯度方向：函数变化增长最快的方向(变量沿此方向变化时函数增长最快)</li><li>负梯度方向：函数变化减少最快的方向(变量沿此方向变化时函数减少最快)</li></ul><p>沿着损失函数的负梯度方向变化，此时损失函数减少最快，能够以最快速度下降到极小值。<br>$$\theta_{k+1}&#x3D;\theta_k-\alpha\cdot\nabla L(\theta_k)$$<br>$\nabla𝐿(𝜃_𝑘)$是参数取值为 $𝜃_𝑘$ 时损失函数 𝐿 的梯度； 𝛼 是每次迭代的步长，被称为**学习率(learning rate)**，是一个常见的超参数，设置过小训练迭代过慢，设置过大不易收敛。</p><blockquote><p>注意每次更新的是“x”，而不是“y”，每次“x”沿着负梯度方向移动一段距离。</p></blockquote><p>梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。</p><ul><li>优点：适用性广，计算简单</li><li>缺点：收敛速度慢，可能陷入局部最优解</li></ul><h3 id="6-2-2-梯度下降分类"><a href="#6-2-2-梯度下降分类" class="headerlink" title="6.2.2 梯度下降分类"></a>6.2.2 梯度下降分类</h3><ol><li><p>批量梯度下降(Batch Gradient Descent，BGD)：每次迭代使用<strong>全部训练数据</strong>计算梯度。</p><ul><li>优点：梯度方向稳定，更新平滑，收敛过程较稳定。</li><li>缺点：每次都计算整个训练集，计算量大，对大数据集效率低。</li></ul></li><li><p>随机梯度下降(Stochastic Gradient Descent，SGD)：每次迭代随机选取<strong>一个样本</strong>计算梯度。</p><ul><li>优点：快速迭代，每次只用一个样本计算梯度；由于引入了随机性，有助于跳出局部最优解。</li><li>缺点：每次更新方向不确定，收敛过程波动很大，甚至难以收敛，在最小值附近震荡。</li></ul></li><li><p>小批量梯度下降(Mini-batch Gradient Descent，MBGD)：每次迭代使用<strong>一小批样本</strong>(如32、64个)计算梯度。</p><ul><li>优点：计算成本相对 BGD 较低，又比 SGD 稳定，兼具 BGD 的稳定和 SGD 的速度。</li><li>缺点：合适的 batch size 需要实验。</li></ul></li></ol><p><a href="https://www.jeremyjordan.me/gradient-descent/">梯度下降优化扩展内容</a></p><h2 id="6-3-牛顿法和拟牛顿法"><a href="#6-3-牛顿法和拟牛顿法" class="headerlink" title="6.3 牛顿法和拟牛顿法"></a>6.3 牛顿法和拟牛顿法</h2><p>牛顿法也是求解无约束最优化问题的常用方法，核心思想是利用目标函数的二阶导数信息（不需要手动指定学习率了），通过迭代逐渐逼近极值点。<br>$$\theta_{k+1}&#x3D;\theta_k-H^{-1}(\theta_k)\cdot\nabla L(\theta_k)$$<br>$𝐻^{−1}(𝜃_𝑘)$ 表示损失函数 $L$ 黑塞矩阵的逆在点 $𝜃_𝑘$ 的取值。</p><ul><li>优点：收敛速度快，精度高。</li><li>缺点：计算非常复杂，可能发散。</li></ul><p>由于牛顿法中需要计算黑塞矩阵的逆 $𝐻^{−1}(𝜃_𝑘)$，这一步比较复杂， 所以可以考虑用一个 $n$ 阶正定矩阵来近似代替它，这种方法称为“拟牛顿法”。 </p><p>牛顿法和拟牛顿法一般用于解决中小规模的凸优化问题。</p><h1 id="7-模型评估指标"><a href="#7-模型评估指标" class="headerlink" title="7 模型评估指标"></a>7 模型评估指标</h1><p>模型的评估指标用于衡量模型在训练集或测试集上的性能，评估结果反映了模型预测的准确性和泛化能力。</p><h2 id="7-1-回归模型"><a href="#7-1-回归模型" class="headerlink" title="7.1 回归模型"></a>7.1 回归模型</h2><h3 id="7-1-1-均方误差-MSE"><a href="#7-1-1-均方误差-MSE" class="headerlink" title="7.1.1 均方误差(MSE)"></a>7.1.1 均方误差(MSE)</h3><p>均方误差(Mean Squared Error, MSE)：每个样本的<strong>预测值与真实值之差的平方</strong>的平均值。<br>$$<br>{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \hat{y}_i)^2<br>$$</p><p>MSE 对误差进行平方，因此对<strong>异常值非常敏感</strong>。MSE的值越小，说明模型的预测越精准，性能越好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br>mean_squared_error(y_true, y_test)<br></code></pre></td></tr></table></figure><h3 id="7-1-2-均方根误差-RMSE"><a href="#7-1-2-均方根误差-RMSE" class="headerlink" title="7.1.2 均方根误差(RMSE)"></a>7.1.2 均方根误差(RMSE)</h3><p>均方根误差(Root Mean Squared Error, RMSE)：均方根误差是均方误差的平方根。<br>$$<br>RMSE&#x3D;\sqrt{MSE}&#x3D;\sqrt{\frac{1}{n}\sum_{i&#x3D;1}^{n}(y_i−\hat{y}_i)^2}<br>$$</p><p>RMSE 同样对<strong>大误差</strong>敏感，因为它是在 MSE 的基础上计算得到的，优势在于与目标的量纲一致。如果一味地降低 RMSE，可能会导致模型对异常值也拟合度很高，容易过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> root_mean_squared_error<br><br>root_mean_squared_error(y_true, y_test)<br></code></pre></td></tr></table></figure><h3 id="7-1-3-平均绝对误差-MAE"><a href="#7-1-3-平均绝对误差-MAE" class="headerlink" title="7.1.3 平均绝对误差(MAE)"></a>7.1.3 平均绝对误差(MAE)</h3><p>平均绝对误差(Mean Absolute Error, MAE)：预测值与真实值差的绝对值的平均值。<br>$$<br>MAE&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^{n}|y_i-\hat{y}_i|<br>$$</p><p>MAE 对所有误差都给予相同的权重，因此对<strong>异常值</strong>不敏感，并且和目标量纲一致。</p><blockquote><p>如果希望模型对异常值更加敏感，可以选择 MSE 或 RMSE。RMSE 比 MSE 更易于解释。<br>如果希望模型对异常值不敏感，可以选择 MAE。<br>在实际应用中，通常会同时考虑这三个指标，以便更全面地评估模型的性能。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br><br>mean_absolute_error(y_true, y_test)<br></code></pre></td></tr></table></figure><h3 id="7-1-4-R-2-决定系数"><a href="#7-1-4-R-2-决定系数" class="headerlink" title="7.1.4 $R^2$ 决定系数"></a>7.1.4 $R^2$ 决定系数</h3><p>$R^2$ 决定系数：衡量模型对目标变量的解释能力，越接近 1 越好。由于分母是均方误差，所以对异常值也敏感。<br>$$R^2&#x3D;1-\frac{MSE}{Var}&#x3D;1-\frac{\sum_{i&#x3D;1}^n(f(x_i)-y_i)^2}{\sum_{i&#x3D;1}^n(y_i-\bar{y})^2}$$<br>决定系数右侧的所减项实际为均方误差与方差的比值。</p><ul><li>均方误差越接近 0，整体越接近 1。</li><li>方差越大，说明真实数据本身规律越弱，允许的误差范围越大，整体也会越接近 1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> r2_score<br><br>r2_score(y_true, y_test)<br></code></pre></td></tr></table></figure><h2 id="7-2-分类模型"><a href="#7-2-分类模型" class="headerlink" title="7.2 分类模型"></a>7.2 分类模型</h2><h3 id="7-2-1-混淆矩阵-Confusion-Matrix"><a href="#7-2-1-混淆矩阵-Confusion-Matrix" class="headerlink" title="7.2.1 混淆矩阵(Confusion Matrix)"></a>7.2.1 混淆矩阵(Confusion Matrix)</h3><p>正类为 Positive (P)，负类为 Negative (N)，总样本数 $n&#x3D;TP+TN+FP+FN$。展示了模型预测结果与实际标签的对比情况，n 分类问题的混淆矩阵为 $n×n$。</p><table>  <thead>    <tr>      <th>真实类别</th>      <th>预测为正例</th>      <th>预测为反例</th>    </tr>  </thead>  <tbody>    <tr >      <td><b>正例 (P)</b></td>      <td>真正例(True Positive, TP)</td>      <td>假反例(False Negative, FN)</td>    </tr>    <tr>      <td><b>反例 (N)</b></td>      <td>假正例(False Positive, FP)</td>      <td>真反例(True Negative, TN)</td>    </tr>  </tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-comment"># 查看混淆矩阵</span><br>cm = confusion_matrix(y_ture, y_pred)<br><br><span class="hljs-comment"># 热力图可视化</span><br>sns.heatmap(cm, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;.2f&#x27;</span>, cmap=<span class="hljs-string">&#x27;warmcool&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="7-2-2-精度-Accuracy"><a href="#7-2-2-精度-Accuracy" class="headerlink" title="7.2.2 精度(Accuracy)"></a>7.2.2 精度(Accuracy)</h3><p>预测正确的比例。<br>$$<br>Accuracy&#x3D;\frac{TP+TN}{n}​<br>$$</p><table>  <thead>    <tr>      <th>真实类别</th>      <th>预测为正例</th>      <th>预测为反例</th>    </tr>  </thead>  <tbody>    <tr>      <td><b>正例 (P)</b></td>      <td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td>      <td style="background-color:#F8CECC;">假反例(False Negative, FN)</td>    </tr>    <tr>      <td><b>反例 (N)</b></td>      <td style="background-color:#F8CECC;">假正例(False Positive, FP)</td>      <td style="background-color:#D5E8D4;">真反例(True Negative, TN)</td>    </tr>  </tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 方式一</span><br>accuracy_score(y_true, y_pred)<br><br><span class="hljs-comment"># 方式二</span><br>model.score(X_test, y_test)<br></code></pre></td></tr></table></figure><p>错误率(Error)：预测错误的比例。<br>$$<br>Error&#x3D;\frac{FP+FN}{n}&#x3D;1−Accuracy<br>$$</p><h3 id="7-2-3-查准率-Precision"><a href="#7-2-3-查准率-Precision" class="headerlink" title="7.2.3 查准率(Precision)"></a>7.2.3 查准率(Precision)</h3><p>预测为正例的样本中，真正为正的比例，衡量模型预测的准不准。<br>$$<br>Precision&#x3D;\frac{TP}{TP+FP}​<br>$$</p><table>  <thead>    <tr>      <th>真实类别</th>      <th>预测为正例</th>      <th>预测为反例</th>    </tr>  </thead>  <tbody>    <tr>      <td><b>正例 (P)</b></td>      <td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td>      <td>假反例(False Negative, FN)</td>    </tr>    <tr>      <td><b>反例 (N)</b></td>      <td style="background-color:#F8CECC;">假正例(False Positive, FP)</td>      <td>真反例(True Negative, TN)</td>    </tr>  </tbody></table><p>核心特点：宁缺毋滥。<br>查准率高，意味着模型在说一个样本是正例时，有很高的可信度。<strong>误报代价高</strong>时更关心，比如垃圾邮件检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score<br><br>precision_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><h3 id="7-2-4-查全率-召回率-Recall"><a href="#7-2-4-查全率-召回率-Recall" class="headerlink" title="7.2.4 查全率&#x2F;召回率(Recall)"></a>7.2.4 查全率&#x2F;召回率(Recall)</h3><p>真正的正例中，被模型判正的比例，衡量模型找得全不全。<br>$$<br>Recall&#x3D;\frac{TP}{TP+FN}<br>$$</p><table>  <thead>    <tr>      <th>真实类别</th>      <th>预测为正例</th>      <th>预测为反例</th>    </tr>  </thead>  <tbody>    <tr>      <td><b>正例 (P)</b></td>      <td style="background-color:#D5E8D4;">真正例(True Positive, TP)</td>      <td style="background-color:#F8CECC;">假反例(False Negative, FN)</td>    </tr>    <tr>      <td><b>反例 (N)</b></td>      <td>假正例(False Positive, FP)</td>      <td>真反例(True Negative, TN)</td>    </tr>  </tbody></table><p>核心特点：宁多报不漏报。<br>查全率高，意味着模型能够把绝大多数的正例都找出来，很少漏掉。<strong>漏报代价高</strong>时更关心，比如病毒检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> recall_score<br><br>recall_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><h3 id="7-2-5-F1度量-F1-score"><a href="#7-2-5-F1度量-F1-score" class="headerlink" title="7.2.5 F1度量(F1-score)"></a>7.2.5 F1度量(F1-score)</h3><p>查准率和查全率是相互制约的，需要一个综合性的指标来平衡它们，F1度量就是它们的调和平均数，同时兼顾了查准率和查全率。<br>$$<br>\frac{1}{F_1}&#x3D;\frac{1}{2}·(\frac{1}{Precision}+\frac{1}{Recall})<br>$$<br>得&#x3D;&gt;<br>$$<br>F_1​&#x3D;2\cdot\frac{Precision\cdot Recall}{Precision+Recall}<br>$$</p><ul><li><p><strong>F-beta度量</strong>：不平衡场景可用加权的 $F_β$​ 强调召回或查准。<br>$$<br>F_β&#x3D;(1+β^2)⋅\frac{PR}{β^2P+R}​<br>$$</p></li><li><p>当 $β&gt;1$ 时，更看重Recall（如 $F_2​$ 度量）</p></li><li><p>当 $β&lt;1$ 时，更看重Precision（如 $F_{0.5}$ 度量）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br><br>f1_score(y_true, y_pred)<br></code></pre></td></tr></table></figure><hr><p>使用 <code>sklearn</code> 中的 <code>classification_report</code> 可以生成分类任务的评估报告， 可以很方便地查看精确率、召回率、F1 分数等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">classification_report(y_true, y_pred)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">             precision    recall    f1-score    support </span><br><span class="hljs-string">        0.0     1.00       1.00       1.00         8 </span><br><span class="hljs-string">        1.0     0.92       1.00       0.96        11 </span><br><span class="hljs-string">        2.0     1.00       0.91       0.95        11 </span><br><span class="hljs-string">          </span><br><span class="hljs-string">accuracy                              0.97        30 </span><br><span class="hljs-string">macro avg       0.97       0.97       0.97        30 </span><br><span class="hljs-string">weighted avg    0.97       0.97       0.97        30</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="7-2-6-ROC曲线"><a href="#7-2-6-ROC曲线" class="headerlink" title="7.2.6 ROC曲线"></a>7.2.6 ROC曲线</h3><ul><li>真正例率（TPR）：实际为正例，被预测为正例的比例，即召回率。(第一行)</li><li>假正例率（FPR）：实际为负例，被预测为正例的比例。（第二行）</li><li>阈值（Threshold）：根据阈值将概率（一般是正例概率）转换为类别标签。</li></ul><p>$$TPR&#x3D;\frac{TP}{\textit{实际正例数}}&#x3D;\frac{TP}{TP+FN}\qquad FPR&#x3D;\frac{FP}{\textit{实际负例数}}&#x3D;\frac{FP}{FP+TN}$$</p><table>  <thead>    <tr>      <th>真实类别</th>      <th>预测为正例</th>      <th>预测为反例</th>    </tr>  </thead>  <tbody>    <tr >      <td><b>正例 (P)</b></td>      <td>真正例(True Positive, TP)</td>      <td>假反例(False Negative, FN)</td>    </tr>    <tr>      <td><b>反例 (N)</b></td>      <td>假正例(False Positive, FP)</td>      <td>真反例(True Negative, TN)</td>    </tr>  </tbody></table><p>ROC 曲线（Receiver Operating Characteristic Curve，受试者工作特征）是评估二分类模型性能的工具，以假正例率（FPR）为横轴，以真正例率（TPR）为纵轴，展示不同阈值下模型的表现。绘制 ROC 曲线时，从高到低调整阈值，计算每个阈值的 TPR 和 FPR 并绘制所有阈值的点，形成 ROC 曲线。<br><img src="/../../../ai_assets/02_roc.png"></p><p>中间的红色虚线是随机猜测概率，只要 ROC 曲线在虚线上方就有预测价值，当然如果在虚线下方说明能够反向预测正确，反转输出也有预测价值。</p><blockquote><p>在左下角时，阈值被设定的很高（比如 0.999才预测为正例），那么模型将所有样本都预测为负例，不预测为正例就不会出错，所以 TPR 和 FPR 都很低。<br>阈值稍微降低，由于此时正例概率很大，TPR 提升很快，有预测就有失误，FPR 随之提升，但没有 TPR 提升快，曲线向上凸起。<br>当阈值继续降低，正例概率变低，将会导致更多的预测失误，FPR 增长速度超越 TPR，曲线开始向下弯曲。<br>右上角是另一种极端，阈值设定很低，所有样本都预测为正例，TPR 和 FPR 都很高。</p></blockquote><h3 id="7-2-7-AUC值"><a href="#7-2-7-AUC值" class="headerlink" title="7.2.7 AUC值"></a>7.2.7 AUC值</h3><p>AUC 值代表 ROC 曲线下的面积，用于量化模型性能。AUC 值越大，模型区分正负类的能力越强，模型性能越好。AUC 值&#x3D;0.5 表示模型接近随机猜测，AUC 值&#x3D;1 代表完美模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_auc_score<br><br><span class="hljs-comment"># 获取正类预测概率值</span><br>y_proba = model.predict_proba(X_test)[:, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 计算 auc 值</span><br>roc_auc_score(y_test, y_proba)<br></code></pre></td></tr></table></figure><p>绘制 ROC 曲线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve, roc_auc_score<br><span class="hljs-keyword">import</span> matplotplib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 获取正类预测概率值</span><br>y_proba = model.predict_proba(X_test)[:, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 返回 FPR, TPR, 阈值 数组</span><br>fpr, tpr, threshold = roc_curve(y_test, y_proba)<br><br><span class="hljs-comment"># 计算 AUC 值</span><br>roc_auc = roc_auc_score(y_test, y_proba)<br><br><span class="hljs-comment"># 绘制 ROC 曲线</span><br>plt.plot(fpr, tpr, label=<span class="hljs-string">f&#x27;ROC curve(roc_auc=<span class="hljs-subst">&#123;roc_auc:<span class="hljs-number">.2</span>f&#125;</span>)&#x27;</span>)<br>plt.plot([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], linestyle=<span class="hljs-string">&#x27;--&#x27;</span>)<br>plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>plt.ylim(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;False Positive Rate&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;True Positive Rate&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;ROC Curve&#x27;</span>)<br>plt.legend(loc=<span class="hljs-string">&#x27;lower right&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/02_roc_curve.png"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_KNN算法</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_KNN%E7%AE%97%E6%B3%95/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_KNN%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>K近邻算法（k-nearest neighbors, KNN）是一种用于分类和回归的非参数统计方法。KNN 算法的原理是<strong>从历史数据中找到 $\small{k}$ 个跟新输入的实例最邻近的实例</strong>，根据它们中的多数所属的类别来对新实例进行分类或者输出新实例的目标值。K近邻算法没有显式的学习训练过程，它用的是“<strong>近朱者赤，近墨者黑</strong>”这样一种简单朴素的思想来实现分类或回归。</p><ul><li>分类问题：在K个最近邻的标签中取众数（由于可能平票，所以通常取奇数K）</li><li>回归问题：在K个最近邻的标签中取平均数</li></ul><h1 id="2-关键参数"><a href="#2-关键参数" class="headerlink" title="2 关键参数"></a>2 关键参数</h1><h2 id="2-1-K值的选择"><a href="#2-1-K值的选择" class="headerlink" title="2.1 K值的选择"></a>2.1 K值的选择</h2><ul><li>K值过小：在较小范围的训练实例中进行预测，容易受到异常值的影响，发生<strong>过拟合</strong></li><li>K值过大：在较大范围的训练实例中进行预测，容易受到均衡值的影响，发生<strong>欠拟合</strong></li></ul><h2 id="2-2-距离的度量"><a href="#2-2-距离的度量" class="headerlink" title="2.2 距离的度量"></a>2.2 距离的度量</h2><h3 id="2-2-1-闵可夫斯基距离"><a href="#2-2-1-闵可夫斯基距离" class="headerlink" title="2.2.1 闵可夫斯基距离"></a>2.2.1 闵可夫斯基距离</h3><p>我们可以用距离（distance）来衡量特征空间中两个实例之间的相似度，闵氏距离全称闵可夫斯基距离（Minkowski Distance），对于两个 $\small{n}$ 维向量 $\small{\mathbf{x}&#x3D;(x_{1}, x_{2}, \cdots, x_{n})}$ 和 $\small{\mathbf{y}&#x3D;(y_{1}, y_{2}, \cdots, y_{n})}$ ，它们之间的距离可以定义为：<br>$$<br>d(\mathbf{x}, \mathbf{y}) &#x3D; (\sum_{i&#x3D;1}^{n}{\vert x_{i} - y_{i} \rvert}^{p})^{\frac{1}{p}}<br>$$</p><h3 id="2-2-2-曼哈顿距离"><a href="#2-2-2-曼哈顿距离" class="headerlink" title="2.2.2 曼哈顿距离"></a>2.2.2 曼哈顿距离</h3><p>当 $p &#x3D; 1$ 时，闵式距离即曼哈顿距离（Manhattan distance），也就是线段对轴产生的投影的距离总和，特点是横平竖直。<br>$$<br>d(\mathbf{x}, \mathbf{y}) &#x3D; \sum_{i&#x3D;1}^{n} \lvert x_{i} - y_{i} \rvert<br>$$<br><img src="/../../../ai_assets/03_manhattan.png"></p><h3 id="2-2-3-欧几里得距离"><a href="#2-2-3-欧几里得距离" class="headerlink" title="2.2.3 欧几里得距离"></a>2.2.3 欧几里得距离</h3><p>当 $p &#x3D; 2$ 时，闵式距离即欧几里得距离（Euclidean distance），也就是现实意义上两点之间的距离。<br>$$<br>d(\mathbf{x}, \mathbf{y}) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n}(x_{i} - y_{i})^{2}}<br>$$<br><img src="/../../../ai_assets/03_oujilide.png"></p><h3 id="2-2-4-切比雪夫距离"><a href="#2-2-4-切比雪夫距离" class="headerlink" title="2.2.4 切比雪夫距离"></a>2.2.4 切比雪夫距离</h3><p>当 $p\to\infty$ 时，闵式距离即切比雪夫距离，即每个轴上投影的最大值。<br>$$<br>d(\mathbf{x}, \mathbf{y}) &#x3D; \underset{i}{max}(\lvert x_{i} - y_{i} \rvert)<br>$$</p><p><img src="/../../../ai_assets/03_chebyshev.png"></p><h1 id="3-特征预处理"><a href="#3-特征预处理" class="headerlink" title="3 特征预处理"></a>3 特征预处理</h1><p>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响（支配）目标结果，使得一些模型（算法）无法学习到其它的特征。</p><h2 id="3-1-归一化"><a href="#3-1-归一化" class="headerlink" title="3.1 归一化"></a>3.1 归一化</h2><p><strong>归一化 (Normalization)</strong> 将数据缩放到一个固定的范围<code>[mi, mx]</code>，最常见的是 <strong>[0, 1]</strong> 之间。<br>常用方法：Min-Max Scaling (最小-最大缩放)</p><ol><li>缩放到<code>[0, 1]</code>（把$x$到$min$的距离映射到整个范围$max-min$内）<br>$$<br>X’&#x3D;\frac{x-min}{max-min}<br>$$</li><li>映射到<code>[mi, mx]</code>范围内（把$X’$放缩$mx-mi$倍，再偏移$mi$）<br>$$<br>X’’&#x3D;X’·(mx-mi)+mi<br>$$</li></ol><p>API实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><br><span class="hljs-comment"># 创建归一化对象，feature_range控制范围[mi, mx]</span><br>mms = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 对数据进行归一化</span><br><span class="hljs-comment"># fit_transform: 通常用于训练集，同时完成transform()和fit()</span><br><span class="hljs-comment"># transform: 通常用于测试集或新数据，使用之前训练集的参数直接transform()</span><br>X_train = mms.fit_transform(X_train)<br>X_test = mms.transform(X_test)<br></code></pre></td></tr></table></figure><ul><li>优点：保留了数据的原始分布</li><li>缺点：对异常值非常敏感，如果存在极端值，会使大部分数据压缩到很小的范围内</li></ul><h2 id="3-2-标准化"><a href="#3-2-标准化" class="headerlink" title="3.2 标准化"></a>3.2 标准化</h2><p><strong>标准化 (Standardization)</strong> 是将数据缩放成<strong>均值为 0，标准差为 1</strong>的分布。<br>$$<br>X’&#x3D;\frac{X-μ}{σ}<br>$$</p><p>其中$μ$为均值(mean)，$σ$为标准差(std)，先减掉均值变为均值为0，再除掉标准差放缩到标准差为1。</p><p>API实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br><span class="hljs-comment"># 创建标准化对象</span><br>ss = StandardScaler()<br><br><span class="hljs-comment"># 对数据进行标准化</span><br><span class="hljs-comment"># fit_transform: 通常用于训练集，同时完成transform()和fit()</span><br><span class="hljs-comment"># transform: 通常用于测试集或新数据，使用之前训练集的参数直接transform()</span><br>X_train  = ss.fit_transform(X_train)<br>X_test = ss.transform(X_test)<br><br><span class="hljs-comment"># 查看原始数据均值、标准差和方差</span><br><span class="hljs-built_in">print</span>(ss.mean_)<br><span class="hljs-built_in">print</span>(ss.scale_)<br><span class="hljs-built_in">print</span>(ss.var_)<br></code></pre></td></tr></table></figure><ul><li>优点：对异常值没那么敏感</li><li>缺点：标准化假设数据服从或近似服从正态分布。如果数据分布与正态分布相差较大，标准化后的效果可能不理想，甚至会适得其反，改变了数据的原始分布</li></ul><h2 id="3-3-独热编码"><a href="#3-3-独热编码" class="headerlink" title="3.3 独热编码"></a>3.3 独热编码</h2><p>对于类别型（category）特征，整数编码会被视为有序数值，导致距离的错误计算，比如红色&#x3D;1，黄色&#x3D;2，绿色&#x3D;3，红色和绿色直接的距离并不比红色和黄色之间远，它们之间都是平等的类别。<br>使用<strong>独热编码（One-Hot Encoding）</strong> 可将类别特征转换为二元向量，消除虚假的顺序关系。</p><table><thead><tr><th align="center">颜色_红色</th><th align="center">颜色_黄色</th><th align="center">颜色_绿色</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><br><span class="hljs-comment"># 创建独热编码对象，删除转换后的第一列</span><br>onehot = OneHotEncoder(drop_first=<span class="hljs-literal">True</span>)<br><br>X_train = onehot.fit_transform(X_train)<br>X_test = onehot.transform(X_test)<br></code></pre></td></tr></table></figure><p><strong>多重共线性</strong>是指特征之间存在高度线性相关关系的现象，上述例子中：<br>$$颜色_红色 + 颜色_黄色 + 颜色_绿色 &#x3D; 1$$<br>这种完全线性相关关系会导致特征矩阵的列之间存在完美共线性，模型参数估计会变得不稳定（矩阵不可逆或接近奇异），导致系数估计值方差增大、模型可解释性下降、过拟合等问题。</p><p>使用 <code>drop=&quot;first&quot;</code> 删掉第一列不仅能打破这种多重共线性，还能减少冗余特征，提升计算效率。</p><p>也可以使用 <code>pd.get_dummies(df)</code> 实现独热编码，返回 DataFrame，可读性更强。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.get_dummies(df, drop_first=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-标签编码"><a href="#3-4-标签编码" class="headerlink" title="3.4 标签编码"></a>3.4 标签编码</h2><p><strong>标签编码器（LabelEncoder）</strong> 将类别特征中的每个类别映射为一个唯一数字，比如将 “红色”、”绿色”、”蓝色” 分别编码为 0、1、2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder<br><br>X_train = [<span class="hljs-string">&#x27;蓝色&#x27;</span>, <span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-string">&#x27;黄色&#x27;</span>, <span class="hljs-string">&#x27;红色&#x27;</span>, <span class="hljs-string">&#x27;蓝色&#x27;</span>]<br><br>le = LabelEncoder()<br>X_train = le.fit_transform(X_train)<br>X_test = le.transform(X_test)<br><br>X_train<br><span class="hljs-comment"># array([1, 0, 2, 0, 1])</span><br></code></pre></td></tr></table></figure><h2 id="3-5-列转换器"><a href="#3-5-列转换器" class="headerlink" title="3.5 列转换器"></a>3.5 列转换器</h2><p><strong>列转换器 (ColumnTransformer)</strong> 可以在同一个数据集中，对不同类型的列（例如数值型、类别型、文本型）应用不同的预处理方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.compose <span class="hljs-keyword">import</span> ColumnTransformer<br><br>numerical_features = [<span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;收入&#x27;</span>]<br>categorical_features = [<span class="hljs-string">&#x27;职业&#x27;</span>, <span class="hljs-string">&#x27;婚姻状况&#x27;</span>]<br><br><span class="hljs-comment"># 创建列转换器</span><br>ct = ColumnTransformer(<br>    transformers=[<br>        <span class="hljs-comment"># 对数值型列进行标准化</span><br>        (<span class="hljs-string">&#x27;num&#x27;</span>, StandardScaler(), numerical_features),  <br>        <span class="hljs-comment"># 对类别型列进行独热编码</span><br>        (<span class="hljs-string">&#x27;cat&#x27;</span>, OneHotEncoder(drop_first=<span class="hljs-literal">True</span>), categorical_features) <br>    ],<br>    remainder=<span class="hljs-string">&#x27;passthrough&#x27;</span>  <span class="hljs-comment"># 其余列不进行处理</span><br>)<br><br>X_train = ct.fit_transform(X_train)<br>X_test = ct.transform(X_test)<br></code></pre></td></tr></table></figure><h1 id="4-模型训练"><a href="#4-模型训练" class="headerlink" title="4 模型训练"></a>4 模型训练</h1><h2 id="4-1-数据集的加载"><a href="#4-1-数据集的加载" class="headerlink" title="4.1 数据集的加载"></a>4.1 数据集的加载</h2><p>首先从<code>scikit-learn</code>加载鸢尾花数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><br><span class="hljs-comment"># 加载数据集</span><br>iris = load_iris()<br><br><span class="hljs-comment"># 特征（150行4列的二维数组，分别是花萼长、花萼宽、花瓣长、花瓣宽）</span><br>X = iris[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-comment"># 标签（150个元素的一维数组，包含0、1、2三个值分别代表三种鸢尾花）</span><br>y = iris[<span class="hljs-string">&#x27;target&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="4-2-数据集的划分"><a href="#4-2-数据集的划分" class="headerlink" title="4.2 数据集的划分"></a>4.2 数据集的划分</h2><p>通过<code>scikit-learn</code>的封装好的函数<code>train_test_split</code>可以很方便地划分训练集和测试集，函数返回一个四元组，分别代表训练特征、测试特征、训练标签、测试标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-comment"># random_state 可以设定随机种子，生成相同的随机划分</span><br><span class="hljs-comment"># stratify 可以分层抽样，保持原有分布</span><br>X_train, X_test, y_train, y_test =<br>train_test_split(X, y, train_size=<span class="hljs-number">0.8</span>, random_state=<span class="hljs-number">18</span>, stratify=y)<br></code></pre></td></tr></table></figure><h2 id="4-3-分类实现"><a href="#4-3-分类实现" class="headerlink" title="4.3 分类实现"></a>4.3 分类实现</h2><p>若样本类别不均衡，可设置<code>weights=&#39;distance&#39;</code>以降低稀有类样本的误判风险。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br><span class="hljs-comment"># 创建模型</span><br>model = KNeighborsClassifier()<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 模型预测</span><br>y_pred = model.predict(X_test)<br></code></pre></td></tr></table></figure><h2 id="4-4-回归实现"><a href="#4-4-回归实现" class="headerlink" title="4.4 回归实现"></a>4.4 回归实现</h2><p>KNN通常用来解决分类任务，不过也可以解决回归任务，通过计算k近邻的平均或加权平均值，来获得新实例目标值的预测。</p><p>KNN 回归模型计算复杂度较高，而且对噪声数据非常敏感，在很多时候它并不是一个很好的选择，KNN回归通常适用于非线性关系明显且数据量不大的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br><br><span class="hljs-comment"># 创建模型</span><br>model = KNeighborsRegressor()<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 模型预测</span><br>y_pred = model.predict(X_test)<br></code></pre></td></tr></table></figure><blockquote><p>即便只有一个特征，也要将X处理为二维数组，因为<code>fit</code>不能接收一维数组作为第一个参数，可以使用<code>reshape(-1, 1)</code>将一维数组转化为n行1列的二维数组，其中<code>-1</code>表示自动计算。</p></blockquote><h1 id="5-模型评估"><a href="#5-模型评估" class="headerlink" title="5 模型评估"></a>5 模型评估</h1><h2 id="5-1-准确率-accuracy"><a href="#5-1-准确率-accuracy" class="headerlink" title="5.1 准确率(accuracy)"></a>5.1 准确率(accuracy)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.score(X_test, y_test)<br></code></pre></td></tr></table></figure><p>不能仅凭准确率判断模型好坏，因为类别不平衡的时候会干扰判断，此外还有查准率(精确率, Precision)、查全率(召回率, Recall)、F1-score等指标。</p><h2 id="5-2-混淆矩阵"><a href="#5-2-混淆矩阵" class="headerlink" title="5.2 混淆矩阵"></a>5.2 混淆矩阵</h2><p>多分类问题中，混淆矩阵的行数和列数都等于类别数，也就是$n×n$的方阵，行表示真实标签，列表示预测标签。</p><ul><li><code>confusion_matrix</code>：生成分类模型混淆矩阵</li><li><code>classification_report</code>：生成分类模型评估报告<ul><li><strong>precision</strong>: 精确率</li><li><strong>recall</strong>: 召回率</li><li><strong>f1-score</strong>: F1度量</li><li><strong>support</strong>: 样本支持数</li><li><strong>accuracy</strong>: 准确率</li><li><strong>macro avg</strong>: 宏平均，每个类别的性能平均值</li><li><strong>weighted avg</strong>: 加权平均，根据每个标签的比例进行加权平均</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix, classification_report<br><br><span class="hljs-comment"># 混淆矩阵</span><br><span class="hljs-built_in">print</span>(confusion_matrix(y_test, y_pred))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">array([[ 8, 0, 0], </span><br><span class="hljs-string">       [ 0, 11, 0], </span><br><span class="hljs-string">       [ 0, 1, 10]])</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 评估报告</span><br><span class="hljs-built_in">print</span>(classification_report(y_test, y_pred))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">             precision    recall    f1-score    support </span><br><span class="hljs-string">        0.0     1.00       1.00       1.00         8 </span><br><span class="hljs-string">        1.0     0.92       1.00       0.96        11 </span><br><span class="hljs-string">        2.0     1.00       0.91       0.95        11 </span><br><span class="hljs-string">          </span><br><span class="hljs-string">accuracy                              0.97        30 </span><br><span class="hljs-string">macro avg       0.97       0.97       0.97        30 </span><br><span class="hljs-string">weighted avg    0.97       0.97       0.97        30</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>使用热力图可视化混淆矩阵：</p><ul><li><code>confusion_matrix()</code>：计算混淆矩阵</li><li><code>heatmap()</code>：绘制热力图<ul><li><code>annot</code>：每个单元格显示数值</li><li><code>cmap</code>：热力图颜色</li><li><code>xticklabels</code>&#x2F;<code>yticklabels</code>：坐标轴标签<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix<br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>]<br><br>cm = confusion_matrix(y_test, y_pred)<br><br>sns.heatmap(cm, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">&#x27;Blues&#x27;</span>,<br>            xticklabels=iris[<span class="hljs-string">&#x27;target_names&#x27;</span>], <br>            yticklabels=iris[<span class="hljs-string">&#x27;target_names&#x27;</span>])<br>            <br>plt.title(<span class="hljs-string">&#x27;混淆矩阵热力图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;预测标签&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;实际标签&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/../../../ai_assets/03_heatmap.png"></li></ul></li></ul><h1 id="6-参数调优和网格搜索"><a href="#6-参数调优和网格搜索" class="headerlink" title="6 参数调优和网格搜索"></a>6 参数调优和网格搜索</h1><p>使用<code>scikit-learn</code>的<code>KNeighborsClassfier</code>创建分类器模型时，可以对模型的超参数进行设定，主要有以下几个参数：</p><ol><li><code>n_neighbors</code>：近邻的数量，就是 KNN 算法中 K 的值。</li><li><code>weights</code>：可以选择 <code>uniform</code>或 <code>distance</code>，前者表示所有样本的权重相同，后者表示距离越近权重越高，默认值是 <code>uniform</code>。当然，我们也可以通过传入自定义的函数来确定每个样本的权重。</li><li><code>algorithm</code>：有 <code>auto</code>、<code>ball_tree</code>、<code>kd_tree</code>、<code>brute</code>四个选项，默认值为 <code>auto</code>。其中 <code>ball_tree</code>是一种树形结构，基于球体划分的方法将数据点分配到层次化的树结构中，在高维数据和稀疏数据场景下有较好的性能；<code>kd_tree</code>也是一种树形结构，通过选择一个维度将空间划分为若干个子区域再进行搜索，从而避免跟所有的邻居进行比较，对于低维度和空间分布均匀的数据，后者有较好的效果，在高维空间中会遇到的维度灾难问题；<code>auto</code>选项是根据输入数据的维度自动选择 <code>ball_tree</code>或 <code>kd_tree</code>；<code>brute</code>选项则是使用暴力搜索算法（穷举法），再处理小数据集时，它是一个简单且有效的选择。</li><li><code>leaf_size</code>：使用 <code>ball_tree</code>或 <code>kd_tree</code>算法时，该参数用于限制树结构叶子节点最大样本数量，默认值为 <code>30</code>，该参数会影响树的构建和节点查找的性能。</li><li><code>p</code>：闵可夫斯基距离公式中的 <code>p</code>，默认值为2，计算欧氏距离。</li></ol><p>手动调整费时费力，可以使用 <strong>网格搜索(Grid Search) 和 交叉验证(Cross Validation)</strong> 对模型的超参数进行调整。</p><ul><li>网格搜索：通过穷举法遍历给定的超参数空间</li><li>交叉验证：通常使用K-fold CV，划分K折，每次使用1折做测试集，重复K次</li></ul><p><img src="/../../../ai_assets/03_kfold.png"></p><p>API实现：</p><ul><li><code>GridSearchCV</code>：<ul><li><code>estimator</code>：要优化的模型</li><li><code>param_grid</code>：超参数搜索空间，是字典，键为超参数，值为超参数取值列表</li><li><code>cv</code>：交叉验证的折数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br><span class="hljs-comment"># 网格搜索交叉验证</span><br>gs = GridSearchCV(<br>    estimator=KNeighborsClassifier(),<br>    param_grid=&#123;<br>        <span class="hljs-string">&quot;n_neighbors&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>],<br>        <span class="hljs-string">&quot;weights&quot;</span>: [<span class="hljs-string">&#x27;uniform&#x27;</span>, <span class="hljs-string">&#x27;distance&#x27;</span>],<br>        <span class="hljs-string">&#x27;p&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>    &#125;,<br>    cv=<span class="hljs-number">5</span><br>)<br><br><span class="hljs-comment"># 在训练集上进行网格搜索</span><br>gs.fit(X_train, y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最佳参数：&#x27;</span>, gs.best_params_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最佳得分：&#x27;</span>, gs.best_score_)<br><br><span class="hljs-comment"># 最佳模型</span><br>best_model = gs.best_estimator_<br><br><span class="hljs-comment"># 直接使用最佳模型进行预测</span><br>gs.predict(X_test)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="7-模型保存和加载"><a href="#7-模型保存和加载" class="headerlink" title="7 模型保存和加载"></a>7 模型保存和加载</h1><p>保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> joblib<br><br>joblib.dump(model, <span class="hljs-string">&#x27;model/model_name.pkl&#x27;</span>)<br></code></pre></td></tr></table></figure><p>加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = joblib.load(<span class="hljs-string">&#x27;model/model_name.pkl&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="8-手撕KNN"><a href="#8-手撕KNN" class="headerlink" title="8 手撕KNN"></a>8 手撕KNN</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-comment"># 1.数据加载</span><br><br>iris = load_iris()<br><span class="hljs-comment"># 特征（150行4列的二维数组，分别是花萼长、花萼宽、花瓣长、花瓣宽）</span><br>X = iris[<span class="hljs-string">&#x27;data&#x27;</span>]<br><span class="hljs-comment"># 标签（150个元素的一维数组，包含0、1、2三个值分别代表三种鸢尾花）</span><br>y = iris[<span class="hljs-string">&#x27;target&#x27;</span>]<br><span class="hljs-comment"># 拼接为一个数组</span><br>data = np.hstack([X, y.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2.数据集划分</span><br><br><span class="hljs-comment"># 在原数组内随机打乱</span><br>np.random.shuffle(data)<br><br><span class="hljs-comment"># 设定训练集大小</span><br>train_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(X) * <span class="hljs-number">0.8</span>)<br><br><span class="hljs-comment"># 索引切片划分训练集和测试集</span><br>X_train, X_test = data[:train_size, :-<span class="hljs-number">1</span>], data[train_size:, :-<span class="hljs-number">1</span>]<br>y_train, y_test = data[:train_size, -<span class="hljs-number">1</span>], data[train_size:, -<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3.计算欧氏距离函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_distance</span>(<span class="hljs-params">u, v</span>):    <br>    <span class="hljs-string">&quot;&quot;&quot;计算n维向量的欧氏距离&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> np.sqrt(np.<span class="hljs-built_in">sum</span>((u - v) ** <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 4.预测单个向量的标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_label</span>(<span class="hljs-params">X_train, y_train, X_one, k</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据历史数据的k个最近邻生成标签</span><br><span class="hljs-string">    param:</span><br><span class="hljs-string">        X_train: 训练集特征</span><br><span class="hljs-string">        y_train: 训练集标签</span><br><span class="hljs-string">        X_one: 待预测的样本特征</span><br><span class="hljs-string">        k: k个最近邻</span><br><span class="hljs-string">    return: 为待预测样本生成的特征</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 遍历求解每个训练集与待测样本的距离</span><br>    dis = [get_distance(X, X_one) <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> X_train]<br><br>    <span class="hljs-comment"># 求解前k个最近邻的标签</span><br>    labels = y_train[np.argpartition(dis, k)[:k]]<br><br>    <span class="hljs-comment"># 返回k个最近邻标签的众数</span><br>    <span class="hljs-keyword">return</span> stats.mode(labels).mode<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 5.预测输入数据集的标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X_train, y_train, X_in, k=<span class="hljs-number">5</span></span>):<br>    <span class="hljs-keyword">return</span> [make_label(X_train, y_train, X, k) <span class="hljs-keyword">for</span> X <span class="hljs-keyword">in</span> X_in]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_机器学习概览</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p><strong>机器学习</strong>：利用经验改善系统自身的性能。</p><blockquote><p>任何经验在计算机内都以数据形式存在。</p></blockquote><p>计算问题分类：</p><ul><li>P问题：可以在多项式时间（合理时间）内求解</li><li>NP问题：在多项式时间内求不出答案，但可以验证一个解</li></ul><p>在计算学习理论当中，有一个很重要的理论模型<strong>PAC模型</strong>。</p><p>如果对于任意小的：</p><ul><li>误差上限 $ε&gt;0$（表示学得多接近真理）</li><li>置信下限 $1−δ$（表示学得多可靠）</li></ul><p>存在一个多项式时间算法，能从有限样本中学到一个假设 $h$，满足：<br>$$<br>{P(error(h)≤ε)≥1−δ}<br>$$<br>也就是说：以至少 $1−δ$ 的概率，学到的模型错误率不超过 $ε$。</p><p>机器学习面对的很多问题，既不是P问题也不是NP问题，这些问题通常是可验证的优化问题，只能从数据中学到<strong>近似最优解</strong>（高概率正确）。</p><h2 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h2><h3 id="1-2-1-数据基本概念"><a href="#1-2-1-数据基本概念" class="headerlink" title="1.2.1 数据基本概念"></a>1.2.1 数据基本概念</h3><ul><li>**标签(label)&#x2F;目标(target)**：模型要预测的结果</li><li>**特征(feature)&#x2F;属性(attribute)**：从数据中抽取出来的，对结果预测有用的信息</li><li>**示例(instance)**：一个具体的输入对象，即一行特征数据，不包含标签。</li><li>**样例(example)**：带有标签的一行数据</li><li>**样本(sample)**：一行或几行，或整个数据集都可以叫样本</li></ul><p><img src="/../../../ai_assets/01_sample.png"></p><h3 id="1-2-2-数据集与空间映射"><a href="#1-2-2-数据集与空间映射" class="headerlink" title="1.2.2 数据集与空间映射"></a>1.2.2 数据集与空间映射</h3><ul><li>**参数(parameter)**：模型通过训练自动学习得到的数值，用于描述模型本身</li><li>**超参数(hyperparameter)**：训练开始前人为设定的参数，控制模型的学习过程或结构，不会在训练中自动学习</li><li>数据集：<ul><li>**训练集(training set)**：用来训练模型的数据</li><li>**验证集(validation set)**：用于调参或选择模型</li><li>**测试集(testing set)**：用来测试模型的数据</li></ul></li><li>机器学习的目标就是**学习一个映射函数$f: \mathcal{X} \rightarrow \mathcal{Y}$*<em>，逼近真实映射函数$f^</em>: \mathcal{X} \rightarrow \mathcal{Y}$<ul><li>属性空间&#x2F;特征空间&#x2F;输入空间：输入特征的所有可能取值集合$\mathcal{X}$</li><li>标签空间&#x2F;目标空间&#x2F;输出空间：输出结果的所有可能取值集合$\mathcal{Y}$</li></ul></li><li>**特征向量(feature vector)**：所有特征表示为向量形式，示例在属性空间中的一个点</li></ul><h3 id="1-2-3-模型相关"><a href="#1-2-3-模型相关" class="headerlink" title="1.2.3 模型相关"></a>1.2.3 模型相关</h3><p>机器学习就是：学习器(learner)基于已标注数据(ground truth)，在假设空间中寻找最优假设(hypothesis)，使其在未知样本上尽可能逼近真实规律(true function)。</p><ul><li>**真相函数(true function)**：世界的真实规律，不可知</li><li>**真值(ground truth)**：我们已知的、标注好的真实标签</li><li>**学习器(learner)**：训练算法，从数据中学习规律，寻找最优假设</li><li>**假设(hypothesis)**：学习器学出来的近似函数，用来逼近真值</li><li>**模型(Model)**：一个机器学习算法与训练后的参数集合，用于进行预测或分类</li></ul><h3 id="1-2-4-任务类型"><a href="#1-2-4-任务类型" class="headerlink" title="1.2.4 任务类型"></a>1.2.4 任务类型</h3><ul><li>**分类(classification)**：根据输入特征，预测离散的类别标签<ul><li>二分类：判断样本属于两种类别中的哪一种，如猫&#x2F;狗<ul><li>正类：我们关注的目标类，通常用标签1表示，如患病</li><li>反类：与正类相对的非目标类，通常用标签0表示，如健康</li><li>正&#x2F;反类是人为定义的，没有绝对好坏，根据视角不同，可以调换</li></ul></li><li>多分类：判断样本属于多个类别中的哪一种，如猫&#x2F;狗&#x2F;鸟</li></ul></li><li>**回归(regression)**：根据输入特征，预测一个连续数值，如预测房价</li></ul><h3 id="1-2-5-监督范式"><a href="#1-2-5-监督范式" class="headerlink" title="1.2.5 监督范式"></a>1.2.5 监督范式</h3><ul><li><strong>监督学习(Supervised Learning)<strong>：用带标签的数据来训练模型，学习输入与输出的映射，常用于</strong>分类</strong>和<strong>回归</strong>任务</li><li><strong>无监督学习(Unsupervised Learning)<strong>：数据没有标签，模型要自己发现规律或结构，常用于</strong>聚类</strong>和<strong>降维</strong>任务</li><li>**半监督学习(Semi-supervised Learning)**：只有少量样本带标签，通过少量监督信息引导整体学习</li><li>**强化学习(Reinforcement Learning)**：模型通过与环境交互、不断试错，根据奖励信号优化策略，以获得最大奖励</li></ul><h3 id="1-2-6-理论基础与泛化"><a href="#1-2-6-理论基础与泛化" class="headerlink" title="1.2.6 理论基础与泛化"></a>1.2.6 理论基础与泛化</h3><ul><li>独立同分布(i.i.d.)：大多数机器学习理论的基本假设<ol><li>独立 (independent)：每个样本的生成不依赖其他样本</li><li>同分布 (identically distributed)：所有样本都来自同一个概率分布</li></ol></li><li>未见样本(unseen instance)：模型在训练时没有见过的样本</li><li>未知分布：训练集和测试集都是从这个分布抽样的，机器学习的目标就是学习到一个模型，使它对这个未知分布的整体表现尽可能好</li><li>**泛化(generalization)**：模型在未见样本上的表现能力</li></ul><h3 id="1-2-7-学习理论"><a href="#1-2-7-学习理论" class="headerlink" title="1.2.7 学习理论"></a>1.2.7 学习理论</h3><ul><li>归纳偏好：学习器在多种可能假设中倾向选择某一类假设的偏好，是学习的前提</li><li>**无免费午餐定理(No Free Lunch, NFL)**：对所有可能的数据分布而言，没有任何算法在所有任务上都优于其他算法，如果一个算法在某些任务上表现好，那它必然在其他任务上表现差</li></ul><blockquote><p>NFL定理的前提是所有问题出现的机会相同，或所有问题同样重要。脱离具体问题，空谈什么算法好没有意义。</p></blockquote><h1 id="2-模型评估与选择"><a href="#2-模型评估与选择" class="headerlink" title="2 模型评估与选择"></a>2 模型评估与选择</h1><p>奥卡姆剃刀原则主张在有多个同样有效的解释时，应选择最简单的那个解释。核心理念是“如无必要，勿增实体”。但判断什么样的模型算简单这个问题并不简单。</p><h2 id="2-1-误差和过拟合"><a href="#2-1-误差和过拟合" class="headerlink" title="2.1 误差和过拟合"></a>2.1 误差和过拟合</h2><p>经验误差并不是越低越好，如果太低可能会导致过拟合，使泛化误差升高。</p><ul><li>经验误差：在训练集上的误差</li><li>泛化误差：在未来样本上的误差</li></ul><p>**过拟合(overfitting)**：模型在训练集上学得太好，甚至记住了噪声或偶然特征，导致在训练集表现好、测试集表现差。<br>**欠拟合(underfitting)**：模型对训练数据学习不足，连训练集都拟合不好，模型太简单、能力不够，无法捕捉数据中的真实规律。<br><img src="/../../../ai_assets/01_fitting.png"></p><p>如何获得测试结果？评估方法<br>如何评估性能优劣？性能度量<br>如何判断实质差别？比较检验</p><h2 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h2><p>模型训练流程：</p><ol><li>初始划分：将原始数据划分为训练集 + 验证集 + 测试集。</li><li>模型训练阶段：在<strong>训练集</strong>上训练模型，在<strong>验证集</strong>上调参、选择最优模型结构，训练过程中验证集不参与梯度更新，只是用来评估。</li><li>模型选择阶段：使用验证集表现最好的参数，重新用<strong>训练集 + 验证集</strong>合并训练一次，得到最终模型。</li><li>模型评估阶段：用<strong>测试集</strong>测试模型性能，测试集只用于一次性、最终评估，不能再回头调参。</li><li>模型部署阶段：最终确认算法后，可以用全量数据（<strong>训练+验证+测试</strong>）重新训练一个生产模型，使模型能利用所有可用数据进行学习。</li></ol><h3 id="2-2-1-留出法-Hold-out"><a href="#2-2-1-留出法-Hold-out" class="headerlink" title="2.2.1 留出法(Hold-out)"></a>2.2.1 留出法(Hold-out)</h3><p><strong>核心思想</strong>：将数据随机分成多个部分，一部分用于训练模型，另一部分用于验证和测试模型。它既可用于模型评估，也可用于模型选择。</p><p><strong>优点</strong>：简单、计算量小，适合大数据集。<br><strong>缺点</strong>：对数据划分方式敏感，数据量少时，训练集和测试集都可能不足。</p><p>注意：</p><ul><li>保证数据分布一致性，例如使用分层采样</li><li>多次重复划分，例如100次随机划分</li><li>测试集要适中，太大影响模型训练效果，太小影响模型测试效果</li></ul><blockquote><p>常见比例：</p><ul><li>训练集 : 测试集 &#x3D; 7 : 3 或 8 : 2</li><li>三划分时：训练 6，验证 2，测试 2</li></ul></blockquote><p>模型评估：<br><img src="/../../../ai_assets/01_holdout_test.png"></p><p>模型选择：<br><img src="/../../../ai_assets/01_holdout_validation.png"></p><h3 id="2-2-2-交叉验证法-Cross-Validation-CV"><a href="#2-2-2-交叉验证法-Cross-Validation-CV" class="headerlink" title="2.2.2 交叉验证法(Cross Validation, CV)"></a>2.2.2 交叉验证法(Cross Validation, CV)</h3><p><strong>核心思想</strong>：将数据划分为 K 个折（fold），每次用 K−1 折训练、剩下 1 折测试，循环 K次，<strong>每个子集都做一次测试集</strong>，取平均度量作为性能估计。</p><p>常见形式：</p><ul><li>**K折交叉验证(K-Fold CV)**：最常见，K一般取10，还有5、20等</li><li>**留一法(Leave-One-Out, LOO)**：K &#x3D; 样本数，每次只留 1 个样本作验证</li></ul><p><strong>优点</strong>：每个样本都参与训练与验证，充分利用数据，评估结果稳定可靠<br><strong>缺点</strong>：计算成本高</p><p><img src="/../../../ai_assets/01_kfold.png"></p><h3 id="2-2-3-自助法-Bootstrap"><a href="#2-2-3-自助法-Bootstrap" class="headerlink" title="2.2.3 自助法(Bootstrap)"></a>2.2.3 自助法(Bootstrap)</h3><p>当数据集非常小，以至于划分训练&#x2F;测试集都感觉很奢侈时，自助法就派上用场了。</p><p><strong>核心思想</strong>：从原始数据集中进行<strong>有放回采样</strong>，形成与原数据等大小的训练集。从未被采样过的样本称为袋外(out-of-bag, OOB)测试集，每次自主采样约有 36.8% 成为 OOB。</p><p><strong>优点</strong>：在数据集较小、难以有效划分训练&#x2F;测试集时非常有用<br><strong>缺点</strong>：有放回采样，改变了原始数据集的分布</p><p><img src="/../../../ai_assets/01_bootstrap.png"></p><h2 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h2><h3 id="2-3-1-回归任务-Regression"><a href="#2-3-1-回归任务-Regression" class="headerlink" title="2.3.1 回归任务(Regression)"></a>2.3.1 回归任务(Regression)</h3><ul><li><strong>均方误差 (Mean Squared Error, MSE)<strong>：每个样本的</strong>预测值与真实值之差的平方</strong>的平均值。<br>$$<br>{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \hat{y}_i)^2<br>$$</li></ul><p>MSE 对误差进行平方，因此对<strong>异常值非常敏感</strong>。MSE的值越小，说明模型的预测越精准，性能越好。</p><ul><li>**均方根误差(Root Mean Squared Error, RMSE)**：均方根误差是均方误差的平方根。<br>$$<br>RMSE&#x3D;\sqrt{MSE}&#x3D;\sqrt{\frac{1}{n}\sum_{i&#x3D;1}^{n}(y_i−\hat{y}_i)^2}<br>$$</li></ul><p>RMSE 同样对<strong>大误差</strong>敏感，因为它是在 MSE 的基础上计算得到的，优势在于与目标的量纲一致。如果一味地降低 RMSE，可能会导致模型对异常值也拟合度很高，容易过拟合。</p><ul><li>**平均绝对误差(Mean Absolute Error, MAE)**：预测值与真实值差的绝对值的平均值。<br>$$<br>MAE&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^{n}|y_i-\hat{y}_i|<br>$$</li></ul><p>MAE 对所有误差都给予相同的权重，因此对<strong>异常值</strong>不敏感，并且和目标量纲一致。</p><blockquote><p>如果希望模型对异常值更加敏感，可以选择 MSE 或 RMSE。RMSE 比 MSE 更易于解释。<br>如果希望模型对异常值不敏感，可以选择 MAE。<br>在实际应用中，通常会同时考虑这三个指标，以便更全面地评估模型的性能。</p></blockquote><h3 id="2-3-2-分类任务-Classification"><a href="#2-3-2-分类任务-Classification" class="headerlink" title="2.3.2 分类任务(Classification)"></a>2.3.2 分类任务(Classification)</h3><p>**混淆矩阵(Confusion Matrix)**：正类为 Positive (P)，负类为 Negative (N)。<br>总样本数 $n&#x3D;TP+TN+FP+FN$。</p><table><thead><tr><th align="left">真实类别</th><th align="left">预测为正例</th><th align="left">预测为反例</th></tr></thead><tbody><tr><td align="left"><strong>正例 (P)</strong></td><td align="left">真正例(True Positive, TP)</td><td align="left">假反例(False Negative, FN)</td></tr><tr><td align="left"><strong>反例 (N)</strong></td><td align="left">假正例(False Positive, FP)</td><td align="left">真反例(True Negative, TN)</td></tr></tbody></table><ul><li><p>**精度(Accuracy)**：预测正确的比例。<br>$$<br>Accuracy&#x3D;\frac{TP+TN}{n}​<br>$$</p></li><li><p>**错误率(Error)**：预测错误的比例。<br>$$<br>Error&#x3D;\frac{FP+FN}{n}&#x3D;1−Accuracy<br>$$</p></li><li><p>**查准率(Precision)**：预测为正例的样本中，真正为正的比例，衡量模型预测的准不准。<br>$$<br>Precision&#x3D;\frac{TP}{TP+FP}​<br>$$</p></li></ul><p>核心特点：宁缺毋滥。<br>查准率高，意味着模型在说一个样本是正例时，有很高的可信度。<strong>误报代价高</strong>时更关心，比如垃圾邮件检测。</p><ul><li>**查全率&#x2F;召回率(Recall)**：真正的正例中，被模型判正的比例，衡量模型找得全不全。<br>$$<br>Recall&#x3D;\frac{TP}{TP+FN}<br>$$</li></ul><p>核心特点：宁多报不漏报。<br>查全率高，意味着模型能够把绝大多数的正例都找出来，很少漏掉。<strong>漏报代价高</strong>时更关心，比如病毒检测。</p><ul><li><p>**F1度量(F1-score)**：查准率和查全率是相互制约的，需要一个综合性的指标来平衡它们，F1度量就是它们的调和平均数，同时兼顾了查准率和查全率。<br>$$<br>\frac{1}{F_1}&#x3D;\frac{1}{2}·(\frac{1}{Precision}+\frac{1}{Recall})<br>$$<br>得&#x3D;&gt;<br>$$<br>F_1​&#x3D;2\cdot\frac{Precision\cdot Recall}{Precision+Recall}<br>$$</p></li><li><p><strong>F-beta度量</strong>：不平衡场景可用加权的 $F_\beta$​ 强调召回或查准。<br>$$<br>F_\beta&#x3D;(1+\beta^2)⋅\frac{PR}{\beta^2P+R}​<br>$$</p></li><li><p>当 $\beta&gt;1$ 时，更看重Recall（如 $F_2​$ 度量）</p></li><li><p>当 $β&lt;1$ 时，更看重Precision（如 $F_{0.5}$ 度量）</p></li></ul><h2 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4 比较检验"></a>2.4 比较检验</h2><p>McNemar检验<br>于交叉验证t检验</p><h1 id="3-线性模型"><a href="#3-线性模型" class="headerlink" title="3 线性模型"></a>3 线性模型</h1><h2 id="3-1-一元线性回归"><a href="#3-1-一元线性回归" class="headerlink" title="3.1 一元线性回归"></a>3.1 一元线性回归</h2><p>一元线性回归方程：<br>$$<br>y&#x3D;{w}\boldsymbol{x}+b<br>$$<br>定义损失函数：<br>$$<br>L(w, b)&#x3D;\sum_{i&#x3D;1}^{m}(y_i-(wx+b))^2<br>$$<br>对损失函数进行最小二乘估计，分别对 $w$ 和 $b$ 求偏导，令导数等于 0，得到闭式(closed-form)解：<br>$$<br>w&#x3D;\frac{\sum_{i&#x3D;1}^{m}y_i(x_i-\bar{x})}{\sum_{i&#x3D;1}^{m}x_i^2-\frac{1}{m}(\sum_{i&#x3D;1}^{m}x_i)^2}\qquad\qquad b&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m}(y_i-wx_i)<br>$$</p><p>线性回归中，对于离散属性的处理：</p><ul><li>若有“序”，则连续化，如高、中、低，可以转为0，1，2</li><li>无“序”，则转为k维向量，如红、绿、蓝，转为三个特征，<code>[1, 0, 0] [0, 1, 0] [0, 0, 1]</code></li></ul><h2 id="3-2-多元线性回归"><a href="#3-2-多元线性回归" class="headerlink" title="3.2 多元线性回归"></a>3.2 多元线性回归</h2><p>多元线性回归方程：<br>$$<br>y&#x3D;w_1x_1+w_2x_2+w_3x_3+\cdots+w_nx_n+b<br>$$<br>可以用向量简化为：$y&#x3D;\boldsymbol{w^Tx}+b$</p><p>其中$\boldsymbol{w}&#x3D;\begin{pmatrix} w_1 \ w_2 \ w_3 \ … \end{pmatrix}$，$\boldsymbol{x} &#x3D; \begin{pmatrix} x_1 \ x_2 \ x_3 \ … \end{pmatrix}$，将$\boldsymbol{w}$进行转置后和$\boldsymbol{x}$做矩阵乘法：$\boldsymbol{w^Tx}&#x3D;\begin{pmatrix} w_1 , w_2 , w_3 ,… \end{pmatrix}×\begin{pmatrix} x_1 \ x_2 \ x_3 \ … \end{pmatrix}$</p><p>还可以将 $b$ 吸收进去$\boldsymbol{w}&#x3D;\begin{pmatrix}1 \ w_1 \ w_2 \ w_3 \ … \end{pmatrix}$，$\boldsymbol{x} &#x3D; \begin{pmatrix} b \ x_1 \ x_2 \ x_3 \ … \end{pmatrix}$，简化书写为：$y&#x3D;\boldsymbol{w^Tx}$</p><p>同样采用最小二乘求解，得到解析解为：<br>$$<br>\boldsymbol{w} &#x3D; (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{y}<br>$$<br>若 $X^TX$ 不满秩，可以解出多个 $w$，此时需要设定归纳偏好，或引入正则化(regularization)。</p><blockquote><p>矩阵的转置与矩阵相乘等于 $L_2$ 范数 $||x||_2$ 的平方：$\boldsymbol{x}^T\boldsymbol{x} &#x3D; ||x||_2^2$</p></blockquote><h2 id="3-3-广义线性回归"><a href="#3-3-广义线性回归" class="headerlink" title="3.3 广义线性回归"></a>3.3 广义线性回归</h2><p>令预测值稍作变换便可得到 $y$ 的衍生物。<br>$$<br>ln,y&#x3D;w^Tx+b<br>$$<br>上述变换得到了对数线性回归(log-linear regression)，实际是用 $e^{w^Tx+b}$ 逼近$y$。</p><p>推广得到广义线性模型的一般形式，将线性回归的输出作为输入传入 $g^{-1}$ 函数：<br>$$<br>y&#x3D;g^{-1}(w^Tx+b)<br>$$</p><p>其中 $g$ 称为联系函数(link function)，是单调可微的，令 $g(·)&#x3D;ln(·)$ 则得到对数线性回归。 </p><h2 id="3-4-对数几率回归（逻辑回归）"><a href="#3-4-对数几率回归（逻辑回归）" class="headerlink" title="3.4 对数几率回归（逻辑回归）"></a>3.4 对数几率回归（逻辑回归）</h2><p>对数几率回归（逻辑回归， Logistic Regression），也称对率回归，是解决分类问题的算法。</p><p>线性回归模型 $z&#x3D;w^Tx+b$ 产生实值输出，我们期望输出 $y\in{0, 1}$ 来解决分类问题，根据上一节的描述，我们需要找到一个 $z$ 和 $y$ 的联系函数。</p><p>理想的单位阶跃函数(unit-step function)为：<br>$$<br>y&#x3D;\begin{cases}0, \qquad z&lt;0 \ 0.5, \quad; z&#x3D;0 \ 1,\qquad z&gt;0\end{cases}<br>$$<br>但是该函数分段，用不可导的点，性质不好，于是寻找替代函数：<br>$$<br>y&#x3D;\frac{1}{1+e^{-z}}<br>$$<br>该函数称为 <strong>sigmoid</strong> 函数，或 <strong>logistics</strong> 函数，具有单调可微、任意阶可微可导的性质。<br><img src="/../../../ai_assets/01_sigmoid.png"></p><p>将线性回归的输出作为输入会得到 {0, 1} 的输出。<br>$$<br>y&#x3D;\frac{1}{1+e^{-(w^Tx+b)}}<br>$$<br>即：<br>$$<br>ln\frac{y}{1-y}&#x3D;w^Tx+b<br>$$<br>根据上一节的广义线性模型，相当于用右侧的线性模型去逼近左侧的 $y$ 衍生物。</p><p>其中 $\frac{y}{1-y}$ 中的 $y$ 表示正例的可能性，$1-y$ 为负例的可能性，整体在统计学上称为几率(odds)，反映了 $x$ 作为正例的相对可能性，加上 $ln$ 称为对数几率(log odds, 亦称为 <strong>logit</strong>)，在计算机学科当中通常使用 <strong>logistics regression</strong>，建议称为对数几率回归，简称<strong>对率回归</strong>。</p><blockquote><p>注意：由于历史原因，逻辑回归本身是一个错误的翻译，<strong>Logistic</strong>并没有逻辑的意思，而是源自 <strong>Logit</strong>，不是 <strong>Logic</strong>，<strong>Logit</strong>本身来自 <strong>Log odds</strong>，也就是对数几率。</p></blockquote><p>对率回归有几大优点：</p><ul><li>不同于很多模型，无需<strong>假设数据分布</strong>，这意味着用很强的普适性</li><li>可以得到类别的近似概率预测</li><li>可用现有数值优化算法求取最优解</li></ul><h2 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h2><p>拆解法：将一个多分类任务转化为多个二分类任务，然后对多个二分类任务的结果进行举手表决。</p><ul><li>一对一(One-vs-One, OvO)：<ul><li>训练 $N(N-1)&#x2F;2$ 个分类器，存储开销和测试时间大</li><li>训练只用两个类的样本，训练时间短</li></ul></li><li>一对其他(One-vs-Rest, OvR)：<ul><li>训练 $N$ 个分类器，存储开销和测试时间小</li><li>训练用到全部样例，训练时间长</li></ul></li></ul><p>实践中，逻辑回归、SVM、神经网络等模型均可通过OvR或OvO扩展至多分类任务。两者预测性能取决于具体的数据分布，大多数情况差不多。<br><img src="/../../../ai_assets/01_ovo_ovr.png"></p><h1 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4 决策树"></a>4 决策树</h1><p>决策树是直接导致机器学习能够成为一个学科的模型，思想非常简单。</p><h2 id="4-1-决策树基本流程"><a href="#4-1-决策树基本流程" class="headerlink" title="4.1 决策树基本流程"></a>4.1 决策树基本流程</h2><p>决策树基于树结构进行决策。</p><ul><li>每个“内部节点”对应某个特征上的“测试”（test）</li><li>某个分支对应该测试的某种可能结果，即该特征的某个取值</li><li>每个“叶子结点”对应一个“预测结果”</li></ul><p>学习过程：通过对训练样本的分析来确定“<strong>划分特征</strong>”，即内部结点所对应的特征。<br>预测过程：将测试示例从根结点开始，沿着划分特征所构成的“判定测试序列”下行，直到叶子结点。</p><p>策略：分而治之（divide-and-conquer）<br>自根至叶的递归过程，在每个中间节点寻找一个划分（split or test）属性。</p><p>既然是递归，停止条件非常重要：</p><ol><li>当前节点的样本都属于同一类别，无需划分。</li><li>当前节点样本有不同类别，但是特征集为空，没有能够划分的特征了，或者其余特征值都相同。</li><li>当前节点包含的样本集合为空（有这个特征但是训练集中没有这种样本）</li></ol><p><img src="/../../../ai_assets/01_tree_process.png"></p><h2 id="4-2-信息增益划分"><a href="#4-2-信息增益划分" class="headerlink" title="4.2 信息增益划分"></a>4.2 信息增益划分</h2><p>信息熵（entropy）是度量样本集合“纯度”的一个指标，当前样本集合 $D$ 中共有 $k$ 种类别，第 $i$ 类样本样本的比例（也就是出现概率）为 $p_k$，则 $D$ 的<strong>信息熵</strong>定义为：<br>$$Ent(D) &#x3D; -\sum_{i &#x3D; 1}^{k} p_i,log_2,p_i$$<br>不难发现，信息熵越小，$D$ 的纯度越大。可以得出，$Ent(D)$的最小值为 0，最大值为 $log_2k$。</p><p>直接以信息熵为基础，计算当前划分对信息熵所造成的变化，也就是<strong>信息增益（information gain）</strong>，衡量的是当前划分对信息的不确定性减少的贡献程度。公式为 <strong>划分前的信息熵 - 划分后的信息熵</strong>。<br>$$\mathrm{Gain}(D,A)&#x3D;\mathrm{Ent}(D)-\sum_{v&#x3D;1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$<br>可以看出， 划分后的信息熵表达的是在给定特征 $A$ 的条件下，数据集 $D$ 的不确定性，称为<strong>条件熵</strong>：<br>$$Ent(D|A)&#x3D;\sum_{v&#x3D;1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</p><ul><li>特征 $A$ 的取值：${a_1, a_2,…a_v}$，共有 V 个</li><li>$D_v$：$D$ 在特征 $A$ 上取值为 $a_v$ 的样本子集</li><li>$\frac{|D_v|}{D}$：取值为 $a_v$ 的样本比例，第 $v$ 个分支的权重，样本越多越重要</li><li>$Ent(D_v)$：子集 $D_v$ 的信息熵</li></ul><p>其实就是按照特征 $A$ 的取值将样本划分为 $V$ 个子集，分别计算每个子集的信息熵 $Ent(D_v)$，但是由于特征 $A$ 的取值并不是均匀的，所以需要按比例划分权重 $\frac{|D_v|}{D}$，每个子集的信息熵与权重相乘 $\frac{|D_v|}{D}Ent(D_v)$，最后再相加，至此得到了给定特征 $A$ 的信息熵，用划分前信息熵 - 划分后信息熵，由此得到了一个差值，即信息增益。<br> <img src="/../../../ai_assets/01_id3_split.png"></p><blockquote><p>划分后的信息熵越小，说明特征 $A$ 的选择性越强，每一个子集 $D_v$ 内部纯度越高。</p></blockquote><p>ID3 树就是使用信息增益作为划分准则。</p><h2 id="4-3-信息增益率划分"><a href="#4-3-信息增益率划分" class="headerlink" title="4.3 信息增益率划分"></a>4.3 信息增益率划分</h2><p>信息增益作为划分准则时，越大越好，即划分后的信息熵越小越好，也就是划分后的子集 $D_v$ 内部越纯越好。如此便会导致一个问题，信息增益倾向于筛选性强，极端来看每个特征值只对应一个结果，那么结果就够纯，所以<strong>信息增益会倾向于选择取值较多的特征</strong>。</p><blockquote><p>比如按照每个人的手机号特征进行划分，由于结果绝对纯正，它的信息增益会很高，但是由此会造成这个树的泛化能力变得极差。</p></blockquote><p>由于信息增益的这个缺陷，引入了<strong>信息增益率（information gain ratio）</strong>：<br>$$\mathrm{Gain_ratio}(D,A)&#x3D;\frac{\mathrm{Gain}(D,A)}{\mathrm{IV}(A)}$$<br>其中 $IV(A)$ 为：<br>$${IV}(A)&#x3D;-\sum_{v&#x3D;1}^{V}\frac{|D_{v}|}{|D|}\log_{2}\frac{|D_{v}|}{|D|}$$<br> $IV(A)$ 表述的基本思想是特征 $A$ 的取值信息熵，取值数目越多，则  $IV(A)$ 取值越大。</p><p>信息增益率希望选择的是：</p><ol><li>信息增益尽可能大</li><li>特征取值尽可能少</li></ol><blockquote><p>这种思想叫做<strong>规范化（normalization）</strong>，在 $R^2$ 系数中也有体现。</p></blockquote><p>由此便解决了信息增益偏向选择取值较多的特征，但我们并不清楚怎样平衡信息增益和特征取值两者的重要性，所以在 C4.5 决策树中并不是单纯的使用信息增益率作为划分依据，而是采用了<strong>启发式方法</strong>。</p><p>算法会检查高信息增益率的特征是否也具有足够高的信息增益。 如果一个特征的信息增益率很高，但其信息增益很低，那么它可能只是因为分裂信息非常小，而不是因为它真的能很好地划分数据。</p><p>C4.5 试图在以下两者之间找到平衡：</p><ul><li>避免选择具有大量值的属性 (信息增益率的作用)</li><li>避免选择分裂信息太小的属性 (启发式修正的作用)</li></ul><h2 id="4-4-基尼指数划分"><a href="#4-4-基尼指数划分" class="headerlink" title="4.4 基尼指数划分"></a>4.4 基尼指数划分</h2><p>样本 $D$ 有 $k$ 种类别，样本属于第 $k$ 种类别的概率为 $p_k$，那么两次抽到的是同一类别的概率为 ${p_k}^2$，一共 $k$ 种类别求和得到抽到任一同样类别的概率，用 1 减去这个概率，反映的是从样本 D 中任取两个样本，其类别标签不一致的概率。<br>$$Gini(D) &#x3D; 1 - \sum_{k&#x3D;1}^{n}{p_{k}}^{2}$$<br>该值称为<strong>基尼指数（Gini index）</strong>，值越小，纯度越高。</p><p>属性 A 的基尼指数为：<br>$$Gini_index(D, A) &#x3D; \sum_{v&#x3D;1}^{V}\frac{\lvert D_{v} \rvert}{\lvert D \rvert}Gini(D_{v})$$<br>和特征熵类似，根据特征 A 的取值，将数据集分为 V 个子集， 分别计算每个子集的基尼指数，按照权重（占比）进行求和。</p><p>CART 树就是基于使用基尼指数作为划分依据，既可以做分类任务，又可以做回归任务，在候选特征集当中，选取基尼指数最小的特征。</p><h2 id="4-5-决策树剪枝"><a href="#4-5-决策树剪枝" class="headerlink" title="4.5 决策树剪枝"></a>4.5 决策树剪枝</h2><p>不止是信息增益和基尼指数，只要有一个概念能够描述划分子集中的数据纯度，便可以产生一个决策树算法。然而研究表明：划分选择的各种准则虽然对决策树的尺寸有较大影响，但对泛化性能的影响很有限。例如信息增益与基尼指数产生的结果，仅在约 2% 的情况下不同。</p><p>剪枝方法和程度对于决策树泛化性能的影响更为显著。</p><p>在整个机器学习中，最大的敌人是过拟合。决策树的目的是把子集划分的越来越纯，当树的深度很深的时候，就学到了不该学的数据，将数据划分过于精细，决策树的泛化性能下降。<strong>剪枝（pruning）</strong> 主动去掉一些分支，之前能分干净的现在做不到了，训练数据的划分能力变弱，但整体的泛化能力变强，剪枝是决策树对付过拟合的主要手段。</p><p>基本策略：剪枝过程中通过划分测试集，评估剪枝前后树的优劣来决定是否剪枝。</p><ul><li>预剪枝 （pre-pruning）：提前终止某些分支的生长（贪心的思想导致不顾及全局最优）<ul><li>划分前验证集精度与划分后相等，根据奥卡姆剃刀原则，预剪枝决策为不划分</li><li>测试时间开销降低，训练时间开销降低</li><li>过拟合风险降低，欠拟合风险增加</li></ul></li><li>后剪枝 （post-pruning）：生成一棵完整的树之后，再回头剪枝<ul><li>划分前验证集精度与划分后相等，根据奥卡姆剃刀原则，后剪枝决策为不剪枝</li><li>测试时间开销降低，训练时间开销增加</li><li>过拟合风险降低，欠拟合风险基本不变</li></ul></li><li>后剪枝泛化性能通常优于预剪枝</li></ul><blockquote><p>通常单个决策树一定要剪枝，而在集成学习中的弱学习器一般不剪枝。</p></blockquote><h1 id="5-支持向量机"><a href="#5-支持向量机" class="headerlink" title="5 支持向量机"></a>5 支持向量机</h1><h2 id="5-1-支持向量机基本型"><a href="#5-1-支持向量机基本型" class="headerlink" title="5.1 支持向量机基本型"></a>5.1 支持向量机基本型</h2><p>找到一个超平面方程 $w^Tx+b&#x3D;1$ ，将空间划分为两类。直觉上看，分类的点离这个超平面越远越好，离这个超平面最近的这些点叫做**支持向量 (support vector)<strong>，两个异类支持向量到超平面的距离之和称之为</strong>间隔 (margin)**。<br><img src="/../../../ai_assets/01_svm.png"></p><h2 id="5-2-求解方法"><a href="#5-2-求解方法" class="headerlink" title="5.2 求解方法"></a>5.2 求解方法</h2><p>目标是寻找参数 $w$ 和 $b$，使得 $γ$ 最大，也就是最大化间隔。<br>$$\begin{aligned}<br>&amp; \arg \min <em>{\boldsymbol{w}, b} \frac{1}{2}|\boldsymbol{w}|^{2} \<br>&amp; \quad \text { s.t. } y</em>{i}\left(\boldsymbol{w}^{\top} \boldsymbol{x}_{i}+b\right) \geq 1, i&#x3D;1,2, \ldots, m.<br>\end{aligned}$$</p><p>如果明白凸优化理论，不难发现这是一个凸二次规划问题，能用优化计算包求解，但可以有更高效的办法——拉格朗日乘子法。</p><p>最终解为：<br>$$f(\boldsymbol{x})&#x3D;\boldsymbol{w}^\top\boldsymbol{x}+b&#x3D;\sum_{i&#x3D;1}^m\alpha_iy_i\boldsymbol{x}_i^\top\boldsymbol{x}+b$$<br>在推导对偶问题时，引入的拉格朗日乘子存在约束条件，需要满足 KTT 条件：<br>$$\left.\left{<br>\begin{array}<br>{ll}\alpha_i\geq0; &amp; \<br>1-y_if(\boldsymbol{x}_i)\leq0; &amp; \<br>\alpha_i\left(1-y_if(\boldsymbol{x}_i)\right)&#x3D;0. &amp;<br>\end{array}\right.\right.$$<br>解的稀疏性：训练完成后，<strong>最终模型仅与支持向量有关</strong>，<strong>支持向量机（Support Vector Machine, SVM）</strong> 因此而得名。</p><p>还有著名的 SMO 算法，是一个迭代更新的算法，先选取 KKT 条件违背程度最大的变量，当变量固定后，原始问题具有闭式解。</p><h2 id="5-3-特征空间映射"><a href="#5-3-特征空间映射" class="headerlink" title="5.3 特征空间映射"></a>5.3 特征空间映射</h2><p>若不存在一个能正确划分两类样本的超平面，怎么办？<br>将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。<br><img src="/../../../ai_assets/01_svm_space.png"></p><blockquote><p>如果原始空间是有限维（特征数有限），那么一定存在一个高维特征空间使样本线性可分。</p></blockquote><p>原始问题：<br>$$\begin{aligned}<br>&amp; \min <em>{\boldsymbol{w}, b} \frac{1}{2}|\boldsymbol{w}|^{2} \<br>&amp; \text { s.t. } y</em>{i}\left(\boldsymbol{w}^{\top} \boldsymbol{\phi}\left(\boldsymbol{x}<em>{i}\right)+b\right) \geqslant 1, i&#x3D;1,2, \ldots, m .<br>\end{aligned}$$<br>对偶问题：<br>$$\begin{aligned}<br>&amp; \max <em>{\boldsymbol{\alpha}} \sum</em>{i&#x3D;1}^{m} \alpha</em>{i}-\frac{1}{2} \sum_{i&#x3D;1}^{m} \sum_{j&#x3D;1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j} \boldsymbol{\phi}\left(\boldsymbol{x}<em>{i}\right)^{\top} \boldsymbol{\phi}\left(\boldsymbol{x}</em>{j}\right) \<br>&amp; \text { s.t. } \sum_{i&#x3D;1}^{m} \alpha_{i} y_{i}&#x3D;0, \quad \alpha_{i} \geqslant 0, \quad i&#x3D;1,2, \ldots, m<br>\end{aligned}$$<br>预测：<br>$$f(\boldsymbol{x})&#x3D;\boldsymbol{w}^{\top} \boldsymbol{\phi}(\boldsymbol{x})+b&#x3D;\sum_{i&#x3D;1}^{m} \alpha_{i} y_{i} \boldsymbol{\phi}\left(\boldsymbol{x}_{i}\right)^{\top} \boldsymbol{\phi}(\boldsymbol{x})+b$$</p><h2 id="5-4-核函数"><a href="#5-4-核函数" class="headerlink" title="5.4 核函数"></a>5.4 核函数</h2><p>由于两个高维向量求内积是困难的，所以设计<strong>核函数 (Kernel Function)</strong> ，它能绕过显式考虑特征映射、缓解计算高维内积的困难，并且直接在原始的特征空间计算。<br>$$\kappa(x_i,x_j)&#x3D;\phi(x_i)^\mathrm{T}\phi(x_j)$$</p><blockquote><p>Mercer 定理：若一个对称函数所对应的核矩阵<strong>半正定</strong>，则它就能作为核函数来使用。</p></blockquote><p>任何一个核函数，都隐式地定义了一个 <strong>RKHS</strong> （Reproducing Kernel Hilbert Space，再生核希尔伯特空间）。</p><p><strong>核函数选择是决定支持向量机性能的关键！</strong></p><blockquote><p>在机器学习中，没有最优解，只有近似最优解。在支持向量机算法中，前面的每一步都经过了严格的数学推导，是确定的，只有核函数这一步是无法确定的。</p></blockquote><h1 id="6-神经网络"><a href="#6-神经网络" class="headerlink" title="6 神经网络"></a>6 神经网络</h1><p>神经网络是由具有适应性的<strong>简单单元</strong>组成的广泛并行互连的<strong>网络</strong>，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。神经网络模型的两个最重要的要素是<strong>神经元模型</strong>和<strong>网络结构</strong>。</p><blockquote><p>神经网络是一个很大的学科领域，这里仅讨论神经网络与机器学习的交集，即“神经网络学习”，亦称“连接主义（connectionism）”学习。</p></blockquote><h2 id="6-1-神经网络模型"><a href="#6-1-神经网络模型" class="headerlink" title="6.1 神经网络模型"></a>6.1 神经网络模型</h2><p>神经网络中的简单单元是<strong>神经元模型</strong>，目前应用最广泛的还是 1943 年 McCulloch and Pitts 提出的 M-P神经元模型。神经网络学得的知识蕴含在连接权重 $w$ 与阈值 $\theta$ 中。<br><img src="/../../../ai_assets/01_neuron.png"></p><p>**激活函数 (activation function)**，也称响应函数、挤压函数，理想的激活函数是阶跃函数，0 表示抑制神经元，而 1 表示激活神经元，但阶跃函数具有不连续、不光滑等不好的性质，常用的是 Sigmoid 函数，在对率回归中也有用到。（其实 Sigmoid 并不是指某一个函数，S 型的函数都可以）<br><img src="/../../../ai_assets/01_activate_function.png"></p><hr><p>目前神经网络最常用的网络结构<strong>多层前馈网络</strong>。</p><ul><li>多层网络：包含隐层的网络</li><li>前馈网络：神经元之间不存在同层连接也不存在跨层连接</li></ul><p>隐层和输出层神经元亦称“功能单元”（Functional Unit）。<br><img src="/../../../ai_assets/01_neural_net.png"></p><h2 id="6-2-万有逼近性"><a href="#6-2-万有逼近性" class="headerlink" title="6.2 万有逼近性"></a>6.2 万有逼近性</h2><p>多层前馈网络有强大的表示能力，也就是<strong>万有逼近性</strong>。</p><p>仅需一个包含足够多神经元的隐层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数。</p><p>如何设置隐层神经元数是未决问题（Open Problem）。 实际常用“试错法”。</p><blockquote><p>万有逼近性并不是神经网络独有的特性，<strong>具有万有逼近性是能够作为机器学习模型的一个前提</strong>，许多数学模型如傅立叶变换、泰勒展开式也具备这种性质。决策树在划分过程中有信息熵支撑最后一定能够划分很干净，支持向量机也有理论保障能够找到间隔满足要求的划分超平面。<br>为什么这里强调神经网络具有万有逼近性？因为神经网络整个训练过程一塌糊涂，是一个黑盒，没有严格的理论支撑，所以原来大家都怀疑它有没有万有逼近性，事实证明它有这个能力。</p></blockquote><h2 id="6-3-缓解过拟合"><a href="#6-3-缓解过拟合" class="headerlink" title="6.3 缓解过拟合"></a>6.3 缓解过拟合</h2><p>早停（early stopping）：</p><ul><li>若训练误差连续 a 轮的变化小于 b，则停止训练</li><li>使用验证集：若训练误差降低、验证误差升高，则停止训练</li></ul><p>正则化 （regularization）：</p><ul><li>在误差目标函数中增加一项描述网络复杂度</li><li>模型偏好比较小的连接权和阈值，使网络输出更“光滑”</li><li>$$E&#x3D;\lambda\frac{1}{m}\sum_{k&#x3D;1}^mE_k+(1-\lambda)\sum_iw_i^2$$</li></ul><p>深度学习并非“突然出现”的”颠覆性技术”，而是经过了长期发展、很多研究者做出贡献，“冷板凳”坐“热”的结果。</p><h1 id="7-贝叶斯分类器"><a href="#7-贝叶斯分类器" class="headerlink" title="7 贝叶斯分类器"></a>7 贝叶斯分类器</h1><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a>7.1 贝叶斯决策论</h2><p>贝叶斯决策论（Bayesian Decision Theory）是是概率框架下实施决策的基本理论。<br>给定 N 个类别，令 $\lambda_{ij}$ 代表将第 $j$ 类样本误分类为第 $i$ 类所产生的损失，则基于后验概率将样本 $x$ 分到第 $i$ 类的条件风险为：<br>$$R(c_i\mid\boldsymbol{x})&#x3D;\sum_{j&#x3D;1}^N\lambda_{ij}P(c_j\mid\boldsymbol{x})$$<br>贝叶斯判定准则（Bayes decision rule）：在条件风险中选择最小的。<br>$$h^*(\boldsymbol{x})&#x3D;\underset{c\in\mathcal{Y}}{\operatorname*{\operatorname*{\arg\min}}}R(c\mid\boldsymbol{x})$$</p><ul><li>$h^*$ 称为贝叶斯最优分类器（Bayes optimal classifier），其总体风险称为贝叶斯风险（Bayes risk）</li><li>$1-R(h^*)$ 反映了学习性能的理论上限</li></ul><h2 id="7-2-生成式和判别式模型"><a href="#7-2-生成式和判别式模型" class="headerlink" title="7.2 生成式和判别式模型"></a>7.2 生成式和判别式模型</h2><p>$P(c\mid x)$ 在现实中通常难以直接获得，从这个角度来看，机器学习所要实现的是基于有限的训练样本尽可能准确地估计出后验概率。</p><p>两种基本策略：</p><ul><li>判别式（Discriminative） 模型<ul><li>思路：直接对 $P(c\mid x)$ 建模</li><li>代表：<ul><li>决策树</li><li>BP 神经网络</li><li>SVM</li></ul></li></ul></li><li>生成式（Generative）模型<ul><li>思路：先对联合概率分布 $P(x\mid c)$ 建模，再由此获得 $P(c\mid x)$<br>  $$P(c\mid x)&#x3D;\frac{P(x,c)}{P(x)}$$</li><li>代表：贝叶斯分类器</li></ul></li></ul><h2 id="7-3-贝叶斯定理"><a href="#7-3-贝叶斯定理" class="headerlink" title="7.3 贝叶斯定理"></a>7.3 贝叶斯定理</h2><p>对于根据贝叶斯定理可以将上式 $P(c\mid x)$ 转为：<br>$$P(c\mid x)&#x3D;\frac{P(c)P(x\mid c)}{P(x)}$$</p><ul><li>$P(c)$：先验概率（Prior），样本空间中各类样本所占的比例，可通过各类样本出现的频率估计（大数定律）</li><li>$P(x)$：证据（Evidence）因子，与类别无关</li><li>$P(x\mid c)$： 样本相对于类标记的类条件概率 (Class-Conditional Probability)，亦称<strong>似然 (Likelihood)</strong></li></ul><p>主要困难在于估计似然。</p><h2 id="7-4-极大似然估计"><a href="#7-4-极大似然估计" class="headerlink" title="7.4 极大似然估计"></a>7.4 极大似然估计</h2><p><strong>先假设某种概率分布形式（独立同分布），再基于训练样例对参数进行估计。</strong></p><p>假定 $P(x\mid c)$ 具有确定的概率分布形式，且被参数 $\theta_c$ 唯一确定，则任务就是利用训练集 D 来估计参数 $\theta_c$。</p><p>$\theta_c$ 对于训练集 D 中第 c 类样本组成的集合 $D_c$ 的似然（Likelihood）为：<br>$$P(D_c\mid\theta_c)&#x3D;\prod_{c\in D}P(x\mid\theta_c)$$<br>概率都是小于 1 的浮点数，连乘易造成下溢，因此通常使用对数似然（Log-Likelihood）：<br>$$LL(\theta_c)&#x3D;\log P(D_c\mid\theta_c)&#x3D;\sum_{x\in D_c}\log P(x\mid\theta_c)$$<br>于是 $\theta_c$ 的极大似然估计为 $\hat{\theta}<em>c&#x3D;\arg\max</em>{\theta_c}LL(\theta_c)$</p><h2 id="7-5-朴素贝叶斯分类器"><a href="#7-5-朴素贝叶斯分类器" class="headerlink" title="7.5 朴素贝叶斯分类器"></a>7.5 朴素贝叶斯分类器</h2><p>朴素贝叶斯分类器（Naive Bayes Classifier）对于：<br>$$P(c\mid x)&#x3D;\frac{P(c)P(x\mid c)}{P(x)}$$<br>主要障碍是求解所有属性上的联合概率 $P(x\mid c)$ ，难以从有限训练样本估计获得，并且存在组合爆炸；样本稀疏的问题。</p><p>基本思路是假定所有特征是独立的。</p><ul><li>估计 $P(c)$：$$P(c)&#x3D;\frac{|D_c|}{|D|}$$</li><li>估计 $P(c\mid x)$：<ul><li>离散属性：令 $D_{cx_i}$ 表示 $D_C$ 中在第 i 个属性上取值为 $x_i$ 的样本组成的集合$$P(x_i\mid c)&#x3D;\frac{|D_{c,x_i}|}{|D_c|}$$</li><li>连续属性：考虑概率密度函数，假定 $p(x_i\mid c)\sim\mathcal{N}(\mu_{c,i},\sigma_{c,i}^2)$ $$p(x_i\mid c)&#x3D;\frac{1}{\sqrt{2\pi}\sigma_{c,i}}\exp\left(-\frac{(x_i-\mu_{c,i})^2}{2\sigma_{c,i}^2}\right)$$</li></ul></li></ul><h2 id="7-6-拉普拉斯修正"><a href="#7-6-拉普拉斯修正" class="headerlink" title="7.6 拉普拉斯修正"></a>7.6 拉普拉斯修正</h2><p>在单纯的贝叶斯定理中，若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现<br>问题，因概率连乘将“抹去”其他属性提供的信息。例如，若训练集中未出现过“敲声&#x3D;清脆”的好瓜，则模型在遇到“敲声&#x3D;清脆”的测试样本时，不论其他特征多么符合好瓜的“定义”，也会断定为好瓜的概率为 0。</p><p><strong>拉普拉斯修正(Laplacian Correction)</strong> 解决了这一问题，思路非常简单，初始时为所有可能的特征值添加 1 个初始值。<br>$$\hat{P}(c)&#x3D;\frac{|D_c|+1}{|D|+N},\quad\hat{P}(x_i\mid c)&#x3D;\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$$</p><p>不过这里假设了特征值与类别的均匀分布，这是额外了引入的 bias，因此要根据实际问题量身定制 bias。比如好人比坏人多，给初始值的时候给好人多一些。</p><h1 id="8-集成学习"><a href="#8-集成学习" class="headerlink" title="8 集成学习"></a>8 集成学习</h1><p>集成学习（Ensemble Learning）将多个个体学习器组合起来，显著提高整体的预测能力。只包含同种类型的个体学习器的集成称为同质集成，包含不同类型个体学习器的称为异质集成。</p><p>术语梳理：</p><ul><li>基学习器：是集成学习的基本组成部分，可以是弱学习器或强学习器。</li><li>个体学习器：广泛指单个模型，强调其与其他学习器的独立性。所有基学习器都是个体学习器。</li><li>弱学习器：专指那些表现略好于随机猜测的模型，通常在集成学习中（尤其是 Boosting）用于组合成强学习器。</li><li>强学习器：性能很强、准确率高的学习器，可以是单个模型或由多个基学习器组合而成的模型（如随机森林）。</li></ul><p>集成学习分为两大类：</p><ul><li>序列化方法<ul><li>AdaBoost ［Freund &amp; Schapire, JCSS97］</li><li><strong>Gradient Boost</strong>［Friedman, AnnStat01］</li><li>LPBoost［Demiriz, Bennett, Shawe-Taylor, MLJ06］</li></ul></li><li>并行化方法<ul><li>Bagging［Breiman, MLJ96］</li><li><strong>Random Forest</strong>［Breiman, MLJ01］</li><li>Random Subspace［Ho, TPAMI98］</li></ul></li></ul><blockquote><p>Gradient Boost 早在 2001 年便已提出，是一种框架性算法，后来华人学生陈天奇在 2014 年发布 XGBoost，是 Gradient Boos 的一种高效实现。它在算法的基础上引入了许多工程化的改进，使得模型训练更快、更稳健，并且在很多竞赛中表现出色。</p></blockquote><h2 id="8-1-Boosting"><a href="#8-1-Boosting" class="headerlink" title="8.1 Boosting"></a>8.1 Boosting</h2><p>由 AdaBoosting 发展而来的这一系列算法称为 Boosting，整体流程为：</p><ol><li>初始化权重：给每个训练样本分配一个初始权重，通常是相同的</li><li>迭代弱学习器：经过多轮迭代，每轮生成一个弱学习器<ol><li>训练弱学习器：使用带有权重的训练数据训练一个新的弱学习器，重点关注权重较高样本</li><li>更新样本权重：每轮的学习器根据评估结果赋予权重（如决策树可以直接处理权重）或采样（按比例抽取，如神经网络中无法处理权重），使错误样本在后续学习中得到更多关注</li></ol></li><li>组合多个弱学习器：将多个弱学习器的预测结果按照加权组合，得到最终结果</li></ol><p><img src="/../../../ai_assets/01_boosting.png"></p><blockquote><p>由于都是前者学习器未能解决的问题，越往后的学习器需要攻克的问题越困难，一般来说准确率越低。</p></blockquote><h2 id="8-2-Bagging"><a href="#8-2-Bagging" class="headerlink" title="8.2 Bagging"></a>8.2 Bagging</h2><p>Bagging 的数据都来自原始数据集，怎样保证多样性？可以使用 Bootstrap 采样，在不同的数据集上训练，得到的结果使用投票解决分类问题，使用平均解决回归问题。<br><img src="/../../../ai_assets/01_bagging.png"></p><h2 id="8-3-好而不同"><a href="#8-3-好而不同" class="headerlink" title="8.3 好而不同"></a>8.3 好而不同</h2><p>Bagging 通过举手表决做出最终判断，如果个体学习器的表决都一样，那么整体的预测并不会有提升，如果个体学习器的错误率很高，整体可能更差。所以 Bagging 的核心思想是个体学习器需要<strong>好而不同</strong>。<br><img src="/../../../ai_assets/01_ensemble.png"></p><p>有一个式子描述“好而不同”，<strong>误差-分歧分解 （error-ambiguity decomposition）</strong>：<br><img src="/../../../ai_assets/01_ensemble_diversity.png"></p><p>然而多样性（diversity）是不易做到的，当多个个体学习器的准确率都达到很高，比如 99% 时，它们之间是高度相似的，此时就可以考虑舍弃一些准确率，从而来提升多样性。</p><blockquote><p>同质集成只需要使用同一种算法，实现方便，但是最大的麻烦是如何保持多样性。<br>异质集成有天然的优点，具有多样性，但是不同算法的输出之间无法直接比较，需要做配准（alignment）。这件事非常困难，所以重点讨论的还是同质集成。</p></blockquote><h1 id="9-聚类"><a href="#9-聚类" class="headerlink" title="9 聚类"></a>9 聚类</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>监督学习：分类、回归<br>无监督学习：聚类、密度估计</p><p>聚类是无监督学习中研究最多、应用最广的。</p><p>目标：将数据样本划分为若干个通常不相交的簇（cluster）。</p><p>既可以作为一个单独过程用于找寻数据内在的分布结构，也可以作为分类等其他学习任务的前驱过程。<br>比如：在没有先验知识的前提下对客户进行分组，提供个性化策略。<br><img src="/../../../ai_assets/01_kmeans.png"></p><h2 id="9-2-聚类性能指标"><a href="#9-2-聚类性能指标" class="headerlink" title="9.2 聚类性能指标"></a>9.2 聚类性能指标</h2><p>聚类性能度量，也称为<strong>有效性指标</strong>（validity index）。</p><ul><li>外部指标（external index）：将聚类结果与参考模型（referencemodel）进行比较。但参考模型并不意味着标准，可以有很多种聚法。如 Jaccard 系数，FM 指数，Rand 指数。</li><li>内部指标（internal index）：直接考察聚类结果而不参考模型。如 DB 指数、Dunn指数。基本想法是簇内尽可能紧密，簇间尽可能远离：<ul><li>簇内相似度高</li><li>簇间相似度低</li></ul></li></ul><h2 id="9-3-距离度量"><a href="#9-3-距离度量" class="headerlink" title="9.3 距离度量"></a>9.3 距离度量</h2><p>上一节中提到簇内尽可能紧密，既然谈到紧密，就一定涉及某种距离度量。</p><p>距离度量（distance metric）需满足的性质：<br>$$\begin{aligned}<br> &amp; \operatorname{\text{非负性:dist}}(\boldsymbol{x}<em>{i},\boldsymbol{x}</em>{j})\geqslant0; \<br> &amp; \text{同一性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j)&#x3D;0\text{ 当且仅当 }\boldsymbol{x}_i&#x3D;\boldsymbol{x}_j\mathrm{~;} \<br> &amp; \text{对称性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j)&#x3D;\mathrm{dist}(\boldsymbol{x}_j,\boldsymbol{x}_i); \<br> &amp; \text{直递性:dist}(\boldsymbol{x}_i,\boldsymbol{x}_j) \leqslant\operatorname{dist}(\boldsymbol{x}_i,\boldsymbol{x}_k)+\operatorname{dist}(\boldsymbol{x}_k,\boldsymbol{x}_j).<br>\end{aligned}$$<br>尽管大部分距离满足上述四个条件，然而某些情况第四条直递性不满足，需要使用非距离度量（Non-metric distance）。在图像识别等领域还有相似度（Similaring），也有非距离度量的理念。</p><p>常用距离形式-闵可夫斯基距离：<br>$$\operatorname{dist}<em>{\operatorname{mk}}(\boldsymbol{x}<em>i,\boldsymbol{x}<em>j)&#x3D;\left(\sum</em>{u&#x3D;1}^n|x</em>{iu}-x</em>{ju}|^p\right)^{\frac{1}{p}}$$</p><p>对于无序（non-ordinal）属性，可使用 VDM(Value Difference Metric)，令$m_{u,a}$表示属性$u$上取值为$a$的样本数，$m_{u,a,i}$表示在第$i$个样本簇中在属性$u$上取值为$a$的样本数，$k$为样本簇数，则属性$u$上两个离散值$a$与$b$之间的 VDM 距离为：<br>$$\begin{aligned}<br>VDM_p(a,b)&#x3D;\sum_{i&#x3D;1}^k\left|\frac{m_{u,a,i}}{m_{u,a}}-\frac{m_{u,b,i}}{m_{u,b}}\right|^p<br>\end{aligned}$$</p><p>对于混合属性，可以使用 MinkovDM：<br>$$\mathrm{MinkovDM}<em>p(x_i,x_j)&#x3D;\left(\sum</em>{u&#x3D;1}^{n_c}|x_{iu}-x_{ju}|^p+\sum_{u&#x3D;n_c+1}^n\mathrm{VDM}<em>p(x</em>{iu},x_{ju})\right)^{\frac{1}{p}}$$</p><h2 id="9-4-聚类方法概述"><a href="#9-4-聚类方法概述" class="headerlink" title="9.4 聚类方法概述"></a>9.4 聚类方法概述</h2><p>聚类的好坏没有绝对标准，可以将人们按男女聚类，也可以按照是否近视聚类。</p><blockquote><p>聚类的故事：<br>老师拿来苹果和梨，让小朋友分成两份。<br>小明把大苹果大梨放一起，小个头的放一起，老师点头，恩，体量感。<br>小芳把红苹果挑出来，剩下的放一起，老师点头，颜色感。<br>小武的结果？不明白。小武掏出眼镜：最新款，能看到水果里有几个籽，左边这堆单数，右边双数。<br>老师很高兴：新的聚类算法诞生了。</p></blockquote><p>聚类也许是机器学习中“新算法”出现最多、最快的领域总能找到一个新的“标准”，使以往算法对它无能为力。</p><ul><li>原型聚类<ul><li>亦称“基于原型的聚类” （prototype-based clustering）</li><li>假设：聚类结构能通过一组原型刻画</li><li>过程：先对原型初始化，然后对原型进行迭代更新求解</li><li>代表：<strong>k均值聚类</strong>，学习向量量化（LVQ），高斯混合聚类</li></ul></li><li>密度聚类<ul><li>亦称“基于密度的聚类”（density-based clustering）</li><li>假设：聚类结构能通过样本分布的紧密程度确定</li><li>过程：从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇</li><li>代表：<strong>DBSCAN</strong>, OPTICS, DENCLUE</li></ul></li><li>层次聚类 （hierarchical clustering）<ul><li>假设：能够产生不同粒度的聚类结果</li><li>过程：在不同层次对数据集进行划分，从而形成树形的聚类结构</li><li>代表：<strong>AGNES</strong>（自底向上），DIANA（自顶向下）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_线性回归</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>回归模型是机器学习和统计学中的一种基本模型，用于预测连续型输出变量。简单的说，给定一组输入变量（自变量）和对应的输出变量（因变量），回归模型旨在找到输入变量和输出变量之间的映射关系。</p><p>线性回归分类：</p><ul><li><p><strong>一元线性回归</strong>：建立一个因变量与单个自变量之间线性关系的模型，也就是只有一个特征。<br>$$<br>y&#x3D;{w}\boldsymbol{x}+b<br>$$<br>$\small{y}$ 是目标变量（因变量）， $\boldsymbol{x}$ 是输入变量（自变量）， $b$ 是偏置（截距,intercept），$w$是权重（回归系数, regression coefficients）</p></li><li><p><strong>多元线性回归</strong>：建立一个因变量与多个自变量之间线性关系的模型，模型具有多个特征。<br>$$<br>y&#x3D;w_1x_1+w_2x_2+w_3x_3+\cdots+w_nx_n+b<br>$$<br>可以用向量简化为：$y&#x3D;\boldsymbol{w^Tx}+b$ 或<br>$$<br>y&#x3D;\boldsymbol{w^Tx}<br>$$<br>其中， $\boldsymbol{\mathbf{x} &#x3D; [1, x_{1}, x_{2}, \dots, x_{n}]}$ 是包含截距的输入向量， $\boldsymbol{\mathbf{w} &#x3D; [w_{0}, w_{1}, w_{2}, \dots, w_{n}]^{T}}$ 是模型参数（包括截距 $b$ 和回归系数 $\boldsymbol{w_{1}, w_{2}, \cdots, w_{n}}$）</p></li></ul><h1 id="2-线性回归求解"><a href="#2-线性回归求解" class="headerlink" title="2 线性回归求解"></a>2 线性回归求解</h1><h2 id="2-1-损失函数"><a href="#2-1-损失函数" class="headerlink" title="2.1 损失函数"></a>2.1 损失函数</h2><p>建立回归模型的目的是为了找到最佳的回归系数 $\boldsymbol{w}$ 和截距 $b$ ，能够使预测值 ${\hat{y_{i}}}$ 与实际观测值 ${y_{i}}$ 之间差异最小化。<br><strong>损失函数（Loss Function）</strong>，也称为代价函数（Cost Function），定义损失函数为：<br>$$<br>L(w)&#x3D;\sum_{i&#x3D;1}^{m}(\hat{y_i}-y_i)^2<br>$$</p><blockquote><p>很多时候损失函数和代价函数两个术语存在混用，严谨来说：</p><ul><li>损失函数：单个训练样本的误差，通常用 $L(w)$, $L(w, b)$</li><li>代价函数：整个训练集的平均误差，损失函数的平均，通常用 $J(θ)$</li></ul></blockquote><p>损失函数 $L(w)$ 最小化时便找到了最佳参数，这为优化参数指明了方向。</p><p><img src="/../../../ai_assets/04_loss.png"></p><h2 id="2-2-正规方程法"><a href="#2-2-正规方程法" class="headerlink" title="2.2 正规方程法"></a>2.2 正规方程法</h2><p><strong>正规方程法（Normal Equation）</strong> 是一种直接计算线性回归模型参数（权重和偏置）的方法，它不需要像梯度下降那样的迭代过程。<br><img src="/../../../ai_assets/04_loss_matrix.png"></p><p>整理后得出多元线性回归方程的解析解为：<br>$$<br>\boldsymbol{w} &#x3D; (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{y}<br>$$</p><p>$\mathbf{X}$ 为特征值矩阵，$\boldsymbol{y}$ 为目标值向量，$\boldsymbol{w}$ 为参数向量，$w_0$ 为偏置。若 $X^TX$ 不满秩，可以解出多个 $w$，此时需要设定归纳偏好，或引入正则化(regularization)。</p><p>$$<br>X &#x3D; \begin{bmatrix} 1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1n} \ 1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2n} \ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ 1 &amp; x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{mn} \end{bmatrix}<br>;;;;;;;;;;;;;<br>y &#x3D; \begin{bmatrix} y_1 \ y_2 \ \vdots \ y_m \end{bmatrix}<br>;;;;;;;;;;;;;<br>w &#x3D; \begin{bmatrix} w_0 \ w_1 \ \vdots \ w_n \end{bmatrix}<br>$$</p><h2 id="2-3-梯度下降法"><a href="#2-3-梯度下降法" class="headerlink" title="2.3 梯度下降法"></a>2.3 梯度下降法</h2><h3 id="2-3-1-梯度下降思想"><a href="#2-3-1-梯度下降思想" class="headerlink" title="2.3.1 梯度下降思想"></a>2.3.1 梯度下降思想</h3><p>梯度下降（Gradient Descent）是一种优化算法，广泛应用于机器学习和深度学习中，用于找到最小化模型损失函数的参数。</p><p>梯度下降是一个迭代过程，不断重复以下步骤直到模型收敛，即损失不再明显减少：</p><ol><li><strong>初始化参数：</strong> 随机设定模型的初始参数$\boldsymbol{w}$（包含权重和偏置）。</li><li><strong>计算损失：</strong> 使用当前的参数计算模型的损失函数 **$J(\boldsymbol{w})$**。</li><li><strong>计算梯度：</strong> 对损失函数 <strong>$J(\boldsymbol{w})$</strong> 计算偏导数，得到当前位置的梯度 $\nabla J(\boldsymbol{w})$，得到损失函数变化最快的方向。<br>$$\nabla J(\mathbf{w}) &#x3D; \left[ \frac{\partial{J}}{\partial{w_{1}}},  \frac{\partial{J}}{\partial{w_{2}}}, \cdots,  \frac{\partial{J}}{\partial{w_{n}}} \right]$$</li><li><strong>更新参数：</strong> 沿着梯度的反方向，根据学习率(learning rate) $\alpha$ 更新参数。<br>$$θ&#x3D;θ−α⋅\nabla J(\mathbf{w})​$$</li><li><strong>重复：</strong> 返回到第 2 步，用新的参数重复计算和更新，直到达到某一停止条件<ol><li>达到最大迭代次数</li><li>损失变化小于某个阈值。</li></ol></li></ol><h3 id="2-3-2-学习率的选择"><a href="#2-3-2-学习率的选择" class="headerlink" title="2.3.2 学习率的选择"></a>2.3.2 学习率的选择</h3><ul><li>学习率过小：收敛速度慢，易陷入局部最优解</li><li>学习率过大：可能导致跳过最优解，甚至发散</li></ul><p><img src="/../../../ai_assets/04_learning_rate.png"></p><p>自适应学习率：高级优化器（如 Adam、Adagrad）动态调整学习率以提升性能</p><h3 id="2-3-3-梯度下降常见分类"><a href="#2-3-3-梯度下降常见分类" class="headerlink" title="2.3.3 梯度下降常见分类"></a>2.3.3 梯度下降常见分类</h3><ol><li><p>批量梯度下降(Batch Gradient Descent，BGD)：每次迭代使用<strong>全部训练数据</strong>计算梯度。</p><ul><li>优点：梯度方向稳定，更新平滑，收敛过程较稳定。</li><li>缺点：每次都计算整个训练集，计算量大，对大数据集效率低。</li></ul></li><li><p>随机梯度下降(Stochastic Gradient Descent，SGD)：每次迭代随机选取<strong>一个样本</strong>计算梯度。</p><ul><li>优点：快速迭代，每次只用一个样本计算梯度；由于引入了随机性，有助于跳出局部最优解。</li><li>缺点：每次更新方向不确定，收敛过程波动很大，甚至难以收敛，在最小值附近震荡。</li></ul></li><li><p>小批量梯度下降(Mini-batch Gradient Descent，MBGD)：每次迭代使用<strong>一小批样本</strong>(如32、64个)计算梯度。</p><ul><li>优点：计算成本相对 BGD 较低，又比 SGD 稳定，兼具 BGD 的稳定和 SGD 的速度。</li><li>缺点：合适的 batch size 需要实验。</li></ul></li></ol><p><a href="https://www.jeremyjordan.me/gradient-descent/">梯度下降优化扩展内容</a></p><h3 id="2-3-4-梯度下降常见问题"><a href="#2-3-4-梯度下降常见问题" class="headerlink" title="2.3.4 梯度下降常见问题"></a>2.3.4 梯度下降常见问题</h3><p>特征缩放：通常需要提前对特征进行缩放（如标准化或归一化），以加快收敛速度。</p><p>局部最优解、鞍点问题：可能陷入局部最优解，或遇到鞍点（梯度为零但非极值点）。<br>解决方案：使用动量（Momentum）、自适应优化器（如 Adam）或二阶方法（如牛顿法）。</p><h2 id="2-4-正规方程和梯度下降对比"><a href="#2-4-正规方程和梯度下降对比" class="headerlink" title="2.4 正规方程和梯度下降对比"></a>2.4 正规方程和梯度下降对比</h2><p>正规方程法：</p><ul><li>一次运算得出</li><li>不需要学习率</li><li>计算量大、容易受到噪声、特征强相关性的影响；如果数据不是线性的，无法使用或效果不好</li><li>应用场景：小数据量场景</li></ul><p>梯度下降法：</p><ul><li>需要迭代求解</li><li>需要选择学习率</li><li>应用场景：更加普适，适合于嘈杂、大数据场景，在各种损失函数中大量使用。在深度学习中模型参数轻松过亿，只能通过迭代求解</li></ul><h1 id="3-API-使用"><a href="#3-API-使用" class="headerlink" title="3 API 使用"></a>3 API 使用</h1><h2 id="3-1-正规方程"><a href="#3-1-正规方程" class="headerlink" title="3.1 正规方程"></a>3.1 正规方程</h2><p><code>LinearRegression</code>使用最小二乘法计算回归模型的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><br>model = LinearRegression(<br>    fit_intercept=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 是否计算偏置</span><br>)<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure><h2 id="3-2-梯度下降"><a href="#3-2-梯度下降" class="headerlink" title="3.2 梯度下降"></a>3.2 梯度下降</h2><p><code>SGDRegressor</code>使用随机梯度下降求解，随机梯度下降对特征的尺度非常敏感，通常需要在训练之前对特征进行标准化或归一化处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">form sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br><br>model = SGDRegressor(<br>    loss=<span class="hljs-string">&quot;squared_error&quot;</span>,  <span class="hljs-comment"># 损失函数，默认为均方误差</span><br>    penalty=<span class="hljs-string">&quot;l2&quot;</span>,  <span class="hljs-comment"># 正则化项，默认为 L2 正则</span><br>    fit_intercept=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 是否计算偏置</span><br>    learning_rate=<span class="hljs-string">&quot;constant&quot;</span>, <span class="hljs-comment"># 学习率策略</span><br>    eta0=<span class="hljs-number">0.1</span>, <span class="hljs-comment"># 初始学习率</span><br>    max_iter=<span class="hljs-number">1000</span>, <span class="hljs-comment"># 最大迭代次数</span><br>    tol=<span class="hljs-number">1e-8</span>, <span class="hljs-comment"># 损失值变化量小于 tol 时停止迭代</span><br>)<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure><ul><li><code>loss</code>：指定优化目标（损失函数），默认值为 <code>&#39;squared_error&#39;</code>（最小二乘法），其他可以选择的值有：<code>&#39;huber&#39;</code>、<code>&#39;epsilon_insensitive&#39;</code> 和 <code>&#39;squared_epsilon_insensitive&#39;</code>，其中 <code>&#39;huber&#39;</code>适用于对异常值更鲁棒的回归模型。</li><li><code>penalty</code>：指定正则化方法，用于防止过拟合，默认为 <code>&#39;l2&#39;</code>（L2 正则化），其他可以选择的值有：<code>&#39;l1&#39;</code>（L1正则化）、<code>&#39;elasticnet&#39;</code>（弹性网络，L1 和 L2 的组合）、<code>None</code>（不使用正则化）。</li><li><code>alpha</code>：正则化强度的系数，控制正则化项的权重，默认值为 <code>0.0001</code>。较大的 <code>alpha</code> 值会加重正则化的影响，从而限制模型复杂度；较小的值会让模型更关注训练数据的拟合。</li><li><code>l1_ratio</code>：当 <code>penalty=&#39;elasticnet&#39;</code> 时，控制 L1 和 L2 正则化之间的权重，默认值为 <code>0.15</code>，取值范围为 <code>[0, 1]</code>（<code>0</code> 表示完全使用 L2，<code>1</code> 表示完全使用 L1）。</li><li><code>tol</code>：优化算法的容差，即判断收敛的阈值，默认值为 <code>1e-3</code>。当目标函数的改变量小于 <code>tol</code> 时，训练会提前终止；如果希望训练更加精确，可以适当降低 <code>tol</code>。</li><li><code>learning_rate</code>：指定学习率的调节策略，默认值为 <code>&#39;constant&#39;</code>，表示使用固定学习率，具体的值由 <code>eta0</code> 指定；其他可选项包括：<ul><li><code>&#39;optimal&#39;</code>：基于公式 <code>eta = 1.0 / (alpha * (t + t0))</code>自动调整。</li><li><code>&#39;invscaling&#39;</code>：按 <code>eta = eta0 / pow(t, power_t)</code> 缩放学习率。</li><li><code>&#39;adaptive&#39;</code>：动态调整，误差减少时保持当前学习率，否则减小学习率。</li></ul></li><li><code>eta0</code>：初始学习率，默认值为 <code>0.01</code>，当 <code>learning_rate=&#39;constant&#39;</code> 或其他策略使用时，<code>eta0</code> 决定了初始更新步长。</li><li><code>power_t</code>：当 <code>learning_rate=&#39;invscaling&#39;</code> 时，控制学习率衰减速度，默认值为 <code>0.25</code>。较小的值会让学习率下降得更慢，从而更长时间地关注全局优化。</li><li><code>early_stopping</code>：是否启用早停机制，默认值为 <code>False</code>。如果设置为 <code>True</code>，模型会根据验证集性能自动停止训练，防止过拟合。</li><li><code>validation_fraction</code>：指定用作验证集的训练数据比例，默认值为 <code>0.1</code>。当 <code>early_stopping=True</code> 时，该参数会起作用。</li><li><code>max_iter</code>：训练的最大迭代次数，默认值为 <code>1000</code>。当数据较大或学习率较小时，可能需要增加迭代次数以保证收敛。</li><li><code>shuffle</code>：是否在每个迭代轮次开始时打乱训练数据，默认值为 <code>True</code>，表示打乱数据。打乱数据有助于提高模型的泛化能力。</li><li><code>warm_start</code>：是否使用上次训练的参数继续训练，默认值为 <code>False</code>。当设置为 <code>True</code> 时，可以在已有模型的基础上进一步优化。</li><li><code>verbose</code>：控制训练过程的日志输出，默认值为 <code>0</code>，可以设置为更高值以观察训练进度。</li></ul><h2 id="3-3-Lasso-回归"><a href="#3-3-Lasso-回归" class="headerlink" title="3.3 Lasso 回归"></a>3.3 Lasso 回归</h2><p>拉索（Lasso）回归在线性回归基础上引入 $\small{L1}$ 正则化项，不仅防止过拟合，还具有特征选择的功能，特别适用于高维数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br><br>model = Lasso()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure><h2 id="3-4-Ridge-回归"><a href="#3-4-Ridge-回归" class="headerlink" title="3.4 Ridge 回归"></a>3.4 Ridge 回归</h2><p>岭（Ridge）回归在线性回归的基础上引入 $\small{L2}$ 正则化项，目的是防止模型过拟合，尤其是当特征数较多或特征之间存在共线性时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br><br>model = Ridge()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure><h2 id="3-5-ElasticNet-回归"><a href="#3-5-ElasticNet-回归" class="headerlink" title="3.5 ElasticNet 回归"></a>3.5 ElasticNet 回归</h2><p>弹性网络（ElasticNet）回归结合了岭回归和套索回归的优点，通过同时引入 $\small{L1}$ 和 $\small{L2}$ 正则化项，适用于高维数据且特征之间存在相关的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> ElasticNet<br><br>model = ElasticNet()<br><br>model.fit(X_train, y_train)<br><span class="hljs-comment"># 查看权重</span><br>model.coef_<br><span class="hljs-comment"># 查看偏置</span><br>model.intercept_<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_逻辑回归</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>逻辑回归（Logistic Regression）尽管名字中含有“回归”，但逻辑回归实际上是一种分类算法，用于处理二分类问题。逻辑回归通过<strong>将线性回归的输出作为输入，映射到[0,1]区间</strong>，来表示某个类别的概率。</p><p>常用的映射函数是 sigmoid 函数：$𝑓(𝑥)&#x3D;\frac{1}{1+𝑒^{−𝑥}}$，将线性回归的输出作为输入会得到 {0, 1} 的输出。<br>$$<br>𝑃(𝑦&#x3D;1∣x)&#x3D;\frac{1}{1+e^{-(w^Tx+b)}}<br>$$<br>$𝑃(𝑦&#x3D;1∣x)$表示输出为 1 类的概率，根据逻辑回归结果和阈值来确认最终预测结果，若逻辑回归结果大于阈值则输出为 1类，反之输出为 0 类。<br>$$<br>\begin{aligned}<br> &amp;<br>\begin{bmatrix}<br>0.5 &amp; 0 &amp; 0.7 \<br>0.5 &amp; 0.5 &amp; 0.9 \<br>0.1 &amp; 1 &amp; 0.6 \<br>0.6 &amp; 0.1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>-1 \<br>2 \<br>0.5<br>\end{bmatrix}&#x3D;\quad<br>\begin{bmatrix}<br>-0.15 \<br>0.95 \<br>2.2 \<br>-0.4<br>\end{bmatrix}\quad\xrightarrow{\mathrm{sigmoid}}<br>\begin{bmatrix}<br>0.46257015 \<br>0.72111518 \<br>0.90024951 \<br>0.40131234<br>\end{bmatrix}\xrightarrow{\text{与阈值 }0.5\text{ 比较}}\quad<br>\begin{bmatrix}<br>0 \<br>1 \<br>1 \<br>0<br>\end{bmatrix}<br>\end{aligned}<br>$$<br><img src="/../../../ai_assets/01_sigmoid.png"></p><blockquote><p>实际逻辑回归是一个翻译错误，Logistic 并没有回归的意思，而是来自统计学中的 log odds（对数几率），后来发明了一个词 Logit 来描述，实际应为对数几率回归，或对率回归。</p></blockquote><h1 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2 损失函数"></a>2 损失函数</h1><p>逻辑回归的损失函数通常使用对数损失（Log Loss），也称为二元交叉熵损失（Binary Cross-Entropy Loss） ， 用于衡量模型输出的概率分布与真实标签之间的差距。 逻辑回归的损失函数来源于最大似然估计（MLE）。<br>对数似然：<br>$$\log L({y,F(X)})&#x3D;\sum_{i&#x3D;1}^ny_i\mathrm{log},p_{x_i}+(1-y_i)\mathrm{log},(1-p_{x_i})$$<br>$y_i$ 是第 $i$ 个样本的真实值(0 或 1)，$p_{x_i}$ 是第 $i$ 个样本属于类别 1 的概率。当 $y_i$ 为 1 时，右边消掉，当 $y_i$ 为 0 时，左边消掉，概率越低，把握越小，则 log 值越小，当似然函数最大时，损失最小。</p><p>拟合就是求似然函数的最大值，为了方便优化，令损失函数为：<br>$$Loss&#x3D;-\frac{1}{n}\sum_{i&#x3D;1}^ny_i\mathrm{log},p_{x_i}+(1-y_i)\mathrm{log},(1-p_{x_i})$$<br>加上负号，求解损失函数的最小值即可，$\frac{1}{n}$ 则类似均方误差中的平均。</p><h1 id="3-API-使用"><a href="#3-API-使用" class="headerlink" title="3 API 使用"></a>3 API 使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression()<br><br>model.fit(X_train, X_test)<br></code></pre></td></tr></table></figure><ul><li><code>penalty</code>：指定正则化类型，用于控制模型复杂度，防止过拟合，默认值为 <code>l2</code>。</li><li><code>C</code>：正则化强度的倒数，默认值为 <code>1.0</code>。较小的 <code>C</code> 值会加强正则化（更多限制模型复杂度），较大的 <code>C</code> 值会减弱正则化（更注重拟合训练数据）。</li><li><code>solver</code>：指定优化算法，默认值为 <code>lbfgs</code>，可选值包括：<ul><li><code>&#39;lbfgs&#39;</code>: 拟牛顿法（默认），仅支持 L2正则化</li><li><code>&#39;newton-cg&#39;</code>: 牛顿法，仅支持 L2正则化</li><li><code>&#39;liblinear&#39;</code>: 坐标下降法，适用于小数据集，支持 L1和 L2正则化</li><li><code>&#39;sag&#39;</code>: 随机平均梯度下降，适用于大规模数据集，仅支持 L2正则化</li><li><code>&#39;saga&#39;</code>: 改进的随机梯度下降，适用于大规模数据，支持 L1、L2和 ElasticNet正则化</li></ul></li><li><code>multi_class</code>：指定多分类问题的处理方式，默认值为 <code>&#39;auto&#39;</code>，根据数据选择 <code>&#39;ovr&#39;</code> 或 <code>&#39;multinomial&#39;</code>，前者表示一对多策略，适合二分类或多分类的基础情况，后者表示多项式回归策略，适用于多分类问题，需与 <code>&#39;lbfgs&#39;</code>、<code>&#39;sag&#39;</code> 或 <code>&#39;saga&#39;</code> 搭配使用。</li><li><code>fit_intercept</code>：是否计算截距（偏置项），默认值为 <code>True</code>。</li><li><code>class_weight</code>：类别权重，处理类别不平衡问题，默认值为 <code>None</code>，设置为 <code>&#39;balanced&#39;</code>可以根据类别频率自动调整权重。</li></ul><h1 id="4-多分类"><a href="#4-多分类" class="headerlink" title="4 多分类"></a>4 多分类</h1><p>逻辑回归通常用于二分类问题，但可以通过一对多（One-vs-Rest，OvR）、一对一（One-vs-One, OvO）以及 Softmax 回归（Multinomial Logistic Regression，多项逻辑回归）来扩展到多分类任务。</p><h2 id="4-1-OvO-OvR"><a href="#4-1-OvO-OvR" class="headerlink" title="4.1 OvO OvR"></a>4.1 OvO OvR</h2><ul><li>OvO 存储开销和测试时间大，训练时间短</li><li>OvR 存储开销和测试时间小，训练时间长</li></ul><p><img src="/../../../ai_assets/01_ovo_ovr.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression(<br>    multi_class=<span class="hljs-string">&#x27;ovr&#x27;</span>  <span class="hljs-comment"># 设置 ovr 或者 ovo</span><br>)<br></code></pre></td></tr></table></figure><p><code>multi_class</code>在后续版本中将会被废弃，取而代之的是一个新的类来实现 OvO、OvR。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.multiclass <span class="hljs-keyword">import</span> OneVsOneClassifier, OneVsRestClassifier<br><br>model1 = OneVsOneClassifier(estimator=LogisticRegression())<br>model2 = OneVsRestClassifier(estimator=LogisticRegression())<br></code></pre></td></tr></table></figure><h2 id="4-2-Softmax-回归"><a href="#4-2-Softmax-回归" class="headerlink" title="4.2 Softmax 回归"></a>4.2 Softmax 回归</h2><p>Softmax 回归（多项逻辑回归）直接扩展逻辑回归到多分类问题，使用 Softmax 函数将模型输出转化为概率分布。<br>对于类别 c：<br>$$P(y&#x3D;c|x)&#x3D;\frac{e^{\beta_{c}^{T}x}}{\sum_{j&#x3D;1}^{C}e^{\beta_{j}^{T}x}}$$<br>损失函数：<br>$$Loss&#x3D;-\frac{1}{n}\sum_{i&#x3D;1}^{n}\sum_{c&#x3D;1}^{C}I(y_{i}&#x3D;c)\mathrm{log}P(y_{i}&#x3D;c|x_{i})$$<br>其中 $𝐼(𝑦_𝑖 &#x3D;c)$ 为示性函数，当 $𝑦_𝑖 &#x3D;c$ 时值为 1，反之值为 0。</p><ul><li>优点：只训练 1 个模型，计算高效，分类一致性更好。</li><li>缺点：计算 Softmax 需要对所有类别求指数，计算量较高。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression(multi_class=<span class="hljs-string">&quot;multinomial&quot;</span>)<br></code></pre></td></tr></table></figure><p>对于多分类问题，LogisticRegression 会自动使用 <code>multinomial</code>，因此 <code>multi_class</code> 参数可省略。整体来看，大多数情况 Softmax 更加优秀，这也是为什么要把 <code>multi_class</code> 移除。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_决策树</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>决策树（Decision Tree）是一种基于树形结构的算法，根据一系列条件判断逐步划分数据，缩小范围，最终得出预测结果。决策树由 4 部分组成：</p><ul><li>根节点：树的节点，包含所有数据</li><li>内部节点：表示特征上的判断条件</li><li>分支：根据判断条件分出的路径</li><li>叶子节点：最终分类或回归的结果</li></ul><p>决策树适用于需要规则化、可解释性和快速决策的场景，尤其在数据特征明确、样本量适中的情况下表现良好。在复杂任务中，它常作为基模型，与集成学习结合（如随机森林、梯度提升树）以提升性能。<br><img src="/../../../ai_assets/06_tree_direct.png"></p><h1 id="2-决策树工作流程"><a href="#2-决策树工作流程" class="headerlink" title="2 决策树工作流程"></a>2 决策树工作流程</h1><p>训练决策树模型有三个核心的步骤：特征选择、决策树构建和决策树剪枝。</p><p>递归选择最优特征，并根据该特征对训练数据进行划分，使得对各个子数据集有一个最好的分类。</p><ol><li>首先构建根结点，将所有训练数据都放在根结点。</li><li>选择一个最优特征，按照这一特征将训练数据集划分成子集，使得各个子集有一个在当前条件下最好的分类。</li><li>如果这些子集已经能够被基本正确分类，那么构建叶结点，并将这些子集分到所对应的叶结点中去； 如果还有子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行划分并构建相应的结点。</li><li>如此递归直至所有训练数据子集被基本正确分类，或者没有合适的特征为止。</li></ol><p>最后每个子集都被分到叶结点有了明确的类，这就生成了一棵决策树。这样生成的决策树对训练数据有很好的分类能力，但可能发生过拟合现象。因此需要对已生成的树进行剪枝，将树变得更简单，从而使它具有更好的泛化能力。</p><h2 id="2-1-特征选择"><a href="#2-1-特征选择" class="headerlink" title="2.1 特征选择"></a>2.1 特征选择</h2><p>特征选择在于选取对训练数据具有分类能力的特征，这样可以提高决策树学习的效率。<br>如果一个特征能够使得分类后的分支结点尽可能属于同一类别，即该结点有着较高的<strong>纯度</strong>（purity），那么该特征对数据集而言就具备较强的分类能力。</p><p>通常选择的准则有信息增益、信息增益率和基尼指数</p><h3 id="2-1-1-信息增益与-ID3"><a href="#2-1-1-信息增益与-ID3" class="headerlink" title="2.1.1 信息增益与 ID3"></a>2.1.1 信息增益与 ID3</h3><p>信息熵（entropy）是度量样本集合“纯度”的一个指标，当前样本集合 $D$ 中共有 $k$ 种类别，第 $i$ 类样本样本的比例（也就是出现概率）为 $p_k$，则 $D$ 的<strong>信息熵</strong>定义为：<br>$$Ent(D) &#x3D; -\sum_{i &#x3D; 1}^{k} p_i,log_2,p_i$$<br>不难发现，信息熵越小，$D$ 的纯度越大。可以得出，$Ent(D)$的最小值为 0，最大值为 $log_2k$。</p><p>直接以信息熵为基础，计算当前划分对信息熵所造成的变化，也就是<strong>信息增益（information gain）</strong>，衡量的是当前划分对信息的不确定性减少的贡献程度。公式为 <strong>划分前的信息熵 - 划分后的信息熵</strong>。<br>$$\mathrm{Gain}(D,A)&#x3D;\mathrm{Ent}(D)-\sum_{v&#x3D;1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$<br>可以看出， 划分后的信息熵表达的是在给定特征 $A$ 的条件下，数据集 $D$ 的不确定性，称为<strong>条件熵</strong>：<br>$$Ent(D|A)&#x3D;\sum_{v&#x3D;1}^{V}\frac{|D_v|}{|D|}\mathrm{Ent}(D_v)$$</p><ul><li>特征 $A$ 的取值：${a_1, a_2,…a_v}$，共有 V 个</li><li>$D_v$：$D$ 在特征 $A$ 上取值为 $a_v$ 的样本子集</li><li>$\frac{|D_v|}{D}$：取值为 $a_v$ 的样本比例，第 $v$ 个分支的权重，样本越多越重要</li><li>$Ent(D_v)$：子集 $D_v$ 的信息熵</li></ul><p>ID3 算法就是基于信息增益进行特征选择的。</p><h3 id="2-1-2-信息增益率与-C4-5"><a href="#2-1-2-信息增益率与-C4-5" class="headerlink" title="2.1.2 信息增益率与 C4.5"></a>2.1.2 信息增益率与 C4.5</h3><p>信息增益作为划分准则时，倾向于筛选性强的特征，极端来看每个特征值只对应一个结果，那么结果就够纯，所以<strong>信息增益会倾向于选择取值较多的特征</strong>。</p><p><strong>信息增益率（information gain ratio）</strong> 可以对这一问题进行校正：<br>$$\mathrm{Gain_ratio}(D,A)&#x3D;\frac{\mathrm{Gain}(D,A)}{\mathrm{IV}(A)}$$<br>其中 $IV(A)$ 为：<br>$${IV}(A)&#x3D;-\sum_{v&#x3D;1}^{V}\frac{|D_{v}|}{|D|}\log_{2}\frac{|D_{v}|}{|D|}$$<br> $IV(A)$ 表述的基本思想是特征 $A$ 的取值信息熵，取值数目越多，则  $IV(A)$ 取值越大。</p><p>信息增益率希望选择的是：</p><ol><li>信息增益尽可能大</li><li>特征取值尽可能少</li></ol><p>C4.5 算法就是基于信息增益比进行特征选择的，但不是仅仅参考信息增益比，而是采用了<strong>启发式方法</strong>，会在 避免取值较多的特征 和 避免信息增益过小 之间找到平衡。</p><h3 id="2-1-3-基尼指数与-CART"><a href="#2-1-3-基尼指数与-CART" class="headerlink" title="2.1.3 基尼指数与 CART"></a>2.1.3 基尼指数与 CART</h3><p>样本 $D$ 有 $k$ 种类别，样本属于第 $k$ 种类别的概率为 $p_k$，那么两次抽到的是同一类别的概率为 ${p_k}^2$，一共 $k$ 种类别求和得到抽到任一同样类别的概率，用 1 减去这个概率，反映的是<strong>从样本 D 中任取两个样本，其类别标签不一致的概率</strong>。<br>$$Gini(D) &#x3D; 1 - \sum_{k&#x3D;1}^{n}{p_{k}}^{2}$$<br>该值称为<strong>基尼指数（Gini index）</strong>，基尼指数越大样本集合的不确定性也越大，这与信息熵相似。</p><p>属性 A 的基尼指数为：<br>$$Gini_index(D, A) &#x3D; \sum_{v&#x3D;1}^{V}\frac{\lvert D_{v} \rvert}{\lvert D \rvert}Gini(D_{v})$$<br>和特征熵类似，根据特征 A 的取值，将数据集分为 V 个子集， 分别计算每个子集的基尼指数，按照权重（占比）进行求和。</p><p>CART 算法就是基于基尼指数进行特征选择的，CART 既可以生成分类树，也可以生成回归树。</p><blockquote><p>在回归问题中面对的特征是连续值，可以通过遍历特征所有可能的取值，找到切分点 $\small{x}$ 让切分后的子集在信息增益比或基尼指数方面达到最优，在数据分裂时以 $\small{x}$ 为分界点将数据划分为 $\small{D_{1}}$ 和 $\small{D_{2}}$ 两个子集，其中 $\small{D_{1}}$ 包含特征值小于等于 $\small{x}$ 的样本， $\small{D_{2}}$ 包含特征值大于 $\small{x}$ 的样本。</p></blockquote><h2 id="2-2-数据分裂"><a href="#2-2-数据分裂" class="headerlink" title="2.2 数据分裂"></a>2.2 数据分裂</h2><p>通过上述准则选定特征后就要进行数据分裂，根据选定特征将数据集分成两个或多个子集，每个子集对应于特征的不同取值。递归对每个子集重复特征选择和数据分裂的动作，直到满足停止条件。</p><p>常见的停止条件：</p><ol><li>树达到预设的深度</li><li>当前结点的样本数量少于预设的阈值</li><li>结点上所有样本属于同一个类别</li><li>信息增益或 Gini 指数的变动低于某个阈值</li></ol><h2 id="2-3-决策树剪枝"><a href="#2-3-决策树剪枝" class="headerlink" title="2.3 决策树剪枝"></a>2.3 决策树剪枝</h2><p>剪枝可以减少树结构的复杂性，避免过拟合的风险，提升泛化能力。</p><ul><li><strong>预剪枝</strong>（pre-pruning）：在构建决策树的过程中设置一些限制条件（上一节中罗列了常见停止条件）提前停止树的生长，避免生成过于复杂的树，但是可能存在欠拟合的风险，因为过早停止分裂可能会遗漏潜在的重要决策规则。</li><li><strong>后剪枝</strong>（post-pruning）：后剪枝是在决策树构建完成后，通过评估和移除一些不必要的分支来简化树结构。在减少过拟合风险的同时，还能较好的保留对数据的拟合能力，但是计算量较大，而且如果没有合适的验证集，剪枝效果就会受到影响。</li></ul><h1 id="3-API-使用"><a href="#3-API-使用" class="headerlink" title="3 API 使用"></a>3 API 使用</h1><p>sklearn 中的基于 CART 算法分别实现了 <code>DecisionTreeClassifier</code> 和 <code>DecisionTreeRegressor</code> 来分别解决分类和回归问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier, DecisionTreeRegressor<br><br>model1 = DecisionTreeClassifier()<br>model2 = DecisionTreeRegressor()<br></code></pre></td></tr></table></figure><ul><li><code>criterion</code>：特征选择（数据分裂质量评估）的标准，可以选择 <code>&#39;gini&#39;</code>或 <code>&#39;entropy&#39;</code>，前者代表基尼指数，也是默认值，后者代表信息增益。</li><li><code>max_depth</code>：树的最大深度，默认值为 <code>None</code>，如果不设置该参数，会存在过拟合风险。</li><li><code>min_samples_split</code>：一个内部结点再次分裂所需的最小样本数，默认值为 <code>2</code>。这个参数可以设置为整数表示最小样本数，也可以设置为浮点数，表示占总样本数的比例。</li><li><code>min_samples_leaf</code>：叶结点所需的最小样本数，默认值为 <code>1</code>。将该参数设置为较大的值可以平滑模型，降低过拟合风险。这个参数也可以设置为整数或浮点数，道理同上。</li><li><code>max_features</code>：用于最佳分裂的特征数，默认值为 <code>None</code>。这个参数可以设置为整数，表示选择固定数量的特征；可以设置为浮点数，表示选择特征的比例；可以设置为字符串，<code>&#39;auto&#39;</code>和 <code>&#39;sqrt&#39;</code>表示将总的特征数量求平方根，用平方根的值作为选择特征的数量，<code>&#39;log2&#39;</code>表示将总的特征数量求对数，用对数值作为选择特征的数量。</li><li><code>class_weight</code>：指定类别的权重，用于处理类别不平衡问题，默认值为 <code>None</code>。可以用字典的方式手动设置每个类别的权重，也可以使用 <code>&#39;balanced&#39;</code>让模型自动调整。</li><li><code>splitter</code>：选择分裂结点的策略，默认值为 <code>&#39;best&#39;</code>，表示最佳分裂，还有一个取值是 <code>&#39;random&#39;</code>，表示随机分裂。</li><li><code>max_leaf_nodes</code>：限制叶结点的最大数量，可以防止树结构过于复杂。</li><li><code>min_impurity_decrease</code>：结点分裂所需的最小不纯度降低值，任何结点只有在不纯度减少超过此值时才会进行分裂。</li><li><code>ccp_alpha</code>：成本复杂度剪枝中的$\small{\alpha}$参数值。这个参数用于控制后剪枝中成本复杂度计算公式中$\small{\alpha}$的值。较小的$\small{\alpha}$值允许更复杂的树，而较大的$\small{\alpha}$值倾向于选择更简单的树。通过调整$\small{\alpha}$，可以找到一个最佳的复杂度和误差之间的平衡点。</li></ul><p>通过以下代码可以可视化决策树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> plot_tree<br><br>plot_tree(<br>    decision_tree=model,               <span class="hljs-comment"># 决策树模型</span><br>    feature_names=iris.feature_names,  <span class="hljs-comment"># 特征的名称</span><br>    class_names=iris.target_names,     <span class="hljs-comment"># 标签的名称</span><br>    filled=<span class="hljs-literal">True</span>                        <span class="hljs-comment"># 用颜色填充</span><br>)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/06_decision_tree_plot.png" alt="06_decision_tree_plot"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_集成学习</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>集成学习（Ensemble Learning）并不是一种具体的算法，而是一种思想：<strong>将多个单模型组合成一个综合模型</strong>，从而克服单一模型可能存在的局限性，提高准确性和稳定性，获得比单一模型更好的泛化能力。</p><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>基学习器 (base learner)、基模型(base model)、基估计器 (base estimator)，指的是集成学习中的单个模型。<br>进一步将基学习器分为弱学习器 (weak learner)和强学习器(strong learner) ，弱学习器是表现略优于随机猜测的学习器。对于二元分类问题，弱分类器定义为准确率约为 50% 的分类器；强学习器则是实现了出色的预测性能，在二元分类问题中准确率大于等于 80%。</p><blockquote><p>注意：很多资料将基学习器和弱学习器混为一谈，因为集成学习（尤其是串行方法）可以有效地将弱学习器提升为强学习器。</p></blockquote><h2 id="1-2-Why-集成学习"><a href="#1-2-Why-集成学习" class="headerlink" title="1.2 Why 集成学习"></a>1.2 Why 集成学习</h2><h3 id="1-2-1-偏差-方差均衡"><a href="#1-2-1-偏差-方差均衡" class="headerlink" title="1.2.1 偏差-方差均衡"></a>1.2.1 偏差-方差均衡</h3><p>为了减少测试误差而增加训练误差的做法被称为<strong>偏差-方差权衡</strong>，也是许多正则化技术背后的驱动原则。</p><ul><li><strong>偏差（Bias）</strong> 衡量的是预测值与真实值之间的平均差异。偏差越大，模型在训练集上的预测准确率就越低。高偏差是指训练过程中的误差较大，优化意味着尝试降低偏差。</li><li><strong>方差（Variance）</strong> 衡量的是给定模型在不同实现之间的预测差异。方差越大，模型对未知数据的预测准确率越低。高方差是指测试和验证过程中的误差较大，泛化是指试图降低方差。</li></ul><p>偏差和方差分别反向代表了模型在训练集和测试集上的准确率，我们希望同时降低模型偏差和方差，但同时降低两者并不总是可行的，因此需要进行正则化。正则化会降低模型方差，但代价是增加偏差。</p><p>模型总误差由偏差、方差和数据集随机性导致的不可约误差构成：<br>$$Error&#x3D;Bias^2+Variance+Irreducible;Error$$</p><h3 id="1-2-1-多模型优势"><a href="#1-2-1-多模型优势" class="headerlink" title="1.2.1 多模型优势"></a>1.2.1 多模型优势</h3><p>任何一种模型都包含众多变量，例如训练数据、超参数等，这些变量会影响最终模型的总误差。因此，即使是单一训练算法也可能产生不同的模型，每个模型都有各自的偏差、方差和不可约误差。通过组合多个不同的模型，集成算法可以降低总体误差，保留每个模型自身的复杂性和优势，例如对特定数据子集的低偏差。</p><p>一般来说，组合模型之间的<strong>多样性越大</strong>，最终的集成模型就越准确。由多种欠正则化模型，即与训练数据过拟合的模型，组成的集成模型性能优于单一正则化模型（集成森林中的决策树不需要剪枝）。集成学习还可以帮助解决高维数据引发的问题，有效替代降维方法。</p><h1 id="2-算法分类"><a href="#2-算法分类" class="headerlink" title="2 算法分类"></a>2 算法分类</h1><p>集成学习主要分为并行和串行两种方法：</p><ul><li>并行方法会将每个基学习器与其他基学习器分开单独训练</li><li>串行方法训练一个新的基础学习器，使其能够最小化前一步训练的模型所犯的错误</li></ul><p><img src="/../../../ai_assets/08_parallel_sequential.png"></p><p>并行方法进一步分为同质学习器和异质学习器，而串行方法通常使用同质学习器。</p><ul><li>同质（Homogeneous）：使用相同的基础学习算法来生成基学习器</li><li>异质（Heterogeneous）：使用不同的基础学习算法来生成基学习器</li></ul><p>目前最流行的三种集成学习技术是 Bagging、Boosting 和 Stacking。</p><h2 id="2-1-Bagging"><a href="#2-1-Bagging" class="headerlink" title="2.1 Bagging"></a>2.1 Bagging</h2><p>Bagging（Bootstrap Aggregating，自助聚合）通过自助采样（bootstrap）构建多个基学习器，然后将这些基学习器的预测结果进行组合（分类问题采用投票法，回归问题采用平均法）</p><p>特点：Bagging 旨在<strong>减少方差</strong>，尤其在基学习器存在较大方差时效果显著。</p><p>典型算法：</p><ul><li>随机森林（Random Forest）：通过构建大量决策树并进行投票来提高分类性能。</li></ul><p><img src="/../../../ai_assets/08_bagging.png"></p><h2 id="2-2-Boosting"><a href="#2-2-Boosting" class="headerlink" title="2.2 Boosting"></a>2.2 Boosting</h2><p>Boosting（提升）是一种迭代方法，模型是按顺序训练的，每个新模型都试图纠正先前模型的错误，最后通过对所有模型的预测进行加权平均。</p><p>特点：Boosting 旨在<strong>减少偏差</strong>，通过逐步改进模型提高预测的准确性，常常应用于简单的基学习器（如决策树桩）。</p><p>典型算法：</p><ul><li>AdaBoost (Adaptive Boosting)：为每个训练样本分配一个权重，并在每次迭代中调整这些权重。</li><li>Gradient Boosting Machine (GBM)：GBM 是一种更通用的 Boosting 算法，它使用梯度下降来优化损失函数。</li><li>XGBoost (Extreme Gradient Boosting)：GBM 的一种优化版本，在效率、精度上都有很大的提升。</li><li>LightGBM (Light Gradient Boosting Machine)：另一种 GBM 的优化版本，它使用基于直方图的算法来加速训练过程，并减少内存使用，特别适用于处理大规模数据集。</li></ul><p><img src="/../../../ai_assets/08_boosting.png"></p><h2 id="2-3-Stacking"><a href="#2-3-Stacking" class="headerlink" title="2.3 Stacking"></a>2.3 Stacking</h2><p>Stacking（堆叠）是将多个基模型的预测结果作为新的特征输入到元学习器（Meta Learner）中进行训练，元学习器的目标是学习如何最好地组合基学习器的预测结果。</p><p>特点：利用不同模型的优势，获得比单个模型更好的性能。</p><p><img src="/../../../ai_assets/08_stacking.png"></p><h1 id="3-随机森林"><a href="#3-随机森林" class="headerlink" title="3 随机森林"></a>3 随机森林</h1><p>随机森林是 Bagging 的一个变体，在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树训练过程中引入了<strong>随机特征选择</strong>，更加增强了模型的多样性。</p><ol><li>Bootstrap采样： 从原始数据集中使用 Bootstrap 有放回抽样，形成多个子集，每个子集用于训练一颗决策树</li><li>构建决策树：每棵树进行节点分裂时，不必考虑所有特征，而是随机选取一部分特征进行分裂</li><li>集成学习：分类任务采用投票法，回归任务采用平均法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><br>model = RandomForestClassifier()<br></code></pre></td></tr></table></figure><ul><li><code>n_estimators</code>： 决策树数量，（default &#x3D; 10）</li><li><code>Criterion</code>： entropy、 或者 gini, (default &#x3D; gini)</li><li><code>max_depth</code>：指定树的最大深度， （default &#x3D; None 表示树会尽可能的生长）</li><li><code>max_features</code>&#x3D;”auto”，决策树构建时使用的最大特征数量<ul><li>“auto”：<code>max _ features=sqrt(n _ features)</code> </li><li>“sqrt”： <code>max _ features=sqrt (n_ features)</code> (same as “auto”)</li><li>“log2”：<code>max _features=log2(n_features) </code></li><li>None：<code>max _ features=n_features</code></li></ul></li><li><code>bootstrap</code>：是否采用有放回抽样，如果为 False 将会使用全部训练样本，（default &#x3D; True）</li></ul><p>随机森林通过集成多个决策树提高了泛化能力且对噪声数据不敏感，适合解决复杂问题。</p><h1 id="4-Boosting"><a href="#4-Boosting" class="headerlink" title="4 Boosting"></a>4 Boosting</h1><h2 id="4-1-Adaboost"><a href="#4-1-Adaboost" class="headerlink" title="4.1 Adaboost"></a>4.1 Adaboost</h2><p>Adaptive Boosting（自适应提升）是基于 Boosting 思想实现集成学习算法。主要有两个特点：</p><ol><li>提高上一轮被弱学习器分类错误的样本权重</li><li>对弱学习器进行线性组合，提高分类效果好的弱学习器权重</li></ol><p>Adaboost 训练过程：</p><ol><li><strong>初始化样本权重</strong>：给每个样本分配一个相等的初始权重，对于 $N$ 个样本，初始权重为：<br>$$w_i^{(1)}&#x3D;\frac{1}{N}$$</li><li><strong>训练弱学习器</strong>：根据当前样本权重训练一个弱学习器，目标是最小化加权误差，第 $t$ 轮得到的弱学习器加权误差为：<br>$$\varepsilon_{t} &#x3D; \sum_{i&#x3D;1}^{N} w_{i}^{(t)} \cdot I(y_{i} \neq h_{t}(x_{i}))$$</li></ol><ul><li>$\varepsilon_{t}$: 第 $t$ 轮弱分类器的加权错误率。</li><li>$N$: 训练样本的总数。</li><li>$w_{i}^{(t)}$: 第 $t$ 轮中第 $i$ 个样本的权重。权重在每轮迭代中都会根据前一轮的表现进行调整（分错的样本权重增加，分对的样本权重减少）。</li><li>$I(\cdot)$: 指示函数 (Indicator Function)。<ul><li>如果括号内的条件 ($y_{i} \neq h_{t}(x_{i})$) 为真（即弱分类器 $h_{t}$ 分错了样本 $x_{i}$），则函数值为 $1$。</li><li>如果条件为假（即弱分类器 $h_{t}$ 分对了样本 $x_{i}$），则函数值为 $0$。</li></ul></li><li>$y_{i}$: 第 $i$ 个样本的真实标签。</li><li>$h_{t}(x_{i})$: 第 $t$ 轮弱分类器对第 $i$ 个样本的预测结果。</li></ul><ol start="3"><li><strong>更新学习器权重</strong>：计算第 $t$ 轮弱学习器的权重，该弱学习器误差越小，权重越大，第 $t$ 轮的弱学习器 $\alpha_t$ 的权重为：<br>$$\alpha_{t} &#x3D; \frac{1}{2} ln \left( \frac{1 - \varepsilon_{t}}{\varepsilon_{t}} \right)$$</li><li><strong>更新样本权重</strong>：根据当前学习器的表现，更新样本权重，误分类样本的权重会增加，正确分类样本的权重会降低，权重更新公式为：<br>$$w_{i}^{(t + 1)} &#x3D; w_{i}^{(t)} \cdot e^{-\alpha_{t} y_{i} h_{t}(x_{i})}$$</li><li><strong>归一化权重</strong>：对所有样本的权重进行归一化，使所有样本权重和为 1。</li><li><strong>构建强学习器</strong>：对所有弱学习器进行加权组合。</li></ol><h2 id="4-2-GBDT"><a href="#4-2-GBDT" class="headerlink" title="4.2 GBDT"></a>4.2 GBDT</h2><h2 id="4-3-XGBoost"><a href="#4-3-XGBoost" class="headerlink" title="4.3 XGBoost"></a>4.3 XGBoost</h2><h2 id="4-4-LightBGM"><a href="#4-4-LightBGM" class="headerlink" title="4.4 LightBGM"></a>4.4 LightBGM</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_K-means聚类</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09_K-means%E8%81%9A%E7%B1%BB/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09_K-means%E8%81%9A%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>聚类是一种<strong>无监督学习</strong>，不需要预先定义的标签，只是根据数据特征去学习，通过度量特相似度或者距离，然后把已知的数据集划分成若干个不同的类别。与分类不同，聚类任务的标是发现数据内在的结构。</p><p>聚类分为两类：</p><ul><li>硬聚类：每个数据点仅属于一个聚类</li><li>软聚类：每个数据点被赋予属于每个已识别聚类的概率</li></ul><p>聚类算法大体上可以分为：</p><ul><li>基于质心的聚类</li><li>基于密度的聚类</li><li>层次聚类</li><li>谱聚类</li></ul><h1 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2 算法流程"></a>2 算法流程</h1><p>K-Means 是一种基于质心迭代的聚类算法，根据质心之间的距离将数据集划分为 K 个相似的簇，并使每个簇内的数据点尽可能相似。</p><p>K-Means 实现步骤：</p><ol><li>初始化 K 个 质心：使用随机选择或初始质心采样方法</li><li>分配质心：将每个样本分配到距离最近的质心</li><li>更新质心：计算每个簇所有样本的均值，作为新的质心</li><li>重复2、3步骤，直到质心位置收敛或达到最大迭代次数</li></ol><p><a href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">聚类可视化</a></p><h1 id="3-API-实现"><a href="#3-API-实现" class="headerlink" title="3 API 实现"></a>3 API 实现</h1><p>使用 <code>make_blobs</code> 生成数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<br><br>X, y = make_blobs(<br>    n_samples=<span class="hljs-number">1000</span>,  <span class="hljs-comment"># 样本数</span><br>    n_features=<span class="hljs-number">2</span>,  <span class="hljs-comment"># 特征数</span><br>    centers=[[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]],  <span class="hljs-comment"># 中心点</span><br>    cluster_std=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>]  <span class="hljs-comment"># 数据标准差</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<br><br>model = KMeans()<br>model.fit(X)<br><br><span class="hljs-comment"># 模型的预测值为簇的编号，并不是分类标签</span><br>ret = model.predict(X) <br><span class="hljs-comment"># 可以将训练和预测合为一步 model.fit_predict(X)</span><br><br><span class="hljs-comment"># 也可以直接使用 labels_ 查看 X 的聚类结果</span><br>model.labels_<br></code></pre></td></tr></table></figure><ul><li><code>n_clusters</code>：指定聚类的簇数，即 $\small{K}$ 值，默认值为 <code>8</code>。</li><li><code>max_iter</code>：最大迭代次数，默认值为 <code>300</code>，控制每次初始化中 K-Means 迭代的最大步数。</li><li><code>init</code>：初始化质心的方法，默认值为 <code>&#39;k-means++&#39;</code>，表示从数据中多次随机选取 K 个质心，每次都计算这一次选中的中心点之间的距离，然后取距离最大的一组作为初始化中心点，推荐使用这个值；如果设置为 <code>&#39;random&#39;</code>则随机选择初始质心。</li><li><code>n_init</code>：和上面的参数配合，指定算法运行的初始化次数，默认值为 <code>10</code>。</li><li><code>algorithm</code>：K-Means 的计算算法，默认值为 <code>&#39;lloyd&#39;</code>。还有一个可选的值为 <code>&#39;elkan&#39;</code>，表示基于三角不等式的优化算法，适用于 K 值较大的情况，计算效率较高。</li><li><code>tol</code>：容忍度，控制算法的收敛精度，默认值为 <code>1e-4</code>。如果数据集较大时，可适当增大此值以加快收敛速度。</li></ul><p>可视化聚类结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], c=model.labels_)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/09_kmeans.png"></p><h1 id="4-模型评估"><a href="#4-模型评估" class="headerlink" title="4 模型评估"></a>4 模型评估</h1><h2 id="4-1-簇内平方和-WCSS"><a href="#4-1-簇内平方和-WCSS" class="headerlink" title="4.1 簇内平方和(WCSS)"></a>4.1 簇内平方和(WCSS)</h2><p>簇内平方和（Within-cluster Sum of Squares, WSS）和误差平方和（Sum of Squared Errors，SSE）是同一概念的不同叫法。衡量每个<strong>簇内样本点到簇中心的距离的平方和</strong>，WCSS 越小，聚类效果越好。<br>$$WCSS&#x3D;\sum_{i&#x3D;1}^\mathrm{k}\sum_{p\in C_i}\left|p-m_i\right|^2$$<br>$C_i$ 表示簇，$k$ 表示聚类中心的个数，$p$ 表示某个簇内的样本，$m$ 表示质心点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以直接查看 WCSS 参数</span><br>model.inertia_<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/09_sse.png"></p><p>肘部法：下降率突然变缓时即认为是最佳 n_clusters 值。<br><img src="/../../../ai_assets/09_elbow.png"></p><h2 id="4-2-SC-轮廓系数"><a href="#4-2-SC-轮廓系数" class="headerlink" title="4.2 SC 轮廓系数"></a>4.2 SC 轮廓系数</h2><p>轮廓系数（轮廓系数 (Silhouette Coefficient）衡量每个样本与其**所在簇的的内聚程度(Cohesion)<strong>，以及与</strong>其他簇的分离程度(Separation)**。轮廓系数范围为<code>[-1, 1]</code>，值越高聚类效果越好。<br>$$SC_i&#x3D;\frac{b_i-a_i}{\max(a_i,b_i)}$$</p><ul><li>$b_i$ 为第 $i$ 个样本到最近簇所有样本的平均距离</li><li>$a_i$ 为第 $i$ 个样本到同簇其他样本的平均距离</li><li>除掉 $\max(a_i,b_i)$ 体现了规范化(normalization)的思想，将两者的差缩放到可比较的范围</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> silhouette_score<br><br>silhouette_score(X, model.labels_)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/09_sc.png"></p><h2 id="4-3-CH-指数"><a href="#4-3-CH-指数" class="headerlink" title="4.3 CH 指数"></a>4.3 CH 指数</h2><p>CH 指数（Calinski-Harabasz Index）衡量簇间方差与簇内方差的比值，考虑簇内的内聚程度、簇外的离散程度、质心的个数。CH 指数越大聚类效果越好。<br>$$\begin{aligned}<br> &amp; \mathrm{CH}(\mathrm{k})&#x3D;\frac{SSB}{SSW}·\frac{m-k}{k-1} \<br> &amp; SSW&#x3D;\sum_{i&#x3D;1}^m\left|x_i-C_{pi}\right|^2 \<br> &amp; SSB&#x3D;\sum_{j&#x3D;1}^kn_j\left|C_j-\bar{X}\right|^2<br>\end{aligned}$$</p><ul><li>$SSW$：相当于 WCSS，簇内每个样本点到质心的距离平方和，衡量簇内距离</li><li>$SSB$：质心到质心均值的距离平方和，衡量簇间距离</li><li> $m$ 代表总样本数，$k$ 代表簇的数量，$\frac{m-k}{k-1}$ 可以看作是一个正则化项，使得在考虑簇之间的分离时，也要考虑到簇的数量以及每个簇的样本量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> calinski_harabasz_score<br><br>calinski_harabasz_score(X, model.labels_)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/09_ch.png"></p><h1 id="5-算法优缺点"><a href="#5-算法优缺点" class="headerlink" title="5 算法优缺点"></a>5 算法优缺点</h1><p>K-Means 是一种经典的聚类算法</p><ul><li>优点：实现简单，算法收敛速度快</li><li>缺点：结果不稳定（跟初始值设定有关），无法解决样本不均衡的问题，容易收敛到局部最优解，受噪声数据影响较大</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_感知机</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10_%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>感知机（Perceptron）是二分类模型， 接收多个信号，输出一个信号。 感知机的信号只有 0、1 两种取值。<br><img src="/../../../ai_assets/10_perceptron.png"></p><p>$𝑥_1$、$𝑥_2$ 是输入信号，$𝑦$ 是输出信号，$𝑤_1$、$𝑤_2$ 是权重，$○$ 称为神经元或节点。只有当输入信号和权重计算之后超过阈值 $\theta$ 时才会输出 1，也称之为神经元被激活。<br>$$y&#x3D;<br>\begin{cases}<br>0 &amp; (w_1x_1+w_2x_2\leq\theta) \<br>1 &amp; (w_1x_1+w_2x_2&gt;\theta) &amp;<br>\end{cases}$$</p><h1 id="2-简单逻辑电路"><a href="#2-简单逻辑电路" class="headerlink" title="2 简单逻辑电路"></a>2 简单逻辑电路</h1><h2 id="2-1-与门-AND-gate"><a href="#2-1-与门-AND-gate" class="headerlink" title="2.1 与门(AND gate)"></a>2.1 与门(AND gate)</h2><p>使用感知机实现简单逻辑电路，满足条件的参数有无数个，如 $(w_1, w_2, \theta)&#x3D;(0.5,0.5,0.7)$。<br>$$\begin{array}{|cc|c|}<br>\hline<br>x_{1} &amp; x_{2} &amp; y \<br>\hline<br>0 &amp; 0 &amp; 0 \<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>1 &amp; 1 &amp; 1 \<br>\hline<br>\end{array}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">AND</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-2-与非门-NAND-gate"><a href="#2-2-与非门-NAND-gate" class="headerlink" title="2.2 与非门(NAND gate)"></a>2.2 与非门(NAND gate)</h2><p>与非门颠倒了与门的输出，满足条件的参数也有无数个，只要把与门的参数值取反即可，比如 $(w_1, w_2, \theta)&#x3D;(-0.5,-0.5,-0.7)$。<br>$$\begin{array}{|cc|c|}<br>\hline<br>x_{1} &amp; x_{2} &amp; y \<br>\hline<br>0 &amp; 0 &amp; 1 \<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1 \<br>1 &amp; 1 &amp; 0 \<br>\hline<br>\end{array}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">NAND</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-3-或门-OR-gate"><a href="#2-3-或门-OR-gate" class="headerlink" title="2.3 或门(OR gate)"></a>2.3 或门(OR gate)</h2><p>实现或门的参数也有无数种，比如 $(w_1, w_2, \theta)&#x3D;(0.5,0.5,0.4)$。<br>$$\begin{array}{|cc|c|}<br>\hline<br>x_{1} &amp; x_{2} &amp; y \<br>\hline<br>0 &amp; 0 &amp; 0 \<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1 \<br>1 &amp; 1 &amp; 1 \<br>\hline<br>\end{array}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">OR</span>(<span class="hljs-params">x1, x2</span>):<br>    w1, w2, theta = <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.4</span><br>    <span class="hljs-keyword">if</span> w1 * x1 + w2 * x2 &gt; theta:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-4-扩展形式"><a href="#2-4-扩展形式" class="headerlink" title="2.4 扩展形式"></a>2.4 扩展形式</h2><p>考虑到以后的事情，这里将 $\theta$ 改为 $-b$，其中 $𝑏$ 为偏置，$𝑤1$,$𝑤2$为权重。权重控制输入信号的重要性，偏置调整神经元被激活的容易程度。<br>$$y&#x3D;<br>\begin{cases}<br>0 &amp; (b+w_1x_1+w_2x_2\leq0) \<br>1 &amp; (b+w_1x_1+w_2x_2&gt;0) &amp;<br>\end{cases}$$</p><p>再来使用这种形式实现一个与门：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AND</span>(<span class="hljs-params">x1, x2</span>):<br>    x = np.array([x1, x2])<br>    w = np.array([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>    b = -<span class="hljs-number">0.7</span><br>    <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>(w * x) + b &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="3-多层感知机"><a href="#3-多层感知机" class="headerlink" title="3 多层感知机"></a>3 多层感知机</h1><p>感知机的局限性在于它只能表示由一条直线划分的空间，使用之前的简单感知机，无法实现异或门（XOR gate）。<br>$$\begin{array}{|cc|c|}<br>\hline<br>x_{1} &amp; x_{2} &amp; y \<br>\hline<br>0 &amp; 0 &amp; 0 \<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1 \<br>1 &amp; 1 &amp; 0 \<br>\hline<br>\end{array}$$</p><p>无法使用一条直线将 0 和 1 分开。<br><img src="/../../../ai_assets/10_split01.png"></p><p>可以考虑使用与门、与非门、或门组合来构成异或门。<br>$$\begin{array}{|cc|cc|c|}<br>\hline<br>x_{1} &amp; x_{2} &amp; s_{1} &amp; s_{2} &amp; y \<br>\hline<br>0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \<br>1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\<br>\hline<br>\end{array}$$</p><p><img src="/../../../ai_assets/10_XOR.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">XOR</span>(<span class="hljs-params">x1, x2</span>):<br>    s1 = NAND(x1, x2)<br>    s2 = OR(x1, x2)<br>    <span class="hljs-keyword">return</span> AND(s1, s2)<br></code></pre></td></tr></table></figure><p>使用感知机的表示方法来表示这个异或门。<br><img src="/../../../ai_assets/10_multi_preceptron.png"></p><p>这就是多层感知机结构，第 0 层的两个神经元接收输入信号，并将信号发送给第 1 层的神经元。 第 1 层的神经元将信号发送给第 2 层的神经元。第 2 层的神经元输出结果。通过叠加层，感知机能进行更加灵活的表示。</p><p>这就是神经网络的基础。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_朴素贝叶斯</title>
    <link href="/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <url>/2025/10/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/04%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-贝叶斯定理"><a href="#1-1-贝叶斯定理" class="headerlink" title="1.1 贝叶斯定理"></a>1.1 贝叶斯定理</h2><p>贝叶斯定理是概率论中的一个重要定理，它描述了如何从主观经验或已知事实出发，通过收集到的样本数据（证据）来更新对事件发生概率的认知（信念）。贝叶斯定理的数学表达式为：<br>$$P(A \mid B) &#x3D; \frac{P(B \mid A)}{P(B)} \cdot P(A)$$</p><ul><li>${P(A)}$ 是事件 ${A}$ 发生的<strong>先验概率</strong>，我们可以理解为已知事实或主观经验（<strong>主观概率</strong>）</li><li>${P(B \mid A)}$ 是在事件 ${A}$ 发生的条件下事件 ${B}$ 发生的<strong>条件概率</strong>，通常也称之为<strong>似然性</strong>（likelihood）</li><li>${P(B)}$ 是事件 ${B}$ 发生的（全）概率，和 ${P(B \mid A)}$ 可以通过收集到的样本数据（证据）获取</li><li>${P(A \mid B)}$ 是在事件 ${B}$ 发生的条件下事件 ${A}$ 发生的条件概率，即收集到样本数据后对事件 ${A}$ 发生概率的重新认知，称之为<strong>后验概率</strong>。</li></ul><p>贝叶斯定理告诉我们一个重要的事实：可以从已知的事实或主观经验出发，通过收集到的证据来更新我们对某个事件发生概率的认知，也就是<strong>可以通过已知的事实和收集的证据来推断出未知的真相</strong>。</p><h2 id="1-2-朴素贝叶斯"><a href="#1-2-朴素贝叶斯" class="headerlink" title="1.2 朴素贝叶斯"></a>1.2 朴素贝叶斯</h2><p>朴素贝叶斯算法是基于贝叶斯定理和特征条件独立性假设的分类算法，因其简单高效而受到广泛应用。朴素贝叶斯算法的关键在于“<strong>朴素</strong>”二字，也就是刚才所说的<strong>特征条件独立性</strong>假设，即用于分类的特征在类确定的条件下都是独立的，该假设使得朴素贝叶斯的学习成为可能。</p><p>假设我们有一个特征集合 ${X &#x3D; {x_1, x_2, \ldots, x_n}}$ 和一个类别 ${C}$ ，朴素贝叶斯算法假设：<br>$$P(X \vert C) &#x3D; P(x_1 \vert C) \cdot P(x_2 \vert C) \cdot \ldots \cdot P(x_n \vert C)$$<br>这个假设使得我们无需考虑特征之间复杂的依赖关系，极大简化了条件概率的计算。</p><h1 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2 算法流程"></a>2 算法流程</h1><h2 id="2-1-训练阶段"><a href="#2-1-训练阶段" class="headerlink" title="2.1 训练阶段"></a>2.1 训练阶段</h2><p>首先计算每个类别的先验概率和每个特征在各个类别下的条件概率。</p><ol><li>计算先验概率：<br>$$<br>P(C_{i}) &#x3D; \frac{n_{i}}{n}<br>$$<br> ${C_{i}}$ 表示类别， ${n_{i}}$ 是类别 ${C_{i}}$ 的样本数量， ${n}$ 是总的样本容量。</li><li>计算条件概率：<br>$$<br>P(x_{j} \vert C_{i}) &#x3D; \frac{n_{i,j}}{n_{i}}<br>$$<br> ${n_{i,j}}$ 是在类别 ${C_{i}}$ 中，特征 ${x_{j}}$ 出现的次数。</li></ol><h2 id="2-2-预测阶段"><a href="#2-2-预测阶段" class="headerlink" title="2.2 预测阶段"></a>2.2 预测阶段</h2><p>给定一个待分类样本 $\small{X}$ ，朴素贝叶斯算法通过以下步骤来计算其属于每个类别的后验概率：<br>$$<br>P(C_{i} \vert X) &#x3D; \frac{P(X \vert C_{i})}{P(X)} \cdot P(C_{i})<br>$$<br>上面的公式中， $\small{P(X)}$ 对应到每个类别都是一个常量，可以忽略掉它，再结合独立性假设有：<br>$$<br>P(C_{i} \vert X) \propto P(C_{i}) \cdot P(x_1 \vert C_{i}) \cdot P(x_2 \vert C_{i}) \cdot \ldots \cdot P(x_n \vert C_{i})<br>$$<br>然后选择具有最高后验概率的类别作为预测结果。</p><h1 id="3-API-使用"><a href="#3-API-使用" class="headerlink" title="3 API 使用"></a>3 API 使用</h1><p>在 <code>sklearn.navie_bayes</code> 模块下有五个朴素贝叶斯算法的变体，每种变体针对不同类型的数据和特征分。</p><table><thead><tr><th>分类器</th><th>特征类型</th><th>主要假设</th></tr></thead><tbody><tr><td><code>BernoulliNB</code></td><td>二元特征</td><td>特征服从 Bernoulli 分布</td></tr><tr><td><code>CategoricalNB</code></td><td>类别特征</td><td>特征服从多项式分布，常用于处理类别数据</td></tr><tr><td><code>ComplementNB</code></td><td>计数特征</td><td>利用补集概率，常用于处理不平衡数据集</td></tr><tr><td><code>GaussianNB</code></td><td>连续特征</td><td>特征服从高斯分布</td></tr><tr><td><code>MultinomialNB</code></td><td>计数特征</td><td>特征服从多项式分布，常用于文本分类</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br><br>model = GaussianNB()<br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 分类结果</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 分类概率，为了方便观看，保留两位小数</span><br>y_proba = model.predict_proba(X_test).<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="4-算法优缺点"><a href="#4-算法优缺点" class="headerlink" title="4 算法优缺点"></a>4 算法优缺点</h1><p>优点：</p><ol><li>逻辑简单容易实现，适合大规模数据集。</li><li>运算开销较小。预测需要用到的概率在训练阶段都已经准好了，当新数据来了之后，只需要获取对应的概率值并进行简单的运算就能获得预测的结果。</li><li>受噪声和无关属性影响小。</li></ol><p>缺点：由于引入了“特征相互独立”这个假设，缺点也相当明显，因为在实际应用中，特征之间很难做到完全独立，尤其是维度很高的数据，如果特征之间的相关性较大，那么分类的效果就会变得很差。</p><p>为了解决朴素贝叶斯的缺点，在其基础上又衍生出了一些新的方法，包括：半朴素贝叶斯（One Dependent Estimator）、AODE（Averaged One Dependent Estimator）、K 依赖朴素贝叶斯、朴素贝叶斯网络、高斯混合朴素贝叶斯等。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>埃氏筛质数判定</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%83%E6%B0%8F%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>从 2 开始，将每个质数的倍数都标记为非质数，最终剩下未被标记的就是质数。<br>举例说明（筛选 2~30 的质数）：</p><ol><li>初始时，默认 2~30 全部为质数。</li><li>2 是质数，标记 2 的所有倍数（4, 6, 8…）不是质数。</li><li>找到下一个未被标记的数：3，是质数，标记 3 的倍数（6, 9, 12…）不是质数。</li><li>接着是 5、7……依此类推，直到 $\sqrt30$ ≈ 5 为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> not_prime[N];  <span class="hljs-comment">// true表示不是质数，false表示质数，默认全是质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// 埃氏筛标记 0~n</span><br>    not_prime[<span class="hljs-number">0</span>] = not_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++)  <br>        <span class="hljs-keyword">if</span>(!not_prime[i])  <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt;= n; j += i)  <br>                not_prime[j] = <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dns">正式课：<span class="hljs-number">51*24=1224</span><br>直播课：<span class="hljs-number">7*180=1260</span><br>正常补课：<span class="hljs-number">4*100+2*24</span>+<span class="hljs-number">2*24=496</span><br>插班补课：<span class="hljs-number">2*100=200</span><br>集训补课：<span class="hljs-number">1</span>*<span class="hljs-number">300=300</span><br>预热课：<span class="hljs-number">6*96=576</span><br>体验课：<span class="hljs-number">5*100=500</span><br>清华附：<span class="hljs-number">1</span>*<span class="hljs-number">400=400</span><br><span class="hljs-number">1224+1260</span>+<span class="hljs-number">496+200</span>+<span class="hljs-number">300+576</span>+<span class="hljs-number">500+400</span>=<span class="hljs-number">4956</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找（唯一值）</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%94%AF%E4%B8%80%E5%80%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在 n 个元素有序的（升序）整型数组 nums 中查找目标值 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li><strong>数组为有序数组</strong></li><li><strong>数组中无重复元素</strong><br>一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的</li></ul><p>根据<strong>循环不变量</strong>规则，二分查找的过程中，想清楚区间的定义，区间的定义就是不变量，保持不变量，在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分区间的定义一般为两种，左闭右闭[left, right]，或者左闭右开[left, right)。</p><h1 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h1><ul><li>左闭右开，左初始边界 <code>left = 0</code>，右初始边界 <code>right = nums.size()</code></li><li><code>while(left &lt; right)</code>，因为左闭右开，右边取不到，left &#x3D;&#x3D; right 没有意义</li><li><code>right</code> 更新为 <code>mid</code>，因为当前 <code>target&lt;nums[mid]</code>，下一个区间不会再去比较 nums[mid]，target 一定在 mid 左边，又因为右开取不到右区间，所以 right 更新为 mid</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为 <code>target&gt;nums[mid]</code>，target 一定在 mid 右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;  <br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size();  <br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;  <br>        <span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  //防止溢出<br>        <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h1><ul><li>左闭右闭，左初始边界 <code>left = 0</code>，右初始边界 <code>right = nums.size() - 1</code></li><li><code>while(left &lt;= right)</code>，因为左闭右闭，left &#x3D;&#x3D; right 有意义可以取到</li><li><code>right</code> 更新为 <code>mid - 1</code>，因为当前 <code>target&lt;nums[mid]</code>，target 一定在 mid 左边，又因为右闭可以取到，所以 right 更新为 mid - 1</li><li><code>left</code> 更新为 <code>mid + 1</code>，因为 <code>target&gt;nums[mid]</code>，target 一定在 mid 右边，因为左闭可以取到，所以 left 更新为 mid + 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> binary_search(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> target) &#123;<br><span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br><span class="hljs-built_in">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整数二分"><a href="#1-整数二分" class="headerlink" title="1 整数二分"></a>1 整数二分</h1><ol><li>指针的跳跃次数 <code>logn</code></li><li><code>l + 1 = r</code> 时结束，也就是 <code>l</code> 和 <code>r</code> 紧挨的时候</li><li>可行区的指针最后一定指向答案</li><li>开区间可以正确处理边界（<code>l</code>和<code>r</code>初始化在数组的两侧）</li></ol><p><strong>注意：</strong> 访问<code>a[l]</code>或<code>a[r]</code>的时候注意边界问题</p><p>例如目标值在左侧，需要判断 <code>a[l] == x</code>，<code>l</code>有可能一直是-1，此时访问<code>a[l]</code>会出现下标越界</p><h2 id="1-1-最大化查找"><a href="#1-1-最大化查找" class="headerlink" title="1.1 最大化查找"></a>1.1 最大化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> q)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid] &lt;= q) l = mid;  <span class="hljs-comment">// l 一直在可行区内</span><br><span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// r 一直在不可行区内</span><br>&#125;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_binary1.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><h2 id="1-2-最小化查找"><a href="#1-2-最小化查找" class="headerlink" title="1.2 最小化查找"></a>1.2 最小化查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid] &gt;= x) r = mid;  <span class="hljs-comment">// r 一直在可行区内</span><br><span class="hljs-keyword">else</span> l = mid;  <span class="hljs-comment">// l 一直在不可行区内</span><br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_binary2.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><h2 id="1-3-二分函数"><a href="#1-3-二分函数" class="headerlink" title="1.3 二分函数"></a>1.3 二分函数</h2><h3 id="1-3-1-lower-bound-begin-end-x-第一个-x"><a href="#1-3-1-lower-bound-begin-end-x-第一个-x" class="headerlink" title="1.3.1 lower_bound(begin, end, x) 第一个 &gt;&#x3D;x"></a>1.3.1 lower_bound(begin, end, x) 第一个 &gt;&#x3D;x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于等于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置（由于r一直在右边界未发生移动）</li></ul><p><img src="/../../../cpp_assets/c_binary_fun1.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回值为地址，减去起始地址a为下标值</span><br><span class="hljs-type">int</span> index = <span class="hljs-built_in">lower_bound</span>(a, a + n, x) - a;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-upper-bound-begin-end-x-第一个-x"><a href="#1-3-2-upper-bound-begin-end-x-第一个-x" class="headerlink" title="1.3.2 upper_bound(begin, end, x) 第一个 &gt;x"></a>1.3.2 upper_bound(begin, end, x) 第一个 &gt;x</h3><ul><li><code>begin</code>：待排序数组的起始地址</li><li><code>end</code>：待排序数组结束地址下一个位置的指针</li><li><code>x</code>：要查找的值</li></ul><p><strong>前提是有序的情况下</strong>：</p><ul><li>如果找得到返回指向第一个大于x值的位置。</li><li>如果找不到则返回指向尾元素的下一个位置</li></ul><p><img src="/../../../cpp_assets/c_binary_fun2.png" alt="Pasted-image-202503311343047ead4742bd8a0a4a.png"></p><blockquote><p>用<code>upper_bound</code>返回值 - a - 1 就是最后一个小于等于x的下标 </p></blockquote><h1 id="2-浮点数二分"><a href="#2-浮点数二分" class="headerlink" title="2 浮点数二分"></a>2 浮点数二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;  <span class="hljs-comment">// eps表示精度，比题目要求小数位多两位即可</span><br><span class="hljs-keyword">while</span>(r - l &gt; eps) &#123;<br><span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-二分答案"><a href="#3-二分答案" class="headerlink" title="3 二分答案"></a>3 二分答案</h1><p>二分答案与二分查找类似，要求满足条件的<strong>答案是单调有序的</strong>。<br>原理：在答案可能的范围<code>(L, R)</code>内二分查找答案，不断检查当前答案是否满足题目的要求，根据检查结果更新查找的区间，最终取得最符合题目要求的答案。</p><p>同样可以使用以下板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> ans)</span> </span>&#123;<br><span class="hljs-comment">// 根据题意，符合条件返回true，否则false</span><br>&#125;<br><br><span class="hljs-comment">// 假设这里分析得出答案最小值为min，最大值为max</span><br><br><span class="hljs-type">int</span> l = min - <span class="hljs-number">1</span>, r = max + <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// 根据题目答案范围设置 l 和 r，注意初始值要在边界两侧，开区间</span><br><span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 下面 l 和 r 的顺序根据题目进行调整</span><br><span class="hljs-keyword">if</span>(check[mid]) l = mid;  <span class="hljs-comment">// 满足题意</span><br><span class="hljs-keyword">else</span> r = mid;  <span class="hljs-comment">// 不满足题意</span><br>&#125;<br><span class="hljs-keyword">return</span> l;  <span class="hljs-comment">// 根据题意进行调整</span><br></code></pre></td></tr></table></figure><blockquote><p>关于开区间，由于最终<code>l</code>和<code>r</code>一定会停在相邻的位置，左边是<code>l</code>，右边是<code>r</code>。<br>最终返回的答案，不论使用的是<code>l</code>还是<code>r</code>，只要作为答案的指针能够在整个答案的闭区间内移动即可。<br>比如：<br>最终答案返回<code>r</code>，<code>r</code>的初始值可以是<code>max</code>，而不用取外侧的<code>max + 1</code>，因为最终<code>r</code>可以取到<code>max</code>；但<code>l</code>必须取到<code>min - 1</code>，因为最终答案有可能是<code>min</code>，而<code>l</code>如果占到<code>min</code>，则会出现<code>r</code>取不到最终答案的情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-模拟枚举"><a href="#1-模拟枚举" class="headerlink" title="1 模拟枚举"></a>1 模拟枚举</h1><p>枚举算法是我们在日常中使用到的最多的一个算法，枚举算法的核心思想就是：<strong>枚举所有的可能</strong>。枚举算法简单粗暴，暴力的枚举所有可能速度可能比较慢，但是总能得出正确答案。</p><p>枚举算法的三要素：<strong>枚举对象</strong>、<strong>枚举范围</strong>和<strong>判定条件</strong></p><blockquote><p>比如密码锁，枚举 000～999 的情况<br>枚举对象：密码<br>枚举范围：000～999<br>判定条件：否密码是否正确(能否打开锁)</p></blockquote><h1 id="2-递归算法"><a href="#2-递归算法" class="headerlink" title="2 递归算法"></a>2 递归算法</h1><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……</p></blockquote><p>这就是语言上的递归，在程序设计领域，递归是指函数 (或方法)<strong>直接</strong>或<strong>间接</strong>调用自身的一种操作，如下图所示。<br><img src="/../../../cpp_assets/c_recursion.png" alt="Pasted-image-202503062344352c9c59d453412a7c.png"></p><p>递归的两大要素</p><ul><li>具有递归边界条件：所描述问题的最简单情况，它本身不再使用递归的定义。</li><li>递归定义：使问题向边界条件转化的规则！</li></ul><p>递归执行的过程中遇到调用函数，程序就先记住当前执行的位置，然后将值拷贝过去，遇到函数就故技重施重复以上操作，直到到达递归边界，再一层一层的回去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在递归函数前面的正序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br>cout &lt;&lt; n;<br><span class="hljs-built_in">funcA</span>(n + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//在递归函数后面的逆序执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span><br><span class="hljs-built_in">funcB</span>(n + <span class="hljs-number">1</span>);<br>cout &lt;&lt; n;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong>否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p></blockquote><h1 id="3-递推算法"><a href="#3-递推算法" class="headerlink" title="3 递推算法"></a>3 递推算法</h1><p>递推算法是一种用<strong>若干步可重复运算</strong>来描述复杂问题的方法。通常是通过计算前面的一些<br>项来得出序列中的指定项的值。<br>比如斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//f[i]记录第i项斐波那契数列是多少</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++） <br>f[i] = f[i - <span class="hljs-number">2</span>] + f[i - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//a[i]记录i条直线分割平面有几个部分</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 原有的 ＋ 新的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>a[i] = a[i - <span class="hljs-number">1</span>] + i; <br></code></pre></td></tr></table></figure><h1 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h1><p>贪心算法（greedy algorithm），又称贪婪算法，在对问题求解时，总是做出在当前看来是<br>最好的选择。<br>不从整体最优上加以考虑，算法得到的是在某种意义上的<strong>局部最优解</strong>。<br>在解决贪心算法的问题时，需要保证每一步所作的贪心选择，能够最终导致问题的整体最优解。</p><h1 id="5-前缀和与差分"><a href="#5-前缀和与差分" class="headerlink" title="5 前缀和与差分"></a>5 前缀和与差分</h1><h2 id="5-1-前缀和"><a href="#5-1-前缀和" class="headerlink" title="5.1 前缀和"></a>5.1 前缀和</h2><p>前缀和是一个常见的算法技巧，用于<strong>快速计算数组中某个区间内元素的和</strong><br>它的基本思想是<strong>预处理</strong>出数组的前缀和数组，然后利用前缀和数组来快速计算任意区间的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></td></tr></table></figure><h2 id="5-2-差分"><a href="#5-2-差分" class="headerlink" title="5.2 差分"></a>5.2 差分</h2><p>差分是一种数学运算方法，一维差分是指数列中<strong>相邻两项之间的差值</strong></p><p>对原数组［l,r］整体增加 c 时，差分数组只需要修改第 l 项和第 r+1 项<br><img src="/../../../cpp_assets/c_dif.png" alt="Pasted-image-202503062344352c9c59d453412a7c.png"></p><p>因为差分数组只是与前面项的差值，所以从第一项累加到第 i 项即可得到原数组第 i 项的数值，可以结合前缀和快速计算</p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h1><h2 id="6-1-常用数学函数"><a href="#6-1-常用数学函数" class="headerlink" title="6.1 常用数学函数"></a>6.1 常用数学函数</h2><ul><li><code>max(a, b)</code> 求同类型两者的较大者</li><li><code>min(a, b)</code> 求同类型两者的较小者</li><li><code>pow(a, b)</code> 求a的b次方</li><li><code>sqrt(x)</code> 求x的开方根</li><li><code>abs(x)</code> 求整数x的绝对值</li><li><code>fabs(x)</code> 求浮点数x的绝对值</li><li><code>round(x)</code> 四舍五入取整</li><li><code>floor(x)</code> 向下取整</li><li><code>ceil(x)</code> 向上取整</li></ul><h2 id="6-2-for-each-注意事项"><a href="#6-2-for-each-注意事项" class="headerlink" title="6.2 for each 注意事项"></a>6.2 for each 注意事项</h2><p><code>for(auto i : arr)</code> i是每一个元素的副本，可以用来遍历容器，但不能修改元素<br><code>for(auto &amp; i : arr)</code> i的引用可以直接修改arr中的实际元素     </p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器填充函数</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-fill-按元素填充"><a href="#1-fill-按元素填充" class="headerlink" title="1 fill() 按元素填充"></a>1 fill() 按元素填充</h1><ul><li>用于将容器或数组的指定范围内的元素赋值为指定值（按元素类型填充）。</li><li>属于 C++ STL 算法（<code>&lt;algorithm&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址到结束地址的下一位置全部赋为目标值</span><br><span class="hljs-built_in">fill</span>(起始地址, 结束地址下一位, 值);<br><br><span class="hljs-built_in">fill</span>(a, a + n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 一维数组</span><br><span class="hljs-built_in">fill</span>(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>] + n * n, <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 二维数组</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 动态数组</span><br></code></pre></td></tr></table></figure><h1 id="2-memset-按字节填充"><a href="#2-memset-按字节填充" class="headerlink" title="2 memset() 按字节填充"></a>2 memset() 按字节填充</h1><ul><li>用于将一块内存的每个字节设置为指定的值（按字节填充）。</li><li>属于 C 标准库函数（<code>&lt;cstring&gt;</code> 头文件）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从起始地址将要填充的字节数都填充为目标值</span><br><span class="hljs-built_in">memset</span>(起始地址, 值， 要填充的字节数);<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a)); <span class="hljs-comment">// 所有元素初始化为0</span><br><br><span class="hljs-type">char</span> c[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(c, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-built_in">sizeof</span>(c));  <span class="hljs-comment">// 所有元素初始化为A</span><br></code></pre></td></tr></table></figure><blockquote><p>不能直接用于非字节类型，比如 <code>int a[5]; memset(a, 1, sizeof(a));</code> 并不会将每个 <code>int</code> 设为 <code>1</code>，而是每个字节设为 <code>0x01</code>，导致每个 <code>int</code> 的实际值为 <code>0x01010101</code>（16843009）。</p></blockquote><h1 id="3-对比"><a href="#3-对比" class="headerlink" title="3 对比"></a>3 对比</h1><table><thead><tr><th>特性</th><th><code>memset</code></th><th><code>fill</code></th></tr></thead><tbody><tr><td><strong>填充单位</strong></td><td>字节</td><td>元素</td></tr><tr><td><strong>头文件</strong></td><td><code>&lt;cstring&gt;</code></td><td><code>&lt;algorithm&gt;</code></td></tr><tr><td><strong>效率</strong></td><td>极高（硬件优化）</td><td>较高（通用循环赋值）</td></tr><tr><td><strong>适用类型</strong></td><td><code>char</code>、内存块</td><td>任意类型（如 <code>int</code>、<code>double</code>）</td></tr><tr><td><strong>安全性</strong></td><td>低（易误用导致数据错误）</td><td>高（类型安全）</td></tr><tr><td><strong>典型用途</strong></td><td>清零内存、初始化字符数组</td><td>初始化 STL 容器、非字节类型数组</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符数组与字符串</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字符数组"><a href="#1-字符数组" class="headerlink" title="1 字符数组"></a>1 字符数组</h1><ul><li><code>strlen(charr)</code> 返回字符串的长度，不包含结束符\0</li><li><code>strcpy(charr1, charr2)</code> 复制字符串，字符串charr2复制给charr1，返回charr1</li><li><code>strncpy(charr1, charr2)</code> 将charr2前n个字符复制给charr1</li><li><code>strcat(charr1, charr2)</code> 拼接字符串，字符串charr2拼接在charr1后面，返回charr1</li><li><code>strncat(charr1, charr2)</code> 将字符串charr2前n个字符拼接到charr1<ul><li><strong>注</strong>：如果添加或者复制后的charr1数组越界则会报错</li></ul></li><li><code>strcmp(charr1,charr2)</code> 比较字符串，如果charr1&gt;charr2 返回正整数，charr1&#x3D;charr2 返回0，charr1&lt;charr2 返回负整数</li><li><code>strncmp(charr1,charr2)</code> 比较charr1和charr2的前n个字符</li></ul><p>字符数组转 <code>int</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">atoi</span>(a);<br></code></pre></td></tr></table></figure><p>字符数组转 &#96;string</p><ul><li><p>直接赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s = a;<br></code></pre></td></tr></table></figure></li><li><p>构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;  <br><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(a)</span></span>;  <span class="hljs-comment">// 全部转换</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(a, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 指定长度转换</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2-string类"><a href="#2-string类" class="headerlink" title="2 string类"></a>2 string类</h1><h2 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h2><p>在 <code>#inlcude &lt;string&gt;</code> 中使用</p><blockquote><p><code>string</code>不是<strong>基本数据类型</strong>，是C++中对<strong>char</strong>封装成的<strong>类</strong>。主要用于<strong>字符串</strong>处理，可以使用<strong>输入输出流</strong>方式直接进行<code>string</code>操作，也可以通过<strong>文件</strong>等手段进行<code>string</code>操作。</p></blockquote><p><img src="/../../../cpp_assets/c_string.png"></p><h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <span class="hljs-comment">//空字符串</span><br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>; <span class="hljs-comment">//5个a</span><br>string s2 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//s2为123456</span><br></code></pre></td></tr></table></figure><h2 id="2-3-输入输出"><a href="#2-3-输入输出" class="headerlink" title="2.3 输入输出"></a>2.3 输入输出</h2><ul><li><p><code>cin &gt;&gt; s;</code>   读到空格、回车、文件结束符停止</p></li><li><p><code>getline(cin, s);</code> 读入一整行</p></li><li><p><code>cout &lt;&lt; s;</code> 输出整个字符串</p></li><li><p><code>cout &lt;&lt; s[2];</code> 按下标输出</p></li></ul><h2 id="2-4-遍历"><a href="#2-4-遍历" class="headerlink" title="2.4 遍历"></a>2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-5-常用函数"><a href="#2-5-常用函数" class="headerlink" title="2.5 常用函数"></a>2.5 常用函数</h2><ul><li><code>str.length()</code>&#x2F;<code>str.size()</code> 返回字符串真实长度，不包含结束符\0</li><li><code>sizeof(type)</code>数据类型用括号  <code>sizeof var_name</code>  变量名可以不用括号 </li><li><code>str.empty()</code> 字符串判空，空串返回<code>true</code>，非空返回<code>false</code></li><li><code>str1.insert(pos, str2)</code> 在str1下标pos处插入str2</li><li><code>str.substr(pos,len)</code> 返回一个从下标pos开始截取长度为len的字符串</li><li><code>str.erase(pos, len)</code> 删除从下标pos开始的len个字符</li><li><code>str1.replace(pos, len, str2) </code> 将str1中下标为pos开始的len个元素替换为str2</li><li><code>str.find(s, pos)</code> 从str中下标为pos的位置开始查找，返回s第一次出现的下标，查找不到返回 <code>string::npos</code></li><li><code>str.clear()</code> 清空str中的内容</li><li>string的拼接复制比较可以直接使用<code>+</code> <code>=</code> <code>&gt; &lt; &gt;= &lt;= != ==</code></li></ul><h4 id="size-获取大小"><a href="#size-获取大小" class="headerlink" title="size()  获取大小"></a><code>size()</code>  <strong>获取大小</strong></h4><p>语法:</p><blockquote><p><strong>s.size()</strong><br>返回<strong>元素数目</strong></p></blockquote><hr><h4 id="length-获取长度"><a href="#length-获取长度" class="headerlink" title="length() 获取长度"></a><code>length()</code> <strong>获取长度</strong></h4><p>语法:</p><blockquote><p><strong>s.length()</strong><br>返回<strong>字符串长度</strong>, 与**size()**返回的数字相同</p></blockquote><hr><h4 id="empty-判空"><a href="#empty-判空" class="headerlink" title="empty() 判空"></a><code>empty()</code> <strong>判空</strong></h4><p>语法:</p><blockquote><p><strong>s.empty()</strong><br>若为空, 返回<strong>true</strong>, 非空返回<strong>false</strong></p></blockquote><hr><h4 id="clear-清空"><a href="#clear-清空" class="headerlink" title="clear() 清空"></a><code>clear()</code> <strong>清空</strong></h4><p>语法:</p><blockquote><p><strong>s.clear</strong>()<br><strong>清空所有元素</strong></p></blockquote><hr><h4 id="push-back-尾部插入"><a href="#push-back-尾部插入" class="headerlink" title="push_back() 尾部插入"></a><code>push_back()</code> <strong>尾部插入</strong></h4><p>语法:</p><blockquote><p><strong>s.push_back(c)</strong><br><strong>尾部插入一个字符</strong>，可用+&#x3D;代替</p></blockquote><hr><h4 id="pop-back-尾部删除"><a href="#pop-back-尾部删除" class="headerlink" title="pop_back() 尾部删除"></a><code>pop_back()</code> <strong>尾部删除</strong></h4><p>语法:</p><blockquote><p><strong>s.pop_back()</strong><br><strong>尾部删除一个元素</strong></p></blockquote><hr><h4 id="back-访问尾部"><a href="#back-访问尾部" class="headerlink" title="back() 访问尾部"></a><code>back()</code> <strong>访问尾部</strong></h4><p>语法:</p><blockquote><p><strong>s.back()</strong><br><strong>访问尾部元素</strong></p></blockquote><hr><h4 id="front-访问头部"><a href="#front-访问头部" class="headerlink" title="front() 访问头部"></a><code>front()</code> <strong>访问头部</strong></h4><p>语法:</p><blockquote><p><strong>s.front()</strong><br><strong>访问头部第一个元素</strong>，可用s[0]代替</p></blockquote><hr><h4 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h4><p>语法:</p><blockquote><p> <strong>s1.insert(pos, s2)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bd&quot;</span>); <span class="hljs-comment">//在下标2处插入bd</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span> (<span class="hljs-number">4</span>, s2); <span class="hljs-comment">//在下标4处插入s2</span><br></code></pre></td></tr></table></figure><hr><h4 id="erase-删除"><a href="#erase-删除" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h4><p>语法:</p><blockquote><p><strong>s.erase(pos, num)</strong><br><strong>s.erase(pos)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//从下标2开始删除4个字符</span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//从下标3开始删除后面所有字符</span><br></code></pre></td></tr></table></figure><hr><h4 id="substr-截取"><a href="#substr-截取" class="headerlink" title="substr() 截取"></a><code>substr()</code> <strong>截取</strong></h4><p>语法:</p><blockquote><p><strong>s.substr(pos, num)</strong><br><strong>s.substr(pos)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标1开始截取3个字符</span><br>s1 = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始截取整个s2</span><br></code></pre></td></tr></table></figure><hr><h4 id="find-查找"><a href="#find-查找" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h4><p>语法:</p><blockquote><p><strong>s1.find(s2, pos)</strong><br><strong>s1.find(s2)</strong><br>查到返回<strong>下标</strong>, 查不到返回 <strong>string::npos</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向后查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.f</span>ind(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向后查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr><h4 id="rfind-逆序查找"><a href="#rfind-逆序查找" class="headerlink" title="rfind 逆序查找"></a><code>rfind</code> <strong>逆序查找</strong></h4><p>语法:</p><blockquote><p><strong>s1.rfind(s2, pos)</strong><br><strong>s1.rfind(s2)</strong><br>查到返回<strong>下标</strong>, 查不到返回 <strong>string::npos</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//逆序查找整个s1, 返回第一次出现&quot;3&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//从下标1开始向前查找, 返回第一次出现&quot;42&quot;的下标</span><br>s<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(s2, <span class="hljs-number">3</span>); <span class="hljs-comment">//从下标3开始向前查找, 返回第一次出现s2的下标</span><br></code></pre></td></tr></table></figure><hr><h4 id="reverse-逆置"><a href="#reverse-逆置" class="headerlink" title="reverse() 逆置"></a><code>reverse()</code> <strong>逆置</strong></h4><p>语法:</p><blockquote><p><strong>reverse(s.begin, s.end)</strong> &#x2F;&#x2F;包含在&lt;algorithm&gt;中<br><strong>字符串逆置</strong></p></blockquote><hr><h4 id="to-string-int-转-string"><a href="#to-string-int-转-string" class="headerlink" title="to_string() int 转 string"></a><code>to_string()</code> <strong>int 转 string</strong></h4><p>语法</p><blockquote><p> <strong>to_string(int)</strong><br> 返回一个<strong>string</strong></p></blockquote><hr><h4 id="stoi-string-转-int"><a href="#stoi-string-转-int" class="headerlink" title="stoi() string 转 int"></a><code>stoi()</code> <strong>string 转 int</strong></h4><p>语法:</p><blockquote><p><strong>stoi(string)</strong><br>返回一个<strong>int</strong></p></blockquote><hr><h4 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy() 复制"></a><code>copy()</code> <strong>复制</strong></h4><p>语法:</p><blockquote><p><strong>s.copy(a, num, pos)</strong><br><strong>s.copy(a, num)</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];<br>s.<span class="hljs-built_in">copy</span>(a, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//从下标2开始复制5个字符到字符数组a</span><br>s.<span class="hljs-built_in">copy</span>(a,<span class="hljs-number">6</span>); <span class="hljs-comment">//从下标0开始复制6个字符到字符数组a</span><br></code></pre></td></tr></table></figure><h1 id="3-字符数组和string类的区别"><a href="#3-字符数组和string类的区别" class="headerlink" title="3  字符数组和string类的区别"></a>3  字符数组和string类的区别</h1><ul><li><code>string</code>是一个类，<code>string s=&quot;abcd&quot;;</code>中的s是一个对象</li><li>初始化方式不同<ul><li>字符数组后面有 [] ，string类型后面没有[]</li><li>初始化的关键字一个是<code>char</code> 一个是<code>string</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> charr2[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>string str1;<br>string str2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>都可以使用<code>cin cout</code>的方式进行输入输出，<code>getline</code>使用有区别</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>]; <br>cin.<span class="hljs-built_in">getline</span>(charr1,<span class="hljs-number">20</span>);<br>string str;<br><span class="hljs-built_in">getline</span>(cin,str);<br></code></pre></td></tr></table></figure><ul><li>都可以使用下标来访问元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h1><p>字节：数据类型占用的空间大小  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a; <span class="hljs-comment">// 整数类型 4字节  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l; <span class="hljs-comment">// 长整数类型 8字节  </span><br><span class="hljs-type">char</span> c; <span class="hljs-comment">// 字符类型 1字节  </span><br><span class="hljs-type">double</span> d; <span class="hljs-comment">// 浮点数类型 8字节  </span><br></code></pre></td></tr></table></figure><h1 id="2-基本运算"><a href="#2-基本运算" class="headerlink" title="2 基本运算"></a>2 基本运算</h1><p><code>+ - * /</code><br>对于 <code>/</code> 除： 整数&#x2F;整数 &#x3D; 整数 10 &#x2F; 3 &#x3D; 3 如果其中有浮点数，则结果有小数，如 10 &#x2F; 3.0 &#x3D; 3.3333    <code>%</code> 取余，如 10 % 3 &#x3D; 1 15 % 4 &#x3D;3<br><strong>类型自动转换</strong>：在运算过程中，如果数据类型不一致，自动将低精度转化为高精度<br><code>char &lt; int &lt; long long &lt; double</code>  </p><h1 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3 输入输出"></a>3 输入输出</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; a;  <span class="hljs-comment">// 输入  </span><br>cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// 输出 endl 换行  </span><br><span class="hljs-comment">// 格式化输出  </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a的值为%d&quot;</span>, a); <span class="hljs-comment">// %d叫做占位符  </span><br><span class="hljs-comment">// %d 整数 %c 字符 %f 浮点数  </span><br></code></pre></td></tr></table></figure><h1 id="4-分支结构"><a href="#4-分支结构" class="headerlink" title="4 分支结构"></a>4 分支结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>) &#123;  <br>代码块<span class="hljs-number">1</span>  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>) &#123;  <br>代码块<span class="hljs-number">2</span>  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>代码块<span class="hljs-number">3</span>  <br>&#125;  <br></code></pre></td></tr></table></figure><p>如果条件1成立则执行代码块1，否则如果条件2成立则执行代码块2，如果前面都不成立，则执行代码块3<br><strong>注意</strong>：任何一个条件成立就停止判断<br>条件里可以用什么运算？  </p><ul><li>关系运算符 <code>==  !=  &gt;=  &lt;=  &gt;  &lt;</code></li><li>逻辑运算符 <code>&amp;&amp;</code>且（两个都满足才满足）  <code>||</code>或（只要一个满足就满足）  <code>!</code>非（相反）</li></ul><h1 id="5-循环结构"><a href="#5-循环结构" class="headerlink" title="5 循环结构"></a>5 循环结构</h1><p><code>for</code> 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(初始化; 条件; 步长) &#123;<br>循环体;<br>&#125;<br><span class="hljs-comment">//第一次循环先执行初始化语句，之后判断是否满足条件，满足则进入循环执行循环体，不满足则跳出循环，执行循环体之后执行步长语句</span><br></code></pre></td></tr></table></figure><p>常见的两种n遍循环的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从0开始，到 &lt; n，取不到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>&#125;<br><span class="hljs-comment">// 从1开始，到 &lt;= n,能取到n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(条件) &#123;<br>循环体;<br>&#125;<br><span class="hljs-comment">// 条件满足则进入循环体，不满足则跳出</span><br></code></pre></td></tr></table></figure><p><code>do-while</code>循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>循环体;<br>&#125; <span class="hljs-keyword">while</span>(条件);<br><span class="hljs-comment">// 不管是否满足条件，至少先执行一次循环体，然后再判断条件，决定是否继续循环</span><br></code></pre></td></tr></table></figure><p>三种循环通用：</p><ul><li><code>break</code>：终止当前的循环</li><li><code>continue</code>：跳过本轮循环</li></ul><h1 id="6-数组"><a href="#6-数组" class="headerlink" title="6 数组"></a>6 数组</h1><p>需要存储很多相同类型的变量，可以使用数组。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[数组长度];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-type">double</span> d[<span class="hljs-number">10000</span>];<br></code></pre></td></tr></table></figure><blockquote><p>数组访问通过下标（索引）完成，下标从0开始，不能越界。</p></blockquote><p>数组的遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维数组</strong><br>可以理解为数组里面的元素还是一个数组，或者理解为一个矩阵，里面都是相同类型的元素。<br>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数据类型 数组名[行数][列数]; <span class="hljs-comment">// 先行后列</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/Pasted%20image%2020250612193944.png"></p><p>对于二维数组的访问，也是通过下标，先行后列。<br>二维数组遍历，借助循环嵌套完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n行m列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>cin &gt;&gt; a[i][j];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 内层循环整个结束之后，外层循环才会执行一次</span><br></code></pre></td></tr></table></figure><h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h1><p>把常用功能进行封装，把相同的功能提取出来，不同的地方作为参数。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回值类型 函数名(参数<span class="hljs-number">1</span>类型 参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>类型 参数<span class="hljs-number">2</span>) &#123;<br>函数体;<br>返回;<br>&#125;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 在主函数调用自定义函数</span><br><span class="hljs-type">int</span> max_num = <span class="hljs-built_in">max</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h1><p>把不同类型的变量封装成一个自定义类型，就叫结构体。<br>比如自己创造一个学生类型。<br>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> 结构体类型名 &#123;<br>类型<span class="hljs-number">1</span> 变量<span class="hljs-number">1</span>;<br>类型<span class="hljs-number">2</span> 变量<span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码写完，是我们自己创造了一个类型为<code>student</code>的数据类型，但还没有创建变量，格式和正常的<code>int</code>一样，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stu中包括name和age</span><br>student stu;<br><span class="hljs-comment">// 也可以创建数组，数组中的每一个元素都是一个结构体</span><br>student s[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>创建结构体变量还有一种简便方法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125; stu;<br></code></pre></td></tr></table></figure><p>结构体成员的访问：<br>使用<code>.</code>来访问结构体变量里面的成员，对于每个成员都像一个普通变量一样使用，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; stu.name &gt;&gt; stu.age;<br><span class="hljs-comment">// 结构体数组使用如下</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; s[i].name &gt;&gt; s[i].age;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL学习指北</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/STL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-STL-概述"><a href="#1-STL-概述" class="headerlink" title="1 STL 概述"></a>1 STL 概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><strong>STL</strong>是Standard Template Library的简称，中文名<strong>标准模板库</strong>，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，<strong>STL</strong>是一些“<strong>容器</strong>”的集合，这些“<strong>容器</strong>”有<code>list</code>,<code>vector</code>,<code>set</code>,<code>map</code>等，<strong>STL</strong>也是<strong>算法</strong>和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。<strong>STL</strong>的目的是<strong>标准化组件</strong>，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。<br>在C++标准中，<strong>STL</strong>被组织为下面的13个<strong>头文件</strong>：<code>&lt;algorithm&gt;</code>、<code>&lt;deque&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;iterator &gt;</code> 、<code>&lt;vector&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;memory.h&gt;</code>、<code>&lt;numeric&gt;</code>、<code>&lt;queue&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt; stack&gt;</code>和</p><hr><p>STL 容器包括<strong>顺序式容器</strong>和<strong>关联式容器</strong>。</p><ul><li>关联容器中的元素按关键字保存和访问；顺序容器中的元素按它们在容器中的位置和顺序保存和访问</li><li>关联容器不支持顺序容器位置相关的操作，因为关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义；关联容器也不支持构造函数或插入操作这些接收一个元素值和一个数量值的操作。</li><li>关联容器支持高效的关键字查找和访问，两个主要的关联容器类型是 <code>map</code> 和 <code>set</code>：<ul><li><code>map</code> 中的元素是键值对（key–value）：关键字起到索引的作用，值则表示与索引相关联的数据。</li><li><code>set</code> 中的元素只包含关键字：<code>set</code> 支持高效的关键字查询操作，检查给定关键字是否在 <code>set</code> 中。</li></ul></li></ul><h2 id="1-2-顺序式容器"><a href="#1-2-顺序式容器" class="headerlink" title="1.2 顺序式容器"></a>1.2 顺序式容器</h2><p><code>vector</code>：动态数组，从末尾能快速插入与删除，直接访问任何元素。<br><code>list</code>：双链表，从任何地方快速插入与删除。<br><code>queue</code>：队列，先进先出。<br><code>deque</code>：双向队列，从前面或后面快速插入与删除，直接访问任何元素。<br><code>priority_queue</code>：优先队列，最高优先级元素总是第一个出列。<br><code>stack</code>：栈，先进后出。</p><p>它们之所以被称为<strong>顺序容器</strong>，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p><h2 id="1-3-关联式容器"><a href="#1-3-关联式容器" class="headerlink" title="1.3 关联式容器"></a>1.3 关联式容器</h2><p>元素位置取决于特定的排序准则，和插入顺序无关。<br><code>set</code>：集合，快速查找，不允许重复值。<br><code>multiset</code>：允许有两个次序相同的元素的集合。<br><code>map</code>：由键值对组成。<br><code>multimap</code>：允许键对有相等次序的映射。</p><h2 id="1-4-容器特点"><a href="#1-4-容器特点" class="headerlink" title="1.4 容器特点"></a>1.4 容器特点</h2><blockquote><p>任何两个容器对象，只要它们的类型相同，就可以用 <strong>&gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</strong> 进行比较运算。 </p></blockquote><p>假设a、b是两个类型相同的容器对象，其规则如下：<br><strong>a &#x3D;&#x3D; b</strong>：若 a 和 b 中的元素个数相同，且对应元素均相等，则a &#x3D;&#x3D; b的值为 true，否则值为 false。元素是否相等是用<code>==</code>运算符进行判断的。<br><strong>a &lt; b**：依次比较，若a中元素少于b则判断成立，或者a中每个元素都大于b中对应的元素成立，为true，否则为false。<br>**a !&#x3D; b**：等价于 !(a &#x3D;&#x3D; b)。<br>**a &gt; b</strong>：等价于 b &lt; a。<br><strong>a &lt;&#x3D; b**：等价于 !(b &lt; a)。<br>**a &gt;&#x3D; b</strong>：等价于 !(a &lt; b)。</p><p><strong>所有容器</strong>都有以下两个成员函数：<br><code>size()</code>：返回容器对象中元素的个数。<br><code>empty()</code>：判断容器对象是否为空。</p><p><strong>顺序容器</strong>和<strong>关联容器</strong>都有以下成员函数：<br><code>begin()</code>：返回指向容器中第一个元素的迭代器。<br><code>end()</code>：返回指向容器中最后一个元素后面的位置的迭代器。<br><code>rbegin()</code>：返回指向容器中最后一个元素的反向迭代器（reverse_iterator）。<br><code>rend()</code>：返回指向容器中第一个元素前面的位置的反向迭代器。<br><code>erase()</code>：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。<br><code>clear()</code>：从容器中删除所有元素。<br>如果一个容器是空的，则 <code>begin()</code> 和 <code>end()</code> 的返回值相等，<code>rbegin()</code> 和 <code>rend()</code> 的返回值也相等。</p><p><strong>顺序容器</strong>还有以下常用成员函数：<br><code>front()</code>：返回容器中第一个元素的引用。<br><code>back()</code>：返回容器中最后一个元素的引用。<br><code>push_back()</code>：在容器末尾增加新元素。<br><code>pop_back()</code>：删除容器末尾的元素。<br><code>insert()</code>：插入一个或多个元素。 </p><p>对于所有容器基本都有的<code>size()</code>、<code>empty()</code>、<code>clear()</code>，下面不再赘述</p><h1 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h1><h2 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h2><p>在 <code>#include &lt;vector&gt;</code> 中使用</p><blockquote><p><code>vector</code>是STL的<strong>动态数组</strong>，在运行时能根据情况改变数组的大小。由于它是以<strong>数组</strong>形式存储，也就是说它的<strong>内存空间是连续的</strong>，所以索引可以在常数时间内完成，但是在中间进行<strong>插入</strong>和<strong>删除</strong>会造成内存块的复制。另外，如果数组后面的内存空间不够，需要申请一块足够大的内存，会影响<code>vector</code>的效率,同时使迭代器失效。</p></blockquote><p><img src="/../../../cpp_assets/c_vector.png"></p><p><strong>vector扩容</strong>示意图:<br><img src="/../../../cpp_assets/c_vector_expand.gif"></p><p><strong>函数</strong>基本功能目录如下!<br><img src="/../../../cpp_assets/c_vector_fun.png"></p><hr><h2 id="2-2-声明"><a href="#2-2-声明" class="headerlink" title="2.2 声明"></a>2.2 声明</h2><table><thead><tr><th>功能</th><th align="left">例子</th><th>说明</th></tr></thead><tbody><tr><td>定义<strong>int</strong>型数组</td><td align="left">vecotr&lt;int&gt; a;</td><td>默认初始化,a为空</td></tr><tr><td></td><td align="left">vector&lt;int&gt; b(a);</td><td>用a定义b</td></tr><tr><td></td><td align="left">vector&lt;int&gt; a(100);</td><td>a有100个值为0的元素</td></tr><tr><td></td><td align="left">vector&lt;int&gt; a(100, 6);</td><td>100个值为6的元素</td></tr><tr><td>定义<strong>string</strong>型数组</td><td align="left">vetor&lt;string&gt; a(10, “null”);</td><td>10个值为null的元素</td></tr><tr><td></td><td align="left">vector&lt;string&gt; vec(10, “hello”);</td><td>10个值为hello的元素</td></tr><tr><td></td><td align="left">vector&lt;string&gt; b(a.begin(), a.end());</td><td>b是a的复制</td></tr><tr><td>定义<strong>结构体</strong>型数组</td><td align="left">struct point { int x, y;}; vector&lt;point&gt; a;</td><td>a用来存坐标</td></tr></tbody></table><ul><li>定义<strong>int</strong>型</li><li>定义<strong>string</strong>型</li><li>定义<strong>结构体</strong>型</li><li>定义<strong>多维数组</strong>,例如定义一个二维数组: <code>vector&lt;int&gt; a[233];</code><br>第一维是固定的长度为233,第二维是动态的</li></ul><p>要注意，它和数组类似但不同一旦声明出来后，<code>vector</code> 容器还是空的没有下标，因此无法直接 <code>cin</code>，需要借助<code>push_back()</code>，访问数据和普通数组一样通过下标访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空的vector 不能输入输出 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 三个元素均为 0 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 三个元素均为1 </span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec3</span><span class="hljs-params">(vec2)</span></span>;<span class="hljs-comment">// 将vec2的元素初始化给vec3</span><br><span class="hljs-comment">// 参数类型要相同 </span><br><br><span class="hljs-comment">// 用迭代器初始化 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite = vec<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 指向vec2的头 </span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = vec<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 指向vec2的尾 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec4</span><span class="hljs-params">(ite, ite1)</span></span>;<br></code></pre></td></tr></table></figure><p>虽然 <code>vector</code> 可以动态扩展，但需要确保在使用下标访问时， <code>vector</code> 已经<strong>分配足够的空间</strong>，否则会出现段错误，如果 <code>vector</code> 还没有分配空间，可以使用 <code>push_back()</code> 插入元素。</p><h2 id="2-3-迭代器"><a href="#2-3-迭代器" class="headerlink" title="2.3 迭代器"></a>2.3 迭代器</h2><p>迭代器就像<strong>STL</strong>容器的“指针”，可以用星号”<code>*</code>“操作符解除引用。<br>一个保存<strong>int</strong>的<strong>vector</strong>的迭代器声明方法为：<code>vector&lt;int&gt;::iterator it;</code><br><strong>vector</strong>的迭代器是“随机访问迭代器”，可以把<strong>vector</strong>的迭代器与一个整数相加减，其行为和<strong>指针</strong>的移动类似。可以把<strong>vector</strong>的两个迭代器相减，其结果也和<strong>指针</strong>相减类似，得到两个迭代器对应下标之间的距离。</p><h2 id="2-4-遍历"><a href="#2-4-遍历" class="headerlink" title="2.4 遍历"></a>2.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(vecor&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); it++) <br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">// auto 代替 vecor&lt;int&gt;::iterator</span><br><br><span class="hljs-comment">// 逆序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); it++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>; it != vec.begin - <span class="hljs-number">1</span>; it--)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : vec) cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-5-常用函数"><a href="#2-5-常用函数" class="headerlink" title="2.5 常用函数"></a>2.5 常用函数</h2><h3 id="push-back-在尾部添加一个元素"><a href="#push-back-在尾部添加一个元素" class="headerlink" title="push_back()  在尾部添加一个元素"></a><code>push_back()</code>  <strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>vec.push_back(value);</strong><br><strong>添加</strong>值为value的元素到当前vector的末尾。</p></blockquote><hr><h3 id="pop-back-删除最后一个元素"><a href="#pop-back-删除最后一个元素" class="headerlink" title="pop_back()  删除最后一个元素"></a><code>pop_back()</code>  <strong>删除最后一个元素</strong></h3><blockquote><p><strong>vec.pop_back();</strong><br><strong>删除</strong>当前vector最后一个元素。</p></blockquote><hr><h3 id="begin-返回起始位置的迭代器"><a href="#begin-返回起始位置的迭代器" class="headerlink" title="begin()  返回起始位置的迭代器"></a><code>begin()</code>  <strong>返回起始位置的迭代器</strong></h3><blockquote><p><strong>vec.begin();</strong><br>返回指向当前vector<strong>起始元素的迭代器</strong>。</p></blockquote><hr><h3 id="end-返回末尾元素下一位置的迭代器"><a href="#end-返回末尾元素下一位置的迭代器" class="headerlink" title="end()  返回末尾元素下一位置的迭代器"></a><code>end()</code>  <strong>返回末尾元素下一位置的迭代器</strong></h3><blockquote><p><strong>vec.end();</strong><br>返回指向当前vector<strong>末尾元素的下一位置的迭代器</strong>。</p></blockquote><hr><h3 id="front-返回起始元素"><a href="#front-返回起始元素" class="headerlink" title="front()  返回起始元素"></a><code>front()</code>  <strong>返回起始元素</strong></h3><blockquote><p><strong>vec.front();</strong><br>返回当前vector<strong>起始元素</strong>。<br>等同于 <code>vec[0]</code> 和 <code>*vec.begin()</code></p></blockquote><hr><h3 id="back-返回末尾元素"><a href="#back-返回末尾元素" class="headerlink" title="back()  返回末尾元素"></a><code>back()</code>  <strong>返回末尾元素</strong></h3><blockquote><p><strong>vec.back();</strong><br>返回当前vector<strong>末尾元素</strong>。<br>等同于 <code>vec[vec.size() - 1]</code> 和 <code>*(vec.end() - 1)</code></p></blockquote><h2 id="2-6-二维vector"><a href="#2-6-二维vector" class="headerlink" title="2.6 二维vector"></a>2.6 二维vector</h2><p><code>vector</code> 可以替代一维数组，并且还可以灵活的自动扩充，当然也可以替代二维数组！，如下声明中的 v 准确来说是变量的声明格式，只不过这个容器神通广大类似于数组，因此叫“一维数组”，但本质是变量。这个变量里面可以塞很多东西，模样像个数组。<br>既然是一个变量，我们可以把它变成一维数组，但很像“二维”，不过每一行都不一定一样长。添加数据的时候要注意，必须找到某一行，然后它是一个变量v[？],通过方法 <code>push_back</code> 将数据保存到这一行的末尾就可以了。访问数据和二维数组一样通过行下标和列下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">// vector 的“二维”</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec[<span class="hljs-number">100</span>];<br><span class="hljs-comment">//添加元素到第0行</span><br>vec[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_vector_array.png"></p><h1 id="3-stack"><a href="#3-stack" class="headerlink" title="3 stack"></a>3 stack</h1><h2 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1 基础概念"></a>3.1 基础概念</h2><p>在 <code>#include &lt;stack&gt;</code> 中使用</p><blockquote><p>栈(<code>stack</code>)是一种<strong>先进后出</strong>的数据结构,栈中只能通过<code>top()</code>来访问<strong>栈顶元素</strong>, 元素的<strong>插入</strong>和<strong>删除</strong>都只能<strong>栈顶</strong>进行。</p></blockquote><p><img src="/../../../cpp_assets/c_stack.png"></p><h2 id="3-2-声明"><a href="#3-2-声明" class="headerlink" title="3.2 声明"></a>3.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>stack&lt;<span class="hljs-type">double</span>&gt; st2;<br>stack&lt;<span class="hljs-type">char</span>&gt; st3;<br></code></pre></td></tr></table></figure><h2 id="3-3-遍历"><a href="#3-3-遍历" class="headerlink" title="3.3 遍历"></a>3.3 遍历</h2><p><strong>堆栈中的数据是不允许随机访问的，也就是说不能通过下标访问，且堆栈内的元素是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将stack中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就需要弹出这个元素，因此该方法只能读取一遍stack中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; st.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    st.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-常用函数"><a href="#3-4-常用函数" class="headerlink" title="3.4 常用函数"></a>3.4 常用函数</h2><h3 id="push-栈顶插入元素"><a href="#push-栈顶插入元素" class="headerlink" title="push()  栈顶插入元素"></a><code>push()</code>  <strong>栈顶插入元素</strong></h3><blockquote><p><strong>st.push(value);</strong><br>在<strong>栈顶</strong>插入一个元素value。</p></blockquote><hr><h3 id="pop-删除栈顶元素"><a href="#pop-删除栈顶元素" class="headerlink" title="pop()  删除栈顶元素"></a><code>pop()</code>  <strong>删除栈顶元素</strong></h3><blockquote><p><strong>st.pop();</strong><br>在<strong>栈顶</strong>删除一个元素。</p></blockquote><hr><h3 id="top-返回栈顶元素"><a href="#top-返回栈顶元素" class="headerlink" title="top()  返回栈顶元素"></a><code>top()</code>  <strong>返回栈顶元素</strong></h3><blockquote><p><strong>st.top()</strong><br>访问<strong>栈顶</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="4-queue"><a href="#4-queue" class="headerlink" title="4 queue"></a>4 queue</h1><h2 id="4-1-基础概念"><a href="#4-1-基础概念" class="headerlink" title="4.1 基础概念"></a>4.1 基础概念</h2><p>在 <code>#include &lt;queue&gt;</code> 中使用</p><blockquote><p>队列(<code>queue</code>)是一种<strong>先进先出</strong>的限制性数据结构，对数据的<strong>存</strong>和<strong>取</strong>有严格要求。它只能通过<code>front()</code>进行访问<strong>队首</strong>元素，通过<code>back()</code>访问<strong>队尾</strong>元素。队列中只有<strong>队头</strong>和<strong>队尾</strong>才可以被外界使用，因此队列<strong>不允许</strong>有<strong>遍历</strong>行为。<br>与<strong>栈</strong>结构不同的是，<strong>队列</strong>的<strong>两端</strong>都”开口”，要求数据只能从<strong>一端进</strong>，从<strong>另一端出</strong>，通常，称进数据的一端为<strong>队尾</strong>，出数据的一端为<strong>队头</strong>，数据元素进队列的过程称为<strong>入队</strong>，出队列的过程称为<strong>出队</strong>。</p></blockquote><p><img src="/../../../cpp_assets/c_queue.png"></p><h2 id="4-2-声明"><a href="#4-2-声明" class="headerlink" title="4.2 声明"></a>4.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>queue&lt;<span class="hljs-type">double</span>&gt; q2;<br>queue&lt;<span class="hljs-type">char</span>&gt; q3;<br></code></pre></td></tr></table></figure><h2 id="4-3-遍历"><a href="#4-3-遍历" class="headerlink" title="4.3 遍历"></a>4.3 遍历</h2><p><strong>和<code>stack</code>类似，不能通过下标访问，是无法遍历的。</strong></p><blockquote><p>我们可以通过while循环的方法将queue中的元素读取一遍，但是这种方法非常局限，因为我们每读取一个元素就要让该元素出队，因此该方法只能读取一遍queue中的元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出队首</span><br>    q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 队首出队</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-常用函数"><a href="#4-4-常用函数" class="headerlink" title="4.4 常用函数"></a>4.4 常用函数</h2><h3 id="push-队尾插入元素"><a href="#push-队尾插入元素" class="headerlink" title="push()  队尾插入元素"></a><code>push()</code>  <strong>队尾插入元素</strong></h3><blockquote><p><strong>q.push(value)</strong><br>在<strong>队尾</strong>插入一个元素value。</p></blockquote><hr><h3 id="pop-删除队头元素"><a href="#pop-删除队头元素" class="headerlink" title="pop()  删除队头元素"></a><code>pop()</code>  <strong>删除队头元素</strong></h3><blockquote><p><strong>q.pop()</strong><br>在<strong>队头</strong>删除一个元素。</p></blockquote><hr><h3 id="front-返回队头元素"><a href="#front-返回队头元素" class="headerlink" title="front()  返回队头元素"></a><code>front()</code>  <strong>返回队头元素</strong></h3><blockquote><p><strong>q.front()</strong><br>返回<strong>队头</strong>元素。</p></blockquote><hr><h3 id="back-返回队尾元素"><a href="#back-返回队尾元素" class="headerlink" title="back()  返回队尾元素"></a><code>back()</code>  <strong>返回队尾元素</strong></h3><blockquote><p><strong>q.back()</strong><br>返回<strong>队尾</strong>元素。</p></blockquote><p><strong>注意</strong>：使用 <code>front()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5 priority_queue"></a>5 priority_queue</h1><h2 id="5-1-基础概念"><a href="#5-1-基础概念" class="headerlink" title="5.1 基础概念"></a>5.1 基础概念</h2><p>在 <code>#inlcude &lt;queue&gt;</code> 中使用</p><blockquote><p>优先队列(priority_queue)，<strong>底层通常使用堆（heap）</strong> 实现。元素被赋予优先级，最高优先级的元素会作为队首元素，有<strong>最高优先级先出</strong>的特征，当访问元素时，只能访问具有最高优先级的元素，可以在任何时候往优先队列里面加入元素，而优先队列底层的数据结构堆（heap）会随时调整结构，使得每次的队首元素都是优先级最高的。priority_queue 可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p></blockquote><h2 id="5-2-声明"><a href="#5-2-声明" class="headerlink" title="5.2 声明"></a>5.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 默认把最大的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br>priority_queue&lt;<span class="hljs-type">double</span>&gt; pq2;<br>priority_queue&lt;<span class="hljs-type">char</span>&gt; pq3;<br><span class="hljs-comment">// 把最小的元素放在队首的位置</span><br>priority_queue&lt;<span class="hljs-type">int</span>，vector&lt;<span class="hljs-type">int</span>&gt;，greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq4;<br></code></pre></td></tr></table></figure><h2 id="5-3-优先级设置"><a href="#5-3-优先级设置" class="headerlink" title="5.3 优先级设置"></a>5.3 优先级设置</h2><h3 id="5-3-1-基本数据类型"><a href="#5-3-1-基本数据类型" class="headerlink" title="5.3.1 基本数据类型"></a>5.3.1 基本数据类型</h3><p>优先队列对基本数据类型的优先级设置一般是数字越大的优先级越高，如果是 char 类型，则是字典序最大的。</p><p>以 <code>int</code> 型为例下面两种是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq1;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; pq2;<br></code></pre></td></tr></table></figure><ul><li><p>第二个参数<code>vector&lt;int&gt;</code>填写的是承载底层数据结构堆 （heap）的容器，如果是其他类型可写为 <code>vector&lt;char&gt;</code>或<code>vector&lt;double&gt;</code></p></li><li><p>第三个参数 <code>less&lt;int&gt;</code> 则是对第一个参数的比较类，<strong>控制优先级</strong>是大是小，<code>less&lt;int&gt;</code> 表示数字大的优先级越大，而 <code>greater&lt;int&gt;</code> 表示数字小的优先级越大。</p></li></ul><h3 id="5-3-2-结构体类型"><a href="#5-3-2-结构体类型" class="headerlink" title="5.3.2 结构体类型"></a>5.3.2 结构体类型</h3><p><strong>方法一</strong>：重载 <code>operator&lt;</code><br>重载（overload）小于号“&lt;”，重载是指对已有的运算符进行重新定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 重载小于运算符，定义优先级</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">// 优先级由 age 实现大堆优先</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &lt; other.age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法二</strong>：使用友元<code>friend</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// friend bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 实现自定义排序</span><br>priority_queue&lt;node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>方法三</strong>：使用 cmp 仿函数</p><p><code>priority_queue</code> 不直接支持使用普通函数（如 <code>cmp</code>）作为比较器，因为 <code>priority_queue</code> 需要一个<strong>类型</strong>而不是一个普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-comment">// 建议使用引用提高效率</span><br>    <span class="hljs-comment">// bool operator()(node const&amp; a, node const&amp; b) &#123;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>        <span class="hljs-comment">// 优先级由 age 的大小决定</span><br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义仿函数 cmp 作为比较器</span><br>priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; pq;<br></code></pre></td></tr></table></figure><blockquote><p>只能对小于号进行重载，重载大于号会编译错误，因为从数学上来讲只需要重载小于号即 f1&gt;f2&lt;&#x3D;&#x3D;&gt;f2&lt;f1。</p></blockquote><h2 id="5-4-遍历"><a href="#5-4-遍历" class="headerlink" title="5.4 遍历"></a>5.4 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出队首</span><br>    pq.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//队首出队</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-常用函数"><a href="#5-5-常用函数" class="headerlink" title="5.5 常用函数"></a>5.5 常用函数</h2><h3 id="push-插入元素"><a href="#push-插入元素" class="headerlink" title="push()  插入元素"></a><code>push()</code>  <strong>插入元素</strong></h3><blockquote><p><strong>pq.push(value)</strong><br>将元素value入队，每次调用排序算法按照优先级排序。</p></blockquote><hr><h3 id="pop-删除队首元素"><a href="#pop-删除队首元素" class="headerlink" title="pop()  删除队首元素"></a><code>pop()</code>  <strong>删除队首元素</strong></h3><blockquote><p><strong>q.pop()</strong><br>删除<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><hr><h3 id="top-返回队首元素"><a href="#top-返回队首元素" class="headerlink" title="top()  返回队首元素"></a><code>top()</code>  <strong>返回队首元素</strong></h3><blockquote><p><strong>pq.top()</strong><br>访问<strong>队首元素</strong>，即最高优先级的元素。</p></blockquote><p><strong>注意</strong>：使用 <code>top()</code> 和 <code>pop()</code> 函数之前，必须用 <code>empty()</code> 判断是否为空。</p><h1 id="6-deque"><a href="#6-deque" class="headerlink" title="6 deque"></a>6 deque</h1><h2 id="6-1-基础概念"><a href="#6-1-基础概念" class="headerlink" title="6.1 基础概念"></a>6.1 基础概念</h2><p>在 <code>#inlcude &lt;deque&gt;</code> 中使用</p><blockquote><p>双端队列(<code>deque</code>)，全名double-ended queue是一种具有<strong>队列</strong>和<strong>栈</strong>的性质的数据结构，它就像是vector和queue的结合。与vector相比，<code>deque</code>在头部增删元素仅需要O(1)的时间；与queue相比，<code>deque</code>像数组一样支持随机访问。双端队列中的元素可以从<strong>两端弹出</strong>，其限定<strong>插入</strong>和<strong>删除</strong>操作在<strong>两端</strong>进行，是一个支持在<strong>两端高效插入或删除元素</strong>的<strong>连续线性存储空间</strong>。 </p></blockquote><p><img src="/../../../cpp_assets/c_deque.png"></p><h2 id="6-2-deque与vector、list"><a href="#6-2-deque与vector、list" class="headerlink" title="6.2 deque与vector、list"></a>6.2 <code>deque</code>与<code>vector</code>、<code>list</code></h2><p><code>deque</code>的结构是一段一段的空间，每段空间都是一样大的，通过一个中控数组（指针数组）进行连接起来。想要扩容就在连接一块空间即可。当指针数组满了，就中控数组扩容即可。这样以来扩容的代价就很低。不需要拷贝原来的数组。对于头插尾插也很简单，就用专门的两个空间进行头插尾插即可，相比<code>vector</code>极大的缓解了扩容、头插头删问题。但是它的[]运算符不够极致。它的[]需要计算在哪个buff数组，在哪个buff数组的第几个。</p><ol><li><strong>内存比较</strong><ul><li><code>vector</code>：连续空间</li><li><code>list</code>：不连续空间</li><li><code>deque</code>：段连续空间</li></ul></li></ol><p><img src="/../../../cpp_assets/c_deque_mem.png"></p><ol start="2"><li>功能比较<ul><li><code>vector</code><ul><li>随机位置的插入和删除效率比较低</li><li>随机访问的效率高（下标运算）</li><li>不支持头添加，支持尾添加</li></ul></li><li><code>list</code><ul><li>随机位置的插入和删除效率高</li><li>不支持随机访问</li><li>支持头添加，支持尾添加</li></ul></li><li><code>deque</code><ul><li>随机位置的插入和删除效率不高（以512个字节为一个单位量）</li><li>支持随机访问（比<code>vector</code>慢，因为要做堆跳转），迭代器的结构较为复杂，会降低访问效率</li><li>支持头添加，支持尾添加</li></ul></li></ul></li><li><strong>使用选择</strong><ul><li>随机访问操作频率高，就选用<code>vector</code></li><li>插入删除频率高，头尾添加，就选用<code>list</code></li><li>随机访问+头添加，就选<code>deque</code></li></ul></li></ol><p><strong>函数</strong>基本功能目录如下<br><img src="/../../../cpp_assets/c_deque_fun.png"></p><hr><h2 id="6-3-声明"><a href="#6-3-声明" class="headerlink" title="6.3 声明"></a>6.3 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deque&lt;<span class="hljs-type">int</span>&gt; dq;       <span class="hljs-comment">// 空的队列，不能输出 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;   <span class="hljs-comment">// 大小为 3 的空队列 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">12</span>)</span></span>;<span class="hljs-comment">// 三个元素均为12 </span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq3</span><span class="hljs-params">(dq2)</span></span>; <span class="hljs-comment">// 复制dq2//参数类型要相同 </span><br></code></pre></td></tr></table></figure><h2 id="6-4-常用函数"><a href="#6-4-常用函数" class="headerlink" title="6.4 常用函数"></a>6.4 常用函数</h2><h3 id="front-返回头部元素"><a href="#front-返回头部元素" class="headerlink" title="front()  返回头部元素"></a><code>front()</code>  <strong>返回头部元素</strong></h3><blockquote><p><strong>dq.front()</strong><br>返回第一个元素的引用。</p></blockquote><hr><h3 id="back-返回尾部元素"><a href="#back-返回尾部元素" class="headerlink" title="back()  返回尾部元素"></a><code>back()</code>  <strong>返回尾部元素</strong></h3><blockquote><p><strong>dq.back()</strong><br>返回最后一个元素的引用。</p></blockquote><hr><h3 id="push-back-在尾部添加一个元素-1"><a href="#push-back-在尾部添加一个元素-1" class="headerlink" title="push_back()  在尾部添加一个元素"></a><code>push_back()</code>  <strong>在尾部添加一个元素</strong></h3><blockquote><p><strong>dq.push_back(value)</strong><br><strong>添加</strong>值为value的元素到末尾。</p></blockquote><hr><h3 id="pop-back-在尾部删除一个元素"><a href="#pop-back-在尾部删除一个元素" class="headerlink" title="pop_back()  在尾部删除一个元素"></a><code>pop_back()</code>  <strong>在尾部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><br><strong>删除</strong>尾部第一个元素。</p></blockquote><hr><h3 id="push-front-在头部添加一个元素"><a href="#push-front-在头部添加一个元素" class="headerlink" title="push_front()  在头部添加一个元素"></a><code>push_front()</code>  <strong>在头部添加一个元素</strong></h3><blockquote><p><strong>dq.push_front(value);</strong><br><strong>添加</strong>值为value的元素到头部。</p></blockquote><hr><h3 id="pop-front-在头部删除一个元素"><a href="#pop-front-在头部删除一个元素" class="headerlink" title="pop_front()  在头部删除一个元素"></a><code>pop_front()</code>  <strong>在头部删除一个元素</strong></h3><blockquote><p><strong>dq.pop_back();</strong><br><strong>删除</strong>头部第一个元素。</p></blockquote><hr><h3 id="insert-插入元素"><a href="#insert-插入元素" class="headerlink" title="insert() 插入元素"></a><code>insert()</code> <strong>插入元素</strong></h3><blockquote><p><strong>dq.insert(iterator, value)</strong>;<br>向iterator迭代器指向元素的前边添加一个元素value，并返回一个迭代器指向新插入的元素。</p></blockquote><hr><h3 id="erase-删除元素"><a href="#erase-删除元素" class="headerlink" title="erase()  删除元素"></a><code>erase()</code>  <strong>删除元素</strong></h3><blockquote><p><strong>dq.erase(iterator);</strong></p><p><strong>dq.erase(iterator1, iterator2)</strong></p><p>参数为一个迭代器，只删除迭代器指向的元素；参数为两个迭代器，删除两个迭代器之间的元素。</p></blockquote><h1 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h1><h2 id="7-1-基础概念"><a href="#7-1-基础概念" class="headerlink" title="7.1 基础概念"></a>7.1 基础概念</h2><p>在 <code>#include &lt;set&gt;</code> 中使用</p><blockquote><p>集合(<code>set</code>) 用于存储<strong>不重复</strong>的元素，并且会自动根据元素的值进行<strong>排序</strong>。</p></blockquote><ul><li><strong>不重复元素</strong>：<code>set</code> 中的元素不能重复。如果尝试插入相同的元素，它会被忽略。</li><li><strong>自动排序</strong>：<code>set</code> 会根据元素的大小自动进行排序，默认是按升序排序。如果想使用自定义的排序规则，也可以提供比较函数。</li><li><strong>高效的查找、插入和删除</strong>：<code>set</code> 通常使用红黑树或类似的平衡树结构实现，所以查找、插入和删除操作的时间复杂度是 O(log N)，其中 N 是集合中的元素个数。</li></ul><h2 id="7-2-声明"><a href="#7-2-声明" class="headerlink" title="7.2 声明"></a>7.2 声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s;    <br>set&lt;<span class="hljs-type">double</span>&gt; s;    <br>set&lt;<span class="hljs-type">char</span>&gt; s;    <br>set&lt;<span class="hljs-keyword">struct</span> node&gt; s;    <br>set&lt;set&lt;<span class="hljs-type">int</span>&gt; &gt; s;<br></code></pre></td></tr></table></figure><h2 id="7-3-遍历"><a href="#7-3-遍历" class="headerlink" title="7.3 遍历"></a>7.3 遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">//  auto 可以代替 set&lt;int&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="7-4-set-排序"><a href="#7-4-set-排序" class="headerlink" title="7.4 set 排序"></a>7.4 set 排序</h2><p>对于基本数据类型可以直接使用 <code>greater&lt;&gt;</code> 实现降序排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; s; <span class="hljs-comment">// &gt;&gt; 可能会被识别为流运算符，中间可以加一个空格&gt; &gt;</span><br></code></pre></td></tr></table></figure><p>结构体类型的自定义排序可以使用如下方法：<br><strong>方法一：</strong> 重载 <code>operator&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Person&amp; p) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> age &lt; p.age;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 使用默认的比较器，重载 operator&lt; 运算符实现自定义排序</span><br>set&lt;Person&gt; person;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong> 使用 cmp 仿函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较器仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br><span class="hljs-comment">// 建议使用引用提高效率</span><br><span class="hljs-comment">// bool operator()(Person const&amp; a, Person const&amp; b)&#123;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person a, Person b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义比较器来排序 </span><br>set&lt;Person, cmp&gt; s;<br></code></pre></td></tr></table></figure><h2 id="7-5-常用函数"><a href="#7-5-常用函数" class="headerlink" title="7.5 常用函数"></a>7.5 常用函数</h2><h3 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>s.insert(value)</strong><br>插入元素到集合中，插入之后集合会自动排序。</p></blockquote><hr><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>s.find(value)</strong><br>查找元素返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向 <code>set.end()</code>。</p></blockquote><hr><h3 id="count-计数"><a href="#count-计数" class="headerlink" title="count() 计数"></a><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>s.count(value)</strong><br>返回指定元素的数量，set中元素是唯一的，如果存在则返回1，不存在则返回0。</p></blockquote><hr><h3 id="erase-删除"><a href="#erase-删除" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>s.erase(value)</strong><br>删除指定的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="8-map"><a href="#8-map" class="headerlink" title="8 map"></a>8 map</h1><h2 id="8-1-基础概念"><a href="#8-1-基础概念" class="headerlink" title="8.1 基础概念"></a>8.1 基础概念</h2><p>在 <code>#inlcude &lt;map&gt;</code> 中使用<br><code>map</code> 就是一种存储<strong>键值对</strong>的数据结构，由键和值构成，一个键对应一个值，我们可以通过键获取到该键所对应的值。</p><ul><li>第一个可以称为关键字(<code>key</code>)，每个关键字只能在 <code>map</code> 中出现一次；</li><li>第二个可能称为该关键字的值(<code>value</code>)；</li></ul><blockquote><p><code>map</code> 相当于一个通讯录，<code>map</code> 中记录的每一个昵称和对应的号码，就好比是一个键值对。<strong>注意每个key只能出现一次</strong>，就像我们的通讯录，如果有了两个小明，那我们就搞不清楚哪个才是小明，所以 <code>key</code> 不能重复。</p></blockquote><p><code>map</code> 主要用于资料一对一映射(one-to-one)的情況，<code>map</code> 內部的实现自建一颗红黑树，这颗树具有对数据<strong>自动排序</strong>的功能，也就是说在 <code>map</code> 内部所有的数据都是有序的。</p><h2 id="8-2-声明"><a href="#8-2-声明" class="headerlink" title="8.2 声明"></a>8.2 声明</h2><p><code>key</code> 和 <code>value</code> 可以是任意你需要的类型，包括自定义类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp1;<br>map&lt;string, string&gt; mp2;<br></code></pre></td></tr></table></figure><h2 id="8-3-遍历"><a href="#8-3-遍历" class="headerlink" title="8.3 遍历"></a>8.3 遍历</h2><p><code>it-&gt;first</code> 和 <code>(*it).first</code> 等价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br><span class="hljs-comment">//  auto 可以代替 map&lt;int, string&gt;::iterator</span><br></code></pre></td></tr></table></figure><h2 id="8-4-插入元素的区别"><a href="#8-4-插入元素的区别" class="headerlink" title="8.4 插入元素的区别"></a>8.4 插入元素的区别</h2><p>以下三种方法虽然都可以实现数据的插入，但是它们是有区别的（第一种和第二种在效果上是完成一样的）</p><ul><li>用 <code>insert</code> 函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当 <code>map</code> 中有这个关键字时，<code>insert</code> 操作是不能在插入数据的</li><li>数组方式插入时可以覆盖以前该关键字对应的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, string&gt; mp;<br> <br><span class="hljs-comment">// 第一种 用insert函數插入pair</span><br>mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">000</span>, <span class="hljs-string">&quot;zhu&quot;</span>));<br> <br><span class="hljs-comment">// 第二种 用insert函数插入value_type数据</span><br>mp.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">001</span>, <span class="hljs-string">&quot;zhuzhu&quot;</span>));<br> <br><span class="hljs-comment">// 第三种 用&quot;array&quot;方式插入</span><br>mp[<span class="hljs-number">111</span>] = <span class="hljs-string">&quot;og&quot;</span>;<br>mp[<span class="hljs-number">222</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="8-5-常用函数"><a href="#8-5-常用函数" class="headerlink" title="8.5 常用函数"></a>8.5 常用函数</h2><h3 id="insert-插入-1"><a href="#insert-插入-1" class="headerlink" title="insert() 插入"></a><code>insert()</code> <strong>插入</strong></h3><blockquote><p><strong>mp.insert(pair&lt;类型1, 类型2&gt;(key, value))</strong><br>将pair作为整个元素插入</p></blockquote><hr><h3 id="find-查找-1"><a href="#find-查找-1" class="headerlink" title="find() 查找"></a><code>find()</code> <strong>查找</strong></h3><blockquote><p><strong>mp.find(key)</strong><br>查找关键 <code>key</code> 返回一个迭代器，如果元素存在则指向该元素；如果不存在，则指向 <code>map.end()</code>。</p></blockquote><hr><h3 id="count-计数-1"><a href="#count-计数-1" class="headerlink" title="count() 计数"></a><code>count()</code> <strong>计数</strong></h3><blockquote><p><strong>mp.count(key)</strong><br>返回指定元素的数量，因为 <code>key</code>值不会重复，所以只有0和1，如果存在则返回1，不存在则返回0。</p></blockquote><hr><h3 id="erase-删除-1"><a href="#erase-删除-1" class="headerlink" title="erase() 删除"></a><code>erase()</code> <strong>删除</strong></h3><blockquote><p><strong>mp.erase(key)</strong><br>删除指定关键字的元素；也可以传递一个迭代器来删除特定位置的元素。成功删除返回1，否则返回0。</p></blockquote><h1 id="9-pair"><a href="#9-pair" class="headerlink" title="9 pair"></a>9 pair</h1><p><code>pair</code> 本质上就是一个内部有两个名字固定的成员变量的结构体，这两个成员变量为：<code>first</code> 成员和 <code>second</code> 成员。使用之前要添加头文件:<code>#include &lt;utility&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//两者是等价的</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>string first;<br><span class="hljs-type">int</span> second;<br>&#125; p;<br><span class="hljs-comment">//定义的同时初始化</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zhuzhu&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//pair的访问</span><br>p.first = <span class="hljs-string">&quot;hhhhh&#x27;</span><br><span class="hljs-string">p.second = 15;</span><br></code></pre></td></tr></table></figure><p>两个 <code>pair</code> 类型数据可以直接使用<code> =、!=、&lt;、&lt;=、&gt;、&gt;=</code>比较</p><ol><li>先以 <code>first</code> 的大小来比较</li><li>当 <code>first</code> 相等时，比较 <code>second</code> 的大小</li></ol><p><code>pair</code> 能够存储两个值，并且值的类型可以不同。可以用在很多标准容器中，特别是需要存储一对<strong>相关联</strong>的值时，比如说x和y坐标，<code>pair</code> 是一种非常好用的模板类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt; s;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; v;<br><br>set.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;) <span class="hljs-comment">// 使用&#123;&#125;表示元素</span><br></code></pre></td></tr></table></figure><blockquote><p>其实<code>map</code>中的每个元素就是一个 <code>pair&lt;const Key, T&gt;</code>，其中 <code>Key</code> 是键，<code>T</code> 是值。<code>map</code>像一个对<code>Key</code>值自动排序的<code>pair</code>数组。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>深度优先搜索算法</strong>（Depth First Search）：英文缩写为 DFS，是一种用于搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。深度优先搜索采用了回溯思想，该算法沿着树的深度遍历树的节点，会尽可能深的搜索树的分支。</p><ul><li>回溯：会搜出每一种可能的路线（求路径，通常N&lt;20）</li><li>不回溯：会搜出每一个能走的点（求能否到达）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br><span class="hljs-type">bool</span> mp[N][N];  <span class="hljs-comment">// 到过位置的标记</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;  <span class="hljs-comment">// 当前访问的点是(x, y)</span><br><span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br><span class="hljs-comment">// 遇到终点做一些事情，比如打印路径、路径数、判断能否到达终点</span><br><span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 返回</span><br>&#125;<br><br>vis[x][y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记此点被访问</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;  <span class="hljs-comment">// 分别搜索四个方向</span><br><span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br><span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br><span class="hljs-comment">// 如果下一个点越界了 不能走</span><br><span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br><span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br><span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || vis[nx][ny]) <span class="hljs-keyword">continue</span>; <br><span class="hljs-built_in">dfs</span>(nx, ny);  <span class="hljs-comment">// 开始搜索下一个合法的节点</span><br>&#125;<br><span class="hljs-comment">// 这个点的上下左右都搜完了，回溯到上一个节点，此点标记为未访问</span><br>vis[x][y] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 根据需求选择是否要回溯</span><br><span class="hljs-comment">// 回溯 会搜出每一种可能的路线</span><br><span class="hljs-comment">// 不回溯 会搜出每一个能走的点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录路径</span><br><span class="hljs-type">int</span> path[N * N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pathsize;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> 终点 &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pathsize; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)-&gt;&quot;</span>, path[i][<span class="hljs-number">0</span>], path[i][<span class="hljs-number">1</span>]);<br>&#125;<br>cout &lt;&lt; 终点 &lt;&lt; endl;<br>&#125;<br><br>vis[x][y] = <span class="hljs-literal">true</span>;<br>path[pathsize][<span class="hljs-number">0</span>] = x;  <span class="hljs-comment">// 添加路径</span><br>path[pathsize++][<span class="hljs-number">1</span>] = y;<br><br><span class="hljs-keyword">for</span>() 搜索下一个点<br><br>vis[x][y] = <span class="hljs-literal">false</span>;<br>pathsize--;  <span class="hljs-comment">// 删除路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于连通块问题，可以在main函数中遍历地图，遇到能构成连通块的符号即可进入dfs，对于进入dfs的点，将其设置为不可构成连通块的符号，并不断搜索其周边连通的符号。在main函数中每次进入dfs相当于遇到一个新的连通块并标记，可以进行计数。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序总结</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h1><p>从左往右相邻的数两两比较，如果左边大于右边则交换，每一轮冒泡会选出一个未排序数字中的最大值放到最后，每一轮确定一个数字的最终位置，排序完n个数字需要n-1轮。</p><ul><li><p>外层循环通过 <code>i</code> 控制遍历次数，最大到 <code>n-1</code>。每轮比较中最大的元素都会被“冒泡”到数组的末尾，因此内层循环的范围是 <code>n - i - 1</code>。</p></li><li><p><code>swapped</code> 用于记录当前轮次是否有元素交换。如果某轮中没有发生交换，意味着数组已经有序，可以提前退出循环，避免不必要的比较。</p></li><li><p>冒泡排序在最差情况下的时间复杂度是 O(n²)，但在最佳情况下（数组已经有序时），通过 <code>swapped</code> 变量，时间复杂度可以优化为 O(n)。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 每次循环开始时重置标志位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;  <span class="hljs-comment">//排好的放在后面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 比较相邻元素</span><br>                <span class="hljs-built_in">swap</span>(a[j], a[j + <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 交换元素</span><br>                swapped = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 记录交换发生</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果没有发生交换，数组已经有序，提前退出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h1><p>从左往右扫描，每一轮选出一个当前未排序数字中的最小值，放到前面，每一轮确定一个数字的最终位置，排完n个数字需要n-1轮。 </p><ul><li><p><strong>外层循环</strong>通过 <code>i</code> 控制遍历次数，最大到 <code>n-1</code>，每次遍历选择数组中未排序部分的第一个元素。</p></li><li><p><strong>内层循环</strong>通过 <code>j</code> 遍历未排序的部分，从 <code>i + 1</code> 开始到 <code>n</code>。内层循环的目的是找到当前未排序部分的最小元素，并记录其索引 <code>minIndex</code>。</p></li><li><p>在每轮结束时，将当前元素 <code>a[i]</code> 与找到的最小元素 <code>a[minIndex]</code> 进行交换。</p></li><li><p>即使数组已经有序，选择排序也仍然需要 O(n²) 的比较次数，因为每次都需要遍历未排序部分。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 每轮排好一个数字，排n-1轮</span><br>        <span class="hljs-type">int</span> minIndex = i;  <span class="hljs-comment">// 假设当前元素为最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)  <span class="hljs-comment">// 排好的放在前面，未排序的数字减少一个</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[minIndex]) minIndex = j;  <span class="hljs-comment">// 找到更小的元素，更新最小值索引</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[minIndex]);  <span class="hljs-comment">// 交换最小值到当前排序位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h1><p><strong>外层循环</strong> (<code>for (int i = 1; i &lt; n; i++)</code>)：从第二个元素开始遍历，作为当前要插入的元素 <code>x</code>。</p><p><strong><code>x</code> 变量</strong>：存储当前要插入的元素，以便在内层循环中进行比较和插入操作。</p><p>**已排序部分的下标 <code>j</code>**：<code>j</code> 初始化为 <code>i - 1</code>，表示已排序部分的最后一个元素。</p><p><strong>内层循环</strong> (<code>while (j &gt;= 0 &amp;&amp; x &lt; a[j])</code>)：</p><ul><li>在已排序部分中查找 <code>x</code> 的插入位置。</li><li><strong>越界检查</strong>：首先判断 <code>j &gt;= 0</code>，确保访问 <code>a[j]</code> 不会越界。</li><li>如果 <code>a[j]</code> 大于 <code>x</code>，则将 <code>a[j]</code> 向右移动，腾出 <code>j + 1</code> 的位置来插入 <code>x</code>。</li></ul><p><strong>插入操作</strong> (<code>a[j + 1] = x</code>)：当找到合适位置后，将 <code>x</code> 插入到 <code>j + 1</code> 的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 从第二个元素遍历要插入的元素</span><br>        <span class="hljs-type">int</span> x = a[i];  <span class="hljs-comment">// 当前要插入的元素</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 已排序的最后一个元素下标</span><br>        <span class="hljs-comment">// 在已排序部分中找到 x 的插入位置</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[j]) &#123;  <span class="hljs-comment">// 先判断j&gt;=0，防止越界错误</span><br>            a[j + <span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 元素向右移动，为x空出位置</span><br>            j--;  <span class="hljs-comment">// 移动到前一个元素</span><br>        &#125;<br>        a[j + <span class="hljs-number">1</span>] = x;  <span class="hljs-comment">// 将 x 插入到找到的位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-桶排序"><a href="#4-桶排序" class="headerlink" title="4 桶排序"></a>4 桶排序</h1><p>**<code>cnt[N] = &#123;0&#125;</code>**：定义一个大小为 <code>N</code> 的数组 <code>cnt</code>，用于统计每个元素的出现次数，初始化为 0。</p><p><strong>输入读取和计数</strong>：使用 <code>for</code> 循环读取 <code>n</code> 个整数输入，检查 <code>x</code> 是否在合法范围内 <code>[0, N)</code>，并通过 <code>cnt[x]++</code> 对每个 <code>x</code> 的出现次数进行统计。</p><p><strong>输出</strong>：第二个 <code>for</code> 循环遍历 <code>cnt</code> 数组，通过嵌套循环输出每个数 <code>i</code> 的值，输出的次数取决于 <code>cnt[i]</code> 的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> cnt[N] = &#123;<span class="hljs-number">0</span>&#125;, n;<br>cin &gt;&gt; n;  <span class="hljs-comment">// 读取元素个数</span><br><span class="hljs-comment">// 读取每个元素并进行计数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; N) cnt[x]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt[i]; ++j)<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 按照计数输出数字 i</span><br></code></pre></td></tr></table></figure><h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5 快速排序"></a>5 快速排序</h1><ol><li>选取一个数作为<strong>基准数</strong></li><li>小于基准数的值放左半区，大于基准数的值放右半区</li><li>再对左右区间重复1、2步，直到各区间只剩一个数</li></ol><p>通过<strong>分治法</strong>，每次递归时选取一个基准值，然后通过双指针将数组划分成两部分，使得左边部分的值小于等于基准值，右边部分的值大于等于基准值。然后递归地对两部分进行排序，直到数组被完全排序。</p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p>递归终止的条件是 <code>l &gt;= r</code>，也就是说当前区间长度为 0 或 1 时，不需要继续排序。</p><p><strong>基准值</strong>：<code>x = a[(l + r) &gt;&gt; 1]</code> 通过 <code>(l + r) &gt;&gt; 1</code> 计算出中间元素的下标，并将它作为基准值 <code>x</code>。</p><p><strong>双指针初始化</strong>：</p><ul><li><code>i = l - 1</code>，指向比基准值小的区域。</li><li><code>j = r + 1</code>，指向比基准值大的区域。</li></ul><p><strong>主循环条件</strong>：<code>while (i &lt; j)</code>，保证左右指针在数组内并且没有交错。</p><p><strong>内循环（左指针 <code>i</code>）</strong>：<code>do i++; while (a[i] &lt; x);</code> 从左向右找到第一个大于等于基准值的元素。</p><p><strong>内循环（右指针 <code>j</code>）</strong>：<code>do j--; while (a[j] &gt; x);</code> 从右向左找到第一个小于等于基准值的元素。</p><blockquote><p>此处必须使用严格的<code>&gt;</code> <code>&lt;</code>，如果使用<code>&gt;=</code> <code>&lt;=</code>选取的基准值是最大值，指针<code>i</code>不会停止，会一直<code>++</code>直到越界</p></blockquote><p><strong>元素交换</strong>：当 <code>i &lt; j</code> 时，交换 <code>a[i]</code> 和 <code>a[j]</code>，确保基准值左边的元素都小于等于它，右边的元素都大于等于它。</p><p><strong>左半部分递归</strong>：对 <code>l</code> 到 <code>j</code> 的部分继续执行快速排序。此时 <code>j</code> 是划分完成后，左半部分的最大值位置。</p><p><strong>右半部分递归</strong>：对 <code>j + 1</code> 到 <code>r</code> 的部分继续执行快速排序。</p><p><strong>注意：</strong> 因为<code>do-while</code>的存在，退出 <code>while</code> 时，j 最终会停在 <strong>（1+r）&#x2F;2</strong> 的位置，也就是 <strong>i &#x3D; j 或 i &#x3D; j + 1</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归结束条件：当区间元素只有1个元素或者没有元素时</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <br>    <br><span class="hljs-comment">// 初始化双指针i和j，</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;  <span class="hljs-comment">//后面会先++或--，所以指向边界的前一个或后一个元素</span><br>    <span class="hljs-type">int</span> pivot = a[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 选择中间位置的值作为基准值</span><br>    <br>    <span class="hljs-comment">// 双指针划分过程</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-comment">// 左指针向右移动，指针左侧都是小于基准值的，找到第一个大于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot);<br>        <span class="hljs-comment">// 右指针向左移动，指针右侧都是大于基准值的，找到第一个小于等于基准值的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot);<br>        <span class="hljs-comment">// 如果i和j两个指针还没有相遇，交换a[i]和a[j]</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br><br><span class="hljs-comment">// 不重不漏</span><br>    <span class="hljs-built_in">quick_sort</span>(a, l, j);  <span class="hljs-comment">// 递归调用，对左半部分（l到j）进行快速排序</span><br>    <span class="hljs-built_in">quick_sort</span>(a, j + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 递归调用，对右半部分（j+1到r）进行快速排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果每次选的<code>pivot</code>能让左右两段近似等分，会生成一颗有 logn 层的均衡的二叉树，每层 i, j两指针将会遍历所有 n 个元素，时间复杂度为 O(nlogn)。<br>如果每次选的<code>pivot</code>只能分离出一个元素，会退化成有 n 层的链，i, j两指针走的总步数&#x3D; n+(n－1)+…+1，时间复杂度退化为 O(n²)。<br><img src="/../../../cpp_assets/c_quick_sort.png" alt="Pasted-image-20250310154403c0d33279d726e024.png"></p><p>在快速排序和快速选择算法中，<strong>分区方法</strong> 是最核心的步骤。它们的核心目标都是将数组划分为两个部分，但实现方式和性能特点不同。</p><h2 id="5-1-Hoare-分区法"><a href="#5-1-Hoare-分区法" class="headerlink" title="5.1 Hoare 分区法"></a>5.1 Hoare 分区法</h2><p>由快速排序的发明者 Tony Hoare 提出，是最原始的分区方案。</p><ul><li><strong>双向指针扫描</strong><ul><li>左指针 <code>i</code> 从数组左端向右移动</li><li>右指针 <code>j</code> 从数组右端向左移动</li><li>直到找到需要交换的元素对</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组被划分为：<code>[ &lt;= pivot ]</code> + <code>[ &gt;= pivot ]</code></li><li>注意：<strong>不保证枢轴值在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hoare_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = a[l + (r - l) / <span class="hljs-number">2</span>]; <span class="hljs-comment">// 选择中间元素作为枢轴</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 因为可能把两个和 pivot 相等的值交换，所以不稳定</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (a[i] &lt; pivot); <span class="hljs-comment">// 找左边第一个 &gt;= pivot 的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (a[j] &gt; pivot); <span class="hljs-comment">// 找右边第一个 &lt;= pivot 的元素</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">return</span> j;         <span class="hljs-comment">// 返回分界点</span><br>        <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设数组为 <code>[3, 1, 4, 2, 5]</code>，选择中间元素 <code>4</code> 为枢轴：</p><ol><li><code>i</code> 找到 <code>4</code>（位置2），<code>j</code> 找到 <code>2</code>（位置3） → 交换 → <code>[3,1,2,4,5]</code></li><li><code>i</code> 移动到 <code>4</code>（位置3），<code>j</code> 移动到 <code>2</code>（位置2） → <code>i &gt;= j</code> → 返回 <code>j=2</code></li></ol><h2 id="5-2-填坑法"><a href="#5-2-填坑法" class="headerlink" title="5.2 填坑法"></a>5.2 填坑法</h2><p> 填坑法，左右指针交替覆盖，是快速排序中一种常见的分区实现方式，可以看作是 Lomuto 分区法的变体。</p><ul><li><strong>枢轴选择</strong>：固定选择左端点 <code>a[l]</code> 作为枢轴值 <code>pivot</code>。</li><li><strong>填坑操作</strong>：<ul><li><strong>右指针扫描</strong>：从右向左找到第一个 <code>&lt; pivot</code> 的元素，将其值覆盖到左指针位置（填左坑）。</li><li><strong>左指针扫描</strong>：从左向右找到第一个 <code>&gt; pivot</code> 的元素，将其值覆盖到右指针位置（填右坑）。</li><li>循环直到左右指针相遇，最后将枢轴值 <code>pivot</code> 放入相遇点。</li></ul></li><li><strong>分区结果</strong><ul><li>最终数组结构：<code>[ &lt;= pivot ]</code> + <code>pivot</code> + <code>[ &gt;= pivot ]</code></li><li><strong>枢轴值一定在最终位置</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <br><span class="hljs-type">int</span> pivot = a[l]; <span class="hljs-comment">//枢轴 </span><br><span class="hljs-keyword">while</span> (l &lt; r) &#123; <br><span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= pivot) r--; <br>a[l] = a[r]; <br><span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= pivot) l++; <br>a[r] = a[l]; <br>&#125; <br>a[l] = pivot; <br><span class="hljs-keyword">return</span> l; <span class="hljs-comment">//返回枢轴位置 </span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h1><p>归并排序主要使用了分治思想，字面上的解释是“<strong>分而治之</strong>”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>“分”而“治”之，先“分”后“治”</p><ul><li>“分”：将问题划分成若干子问题然后递归求解</li><li>“治”：将子问题的答案整合在一起</li></ul><p><img src="/../../../cpp_assets/c_merge_sort.png" alt="Pasted-image-202503071129090c2390f01aa20eb3.png"></p><p>归并排序将待排序序列划分成若干个子序列，将子序列合并为一个有序序列。具体来说通过递归将数组分成两半，分别排序，递归到最后，实际是把单个元素看作一个有序序列，开始<strong>两两归并</strong>，形成一个两个元素的有序序列，再两两归并，形成一个四个元素的有序序列，不断合并两个有序的子数组来达到排序的效果。<br><img src="/../../../cpp_assets/c_merge_sort_tree.png" alt="Pasted-image-202503310022534718d6a70a594701.png"></p><ul><li><code>a[]</code> 是要排序的数组。</li><li><code>l</code> 是当前处理的数组区间的左边界（闭区间）。</li><li><code>r</code> 是当前处理的数组区间的右边界（闭区间）。</li></ul><p><strong>终止条件</strong>：如果 <code>l &gt;= r</code>（即数组只剩一个或没有元素时），直接返回。</p><ul><li><code>mid = (l + r) &gt;&gt; 1</code>：通过取中间位置 <code>mid</code> 将当前区间 <code>[l, r]</code> 分为两个子区间 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code>。</li><li>递归调用 <code>merge_sort(a, l, mid)</code> 对左半部分排序，<code>merge_sort(a, mid + 1, r)</code> 对右半部分排序。</li></ul><p><strong>合并两个有序部分</strong>：</p><ul><li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向左半部分 <code>[l, mid]</code> 和右半部分 <code>[mid + 1, r]</code> 的起始位置。通过比较 <code>a[i]</code> 和 <code>a[j]</code> 的值，将较小的值放入临时数组 <code>tmp[]</code>（因为是<code>&lt;=</code>，相等的时候把左边元素放入临时数组，所以稳定）。</li><li>如果左半部分未遍历完，将剩余部分加入 <code>tmp[]</code>。</li><li>如果右半部分未遍历完，也将其加入 <code>tmp[]</code>。</li><li>最后，将临时数组 <code>tmp[]</code> 中的元素复制回原数组 <code>a[]</code>，完成本次合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 递归终止条件：如果子序列中只有1个元素或0个元素，返回</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算中间索引，将数组一分为二</span><br>    <span class="hljs-comment">// l + (r - l) / 2  防止溢出</span><br>    <br>    <span class="hljs-built_in">merge_sort</span>(a, l, mid); <span class="hljs-comment">// 递归排序左半部分</span><br>    <span class="hljs-built_in">merge_sort</span>(a, mid + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// 递归排序右半部分</span><br><br>    <span class="hljs-comment">// 合并两个已排序的部分</span><br><span class="hljs-type">int</span> k = l; <span class="hljs-comment">// 临时数组的索引</span><br><span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左半部分和右半部分的指针</span><br>     <br>    <span class="hljs-comment">// 合并过程：将较小的元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-comment">// 如果左半部分当前元素小于等于右半部分，加入临时数组</span><br>        <span class="hljs-comment">// 正是因为这里是 &lt;= ，如果元素相等先取前面的，所以稳定</span><br>        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) tmp[k++] = a[i++]; <br>        <span class="hljs-comment">// 否则，加入右半部分的当前元素</span><br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++]; <br>    &#125;<br>    <br>    <span class="hljs-comment">// 将左半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++]; <br>    <span class="hljs-comment">// 将右半部分的剩余元素加入临时数组</span><br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = a[j++]; <br><br>    <span class="hljs-comment">// 将临时数组的内容复制回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= r; i++) a[i] = tmp[i]; <br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">快速排序</th><th align="center">归并排序</th></tr></thead><tbody><tr><td align="center">分治</td><td align="center">先交换，后拆分</td><td align="center">先拆分，后合并</td></tr><tr><td align="center">稳定性</td><td align="center">不稳定</td><td align="center">稳定</td></tr></tbody></table><h1 id="7-sort-排序"><a href="#7-sort-排序" class="headerlink" title="7 sort()排序"></a>7 sort()排序</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p><code>sort()</code>函数是一个比较<strong>灵活</strong>的函数。很多解释是：<code>sort()</code>函数是类似于快速排序的方法，时间复杂度为n*log2(n)，执行效率较高。</p><blockquote><p>STL中的<code>sort()</code>并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过 深，有出现最坏情况的倾向，还会改用堆排序。</p></blockquote><h2 id="7-2-sort-的使用方法"><a href="#7-2-sort-的使用方法" class="headerlink" title="7.2 sort()的使用方法"></a>7.2 sort()的使用方法</h2><p>在C++中使用<code>sort()</code>函数需要使用<code>#include &lt;algorithm&gt;</code>头文件，algorithm意为”算法”，是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(begin, end, cmp);<br></code></pre></td></tr></table></figure><p><code>sort()</code>函数可以对给定区间的元素进行排序，它有三个参数：</p><ul><li>其中<code>begin</code>为待排序数组的起始地址</li><li><code>end</code>为指向待排序数组结束地址下一个位置的指针</li><li><code>cmp</code>参数为排序准则，如果不写，<strong>默认从小到大</strong>进行排序。如果我们想从大到小排序可以将<code>cmp</code>参数写为<code>greater&lt;int&gt;()</code>，<code>&lt;&gt;</code>中表示排序数组的类型，C++11中可以透明比较器<code>greater&lt;&gt;()</code>。如果需要按照其他的排序准则，那么需要我们自己定义一个<code>bool</code>类型的函数来传入。</li></ul><p>使用<code>sort()</code>不仅仅可以从大到小或者从小到大排，还可以按照一定的准则进行排序，编写<code>cmp</code>函数传入<code>sort()</code>函数。比如按照个位从小到大比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a % <span class="hljs-number">10</span> &gt; b % <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对<strong>结构体</strong>进行排序，比如定义一个结构体包含学生的姓名和年龄，按照年龄从小到大排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a, Student b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上的代码示例中使用了<strong>值传递</strong>，每次调用函数都会创建<code>Student</code>对象的副本，增加额外的开销，降低排序的效率，使用<strong>引用传递</strong>可以避免拷贝开销，更加高效。值传递会创建参数的副本，对于大型对象或复杂数据结构，可能涉及大量的内存分配和数据复制，引用传递避免了这些操作，因为它直接操作原始对象。</p><table><thead><tr><th>特性</th><th>值传递</th><th>引用传递</th></tr></thead><tbody><tr><td>数据传递方式</td><td>副本传递，函数操作的是实参的副本</td><td>引用传递，函数操作的是实参的原数据</td></tr><tr><td>内存开销</td><td>需要创建副本，开销较大，尤其对于大型对象</td><td>无需创建副本，内存开销小</td></tr><tr><td>是否修改实参</td><td>函数内部的修改不会影响实参</td><td>函数内部的修改会直接影响实参</td></tr><tr><td>安全性</td><td>相对更安全，因为函数无法修改外部数据</td><td>可能产生副作用，修改不应修改的数据</td></tr><tr><td>适用场景</td><td>当不希望修改外部数据，或数据结构比较简单时使用</td><td>当需要修改实参，或数据结构较大时使用</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; a,<span class="hljs-type">const</span> Student&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用参数</strong>：<code>const Student&amp; a</code> 和 <code>const Student&amp; b</code> 表示对 <code>Student</code> 类型的常量引用，这样函数内部无法修改 <code>Student</code> 的内容，同时避免了复制带来的性能损失。</p><p><strong>const 关键字</strong>：使用 <code>const</code> 关键字表明函数不会修改传入的对象，这也是一个良好的编码习惯。 </p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>广度优先搜索</strong>（Breadth First Search)：英文缩写为（BFS），是一种用于搜索树或图的算法。从起始节点开始逐层扩展搜索，直到达到目标节点。它以广度的方式探索图中的节点，即先访问离起始节点最近的节点，然后逐渐扩展到距离更远的节点。</p><p>广度优先搜索的实现：</p><ol><li>将起始节点放入队列中，并将其标记为已访问。</li><li>从队首取出一个节点作为当前节点。</li><li>遍历当前节点的所有邻居节点：如果邻居节点没有被访问过，则将其放入队列中并标记为已访问。</li><li>重复步骤2和3，直到队列为空或找到目标节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> mp[N][N];  <span class="hljs-comment">// 地图</span><br>step step[N][N];  <span class="hljs-comment">// 记录到达某点的最短步数</span><br>queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;  <span class="hljs-comment">// 辅助广搜的队列</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;  <span class="hljs-comment">// 方向数组  根据需求确定搜索方向</span><br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 步数初始化为-1，在记录步数的同时也可以记录哪些点走过</span><br><span class="hljs-built_in">fill</span>(step[<span class="hljs-number">0</span>], step[<span class="hljs-number">0</span>] + N * N, <span class="hljs-number">-1</span>)<br><br><span class="hljs-type">void</span> <span class="hljs-built_in">bfs</span>(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy) &#123;<br>q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);  <span class="hljs-comment">// 起始节点入队</span><br>step[sx][sy] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点设为0步，也可能是1步，并且达到了标记已访问的作用</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 队列不为空，就要继续搜</span><br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;  <span class="hljs-comment">// 当前节点的x坐标</span><br><span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;  <span class="hljs-comment">// 当前节点的y坐标</span><br>q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 取出当前节点</span><br><br><span class="hljs-keyword">if</span> (x, y) 是终点 &#123;  <span class="hljs-comment">// 遇到结束条件，如果没有结束条件就把能搜的点都搜完</span><br><span class="hljs-comment">// 遇到终点做一些事情，比如最短步数、判断能否到达终点</span><br><span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 结束</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];  <span class="hljs-comment">// 下一个点的x坐标</span><br><span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下一个点的y坐标</span><br><span class="hljs-comment">// 如果下一个点越界了 不能走</span><br><span class="hljs-comment">// 注意下面两个if要先判断是否越界，才可以访问 </span><br><span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 如果下一个点是障碍 或者 下一个点访问过 不能走</span><br><span class="hljs-keyword">if</span>(mp[nx][ny] 是障碍 || step[nx][ny] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <br>q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);  <span class="hljs-comment">// 能走的点就入队</span><br><span class="hljs-comment">// 走到下一个点的步数等于这个点的步数+1</span><br>step[nx][ny] = step[x][y] + <span class="hljs-number">1</span>;  <br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特别注意：要在<strong>入队时就对节点进行标记</strong>，如果在出队时标记，两个点都指向某个未访问的节点时，它会被<strong>重复入队</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-图的概念"><a href="#1-图的概念" class="headerlink" title="1 图的概念"></a>1 图的概念</h1><p>图是一种由<strong>结点</strong>和<strong>边</strong>组成的数据结构，其中结点表示图中的<strong>对象</strong>，边表示这些对象之间的<strong>关系</strong>。</p><ul><li>结点(Vertex)：也称为顶点，是图中的基本单元，表示一个实体或一个抽象概念。</li><li>边(Edge)：结点之间的连线，表示结点之间的关系。</li></ul><hr><ul><li>无向图：由没有方向的边组成的图，也称为无向网络或无向图形。<ul><li>无向边表示两个结点之间的双向关系。</li></ul></li><li>有向图：由有方向的边组成的图，也称为有向网络或有向图形。<ul><li>有向边从一个结点指向另一个结点，表示一个方向的关系。</li><li>在有向图中结点也称为起点或终点。</li></ul></li><li>带权图：边上带有权值的图。<ul><li>权值：可以形象地理解为通过这条边的花费的时间、距离、金额等等。</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717153210%201.png"></p><hr><ul><li>无向完全图：图中任意两个顶点之间都存在边。<ul><li>一个 n 阶的完全无向图含有n ×（n－1) &#x2F; 2 条边</li></ul></li><li>有向完全图：图中任意两个顶点之间都存在方向相反的两条边。<ul><li>一个 n 阶的完全有向图含有n ×（n－1）条边</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717155915%201.png"></p><hr><ul><li>自环：一个结点连接到自身的边</li><li>重边：两个结点之间存在多条边</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717153349%201.png"></p><ul><li>简单图(Simple Graph)：一种无向图或有向图，其中不存在自环和重边。</li><li>多重图(Multigraph)：一种有向图或无向图，其中存在自环或重边。</li></ul><hr><ul><li>稀疏图：图中的边很少，边之间的连接相对稀疏。</li><li>稠密图：图中的边很多，边之间的连接非常密集。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717160209%201.png"></p><h1 id="2-图的简单性质"><a href="#2-图的简单性质" class="headerlink" title="2 图的简单性质"></a>2 图的简单性质</h1><h2 id="2-1-度数"><a href="#2-1-度数" class="headerlink" title="2.1 度数"></a>2.1 度数</h2><p>度数：指与一个结点相连的边的数量。</p><ul><li>在无向图中，一个结点的度数就是它的连接数。</li><li>在有向图中，一个结点的入度是指指向该结点的边的数量，出度是指从该结点出发的边的数量。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717160748%201.png"></p><h2 id="2-2-路径"><a href="#2-2-路径" class="headerlink" title="2.2 路径"></a>2.2 路径</h2><ul><li>路径：指从一个结点到另一个结点的连续边构成的序列，路径的长度是指该路径中边的数量。如果两个结点之间存在路径，则这两个结点是连通的。</li><li>简单路径：指从一个结点到另一个结点的连续边构成的序列，序列中的结点不可以重复，即同一条边最多经过一次。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161538%201.png"></p><ul><li>环路：一个路径，它的起点和终点相同，且路径上的每个结点可以重复，即同一条边可以多次经过。</li><li>简单环路：一个路径，它的起点和终点相同，且路径上的每个结点都不重复（除了起点和终点，即同一条边不可以多次经过）。一个图如果不包括任何环它就是无环图。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161242%201.png"></p><h2 id="2-3-连通性"><a href="#2-3-连通性" class="headerlink" title="2.3 连通性"></a>2.3 连通性</h2><ul><li>连通性：如果对于任意两个结点之间都存在路径，这个图是连通的。如果一个图不是连通的，则可以分为多个连通分量。</li><li>对于有向图，存在强连通和弱连通之分：<ul><li>强连通：任意两个结点 u 和 v 之间存在一条从 u 到 v 的有向路径，同时存在一条从 v 到 u 的有向路径。</li><li>弱连通：将有向图中的所有边都看作无向边后得到的连通图。</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717161902%201.png"></p><ul><li>连通分量：一个无向图的极大连通子图<ul><li>首先，它是这个无向图的一个连通子图(保证了连通)</li><li>其次，它不是这个无向图的其他连通子图的子图 (保证了极大)</li></ul></li><li>强连通分量：一个有向图的极大强连通子图</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162039%201.png"></p><h1 id="3-图的存储"><a href="#3-图的存储" class="headerlink" title="3 图的存储"></a>3 图的存储</h1><h2 id="3-1-邻接矩阵"><a href="#3-1-邻接矩阵" class="headerlink" title="3.1 邻接矩阵"></a>3.1 邻接矩阵</h2><p>邻接矩阵：一种二维数组其中每个元素表示两个结点之间的边。</p><h3 id="3-1-1-无向图"><a href="#3-1-1-无向图" class="headerlink" title="3.1.1 无向图"></a>3.1.1 无向图</h3><p>无向图的邻接矩阵存储：如果两个结点之间存在边，则数组中对应的元素为1，否则为 0。</p><p>在无向图中，邻接矩阵是一个对称矩阵，且主对角线一定为0。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162713%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 是否相连</span><br>mp[x][y］= mp[y][x] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="3-1-2-有向图"><a href="#3-1-2-有向图" class="headerlink" title="3.1.2 有向图"></a>3.1.2 有向图</h3><p>有向图的邻接矩阵存储：如果结点 x 有一条指向结点 y 的边，那么 mp[x][y] 就标记为 1。</p><p>与无向图不同，有向图不一定满足<code> mp[x][y］= mp[y][x]</code></p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717162954%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 是否指向 结点 y</span><br>mp[x][y] = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h3 id="3-1-3-带权图"><a href="#3-1-3-带权图" class="headerlink" title="3.1.3 带权图"></a>3.1.3 带权图</h3><p>带权图的邻接矩阵存储：<code>mp[x][y]</code> 表示结点 x 到结点 y 边的权值。</p><p>在边不存在的情况下，会适当地取较大的常数，与普通权值进行区分。<br>带权图输入<strong>注意重边！注意重边！注意重边！</strong></p><p><img src="/../../../cpp_assets/Pasted%20image%2020250717163306%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mp[x][y］表示结点 x 和 结点 y 之间的权值</span><br>mp[x][y] = len;<br></code></pre></td></tr></table></figure><ul><li>邻接矩阵的优点：查询两个结点之间是否存在边的时间复杂度为O(1)，适用于稠密图。</li><li>邻接矩阵的缺点：占用空间较大，尤其是对于稀疏图时，浪费大量的空间。</li></ul><h2 id="3-2-边集数组"><a href="#3-2-边集数组" class="headerlink" title="3.2 边集数组"></a>3.2 边集数组</h2><h2 id="3-3-邻接表"><a href="#3-3-邻接表" class="headerlink" title="3.3 邻接表"></a>3.3 邻接表</h2><h1 id="4-特殊图"><a href="#4-特殊图" class="headerlink" title="4 特殊图"></a>4 特殊图</h1><h2 id="4-1-欧拉路与欧拉回路"><a href="#4-1-欧拉路与欧拉回路" class="headerlink" title="4.1 欧拉路与欧拉回路"></a>4.1 欧拉路与欧拉回路</h2><ul><li>欧拉路：是一种在图中经过每条边恰好一次的路径，但<strong>不要求回到起点</strong>。</li><li>欧拉回路：是一种从起点开始、经过所有边恰好一次、最终<strong>回到起点</strong>的回路。</li></ul><p>欧拉图：存在一条路径可以经过图上所有边恰好一次，并且最终回到起点的图。也就是说，如果一个图存在欧拉回路，那么这个图就是<strong>欧拉图</strong>。</p><ul><li><p>欧拉图&#x2F;欧拉回路的判断：</p><ul><li>无向图：所有顶点的度数必须都是偶数</li><li>有向图：所有顶点的度数必须都是偶数，并且入度和出度必须相等</li></ul></li><li><p>欧拉路的判断：</p><ul><li>无向图：恰好有两个顶点的度数是奇数，其余顶点的度数都是偶数</li><li>有向图：至多一个顶点的出度与入度之差为1，至多一个顶点的入度与出度之差为1，其他顶点的入度和出度相等</li></ul></li></ul><p>如果一个图不存在欧拉路，则称该图是<strong>非欧拉图</strong>。</p><h2 id="4-2-负权回路"><a href="#4-2-负权回路" class="headerlink" title="4.2 负权回路"></a>4.2 负权回路</h2><p>如果存在一个环，而这个环上所有权值之和是负数，那这就是个<strong>负权环</strong>，也叫<strong>负权回路</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1 单链表"></a>1 单链表</h1><p>链表是一种物理存储单元上<strong>非连续、非顺序的存储结构</strong>，插入和删除速度快，并且不需要像数组一样预先开辟空间链表结构可以充分利用计算机内存空间，实现灵活地内存动态管理。</p><p><img src="/../../../cpp_assets/c_linklist_info%201.png" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><p>链表由一系列结点组成，每个结点包括两个部分：</p><ul><li>存储数据元素的数据域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="1-1-链表的创建"><a href="#1-1-链表的创建" class="headerlink" title="1.1 链表的创建"></a>1.1 链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>node *next;  /存储下一个结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><ul><li>使用 <code>new</code> 运算符来动态申请空间</li><li>使用 <code>-&gt;</code> 结构体指针运算符来访问内部成员</li><li>头结点数据域通常不做存储（删除结点只能通过它前一个结点指向它后一个结点，头结点没有前一个结点）</li></ul><p><code>*head.data</code> 和 <code>head-&gt;data</code> 效果是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//指针域初始化为空</span><br>tail-&gt;next = p;  <span class="hljs-comment">//连到尾结点后面</span><br>tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-链表的遍历"><a href="#1-2-链表的遍历" class="headerlink" title="1.2 链表的遍历"></a>1.2 链表的遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *p = head;  <span class="hljs-comment">//使用p作为当前结点，从头开始遍历</span><br><span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//判断下一个结点是否为空</span><br>cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">//输出下一个结点的数据，因为头结点无数据</span><br>p = p-&gt;next;  <span class="hljs-comment">//p更新为下一个结点</span><br>&#125; <br></code></pre></td></tr></table></figure><h2 id="1-3-链表的删除"><a href="#1-3-链表的删除" class="headerlink" title="1.3 链表的删除"></a>1.3 链表的删除</h2><p>删除单链表中p结点的下一个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;next = p-&gt;next-&gt;next;  <span class="hljs-comment">//将p所指的下一个结点修改为下一个结点的下一个结点</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_link_delete%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="1-4-链表的插入"><a href="#1-4-链表的插入" class="headerlink" title="1.4 链表的插入"></a>1.4 链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//先将新结点的指针域指向p的下一个结点</span><br>p-&gt;next = s;  <span class="hljs-comment">//再将p的下一个结点修改为s</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_link_insert%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="1-5-链表和数组"><a href="#1-5-链表和数组" class="headerlink" title="1.5 链表和数组"></a>1.5 链表和数组</h2><p><strong>数组：</strong></p><ul><li>优点：<br>随机访问性强，查找速度快。</li><li>缺点：<br>插入和删除效率低，，可能浪费内存，，内存空间要求高，数组大小固定，不能动态拓展。</li></ul><p><strong>链表：</strong></p><ul><li>优点：<br>插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</li><li>缺点：<br>不能随机查找，必须从第一个开始遍历，查找效率低。</li></ul><table><thead><tr><th align="center"></th><th align="center">查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td align="center">数组</td><td align="center">O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td align="center">链表</td><td align="center">O(n)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h1 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2 双向链表"></a>2 双向链表</h1><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有<strong>两个指针</strong>，分别指向<strong>直接后继</strong>和<strong>直接前驱</strong>，所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的<strong>前驱结点</strong>和<strong>后继结点</strong>。</p><p><img src="/../../../cpp_assets/c_double_link%201.png" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><p>双向链表每个节点有三个部分：</p><ul><li>存储数据元素的数据域</li><li>存储上一个节点地址的指针域</li><li>存储下一个结点地址的指针域</li></ul><h2 id="2-1-双链表的创建"><a href="#2-1-双链表的创建" class="headerlink" title="2.1 双链表的创建"></a>2.1 双链表的创建</h2><p><strong>1.定义结构体存储结点信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> data;  <span class="hljs-comment">//存储当前结点的数据值</span><br>node *pre, *next;  /存储前驱和后继结点的地址<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.创建头尾节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *head, *tail;  <span class="hljs-comment">//定义头结点和尾结点</span><br>head = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请内存空间</span><br>head-&gt;pre = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//前驱指针初始化为空</span><br>head-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>tail = head;  <span class="hljs-comment">//此时的头结点也是尾结点</span><br></code></pre></td></tr></table></figure><p><strong>3.添加新结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;  <span class="hljs-comment">//会自动获取到输入内容的结束位置，再终止输入</span><br>node *p = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//定义新结点p，动态申请新的空间</span><br>p-&gt;data = x;  <span class="hljs-comment">//给数据域赋值</span><br>p-&gt;pre = tail;  <span class="hljs-comment">//前驱指针指向前驱节点tail</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后继指针初始化为空</span><br>tail-&gt;next = p;  <span class="hljs-comment">//尾结点的后继指针指向p</span><br>tail = p;  <span class="hljs-comment">//尾结点更新为当前的p</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-双链表的删除"><a href="#2-2-双链表的删除" class="headerlink" title="2.2 双链表的删除"></a>2.2 双链表的删除</h2><p>删除双链表中p结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;pre-&gt;next = p-&gt;next;  <span class="hljs-comment">//将p上一个结点的后继指针指向p的下一个结点</span><br>p-&gt;next-&gt;pre = p-&gt;pre;  <span class="hljs-comment">//将p下一个结点的前驱指针指向p的上一个结点</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_double_delete%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="2-3-双链表的插入"><a href="#2-3-双链表的插入" class="headerlink" title="2.3 双链表的插入"></a>2.3 双链表的插入</h2><p>在p结点之后插入一个结点s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *s = <span class="hljs-keyword">new</span> node;  <span class="hljs-comment">//动态申请新的空间</span><br>s-&gt;next = p-&gt;next;  <span class="hljs-comment">//新结点的后继指针域指向p的下一个结点</span><br>s-&gt;pre = p;  <span class="hljs-comment">//新结点的前驱指针指向p</span><br>p-&gt;next-&gt;pre = s;  <span class="hljs-comment">// p的下一个结点的前驱指针指向s</span><br>p-&gt;next = s;  <span class="hljs-comment">//p的后继指针指向s</span><br></code></pre></td></tr></table></figure><p><img src="/../../../cpp_assets/c_double_insert%201.gif" alt="Pasted-image-2025040117473344f072a03e24e176.png"></p><h2 id="2-4-双向循环链表"><a href="#2-4-双向循环链表" class="headerlink" title="2.4 双向循环链表"></a>2.4 双向循环链表</h2><p>双向循环链表：最后一个结点的后继指针指向头结点，且头结点的前驱指针指向最后一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">head-&gt;pre = tail;<br>tail-&gt;next = head;<br></code></pre></td></tr></table></figure><h2 id="2-5-双链表优缺点"><a href="#2-5-双链表优缺点" class="headerlink" title="2.5 双链表优缺点"></a>2.5 双链表优缺点</h2><ul><li><strong>优点：</strong><br>从双向链表中的任意一个结点开始，都可以很方便地访问前驱结点和后继结点</li><li><strong>缺点：</strong><br>增加删除节点复杂，需要多分配一个指针存储空间</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-树的概念"><a href="#1-树的概念" class="headerlink" title="1 树的概念"></a>1 树的概念</h1><p>树作为一种非线性的数据结构，是由$n(n ≥ 0)$个结点组成的有限集合。<br>如果 $n &#x3D; 0$ 称为空树，如果 $n &gt; 0$，树有且仅有一个特定的结点——根结点。<br>除根结点外的其他结点划分为互不相交的有限集，每个集合又是一棵树，称为根结点的子树。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718155005%201.png"></p><hr><ul><li>树的度：结点拥有的子树的数量为结点的度，树的度定义为树的所有结点中度的最大值。</li><li>度为 0 的结点为<strong>叶子结点</strong>，度不为 0 的结点为分支结点。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718155659%201.png"></p><hr><p>树的前驱和后继：</p><ul><li>除根结点没有前驱外，其余每个结点都有唯一的一个<strong>前驱结点</strong>。</li><li>除叶子结点没有后继外，每个结点都可以有多个<strong>后继结点</strong>。</li><li>结点的直接后继称为结点的<strong>孩子</strong>，结点的直接前驱称为结点的<strong>父亲</strong>，同一个双亲的不同结点互称<strong>兄弟</strong>。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718160119%201.png"></p><hr><p>树中结点的层次：树中根结点为第 1 层，根结点的孩子为第2层，依次类推。<br>树的深度（高度）：树中结点的最大层次。（部分题目中根结点为第 0 层）</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718160402%201.png"></p><hr><ul><li>$n$ 个结点的树，有且仅有 $n－1$  条边</li><li>树中任意两个结点之间有且仅有一条简单路径（路径上的结点都不相同的路径）</li></ul><h1 id="2-树的存储"><a href="#2-树的存储" class="headerlink" title="2 树的存储"></a>2 树的存储</h1><h2 id="2-1-双亲表示法"><a href="#2-1-双亲表示法" class="headerlink" title="2.1 双亲表示法"></a>2.1 双亲表示法</h2><p>对父节点进行存储</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718161156%201.png"></p><p>第一行一个整数 $n$，表示结点个数<br>第二行 $n－1$ 个数，第 $i$ 个数是结点 $i + 1$ 的父节点编号（第 1 个数的值是 2 号结点的父结点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, tree[N];<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) cin &gt;&gt; tree[i];<br></code></pre></td></tr></table></figure><h2 id="2-2-孩子表示法"><a href="#2-2-孩子表示法" class="headerlink" title="2.2 孩子表示法"></a>2.2 孩子表示法</h2><p>对孩子节点进行存储</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718161351%201.png"></p><p>第一行一个整数 $n$，表示结点个数<br>第二行 $n－1$ 个数，第 $i$ 个数是结点 $i + 1$ 的父节点编号（第 1 个数的值是 2 号结点的父结点）</p><p>使用 <code>vector</code> 存储每一个结点的所有孩子，因此<code>tree[i]</code> 里存储的是 i 结点的所有孩子结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br>tree[x].<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3 二叉树"></a>3 二叉树</h1><h2 id="3-1-二叉树的概念"><a href="#3-1-二叉树的概念" class="headerlink" title="3.1 二叉树的概念"></a>3.1 二叉树的概念</h2><p>二叉树（Binary Tree，简称BT）是一种度数 <strong>最大为 2</strong> 的树，即二叉树的每个结点<strong>最多</strong>有两个子结点。每个结点的子结点分别称为左孩子、右孩子，它的两棵子树称为左子树、右子树。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718162657%201.png"></p><hr><p>一棵深度为 $k$ 且有 $2^k－1$ 个结点的二叉树称为<strong>满二叉树</strong>。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718165447%201.png"></p><hr><p>若二叉树的高度为 $k$，除第 $k$ 层外，其它各层 $1～k－1$的结点数都达到<strong>最大个数</strong>，且第 $k$ 层缺少的结点是从右到左并连续的，这就是<strong>完全二叉树</strong>。</p><p><img src="/../../../cpp_assets/Pasted%20image%2020250718165830%201.png"></p><h2 id="3-2-二叉树的性质"><a href="#3-2-二叉树的性质" class="headerlink" title="3.2 二叉树的性质"></a>3.2 二叉树的性质</h2><ul><li><strong>「性质一」</strong> 在二叉树的第 $i$ 层上最多有$2^{i-1}$个结点（i &gt;&#x3D;1）。第 1 层最多 1 个结点，第 2 层最多 2个结点，第 3 层最多 4 个结点。（像二进制位权）</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718163730%201.png"></p><ul><li><strong>「性质二」</strong> 深度为 $k$ 的二叉树至多有 $2^k-1$ 个结点（$k &gt;&#x3D;1$)（像二进制全 1 的情况）</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718163900%201.png"></p><ul><li><strong>「性质三」</strong> 对任意一棵二叉树，如果其叶子结点的数量为 $n_0$，度为 $2$ 的结点数为 $n_2$，则一定满足$n_0 &#x3D; n_2 + 1$。</li></ul><blockquote><p>证明：<br>结点总数 $n$ 等于 $0$  度结点 $n_0$、$1$ 度结点 $n_1$，$2$  度结点 $n_2$ 之和。即 $\textcolor{red}{n &#x3D; n_0 + n_1 + n_2}$  (式子1)<br>1 度结点有 1 个孩子，2 度结点有 2 个孩子，树中只有根结点不是任何结点的孩子，故二叉树中结点总数又可以表示为 $\textcolor{red}{n &#x3D; n_1 + 2n_2 + 1}$ (式子2)<br>由式子1和式子2得到 $\textcolor{red}{n_0 &#x3D; n_2 + 1}$。</p></blockquote><ul><li><strong>「性质四」</strong> 具有 $n(n≥0)$ 个结点的完全二叉树的深度为 $\lfloor log_2n \rfloor+1$。（$\lfloor \rfloor$表示下取整）<ul><li>其实就是最多把最后一层填满，为$2^k-1$，对于61来说，不足64，$2^6&#x3D;64$，6层就够了。</li></ul></li></ul><blockquote><p>证明：<br>深度为 $k$ 的完全二叉树，前面 $k－1$ 层一定是满的，所以 $n &gt; 2^{k-1}－ 1$，同时 $n ≤ 2^k-1$，得到 $\textcolor{red}{2^{k-1}－ 1 &lt; n ≤ 2^k－1}$，所以 $k&#x3D; \lfloor log_2n \rfloor+1$。</p></blockquote><ul><li><strong>「性质五」</strong> 如将一棵有 $n$ 个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号 1，2，…，n，则有以下关系：<ul><li>若 $i&#x3D;1$，则结点 $i$ 为根，无父结点</li><li>若 $i&gt;1$，则 $i$ 的父结点编号为 $\lfloor i&#x2F;2 \rfloor$</li><li>若 $2 × i &gt; n$，则 $i$ 无左孩子，否则其左孩子编号为 $2×i$</li><li>若 $2×i+1&gt;n$，则 $i$ 无右孩子，否则其右孩子编号为$２×ｉ+ 1$</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250718174304%201.png"></p><h1 id="4-二叉树遍历"><a href="#4-二叉树遍历" class="headerlink" title="4 二叉树遍历"></a>4 二叉树遍历</h1><p>先中后由<strong>根的位置决定</strong></p><h2 id="4-1-先序遍历"><a href="#4-1-先序遍历" class="headerlink" title="4.1 先序遍历"></a>4.1 先序遍历</h2><p>先序遍历也叫做先根遍历。<br>顺序：<strong>根 → 左 → 右</strong><br>首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树，如果二叉树为空则返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719104738%201.png"></p><ol><li>输出当前结点的值</li><li>递归去处理左子树</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-type">int</span> left;<br><span class="hljs-type">int</span> right;<br>&#125; t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>cout &lt;&lt; t[id].value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点的值</span><br><span class="hljs-keyword">if</span>(t[id].left) <span class="hljs-built_in">pre_order</span>(t[id].left); <span class="hljs-comment">// 有左孩子访问左孩子</span><br><span class="hljs-keyword">if</span>(t[id].right) <span class="hljs-built_in">pre_order</span>(t[id].right);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br><br><span class="hljs-comment">// 完全二叉树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-中序遍历"><a href="#4-2-中序遍历" class="headerlink" title="4.2 中序遍历"></a>4.2 中序遍历</h2><p>中序遍历也叫做中根遍历。<br>顺序：<strong>左 → 根 → 右</strong><br>首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树，若二叉树为空则结束返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719105039%201.png"></p><ol><li>递归去处理左子树</li><li>输出当前结点的值</li><li>递归去处理右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>); <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 有右孩子访问右孩子</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h2><p>后序遍历也叫做后根遍历。<br>顺序：<strong>左 → 右 → 根</strong><br>首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点，若二叉树为空则结束返回。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719105326%201.png"></p><ol><li>递归去处理左子树</li><li>递归去处理右子树</li><li>输出当前结点的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 访问id节点</span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 有左孩子访问左孩子  </span><br>    <span class="hljs-keyword">if</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= n) <span class="hljs-built_in">dfs</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 有右孩子访问右孩子</span><br>    cout &lt;&lt; tree[id] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-层次遍历"><a href="#4-4-层次遍历" class="headerlink" title="4.4 层次遍历"></a>4.4 层次遍历</h2><p>二叉树的层次遍历，就是指从二叉树的第一层（根结点）开始，从上至下逐层遍历，在同一层中，则按照从左到右的顺序对结点逐个访问。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719113102%201.png"></p><h1 id="5-二叉树重建"><a href="#5-二叉树重建" class="headerlink" title="5 二叉树重建"></a>5 二叉树重建</h1><h2 id="5-1-重建思路"><a href="#5-1-重建思路" class="headerlink" title="5.1 重建思路"></a>5.1 重建思路</h2><p>二叉树有三种不同的遍历方式：先序遍历，中序遍历和后序遍历。<br>中序遍历+另外任意一种遍历方式，可以<strong>唯一确定一颗二叉树</strong>。先序遍历与后序遍历<strong>不一定</strong>能唯一确定一个二叉树。</p><p>操作步骤：</p><ol><li>通过先序&#x2F;后序，判断<strong>根结点</strong></li><li>通过根结点在中序里判断<strong>左右子树</strong></li><li>在先序&#x2F;后序中找到左右节点，重复操作，画出树的结构。</li></ol><p><img src="/../../../cpp_assets/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%201.gif"></p><h2 id="5-2-重建代码"><a href="#5-2-重建代码" class="headerlink" title="5.2 重建代码"></a>5.2 重建代码</h2><h3 id="5-2-1-求先序"><a href="#5-2-1-求先序" class="headerlink" title="5.2.1 求先序"></a>5.2.1 求先序</h3><p>已知中序和后序，求先序。<br>后序遍历的最后一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求先序序列，所以是先输出，再递归左子树，再递归右子树。</p><ul><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>后序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="/../../../cpp_assets/11_clear_compress%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_pre</span><span class="hljs-params">(string in, string post)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(post.<span class="hljs-built_in">back</span>());  <br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 先序，先输出根节点，再递归左子树和右子树</span><br>    string in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id), post_left = post.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), post_right = post.<span class="hljs-built_in">substr</span>(id, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_pre</span>(in_left, post_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_pre</span>(in_right, post_right);  <span class="hljs-comment">// 递归右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-求后序"><a href="#5-2-2-求后序" class="headerlink" title="5.2.2 求后序"></a>5.2.2 求后序</h3><p>已知先序和中序，求后序。<br>先序遍历的第一个是根节点，由这个根节点可以在中序遍历中确定左子树和右子树的大小和元素，然后递归的去处理左子树和右子树，由于是求后序序列，所以是先递归左子树，再递归右子树，再输出。</p><ul><li>先序<ul><li>左子树：1 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li><li>中序<ul><li>左子树：0 开始，id 个元素</li><li>右子树：id + 1 开始，len - id - 1 个元素</li></ul></li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250719184128%201.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_post</span><span class="hljs-params">(string pre, string in)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> len = in.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 长度为0，返回</span><br>    <span class="hljs-comment">// 查找在中序中的根节点下标，作为分割点划分左子树、右子树</span><br>    <span class="hljs-type">int</span> id = in.<span class="hljs-built_in">find</span>(pre.<span class="hljs-built_in">front</span>());  <br>    string pre_left = pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, id), in_left = in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, id);  <br>    string pre_right = pre.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>), in_right = in.<span class="hljs-built_in">substr</span>(id + <span class="hljs-number">1</span>, len - id - <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">dfs_post</span>(pre_left, in_left);  <span class="hljs-comment">// 递归左子树</span><br>    <span class="hljs-built_in">dfs_post</span>(pre_right, in_right);  <span class="hljs-comment">// 递归右子树</span><br>    cout &lt;&lt; in[id];  <span class="hljs-comment">// 后序，先递归左子树和右子树，再输出根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-二叉搜索树"><a href="#6-二叉搜索树" class="headerlink" title="6 二叉搜索树"></a>6 二叉搜索树</h1><p>二叉搜索树（Binary Search Tree，BST）是一种应用非常广泛的二叉树，又称二叉查找树，二叉排序树，可以用二叉树进行组织。一般用亲子结构表示一个结点，即一个树结点中，除了数据 <code>data</code> 以外，还包含 <code>left</code>，<code>right</code> 和 <code>parent</code>。<br><strong>二叉搜索树</strong>具有的性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它根结点的值。</li><li>若右子树不空，则右子树上所有结点的值均大于它根结点的值。</li><li>左右子树也是一棵二叉搜索树。</li></ul><p>搜索过程总结：</p><ul><li>比根结点数据大，且右子树不空，则向右子树搜索，若右子树空则数据不存在。</li><li>比根结点数据小，且左子树不空，则向左子树搜索，若左子树空则数据不存在。</li></ul><p><img src="/../../../cpp_assets/Pasted%20image%2020250719192504%201.png"></p><p>根据二叉搜索树的性质和图示，可以得出二叉搜索树中的<strong>最大值在树的最右侧</strong>，<strong>最小值在树的最左侧</strong>。</p><blockquote><p>由于二叉搜索树可以用二叉树进行组织，因此，该搜索的过程可以用二叉树递归遍历实现。搜索效率平均$O(log_2N)$。<br>但存在这样的一种特殊情况，此时的二叉搜索树退化为一条单链，搜索效率降为 $O(n)$。<br><img src="/../../../cpp_assets/Pasted%20image%2020250719193119%201.png"></p></blockquote><h1 id="7-哈夫曼树"><a href="#7-哈夫曼树" class="headerlink" title="7 哈夫曼树"></a>7 哈夫曼树</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><p>哈夫曼树（Huffman Tree），又称<strong>最优二叉树</strong>，是一种<strong>带权路径长度最短</strong>的二叉树，广泛应用于<strong>数据压缩</strong>（如 ZIP、JPEG、MP3 等编码技术）。它由 David A. Huffman 在 1952 年提出，权值越大的节点越靠近根结点，越小的节点就越远离根节点，是贪心算法（Greedy Algorithm）的经典应用。</p><ul><li>权值（Weight）：每个叶子节点可以赋予一个权值（Weight），通常表示字符出现的频率或概率。</li><li>路径长度（Path Length）：从根节点到某个节点所经过的边的数量。</li><li>带权路径长度（Weighted Path Length）：树中所有叶子节点的权值乘以其路径长度的总和。</li></ul><p>哈夫曼树的目标：构造 <strong>WPL</strong> 最小的二叉树，以提高编码效率。</p><h2 id="7-2-构建步骤"><a href="#7-2-构建步骤" class="headerlink" title="7.2 构建步骤"></a>7.2 构建步骤</h2><ol><li>初始化：将所有节点视为独立的树，每个树仅含一个节点。</li><li>选择最小权值的两棵树：从森林中选出<strong>权值最小</strong>的两棵树（节点）。</li><li>合并两棵树：把这两棵树作为左右子树构成一个新节点，其权值为两个子树的权值之和。</li><li>重复步骤 2~3，直到森林中只剩一棵树，即为<strong>哈夫曼树</strong>。</li></ol><p><img src="/../../../cpp_assets/PixPin_2025-07-19_23-08-34%201.gif"></p><p>在判别树中，若带权路径长度越小，说明判别次数越少，在底层的执行效率上也会相应更高，这也是体现最优二叉树“优”的地方之一。</p><h2 id="7-3-哈夫曼编码"><a href="#7-3-哈夫曼编码" class="headerlink" title="7.3 哈夫曼编码"></a>7.3 哈夫曼编码</h2><p>哈夫曼编码是从哈夫曼树中生成的一种<strong>变长编码</strong>：</p><ul><li>高频字符用短编码，低频字符用长编码。</li><li><strong>无前缀冲突</strong>（任何编码都不是另一个编码的前缀）。</li><li>从根节点出发，<strong>左边编码为0，右边编码为1</strong>。</li><li>从根节点到叶子节点的路径就是该字符的编码。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1 Dijkstra 算法"></a>1 Dijkstra 算法</h1><p>Dijkstra（迪杰斯特拉）算法适用于<strong>单源最短路径</strong>问题，即从一个起点出发，计算到所有其他点的最短路径。它只能用于<strong>边权非负</strong>的图（所有边的权重 ≥ 0），无法解決<strong>带负权的图</strong>的最短路问题。</p><p>Dijkstra 算法的核心思想是<strong>贪心算法</strong>，将所有节点分为<strong>已确定</strong>最短路径的节点和<strong>未确定</strong>最短路径的节点:</p><ol><li>初始时，将所有顶点的最短距离设为∞，源点的距离设为0</li><li>每次从未确定节点中选择距离最小的节点，作为当前节点，将其标记为已确定</li><li>遍历当前节点的所有邻居，更新该节点的所有邻居节点的距离（<strong>松弛</strong>操作）</li><li>重复上述过程，直到所有节点都被加入已确定集合</li></ol><blockquote><p>“松弛”就是检查当前路径是否更短，如果是，就更新最短距离。</p></blockquote><ul><li>邻接矩阵+迭代</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点 边 起始点 图 距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">// 未确定节点的距离设为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始节点距离设为0</span><br><br><span class="hljs-comment">// 一次确定一个节点的最短路，n个节点需要n次循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;  <span class="hljs-comment">// id标记当前节点，初始化为0，距离为无穷大</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <span class="hljs-comment">// 在未确定节点中寻找距离最小的节点</span><br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; dis[id]) id = j;  <br>  <br>        vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 将当前节点标记为已确定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <br>        <span class="hljs-comment">// 松弛，当前节点的邻居，从当前节点出发路径更短</span><br>            <span class="hljs-keyword">if</span> (mp[id][j] != INT_MAX &amp;&amp; dis[id] + mp[id][j] &lt; dis[j])  <br>                dis[j] = dis[id] + mp[id][j];  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归实现（数据稍大会栈溢出）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, m, s, mp[N][N], dis[N];  <span class="hljs-comment">// 节点  边  起始点  图  距离</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 已确定节点</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;  <span class="hljs-comment">// 当前节点</span><br>    <span class="hljs-type">int</span> mini = INT_MAX, ni = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未确定节点中的最短距离和节点编号</span><br>    vis[id] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为已确定</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        <span class="hljs-keyword">if</span>(!vis[i]) &#123;  <span class="hljs-comment">// 遍历还未确定的节点</span><br>        <span class="hljs-comment">// 当前节点能访问到的邻居 并且 从当前节点出发的路径更短</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != INT_MAX &amp;&amp; dis[id] + mp[id][i] &lt; dis[i])  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>            <span class="hljs-comment">// 在所有还未确定的节点中寻距离最短的</span><br>            <span class="hljs-keyword">if</span>(dis[i] &lt; mini) &#123; <br>                mini = dis[i];  <span class="hljs-comment">// 更新最短距离</span><br>                ni = i;  <span class="hljs-comment">// 更新节点编号</span><br>            &#125;  <br>        &#125;    <br>&#125;  <br><span class="hljs-comment">// 如果找到了未确定节点中的最短距离节点，作为当前节点传入dij</span><br><span class="hljs-keyword">if</span>(ni != <span class="hljs-number">-1</span>) <span class="hljs-built_in">dij</span>(ni);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;  <br>    <span class="hljs-built_in">fill</span>(mp[<span class="hljs-number">0</span>], mp[<span class="hljs-number">0</span>] + N * N, INT_MAX);  <span class="hljs-comment">// 边初始化为无穷大</span><br>    <span class="hljs-keyword">while</span>(m--) &#123;  <br>        <span class="hljs-type">int</span> u, v, w;  <br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  <br>        mp[u][v] = <span class="hljs-built_in">min</span>(mp[u][v], w);  <span class="hljs-comment">// 处理重边  </span><br>    &#125;  <br>  <br>    <span class="hljs-built_in">fill</span>(dis, dis + N, INT_MAX);  <span class="hljs-comment">//  距离初始化为无穷大</span><br>    dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//  起始点距离初始化为0</span><br>    <span class="hljs-built_in">dij</span>(s);  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <br>        <span class="hljs-keyword">if</span>(dis[i] != INT_MAX) cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Bellman-Ford-算法"><a href="#2-Bellman-Ford-算法" class="headerlink" title="2 Bellman-Ford 算法"></a>2 Bellman-Ford 算法</h1><p>Bellman-Ford（贝尔曼-福特）算法是用于解决<strong>单源最短路径</strong>问题的经典算法，它可以处理图中包含负权边的情况，并能检测出图中是否存在负环。</p><p>Bellman-Ford算法的核心是“<strong>不断松弛边</strong>”。对所有边进行 <code>n - 1</code> 次松弛（n为顶点个数），之后再跑一次检测负环。</p><ol><li>初始化：将所有顶点的最短距离估计值设为∞，源点的距离设为0</li><li>松弛操作：重复 n-1 次松弛，每次遍历所有边，对每条边进行松弛操作</li><li>检查负环：再进行一次松弛操作，如果还能更新则说明存在负环</li></ol><blockquote><p>为什么进行 n-1 次松弛，因为进行一次 Bellman-Ford，距离起点一条边的点的最短路确定， 进行两次，距离起点两条边的点的最短路确定， 总共n个点，最短路最多经过 n-1 条边，所以进行 n-1 次松弛即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N];  <span class="hljs-comment">// 节点数 边数 起始点 目标点 距离</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> u;  <br>    <span class="hljs-type">int</span> v;  <br>    <span class="hljs-type">int</span> w;  <br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight) : <span class="hljs-built_in">u</span>(from), <span class="hljs-built_in">v</span>(to), <span class="hljs-built_in">w</span>(weight) &#123;&#125;  <br>&#125;;  <br>vector&lt;Edge&gt; egs;   <span class="hljs-comment">// 使用边集数组进行存储，方便对每一条</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bf</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-comment">// 除起始点之外的距离设为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// n-1 次操作，每次确定距离为 i 的节点最短路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;  <span class="hljs-comment">// 每次操作对所有边进行</span><br>        <span class="hljs-comment">// 当前边的起始点 当前边的到达点 当前边的权值</span><br>            <span class="hljs-type">int</span> from = egs[j].u, to = egs[j].v, weight = egs[j].w;  <br>            <span class="hljs-keyword">if</span>(dis[from] + weight &lt; dis[to])  <span class="hljs-comment">// 松弛操作</span><br>                dis[to] = dis[from] + weight;  <br>        &#125;  <br>    &#125;&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;  <br>    egs.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 占位 vector 的 0 号位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        <span class="hljs-type">int</span> x, y, z;  <br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;  <br>        <span class="hljs-comment">// 直接将 Edge(x,y,z) push_back 进 vector</span><br>        egs.<span class="hljs-built_in">emplace_back</span>(x, y, z);  <br>    &#125;  <br>  <br>    <span class="hljs-built_in">bf</span>();  <br>  <br>    cout &lt;&lt; dis[t];  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-SPFA-算法"><a href="#3-SPFA-算法" class="headerlink" title="3 SPFA 算法"></a>3 SPFA 算法</h1><p>SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的队列优化版本，用于求<strong>单源最短路径</strong>，减少了不必要的冗余运算，同样可以处理存在负权边的情况。</p><p>与 Bellman-Ford 每次都遍历所有边不同，SPFA 利用队列优化了 Bellman-Ford 算法中不必要的松弛操作，只对发生了松弛操作的结点的邻接结点进行松弛。</p><ol><li>初始化所有节点到起始点的距离为 ∞，源点为 0</li><li>将源点入队，并标记为在队列中</li><li>当队列不为空时：<ul><li>取出队首节点作为当前节点，弹出并标记为不在队列中</li><li>遍历从当前节点的所有临接边，尝试松弛操作</li><li>如果松弛成功，判断这个邻居节点是否在队列中，如果不在则入队</li></ul></li><li>重复以上操作直到队列为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;  <br><span class="hljs-type">int</span> n, m, s, t, dis[N], mp[N][N];  <span class="hljs-comment">// 节点 边 源点 终点 距离 图 </span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// 辅助队列</span><br><span class="hljs-type">bool</span> vis[N];  <span class="hljs-comment">// 标记节点是否在队列</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-comment">// 除源点外的其他节点距离初始化为无穷大</span><br>    <span class="hljs-built_in">fill</span>(dis, dis + N, <span class="hljs-number">1e9</span>);  <br>    dis[s] = <span class="hljs-number">0</span>;  <br>  <br>    q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 源点入队</span><br>    vis[s] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 并把源点标记为在队列</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <br>        <span class="hljs-type">int</span> id = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>        q.<span class="hljs-built_in">pop</span>();  <br>        vis[id] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为不在队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 遍历所有邻居节点</span><br>            <span class="hljs-keyword">if</span>(mp[id][i] != <span class="hljs-number">1e9</span> &amp;&amp; dis[id] + mp[id][i] &lt; dis[i]) &#123;  <br>                dis[i] = dis[id] + mp[id][i];  <span class="hljs-comment">// 松弛</span><br>                <span class="hljs-comment">// 如果不在队列则入队，并标记为在队列</span><br>                <span class="hljs-keyword">if</span>(!vis[i]) &#123; <br>                    q.<span class="hljs-built_in">push</span>(i);  <br>                    vis[i] = <span class="hljs-literal">true</span>;  <br>                &#125;  <br>            &#125;       <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SPFA 每轮更新中将“更近一层”的节点的最短路径传递出去，这个过程和 BFS 逐层访问节点的方式有点相似。</p></blockquote><h1 id="4-Floyd-算法"><a href="#4-Floyd-算法" class="headerlink" title="4 Floyd 算法"></a>4 Floyd 算法</h1>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度加减</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1 高精度加法"></a>1 高精度加法</h1><p>主要有以下几步：</p><ol><li><strong>输入处理</strong>：使用字符串来存储大整数，避免数值范围限制。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相加</strong>：从最低位开始，逐位相加并处理进位。</li><li><strong>最高进位</strong>：在最后检查是否有剩余进位。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N], b[N], c[N];  <span class="hljs-comment">// 方便进位和数位对齐的逆序整型数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 计算长度</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();<br><span class="hljs-comment">// 逆序存储到整型数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) a[i] = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) b[i] = num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// 循环较长数字的位数</span><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>c[i] += a[i] + b[i];  <span class="hljs-comment">// 这一位加上两个数的和</span><br>c[i + <span class="hljs-number">1</span>] += c[i] / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10进位到下一位</span><br>c[i] %= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 这一位超过10要取余</span><br>&#125; <br><br><span class="hljs-keyword">if</span>(c[len]) len++;  <span class="hljs-comment">// 如果最高位有进位，长度加1</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; c[i];  <span class="hljs-comment">// 逆序输出</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 分别计算两数的最后一位数下标，并初始化进位</span><br>    <span class="hljs-type">int</span> i = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br><br>    string res;<br>    <span class="hljs-comment">// 只要有数字没加完 或 有进位没处理就继续运算</span><br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>        <span class="hljs-type">int</span> sum = carry;  <span class="hljs-comment">// 这一位的结果先赋为进位值</span><br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>) sum += num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第一个数没加完就加</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span>) sum += num2[j--] - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 第二个数没加完就加</span><br><br>        carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 计算是否有进位</span><br>        res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 对10取余处理进位</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 翻转答案</span><br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">addBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-comment">// 确保 num1 是较长的数字</span><br><span class="hljs-keyword">if</span>(num<span class="hljs-number">1.l</span>ength() &lt; num<span class="hljs-number">2.l</span>ength()) <span class="hljs-built_in">swap</span>(num1, num2);<br><br>string res;  <span class="hljs-comment">// 最终答案</span><br><span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位，初始为0</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.l</span>ength(), len2 = num<span class="hljs-number">2.l</span>ength();  <span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 从最低位开始相加，加到较长数字的位数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <br><span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br><span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br><span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这一位的总和等于：两数相加并加上进位</span><br><span class="hljs-type">int</span> sum = digit1 + digit2 + carry;<br>carry = sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 下一位的进位等于这一位总和对10整除</span><br>res += sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 最终这一位的结果要对10取余，并且恢复为字符串</span><br>&#125;<br><br><span class="hljs-comment">// 如果还有进位，说明最高位也发生了进位，超出了原有最长位数，要单独处理</span><br><span class="hljs-keyword">if</span>(carry) res += carry + <span class="hljs-string">&#x27;0&#x27;</span>; <br><br><span class="hljs-comment">// 由于前面是从最低位开始加的，这里要对结果进行翻转</span><br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2 高精度减法"></a>2 高精度减法</h1><p>主要有以下几步</p><ol><li><strong>比较大小</strong>：比较两个数字字符串的大小，确定减数和被减数，并标记负号。</li><li><strong>对齐数字</strong>：确保两个数字的数位对齐（前面补零）。</li><li><strong>逐位相减</strong>：从最低位开始，逐位相减并处理借位。</li><li><strong>结果处理</strong>：移除结果中的前导零，判断是否添加负号。</li><li><strong>结果反转</strong>：因为是从低位开始计算，所以最后需要反转字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">subBigNumber</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><span class="hljs-type">char</span> op = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 记录符号</span><br><span class="hljs-comment">// 确保 num1 &gt; num2，否则记录负号并交换</span><br><span class="hljs-keyword">if</span>(num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() || num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() == num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &amp;&amp; num1 &lt; num2) &#123;<br>op = <span class="hljs-string">&#x27;-&#x27;</span>;<br><span class="hljs-built_in">swap</span>(num1, num2);<br>&#125;<br><br>string res;  <span class="hljs-comment">// 最终答案</span><br>    <span class="hljs-type">int</span> borrow = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 借位，初始为0</span><br><span class="hljs-type">int</span> len1 = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), len2 = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 运算按较长数字的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<br><span class="hljs-comment">// 较长数字正常 -&#x27;0&#x27; 转化为 int 即可</span><br><span class="hljs-type">int</span> digit1 = num1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">// 如果超出了较短数字的位数，默认补0即可</span><br><span class="hljs-type">int</span> digit2 = i &lt; len2 ? num2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 这一位的结果等于：两数相减并减去借位</span><br><span class="hljs-type">int</span> dif = digit1 - digit2 - borrow;<br><span class="hljs-comment">// 判断是否需要借位</span><br><span class="hljs-keyword">if</span>(dif &lt; <span class="hljs-number">0</span>) borrow = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> borrow = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 这一位的结果先加10再取余，可以处理需要借位的负数，并 + &#x27;0&#x27; 转字符</span><br>res += (dif + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理前导0，但注意保留一个，因为结果可能为0</span><br><span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;0&#x27;</span>) res.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 处理负号</span><br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) res += <span class="hljs-string">&#x27;-&#x27;</span>;<br><br><span class="hljs-comment">// 翻转字符串</span><br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件读取</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>如果需要从文件读入数据，并把输出数据保存为文件，需要使用文件读取。</p><ul><li><code>freopen</code>为<code>file reopen</code>，意为文件重新打开，实现重定向标准输入输出</li><li>第一个参数为文件名可以修改，输入文件为<code>.in</code>，输出文件为<code>.out</code></li><li>第二个参数，<code>r</code>代表读(read)，<code>w</code>代表写(write)</li><li>第三个参数，<code>stdin</code>标准输入，<code>stdout</code>标准输出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br></code></pre></td></tr></table></figure><p><code>main</code>函数开头加上这两行，程序会打开与编译器同目录下的<code>test.in</code>文件，从中读取输入数据，代码部分不需要修改，运行结果会保存到编译器同目录下的<code>test.out</code>文件，没有此命名文件则会自动创建此文件。</p><p>文件使用完成之后需要关闭文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fclose</span>(stdin);  <span class="hljs-comment">// 关闭输入文件</span><br><span class="hljs-built_in">fclose</span>(stdout);  <span class="hljs-comment">// 关闭输出文件</span><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>cout &lt;&lt; a;<br><br><span class="hljs-built_in">fclose</span>(stdin); <br><span class="hljs-built_in">fclose</span>(stdout);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件目录关系默认如下：<br><img src="/../../../cpp_assets/c_dir.png" alt="Pasted-image-2025043021535005a39c529573ea8f.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准输入输出</title>
    <link href="/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2025/10/26/C++%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><code>cin &gt;&gt;</code> <code>cout &lt;&lt;</code>  </p><p><code>scanf()</code>  <code>printf()</code> </p><p><code>getchar(c)</code> 字符输入  <code>putchar(c)</code> 字符输出</p><p><code>gets(str)</code> 读取一整行，回车或EOF停止，不会判断上限，不安全</p><p><code>fgets(str, 100, stdin)</code> 读取一整行，读取最多100个字符存到str中</p><p><code>cin.getline(str, 100)</code>  <code>getline(cin, str)</code> 读取一整行，读取最多100个字符存到str中</p><p><strong>注意</strong>：当同时使用<code>cin&gt;&gt;</code>, <code>getline()</code>时，在<code>cin&gt;&gt;</code>之后，<code>getline()</code>之前，需要将回车符作为输入流cin以清除缓存，在<code>cin</code>和<code>getline()</code>中间插入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; <br>...<br>str=<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">getline</span>(cin,str);<br>...<br><span class="hljs-built_in">getline</span>()<br></code></pre></td></tr></table></figure><p>如果不这样做的话，在控制台上就不会出现<code>getline()</code>的输入提示，而是直接跳过，因为程序默认将之前的变量作为输入流。</p><table><thead><tr><th align="center">数据类型</th><th align="center">占位符</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">%d</td></tr><tr><td align="center">long long</td><td align="center">%lld</td></tr><tr><td align="center">float</td><td align="center">%f</td></tr><tr><td align="center">double</td><td align="center">scanf 用 %lf，printf 用 %f</td></tr><tr><td align="center">char</td><td align="center">%c</td></tr></tbody></table><ul><li><p>无论单双精度，<code>printf</code> 都会将浮点数提升为双精度，所以在输出时不区分单双精度</p></li><li><p><code>printf()</code> 特殊输出格式</p><ul><li><p><code>%md</code> 右对齐m位输出，高位用空格补齐</p></li><li><p><code>%0md</code> 右对齐m位输出，高位用0补齐</p></li><li><p><code>%.mf</code> 浮点数保留m位小数</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C基本语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用指南</title>
    <link href="/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统！</p><h1 id="1-安装和配置Git"><a href="#1-安装和配置Git" class="headerlink" title="1 安装和配置Git"></a>1 安装和配置Git</h1><h2 id="1-1-Linux环境"><a href="#1-1-Linux环境" class="headerlink" title="1.1 Linux环境"></a>1.1 Linux环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否安装 git</span><br>git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS 系列</span><br>sudo yum install git <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu 系列</span><br>sudo apt install git<br></code></pre></td></tr></table></figure><h2 id="1-2-macOS环境"><a href="#1-2-macOS环境" class="headerlink" title="1.2 macOS环境"></a>1.2 macOS环境</h2><p>使用Homebrew可以很方便地安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 Homebrew 是否安装</span><br>brew -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Homebrew</span><br>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>brew install git<br></code></pre></td></tr></table></figure><h2 id="1-3-Windows环境"><a href="#1-3-Windows环境" class="headerlink" title="1.3 Windows环境"></a>1.3 Windows环境</h2><p>可以先安装一个包管理工具<a href="https://scoop.sh/">Scoop</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 git</span><br>scoop install git<br></code></pre></td></tr></table></figure><h2 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h2><p>由于Git是分布式版本控制系统，所以安装之后还要配置个人信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure><h1 id="2-版本库"><a href="#2-版本库" class="headerlink" title="2 版本库"></a>2 版本库</h1><p><strong>版本库又名仓库</strong>（Repository），可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪。</p><h2 id="2-1-创建版本库"><a href="#2-1-创建版本库" class="headerlink" title="2.1 创建版本库"></a>2.1 创建版本库</h2><p>进入文件夹执行<code>git init</code>命令就可以把这个目录变成Git管理的仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><blockquote><p>目录下会自动生成一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，不要乱动。</p></blockquote><p>如果想要把<code>.git</code>目录生成到别的文件夹，可以使用下面的命令指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init --separate-git-dir=D:/Develop/GitRecord<br></code></pre></td></tr></table></figure><p>实际是生成了一个<code>.git</code>文件里面写入了<code>gitdir: D:/Develop/GitRecord</code>。</p><h2 id="2-2-添加文件到版本库"><a href="#2-2-添加文件到版本库" class="headerlink" title="2.2 添加文件到版本库"></a>2.2 添加文件到版本库</h2><p>假设当前有一个仓库叫做DemoProject，在这个目录下创建文件<code>readme.txt</code>，把文件放入仓库一共需要两步。使用<code>add</code>添加多个文件到仓库，使用<code>commit</code>一次性提交到仓库。</p><ol><li><p>使用<code>git add</code>把文件添加到仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add readme.txt<br></code></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p></li><li><p>使用<code>git commit</code>把文件提交到仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;提交说明&quot;<br></code></pre></td></tr></table></figure></li></ol><p>如果想要把已有目录交给<code>git</code>管理，可以使用<code>git add .</code>将所有文件全部添加到暂存区，然后一次性<code>git commit</code>进行提交。</p><blockquote><p>所有的版本控制系统，都只能跟踪文本文件的改动，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化。另外不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。</p></blockquote><h2 id="2-3-Git工作流程"><a href="#2-3-Git工作流程" class="headerlink" title="2.3 Git工作流程"></a>2.3 Git工作流程</h2><p>牢记Git分为以下三个核心区域，它们是并列关系，构成了Git的核心工作流。</p><ul><li>**工作区 (Working Directory &#x2F; Working Tree)**：电脑上看到的实际目录，实际开发的地方</li><li>**暂存区 (Staging Area &#x2F; Index)**：一个缓存区，保存了 <code>git add</code> 准备提交的文件快照</li><li>**版本库 (Local Repository)**：已经 <code>git commit</code> 的所有历史版本</li></ul><blockquote><p>工作区有一个隐藏目录<code>.git</code>不算工作区，里面存储的是Git的<strong>版本库</strong>。暂存区（<code>index</code> 文件）虽然物理上位于 <code>.git</code> 目录中，但它不属于版本库。</p></blockquote><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的<strong>暂存区</strong>，还有Git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><img src="/../../../tool_assets/repo.png"></p><p>了解了工作区和版本库，对于很多操作就明白实际是做什么了。</p><ul><li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区</li><li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支</li></ul><blockquote><p><strong>Git管理的是修改，而不是文件。</strong> 每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p></blockquote><h1 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3 版本管理"></a>3 版本管理</h1><h2 id="3-1-查看信息"><a href="#3-1-查看信息" class="headerlink" title="3.1 查看信息"></a>3.1 查看信息</h2><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，比如是否有文件修改（新增、删除都属于修改）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>modified:   readme.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><br></code></pre></td></tr></table></figure><p><code>git diff</code>命令可以知道某个文件具体修改了什么内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff readme.txt<br></code></pre></td></tr></table></figure><p>提交修改和提交新文件是一样的，第一步<code>git add</code>，第二步<code>git commit</code>。</p><h2 id="3-2-版本回退"><a href="#3-2-版本回退" class="headerlink" title="3.2 版本回退"></a>3.2 版本回退</h2><p>每一次<code>commit</code>相当于一个版本，使用<code>git log</code>可以查看版本历史记录，加上<code>--pretty=oneline</code>参数可以让显示更清晰。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log [--pretty=oneline]<br></code></pre></td></tr></table></figure><p>使用<code>git reset</code>回到指定版本，Git中<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，更早的版本是<code>HEAD~n</code>，n表示上n个版本，也可以直接指定版本号（不用写全，Git会自动去找）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><h2 id="3-3-撤销修改"><a href="#3-3-撤销修改" class="headerlink" title="3.3 撤销修改"></a>3.3 撤销修改</h2><h3 id="3-3-1-未到暂存区"><a href="#3-3-1-未到暂存区" class="headerlink" title="3.3.1 未到暂存区"></a>3.3.1 未到暂存区</h3><p>使用<code>git checkout -- file</code>可以丢弃工作区的修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure><blockquote><p><code>--</code>  双破折号非常重要，它告诉 Git后面的参数是一个文件路径，而不是一个分支名。</p></blockquote><p>Git会执行以下操作：</p><ol><li>查找<strong>暂存区</strong>中 <code>readme.txt</code> 的版本（找不到会从 <code>HEAD</code>，即最后一次提交中恢复。）</li><li>用这个版本的文件<strong>覆盖</strong>工作目录中的 <code>readme.txt</code></li></ol><p>本质上这是一个反向的 <code>git add</code> 操作：<br><code>git add &lt;file&gt;</code> 会将工作目录中的文件快照存入暂存区（index）。<br><code>git checkout -- &lt;file&gt;</code> 会将暂存区里的文件快照<strong>还原</strong>到工作目录，从而丢弃对文件所做的所有本地修改。</p><h3 id="3-3-2-已到暂存区"><a href="#3-3-2-已到暂存区" class="headerlink" title="3.3.2 已到暂存区"></a>3.3.2 已到暂存区</h3><ol><li>使用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD readme.txt<br></code></pre></td></tr></table></figure></li></ol><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><ol start="2"><li>放回工作区后，暂存区是干净的，工作区有所修改，再使用未到暂存区的处理方式<code>git checkout -- file</code>。</li></ol><h2 id="3-4-删除文件"><a href="#3-4-删除文件" class="headerlink" title="3.4 删除文件"></a>3.4 删除文件</h2><p>当删除文件之后，工作区和版本库不一致，有两种选择。</p><ol><li>确实要从版本库删除该文件</li></ol><p>和添加文件类似，第一步<code>git rm</code>从暂存区移除，第二步<code>git commit</code>提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm readme.txt<br><br>git commit<br></code></pre></td></tr></table></figure><blockquote><p>先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和直接使用<code>git rm &lt;file&gt;</code>效果是完全相同的。</p></blockquote><ol start="2"><li>误删文件，想要恢复</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- readme.txt<br></code></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h1 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4 远程仓库"></a>4 远程仓库</h1><h2 id="4-1-SSH密钥配置"><a href="#4-1-SSH密钥配置" class="headerlink" title="4.1 SSH密钥配置"></a>4.1 SSH密钥配置</h2><ol><li>生成SSH密钥对</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>生成在C:\Users\你的用户名.ssh目录下，<code>id_ed25519.pub</code>是公钥，<code>id_ed25519</code>是私钥。</p><ol start="2"><li><p>将公钥添加到 GitHub</p><ul><li>打开 <code>C:\Users\你的用户名\.ssh\id_ed25519.pub</code>，复制内容</li><li>进入 GitHub → Settings → SSH and GPG keys → 添加新 SSH 密钥</li></ul></li><li><p>SSH测试连接</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果看到 <code>Hi 你的用户名! You&#39;ve successfully authenticated...</code> 说明 SSH 配置成功。</p><h2 id="4-2-添加到远程库"><a href="#4-2-添加到远程库" class="headerlink" title="4.2 添加到远程库"></a>4.2 添加到远程库</h2><ol><li>先在Github创建远程仓库，在本地仓库执行以下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure></li></ol><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><ol start="2"><li>使用<code>git remote -v</code>可以检查远程仓库地址：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure></li></ol><p>如果能显示下列信息，说明远程仓库配置没问题，可以进行推送和拉取了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">origin  git@github.com:账户名/仓库名.git (fetch)<br>origin  git@github.com:账户名/仓库名.git (push)<br></code></pre></td></tr></table></figure><h2 id="4-3-推送到远程库"><a href="#4-3-推送到远程库" class="headerlink" title="4.3 推送到远程库"></a>4.3 推送到远程库</h2><p>使用远程库比本地工作流程多一步push，为下面三步：</p><ol><li>把改动放入暂存区<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &lt;文件&gt;<br></code></pre></td></tr></table></figure></li><li>把暂存区改动提交到本地仓库，生成一个新的commit<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;说明&quot;<br></code></pre></td></tr></table></figure></li><li>把本地仓库的commit推送到远程仓库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：如果远程仓库的默认分支是 <code>main</code>，命令里的 <code>master</code> 改成 <code>main</code> 即可。<br>Github后来把默认主分支改成<code>main</code>了。</p></blockquote><hr><p>每次推送执行<code>git push origin master</code>命令较长，推荐<strong>在第一次推送时</strong>加上<code>-u</code>参数，除了推送之外，它还会把本地分支 <code>master</code> 与远程分支 <code>origin/master</code> 关联起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin master<br></code></pre></td></tr></table></figure><p>与远程分支关联以后就可以简化命令，直接使用<code>push</code>推送，使用<code>pull</code>拉取，Git 就会自动知道本地的 <code>master</code> 对应远程的 <code>origin/master</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br>git pull<br></code></pre></td></tr></table></figure><h2 id="4-4-从远程库克隆"><a href="#4-4-从远程库克隆" class="headerlink" title="4.4 从远程库克隆"></a>4.4 从远程库克隆</h2><p>在本地目录运行下面命令即可克隆一个本地库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:账户名/仓库名.git<br></code></pre></td></tr></table></figure><p><code>git clone</code> 下来的仓库，Git 会自动创建一个名为 <code>origin</code> 的远程别名，本地分支和远程分支已经自动关联了，一般直接 <code>git push / git pull</code> 就可以，不需要再手动 <code>-u</code>。</p><h1 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5 分支管理"></a>5 分支管理</h1>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/10/26/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Linux-系统概述"><a href="#1-Linux-系统概述" class="headerlink" title="1 Linux 系统概述"></a>1 Linux 系统概述</h1><ul><li>Linux 发行时间: 1991年</li><li>Linux 的创始人: 林纳斯·托瓦兹</li><li>Linux 的吉祥物: 企鹅</li><li>官网地址: <a href="https://www.kernel.org/">https://www.kernel.org/</a></li></ul><blockquote><p><strong>Linux 发行版</strong> &#x3D; Linux 内核 + 系统库 + 系统软件</p><p>Linux 的内核完全开源免费，但是 Linux 的发行版不一定免费。</p></blockquote><p>Linux 是目前服务器端用到的最多的操作系统，支持 7 * 24小时高性能服务。<br>常见的 Linux 发行版：</p><ul><li>RedHat: 世界最大的 Linux 发行版厂商，已经被 IBM 收购</li><li>Ubuntu: 桌面操作系统做最好的</li><li>CentOS: 目前中国市场使用最多的 Linux 版本，目前已经被 RedHat 收购,但依然免费</li><li>Deepin: 深度公司开发的 Linux 版本，国内做的最好的 Linux 发行版</li></ul><p><img src="/../../../tool_assets/1739856296312.png" alt="1739856296312"></p><h1 id="2-Linux-的目录结构"><a href="#2-Linux-的目录结构" class="headerlink" title="2 Linux 的目录结构"></a>2 Linux 的目录结构</h1><ul><li>Linux 和 Windows, Mac 一样, 都是文件系统, 采用文件和文件夹的形式来管理数据</li></ul><ul><li>只不过在 Linux 操作系统中，是没有盘符概念的，任何文件(文件夹)都是从根目录开始进行拆分的</li><li>且 Linux 中采用的是<strong>目录树结构</strong>，Windows 中采用的是<strong>森系结构</strong></li></ul><p>Linux 中常用的目录结构:</p><ul><li><code>/etc</code>：存放 Linux 配置文件的目录</li><li><code>/opt</code>：存放应用程序的目录</li><li><code>/bin</code>：终端指令集存放的目录</li><li><code>/sbin</code>：超级管理员用户使用的指令集，包括用户的创建删除等指令</li><li><code>/home</code>：普通用户的家目录</li><li><code>/root</code>：超级管理员的家目录,</li></ul><p><img src="/../../../tool_assets/666666666.png" alt="666666666"></p><h1 id="3-基础命令"><a href="#3-基础命令" class="headerlink" title="3 基础命令"></a>3 基础命令</h1><p>Linux指令的构成：<code>command [-options] [arguments]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">linux指令 = 命令(做什么) + 选项(怎么做) + 参数(对谁做)  <br><br>command: 命令名, 相应功能的英文单词或单词的缩写  <br>-options: 选项, 可用来对命令进行控制, 也可以省略  <br>arguments: 传给命令的参数, 可以是零个、一个或者多个<br></code></pre></td></tr></table></figure><h2 id="3-1-文件与目录操作"><a href="#3-1-文件与目录操作" class="headerlink" title="3.1 文件与目录操作"></a>3.1 文件与目录操作</h2><h3 id="3-1-1-路径导航"><a href="#3-1-1-路径导航" class="headerlink" title="3.1.1 路径导航"></a>3.1.1 路径导航</h3><h4 id="ls（列出内容）"><a href="#ls（列出内容）" class="headerlink" title="ls（列出内容）"></a>ls（列出内容）</h4><p><code>ls</code> 源自 <strong>list</strong>，用于<strong>查看指定位置的文件和子目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [-a -l -h] [路径信息]<br><br>-a  # all, 显示所有文件（包括以.开头的隐藏文件）<br>-l  # long format, 以长格式列出文件（权限、所有者、大小、修改时间等）<br>-h# human-readable, 以人类可读的格式（如 KB、MB）显示文件大小（需配合 -l 使用）<br></code></pre></td></tr></table></figure><p>选项可以随意自由组合，且选项的顺序可以随意调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls# 列出当前目录的文件和子目录（不包括隐藏的）<br>ls -lh  # 以长格式显示文件信息，并以易读的方式显示文件大小<br>ls -al  # 以长格式显示文件信息，包括隐藏文件<br>ls -alh # 以长格式显示文件信息，包括隐藏文件，并以易读的方式显示文件大小<br></code></pre></td></tr></table></figure><p><code>ls</code> 参数可以查看指定路径的文件信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /      # 查看根目录的文件和子目录<br>ls -a aa  # 显示当前目录下的 aa 目录中的文件内容，包括隐藏文件<br>ll        # 完全等价于 ls -l, 可以快速查看文件的详细信息（也可以搭配 -h -a 使用）<br></code></pre></td></tr></table></figure><h4 id="cd（切换目录）"><a href="#cd（切换目录）" class="headerlink" title="cd（切换目录）"></a>cd（切换目录）</h4><p><code>cd</code> 源自 <strong>change directory</strong>，用于<strong>改变工作目录</strong>。</p><ul><li>绝对路径：从根目录出发，直到目标文件的目录层级</li><li>相对路径：从当前目录出发，直到目标文件目录层级</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd [绝对路径或相对路径]<br><br>..    # 代表上一级目录<br>../   # 同上，代表上一级目录<br>./    # 代表当前路径，可以省略<br></code></pre></td></tr></table></figure><ul><li><code>cd</code> 命令无需选项，只有参数，表示要切换到哪个目录下</li><li><code>cd</code> 命令不写参数直接执行，表示回到用户的家目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc  # 切换到 /etc 目录<br>cd       # 回家，root 账号家目录是 /root，其他账号家目录是 /home<br>cd ~     # 返回家目录，即 cd ~ 等价于 cd，都是回家<br>cd -     # 返回上一次操作的工作目录<br></code></pre></td></tr></table></figure><h4 id="pwd（当前路径）"><a href="#pwd（当前路径）" class="headerlink" title="pwd（当前路径）"></a>pwd（当前路径）</h4><p><code>pwd</code> 源自 <strong>print work directory</strong>，用于<strong>打印工作目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd    # 当前在哪个目录, 就打印什么路径.<br></code></pre></td></tr></table></figure><h3 id="3-1-2-增删改"><a href="#3-1-2-增删改" class="headerlink" title="3.1.2 增删改"></a>3.1.2 增删改</h3><h4 id="mkdir（创建目录）"><a href="#mkdir（创建目录）" class="headerlink" title="mkdir（创建目录）"></a>mkdir（创建目录）</h4><p><code>mkdir</code> 源自 <strong>make directory</strong>，用于<strong>创建新文件夹</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [-p] 目录名称<br>-p    # parents, 自动创建所需的父目录（如果不存在）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单级目录</span><br>mkdir aa            # 在当前目录下创建 aa 文件夹<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建多级目录</span><br>mkdir aa/bb/cc      # 创建多级目录，如果 aa/bb 目录不存在，则：报错<br>mkdir -p aa/bb/cc   # 自动创建所需要的目录<br></code></pre></td></tr></table></figure><h4 id="touch（创建文件）"><a href="#touch（创建文件）" class="headerlink" title="touch（创建文件）"></a>touch（创建文件）</h4><p><code>touch</code> 用于<strong>修改文件时间戳</strong>或<strong>创建空文件</strong>。</p><ul><li><code>touch</code> 可以创建一个新的文件，文件的扩展名随意，甚至可以是不存在的扩展名</li><li><code>touch</code> 创建的文件如果存在不报错，但是没有新文件产生</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建单个文件</span><br>touch 1.txt        <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性创建多个文件</span><br>touch 1.txt 2.jpg 3.mp3<br></code></pre></td></tr></table></figure><h4 id="cp（复制）"><a href="#cp（复制）" class="headerlink" title="cp（复制）"></a>cp（复制）</h4><p><code>cp</code> 源自 <strong>copy</strong>，用于<strong>拷贝文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp 源文件 目标文件<br>cp -r 源目录 目标目录<br>-r      # recursive, 递归复制目录（包括子目录和文件）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝文件</span><br>cp 1.txt /aa         # 拷贝 1.txt 到 /aa 目录下<br>cp 1.txt /aa/2.txt   # 拷贝 1.txt 到 /aa 目录下，并命名为 2.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝目录</span><br>cp -r aa bb          # 递归拷贝 aa 文件夹到 bb 文件夹下<br></code></pre></td></tr></table></figure><h4 id="mv（移动-重命名）"><a href="#mv（移动-重命名）" class="headerlink" title="mv（移动&#x2F;重命名）"></a>mv（移动&#x2F;重命名）</h4><p><code>mv</code> 源自 <strong>move</strong>，用于 <strong>移动</strong>或<strong>重命名文件</strong>文件和目录，类似于 windows 剪切。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 源文件 目标路径  # 将文件移动到目标路径<br>mv 旧名字 新名字    # 重命名（本质是在同一目录下移动）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动</span><br>mv file.txt /tmp/          # 移动 file.txt 到 /tmp 目录<br>mv folder/ /backup/        # 移动 folder 到 /backup 目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重命名</span><br>mv old.txt new.txt         # 文件重命名<br>mv old_dir/ new_dir/       # 目录重命名<br></code></pre></td></tr></table></figure><h4 id="rm（删除）"><a href="#rm（删除）" class="headerlink" title="rm（删除）"></a>rm（删除）</h4><p><code>rm</code> 源自 <strong>remove</strong>，用于 <strong>删除文件或目录</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm 文件名<br>rm -r 目录名<br>-r      # recursive, 递归删除目录（包括子目录和文件）<br>-f      # force, 强制删除，不进行询问<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件</span><br>rm 1.txt    # 删除当前目录下的 1.txt<br>rm /*.txt   # 删除根目录下的所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除文件夹</span><br>rm -r aa    # 删除当前目录下的 aa 文件夹<br>rm -rf /bb  # 强制删除根目录下的 bb 文件夹不进行提示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性删除多个</span><br>rm -rf /*              # 通过 * 通配符删除所有文件<br>rm 1.txt 2.jpg 3.mp3   # 一次性删除这三项文件<br></code></pre></td></tr></table></figure><h3 id="3-1-3-内容查看"><a href="#3-1-3-内容查看" class="headerlink" title="3.1.3 内容查看"></a>3.1.3 内容查看</h3><h4 id="cat（全量查看）"><a href="#cat（全量查看）" class="headerlink" title="cat（全量查看）"></a>cat（全量查看）</h4><p><code>cat</code> 源自 <strong>concatenate</strong>，连接、查看文件内容，常用于<strong>查看小型文本文件</strong>。</p><ul><li>一次性输出全部内容，大文件显示不全，且过于消耗内存，适合小文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名<br>-n  # number, 显示行号<br></code></pre></td></tr></table></figure><h4 id="more（分页查看）"><a href="#more（分页查看）" class="headerlink" title="more（分页查看）"></a>more（分页查看）</h4><p><code>more</code> 是一个分页查看工具，主要用于<strong>查看中型文本文件</strong>。</p><ul><li>分页查看文件，支持手动翻页，更加灵活，但同样消耗内存。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">more 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Enter          向下一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">D(down)/Space  向下一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">B(back)        向上一页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Q(quit)        退出</span><br></code></pre></td></tr></table></figure><h4 id="tail（查看尾部，日志监控）"><a href="#tail（查看尾部，日志监控）" class="headerlink" title="tail（查看尾部，日志监控）"></a>tail（查看尾部，日志监控）</h4><p><code>tail</code> 意为“尾部”，用于<strong>查看文件末尾内容</strong> ，适合监控日志文件或实时查看新增内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail [-n NUM -f] 文件名<br>-n NUM   # number, 显示末尾 NUM 行（默认 10）, n 可以省略，简写为 -NUM<br>-f       # follow, 实时跟踪文件更新<br><br>tail 1.txt           # 查看文件末尾 10 行（默认）<br>tail -5 1.txt        # 查看文件末尾 5 行<br>tail -100f log.txt   # 动态查看文件末尾 100 行<br></code></pre></td></tr></table></figure><h2 id="3-2-搜索与过滤"><a href="#3-2-搜索与过滤" class="headerlink" title="3.2 搜索与过滤"></a>3.2 搜索与过滤</h2><h3 id="3-2-1-文件搜索"><a href="#3-2-1-文件搜索" class="headerlink" title="3.2.1 文件搜索"></a>3.2.1 文件搜索</h3><h4 id="which（查找命令路径）"><a href="#which（查找命令路径）" class="headerlink" title="which（查找命令路径）"></a>which（查找命令路径）</h4><p><code>which</code> 用于<strong>查找命令的完整路径</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">which 命令名<br><br>which ls        # 输出：/usr/bin/ls<br>which ifconfig  # 输出：/usr/sbin/ifconfig<br></code></pre></td></tr></table></figure><h4 id="find（按条件递归查找文件）"><a href="#find（按条件递归查找文件）" class="headerlink" title="find（按条件递归查找文件）"></a>find（按条件递归查找文件）</h4><p><code>find</code> 通过条件筛选，用于<strong>查找符合条件的文件和目录</strong>。</p><ul><li>不指定路径时：默认从当前目录递归搜索</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [路径] [筛选条件]<br>-name 按名称过滤<br>-size 按大小过滤  <br>-size +100M 大于100MB  <br>-size -1G 小于1GB<br>-type 按类型过滤  <br>-type f 文件  <br>-type d 目录 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按名称搜索</span><br>find / -name &#x27;abc*&#x27;         # 查找根目录下所有 abc 开头的文件<br>find /path -name &quot;*.txt&quot;    # 查找 /path 目录下所有 .txt 文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按大小搜索</span><br>find / -size +1G            # 查找根目录下大于 1GB 的文件<br>find ~ -size -10M           # 查找家目录下小于 10MB 的文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按类型搜索</span><br>find / -type d -name &quot;log&quot;  # 搜索名为 log 的目录<br></code></pre></td></tr></table></figure><h3 id="3-2-2-内容过滤"><a href="#3-2-2-内容过滤" class="headerlink" title="3.2.2 内容过滤"></a>3.2.2 内容过滤</h3><h4 id="grep（文本匹配）"><a href="#grep（文本匹配）" class="headerlink" title="grep（文本匹配）"></a>grep（文本匹配）</h4><p><code>grep</code> 源自 <strong>global regular expression print</strong>（全局正则表达式打印），用于<strong>搜索符合条件的文本并打印所在行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [-n] &quot;要搜索的内容&quot; 文件名<br>-n       # number, 显示行号<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep &#x27;world&#x27; 1.txt  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world code</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br><br>grep -n &#x27;python&#x27; 1.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印内容： 2: python world good</span><br></code></pre></td></tr></table></figure><h4 id="wc（行-词-字节统计）"><a href="#wc（行-词-字节统计）" class="headerlink" title="wc（行&#x2F;词&#x2F;字节统计）"></a>wc（行&#x2F;词&#x2F;字节统计）</h4><p><code>wc</code> 源自 <strong>word count</strong>，用于<strong>统计文本行数、单词数、字节数</strong>。</p><ul><li>单词按照空格划分</li><li>在默认的 UTF-8 编码下，1汉字 &#x3D; 3字节，1汉字 &#x3D; 1字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc [-l -w -c -m] 文件名<br>-l             # line, 行数<br>-w             # word, 单词数<br>-c             # character, 字节数<br>-m             # multibyte, 字符数<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：hello world</span><br>wc 1.txt       # 输出：1 2 12 ，分别代表行数、单词数、字节数<br>wc -wlc 1.txt  # 同上，包括 -lwc 都一样，没有顺序之分<br></code></pre></td></tr></table></figure><h2 id="3-3-文本打印"><a href="#3-3-文本打印" class="headerlink" title="3.3 文本打印"></a>3.3 文本打印</h2><h3 id="echo（输出文本-变量）"><a href="#echo（输出文本-变量）" class="headerlink" title="echo（输出文本&#x2F;变量）"></a>echo（输出文本&#x2F;变量）</h3><p><code>echo</code> 意为“回声”，功能类似于 Python 的 <code>print</code>，用于 <strong>输出文本或变量内容到标准输出（屏幕）</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [-n -e] &#x27;内容&#x27;<br>-n不自动换行（末尾不加换行符）<br>-e启用转义字符（如 \n 换行）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出文本到屏幕</span><br>echo &quot;Hello, World!&quot;      # 输出：Hello, World!<br>echo - e &quot;Hello\nWorld!&quot;  # 输出两行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出变量到屏幕</span><br>name=&#x27;zhu&#x27;                # = 两侧不能有空格<br>echo &quot;my name is $name&quot;   # 使用 $ 表示变量，输出：my name is zhu<br></code></pre></td></tr></table></figure><h2 id="3-4-数据流控制"><a href="#3-4-数据流控制" class="headerlink" title="3.4 数据流控制"></a>3.4 数据流控制</h2><h3 id="3-4-1-（输出重定向）"><a href="#3-4-1-（输出重定向）" class="headerlink" title="3.4.1 &gt;&#x2F;&gt;&gt;（输出重定向）"></a>3.4.1 <code>&gt;</code>&#x2F;<code>&gt;&gt;</code>（输出重定向）</h3><p>重定向通过符号控制数据的输入&#x2F;输出方向，用于<strong>控制数据的流向</strong>（如输出到文件或管道）。</p><ul><li>重定向是命令与文件间的传递，用于保存输出或读取文件输入</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">    <span class="hljs-comment"># 覆盖写入文件（若文件不存在则创建）</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;    <span class="hljs-comment"># 追加到文件末尾</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">快速创建文件</span><br>echo &quot;This is line 1&quot; &gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">追加文本</span><br>echo &quot;This is line 2&quot; &gt;&gt; 1.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重定向输出</span><br>ls /usr/bin &gt; cmd.txt   # 将输出信息重定向到 cmd.txt 中，相当于写入<br></code></pre></td></tr></table></figure><h3 id="3-4-2-（管道符）"><a href="#3-4-2-（管道符）" class="headerlink" title="3.4.2 |（管道符）"></a>3.4.2 <code>|</code>（管道符）</h3><p>管道（Pipe <code>|</code> ）用于将 <strong>前一个命令的输出</strong> 作为 <strong>后一个命令的输入</strong>，实现多命令协作处理数据。</p><ul><li>管道符是命令与命令间的传递，用于多命令协作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令1 | 命令2 | 命令3...<br><br>ls / | wc -w    # 输出：20，统计根目录下的目录数<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.txt 内容：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">hello world</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python world good</span><br>cat 1.txt | grep &#x27;python&#x27; | wc -w   # 输出：3，先查文件，再过滤，再统计单词<br></code></pre></td></tr></table></figure><h3 id="3-4-3-（命令替换）"><a href="#3-4-3-（命令替换）" class="headerlink" title="3.4.3 `&#x2F;$()（命令替换）"></a>3.4.3 <code>`</code>&#x2F;<code>$()</code>（命令替换）</h3><p>反引号<code>`</code>用于 **命令替换**，可以将 **命令的输出结果** 作为字符串嵌入到其他命令中，现代脚本中可以使用 <code>$( )</code> 语法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `ls / | wc -w`<br>echo $(ls / | wc -w)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出：20</span><br></code></pre></td></tr></table></figure><h2 id="3-5-vi-vim-命令"><a href="#3-5-vi-vim-命令" class="headerlink" title="3.5 vi&#x2F;vim 命令"></a>3.5 vi&#x2F;vim 命令</h2><p><code>vi</code> 全称叫: Visual Interface，类似于 windows 的记事本，是 Linux 中最经典的文本编辑器。<br><code>vim</code> 是 vi 的加强版本，兼容 vi 的所有指令，不仅能编辑文本，而且还具有 shell 程序编辑的功能，可以不同颜色的字体来辨别语法的正确性。</p><ul><li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li><li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi 文件名<br>vim 文件名<br></code></pre></td></tr></table></figure><p><code>vi</code> &#x2F; <code>vim</code> 编辑器的三种工作模式：</p><ul><li><strong>命令模式</strong>（默认&#x2F;Command mode）<br>从键盘上输入的任何字符都被当做命令来解释，但输入的命令并不回显在屏幕上。若输入的字符不是 vi 的合法命令，vi 会响铃报警。</li><li><strong>输入模式</strong>（Insert mode）<br>也就是所谓的编辑模式、插入模式。用户输入的任何字符都被 vi 当做文件内容保存起来，并将其显示在屏幕上。</li><li><strong>底线命令模式</strong>（Last line mode）<br>底线命令模式也称命令行模式。此时 vi 会在屏幕最后一行显示一个<code>:</code>作为末行模式的说明符，等待用户输入命令，多数文件管理命令都是在此模式下执行的。</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250729181400.png"></p><ul><li>命令模式：<ul><li><code>iao</code> 进入编辑模式</li><li><code>:</code> 进入底线命令模式</li><li><code>dd</code> 删除当前行</li><li><code>ndd</code> 向下删除 n 行</li><li><code>yy</code> 复制当前行</li><li><code>nyy</code> 向下复制 n 行</li><li><code>p</code> 粘贴</li><li><code>gg</code> 回到行首（文件开头）</li><li><code>G</code> 回到行尾（文件结尾）</li><li><code>u</code> 撤销</li><li><code>Ctrl</code>+<code>r</code>：反撤销</li><li><code>/文本</code>：查询文本并高亮显示</li></ul></li><li>底线命令模式：<ul><li><code>:q</code> 退出不保存</li><li><code>:q!</code> 强制退出不保存</li><li><code>:wq</code> write quit 退出并保存（快捷键<code>ZZ</code>）</li><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 隐藏行号</li><li><code>:noh</code>&#x2F;<code>:nohl</code> no highlight，取消高亮显示</li></ul></li><li>输入模式：<ul><li><code>ESC</code> 回到命令模式</li></ul></li></ul><h2 id="3-6-命令手册"><a href="#3-6-命令手册" class="headerlink" title="3.6 命令手册"></a>3.6 命令手册</h2><p>大多数手册都是全英文的，可以通过重定向符：<code>man ls &gt; ls-man.txt</code>，输出手册到文件，然后通过翻译软件查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助文档.</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: 命令名 --<span class="hljs-built_in">help</span></span>  <br>ls --help  <br>​  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助手册</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式: man 命令名  manual，手册</span><br>man ls<br></code></pre></td></tr></table></figure><h1 id="4-用户和权限"><a href="#4-用户和权限" class="headerlink" title="4 用户和权限"></a>4 用户和权限</h1><p>在 Linux 系统中，拥有最大权限的账户名为：<code>root</code>（超级管理员）。<br>普通用户的权限，一般在其 HOME 目录内是不受限的，一旦出了 HOME 目录，大多数地方，普通用户仅有只读和执行权限，无修改权限。</p><h2 id="4-1-用户和用户组"><a href="#4-1-用户和用户组" class="headerlink" title="4.1 用户和用户组"></a>4.1 用户和用户组</h2><p>Linux系统中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组中</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250729213542.png"></p><p>Linux中关于权限的管控级别有2个级别，分别是：</p><ul><li>针对<strong>用户</strong>的权限控制</li><li>针对<strong>用户组</strong>的权限控制</li></ul><h3 id="4-1-1-用户组管理"><a href="#4-1-1-用户组管理" class="headerlink" title="4.1.1 用户组管理"></a>4.1.1 用户组管理</h3><h4 id="getent-group（查看所有用户组）"><a href="#getent-group（查看所有用户组）" class="headerlink" title="getent group（查看所有用户组）"></a>getent group（查看所有用户组）</h4><p><code>getent</code> 源自 <strong>get entries</strong>（entry: 条目）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent group<br></code></pre></td></tr></table></figure><h4 id="groupadd（创建用户组）"><a href="#groupadd（创建用户组）" class="headerlink" title="groupadd（创建用户组）"></a>groupadd（创建用户组）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> 组名<br></code></pre></td></tr></table></figure><h4 id="groupdel（删除用户组）"><a href="#groupdel（删除用户组）" class="headerlink" title="groupdel（删除用户组）"></a>groupdel（删除用户组）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupdel 组名<br></code></pre></td></tr></table></figure><h3 id="4-1-2-用户管理"><a href="#4-1-2-用户管理" class="headerlink" title="4.1.2 用户管理"></a>4.1.2 用户管理</h3><h4 id="getent-passwd（查看所有用户）"><a href="#getent-passwd（查看所有用户）" class="headerlink" title="getent passwd（查看所有用户）"></a>getent passwd（查看所有用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getent passwd<br></code></pre></td></tr></table></figure><h4 id="useradd（创建用户）"><a href="#useradd（创建用户）" class="headerlink" title="useradd（创建用户）"></a>useradd（创建用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd [-g 组名] 用户名<br>-g   # group，指定用户所在组。不写会创建和用户名一模一样的组名，并添加用户到该组中<br></code></pre></td></tr></table></figure><h4 id="userdel（删除用户）"><a href="#userdel（删除用户）" class="headerlink" title="userdel（删除用户）"></a>userdel（删除用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel [-r] 用户名<br>-r   # remove，删除用户的同时，把 /home 目录下该用户的目录也删除<br></code></pre></td></tr></table></figure><h4 id="usermod（修改用户属性）"><a href="#usermod（修改用户属性）" class="headerlink" title="usermod（修改用户属性）"></a>usermod（修改用户属性）</h4><p><code>usermod</code> 源自 <strong>user modify</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -aG 组名 用户名<br>-aG    # append group，追加用户到附加组<br></code></pre></td></tr></table></figure><h4 id="id（查看用户）"><a href="#id（查看用户）" class="headerlink" title="id（查看用户）"></a>id（查看用户）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id [用户名]    # 不指定用户名会查看自身<br></code></pre></td></tr></table></figure><h4 id="passwd（修改用户密码）"><a href="#passwd（修改用户密码）" class="headerlink" title="passwd（修改用户密码）"></a>passwd（修改用户密码）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">passwd</span> 用户名<br></code></pre></td></tr></table></figure><h3 id="4-1-3-切换用户及借调权限"><a href="#4-1-3-切换用户及借调权限" class="headerlink" title="4.1.3 切换用户及借调权限"></a>4.1.3 切换用户及借调权限</h3><h4 id="su（切换用户）"><a href="#su（切换用户）" class="headerlink" title="su（切换用户）"></a>su（切换用户）</h4><p><code>su</code> 源自 <strong>swith user</strong>，用于<strong>切换用户</strong>。</p><ul><li>使用普通用户，切换到其它用户需要输入密码，如切换到 root 用户</li><li>使用 root 用户切换到其它用户，无需密码，可以直接切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su [用户名]      # 省略用户名表示切换到 root<br></code></pre></td></tr></table></figure><blockquote><p>切换用户后，可以通过 <code>exit</code> 命令退回上一个用户，也可以使用快捷键：<code>Ctrl</code> + <code>D</code>。</p></blockquote><h4 id="sudo（借调权限）"><a href="#sudo（借调权限）" class="headerlink" title="sudo（借调权限）"></a>sudo（借调权限）</h4><p><code>sudo</code> 源自 <strong>superuser do</strong>，临时借调权限，为普通的命令授权，<strong>临时以 root 身份执行</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo 要执行的命令<br></code></pre></td></tr></table></figure><blockquote><p>权限记录在 etc 目录下的 sudoers 文件中，root 用户可以通过 visudo 命令修改。如果没有权限, 则会记录该行为到日志。</p></blockquote><h2 id="4-2-查看权限信息"><a href="#4-2-查看权限信息" class="headerlink" title="4.2  查看权限信息"></a>4.2  查看权限信息</h2><p>使用 <code>ll</code> 显示如下信息结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">文件类型和权限 硬链接数 所有者  所属组  文件大小  最后修改时间   文件名/目录名<br>-rw-r--r--       1     user   group   1234    Jul 29 10:00  file.txt<br>drwxr-xr-x       2     user   group   4096    Jul 28 15:32  my_folder<br></code></pre></td></tr></table></figure><ol><li>第 1 个字符：文件类型<ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录，源自 directory</li><li><code>l</code> 软链接，源自 link</li></ul></li><li>第 2-10 个字符：权限（所有者、所属组、其他用户）<ul><li><code>r</code> 读，源自 read</li><li><code>w</code> 写，源自 write</li><li><code>x</code> 执行，源自 execute</li><li><code>-</code> 无</li></ul></li></ol><p><img src="/../../../tool_assets/Pasted%20image%2020250729230728.png"></p><blockquote><p><strong>注意：</strong> 文件&#x2F;目录的所有者和所属组是两个独立的属性，所有者并不是一定要在所属组内。</p></blockquote><h2 id="4-3-修改权限信息"><a href="#4-3-修改权限信息" class="headerlink" title="4.3 修改权限信息"></a>4.3 修改权限信息</h2><h3 id="4-3-1-chmod（修改文件权限）"><a href="#4-3-1-chmod（修改文件权限）" class="headerlink" title="4.3.1 chmod（修改文件权限）"></a>4.3.1 chmod（修改文件权限）</h3><p><code>chmod</code> 源自 <strong>change mode</strong>，用于修改文件或目录的<strong>访问权限</strong>，即读（r）、写（w）、执行（x）权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [-R] [权限设置] 文件/目录<br>-R 递归修改目录及其内容权限<br></code></pre></td></tr></table></figure><ul><li>符号模式（ugo+rwx）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x 1.txt  # 所有者:rwx, 所属组:r-x, 其它用户: --x<br>chmod -x 1.txt    # 所有者, 所属组, 其它权限都去掉 x 权限<br>chmod u+x,g-r,o=rw 1.txt# 所有者 +x 权限, 所属组 -r 权限, 其它权限为: rw-<br></code></pre></td></tr></table></figure><ul><li>数字模式（八进制）</li></ul><table><thead><tr><th align="center">数字</th><th align="center">权限</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">4</td><td align="center"><code>r</code></td><td align="center">读</td></tr><tr><td align="center">2</td><td align="center"><code>w</code></td><td align="center">写</td></tr><tr><td align="center">1</td><td align="center"><code>x</code></td><td align="center">执行</td></tr><tr><td align="center">0</td><td align="center"><code>-</code></td><td align="center">无权限</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">三类用户（所有者 / 组 / 其他用户）分别对应一个数字，组合成三位数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7 = 4 (r) + 2 (w) + 1 (x) = rwx</span><br>chmod 764 file.txt  # 所有者：rwx，组：rw-，其他：r--<br>chmod 777 1.txt# 俗称: 满权限.<br></code></pre></td></tr></table></figure><h3 id="4-3-2-chown（修改文件归属）"><a href="#4-3-2-chown（修改文件归属）" class="headerlink" title="4.3.2 chown（修改文件归属）"></a>4.3.2 chown（修改文件归属）</h3><p><code>chown</code>源自 <strong>change owner</strong>，用于修改文件或目录的<strong>所有者</strong>和<strong>所属用户组</strong>。</p><p>普通用户无法修改所属为其它用户或组，所以此命令只适用于 root 用户执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown [-R] [用户] [:用户组] 文件/目录<br>-R 递归修改目录及其内容所属<br><br>chown zhangsan 1.txt   # 改变文件所有者<br>chown :python  1.txt   # 改变文件所属组<br>chown lisi:dev 1.txt   # 改变所有者和组<br>chown -R wangwu aa     # 改变所有者，包括目录子级<br></code></pre></td></tr></table></figure><h1 id="5-Linux-实用操作"><a href="#5-Linux-实用操作" class="headerlink" title="5 Linux 实用操作"></a>5 Linux 实用操作</h1><h2 id="5-1-常用快捷键"><a href="#5-1-常用快捷键" class="headerlink" title="5.1 常用快捷键"></a>5.1 常用快捷键</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Ctrl + C      # 强制结束（执行）<br>Ctrl + L      # 清屏，等价于 clear<br>Ctrl + D      # 强制登出账号，回到上一个账号，等价于 exit<br><br>Ctrl + A      # 跳转到命令 行首<br>Ctrl + E      # 跳转到命令 行尾<br>Ctrl + ←      # 上一个单词<br>Ctrl + →      # 下一个单词<br><br>history       # 查看历史命令<br>!命令名  # 在历史命令中匹配最近的命令<br>Ctrl + r      # 在历史命令中搜索命令<br></code></pre></td></tr></table></figure><h2 id="5-2-软件安装与服务管理"><a href="#5-2-软件安装与服务管理" class="headerlink" title="5.2 软件安装与服务管理"></a>5.2 软件安装与服务管理</h2><h3 id="5-2-1-yum（软件包管理）"><a href="#5-2-1-yum（软件包管理）" class="headerlink" title="5.2.1 yum（软件包管理）"></a>5.2.1 yum（软件包管理）</h3><p><code>yum</code> 是 Yellowdog Updater, Modified 的缩写，基于 rpm (Red Hat Package Manager) 的高级封装，自动解决依赖 + 仓库管理。类似于 windows 或 mac 的<strong>应用商店</strong>，直接从中查找并安装。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>安装软件</strong></td><td><code>yum install package</code></td><td>安装指定软件包及其依赖</td></tr><tr><td><strong>更新软件</strong></td><td><code>yum update package</code></td><td>更新指定软件包（不指定则更新所有）</td></tr><tr><td><strong>卸载软件</strong></td><td><code>yum remove package</code></td><td>删除软件包（保留配置文件）</td></tr><tr><td><strong>搜索软件</strong></td><td><code>yum search keyword</code></td><td>根据关键词搜索软件包</td></tr><tr><td><strong>列出已安装</strong></td><td><code>yum list installed</code></td><td>显示所有已安装的软件包</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum [-y] [install | update | remove | search] 包名<br>-y     # yes，在安装过程中自动回答 yes<br><br>yum -y install wget   # 通过 yum 安装 wget<br></code></pre></td></tr></table></figure><blockquote><p> Debian&#x2F;Ubuntu 系统中使用 <code>apt</code> 包管理工具，和 <code>yum</code> 格式一样，更改为 <code>apt</code> 即可。</p></blockquote><h3 id="5-2-2-systemctl（服务管理）"><a href="#5-2-2-systemctl（服务管理）" class="headerlink" title="5.2.2 systemctl（服务管理）"></a>5.2.2 systemctl（服务管理）</h3><p><code>systemctl</code> 源自 <strong>system control</strong>，是 Linux 系统中用于<strong>管理 systemd 系统和服务管理器</strong>的核心工具。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>启动服务</strong></td><td><code>systemctl start nginx</code></td><td>启动服务</td></tr><tr><td><strong>停止服务</strong></td><td><code>systemctl stop nginx</code></td><td>停止服务</td></tr><tr><td><strong>重启服务</strong></td><td><code>systemctl restart nginx</code></td><td>重启服务</td></tr><tr><td><strong>查看状态</strong></td><td><code>systemctl status nginx</code></td><td>显示服务运行状态和日志片段</td></tr><tr><td><strong>启用开机自启</strong></td><td><code>systemctl enable nginx</code></td><td>设置服务开机自启动</td></tr><tr><td><strong>禁用开机自启</strong></td><td><code>systemctl disable nginx</code></td><td>取消服务开机自启动</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status | enable | disable] 服务名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用服务</span><br>NetworkManager   # 主网络服务<br>network   # 副网络服务<br>firewalld   # 防火墙<br>sshd   # 远程连接服务<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关掉防火墙并取消开机自启动</span><br>systemctl stop firewalld<br>systemctl disable firewalld<br></code></pre></td></tr></table></figure><h2 id="5-3-网络操作"><a href="#5-3-网络操作" class="headerlink" title="5.3 网络操作"></a>5.3 网络操作</h2><h3 id="5-3-1-诊断工具"><a href="#5-3-1-诊断工具" class="headerlink" title="5.3.1 诊断工具"></a>5.3.1 诊断工具</h3><h4 id="ifconfig（ip配置）"><a href="#ifconfig（ip配置）" class="headerlink" title="ifconfig（ip配置）"></a>ifconfig（ip配置）</h4><p><code>ifconfig</code> 源自 <strong>interface configuration</strong>，用于<strong>查看和配置网络接口</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><h4 id="ping（连通性测试）"><a href="#ping（连通性测试）" class="headerlink" title="ping（连通性测试）"></a>ping（连通性测试）</h4><p><code>ping</code> 源自 <strong>Packet InterNet Groper</strong>，发送 ICMP 请求包，<strong>测试网络是否通畅及延迟</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping [-c Num] 域名 | ip<br>-c Num    # count，发送 N 次请求后停止<br><br>ping -c 3 baidu.com   # 向百度发送 3 次请求测试连通性<br></code></pre></td></tr></table></figure><h4 id="netstat（端口监听）"><a href="#netstat（端口监听）" class="headerlink" title="netstat（端口监听）"></a>netstat（端口监听）</h4><p><code>netstat</code> 源自 <strong>network statistics</strong>，用于<strong>查看网络连接、监听端口、路由信息</strong>。</p><ul><li>IP地址，设备在网络中的唯一标识</li><li>端口号，程序在设备上的唯一标识</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -anp   # 查看本机所有端口号<br>-anp           # 来源: all network port<br><br>netstat -anp | grep 3306    # 使用 grep 过滤查看 3306 端口号占用情况<br></code></pre></td></tr></table></figure><blockquote><p>计算机程序之间的通讯，通过 IP 只能确定计算机，但是无法确定具体的程序。通过端口可以确定计算机上具体的程序，确保程序之间进行沟通。<br>Linux 系统端口号范围: 0 ~ 65535，其中0 ~ 1023已经被用作系统端口或者保留端口了。</p></blockquote><h3 id="5-3-2-数据传输"><a href="#5-3-2-数据传输" class="headerlink" title="5.3.2 数据传输"></a>5.3.2 数据传输</h3><h4 id="wget（下载文件）"><a href="#wget（下载文件）" class="headerlink" title="wget（下载文件）"></a>wget（下载文件）</h4><p><code>wget</code> 源自 <strong>web get</strong>，用于<strong>从网络上下载文件</strong>，支持 HTTP、HTTPS、FTP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget url地址<br><br>wget https://img-home.csdnimg.cn/images/20201124032511.png   # 下载图片<br></code></pre></td></tr></table></figure><h4 id="curl（发送请求）"><a href="#curl（发送请求）" class="headerlink" title="curl（发送请求）"></a>curl（发送请求）</h4><p><code>curl</code> 源自 <strong>client URL</strong>，用于<strong>模拟浏览器发送请求</strong>，常用于测试 API、下载网页内容等，支持多种协议（HTTP、FTP、SFTP、SMTP）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl url地址<br><br>curl https://www.bilibili.com/    # 爬取哔哩哔哩网页代码<br></code></pre></td></tr></table></figure><h4 id="lrzsz（上传和下载）"><a href="#lrzsz（上传和下载）" class="headerlink" title="lrzsz（上传和下载）"></a>lrzsz（上传和下载）</h4><p><code>lrzsz</code> 源自 <strong>Linux Receive ZMODEM Send ZMODEM</strong>，也就是 Linux ZMODEM 收发工具，用于在终端环境中<strong>上传（<code>rz</code>）或下载（<code>sz</code>）文件</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rz           # 弹出文件选择窗口，选择文件后自动上传到当前目录<br>sz 文件名  # 弹出保存对话框，选择保存路径即可<br></code></pre></td></tr></table></figure><p>或者在 FinalShell、Tabby 等工具中直接拖拽即可上传下载。</p><p><img src="/../../../tool_assets/Pasted%20image%2020250730224752.png"></p><h2 id="5-4-进程管理"><a href="#5-4-进程管理" class="headerlink" title="5.4 进程管理"></a>5.4 进程管理</h2><p>程序运行在操作系统中，是被操作系统所管理的。为方便管理运行的程序，每一个程序在运行的时候都会被操作系统注册为系统中的一个<strong>进程</strong>，并会为每一个进程都分配一个独有的 PID。</p><h3 id="5-4-1-ps（查看进程）"><a href="#5-4-1-ps（查看进程）" class="headerlink" title="5.4.1 ps（查看进程）"></a>5.4.1 ps（查看进程）</h3><p><code>ps</code> 源自 <strong>process status</strong>，用于显示当前系统的<strong>进程状态信息</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps [-e -f]<br>-e       # every，列出所有进程<br>-f       # full format，显示完整格式<br><br>ps -ef                # 查看本机运行的所有进程<br>ps -ef | grep mysql  # 查看本机和MySQL相关的进程.<br></code></pre></td></tr></table></figure><h3 id="5-4-2-kill（结束进程）"><a href="#5-4-2-kill（结束进程）" class="headerlink" title="5.4.2 kill（结束进程）"></a>5.4.2 kill（结束进程）</h3><p>向进程发送信号（默认 <code>SIGTERM</code>），用于<strong>终止或控制进程</strong>。</p><table><thead><tr><th>信号编号</th><th>信号名</th><th>作用</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>SIGHUP</code></td><td>重启进程（重新加载配置）</td></tr><tr><td><code>2</code></td><td><code>SIGINT</code></td><td>中断进程（等同 <code>Ctrl+C</code>）</td></tr><tr><td><code>9</code></td><td><code>SIGKILL</code></td><td>强制终止（不可被忽略）</td></tr><tr><td><code>15</code></td><td><code>SIGTERM</code></td><td>优雅终止（默认信号）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill [-编号] PID<br><br>kill -9 进程的 PID# 强制杀死进程，不使用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制。<br></code></pre></td></tr></table></figure><h2 id="5-5-软链接和硬链接"><a href="#5-5-软链接和硬链接" class="headerlink" title="5.5 软链接和硬链接"></a>5.5 软链接和硬链接</h2><p><code>ln</code> 源自 <strong>link</strong>，用于<strong>文件共享</strong>。</p><ul><li>软链接：是一个独立的文件，内容为源文件的路径</li><li>硬链接：是文件系统的目录项，直接指向源文件的 inode</li></ul><table><thead><tr><th><strong>特性</strong></th><th>软链接（Symbolic Link）</th><th>硬链接（Hard Link）</th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>类似 Windows 的快捷方式</td><td>是原始文件的另一个名称（指向相同 inode）</td></tr><tr><td><strong>inode 号</strong></td><td>与源文件不同（新 inode）</td><td>与源文件相同（共享 inode）</td></tr><tr><td><strong>源文件删除</strong></td><td>软链接失效（“断链”）</td><td>硬链接仍有效（数据未删除）</td></tr><tr><td><strong>文件大小</strong></td><td>存储链接路径的字节数（较小）</td><td>不额外占用空间（与源文件共享数据块）</td></tr><tr><td><strong>命令</strong></td><td><code>ln -s 源文件 链接名</code></td><td><code>ln 源文件 链接名</code></td></tr></tbody></table><ul><li>软链接：若源文件被删除，软链接变成“悬空链接”（无法访问）</li><li>硬链接：删除源文件后，硬链接仍能访问数据（直到所有硬链接被删除）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">软链接，类似于 windows 的快捷方式</span><br>ln -s 要链接文件/目录的路径 软链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 ipcfg 配置文件创建软链接 ip</span> <br>ln -s /etc/sysconfig/network-scripts/ifcfg-ens33 ip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">硬链接，原始文件的别名，有点类似 C++ 的引用</span><br>ln 要链接文件的路径 硬链接名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 a.txt 的硬链接 b.txt</span><br>ln a.txt b.txt<br></code></pre></td></tr></table></figure><blockquote><p><strong>inode</strong>（Index Node）是 Linux&#x2F;Unix 文件系统中的一种<strong>元数据结构</strong>，用于存储文件的<strong>核心属性</strong>（如权限、大小、所有者、数据块位置等），但不包含文件名。每个文件或目录都有一个唯一的 inode，通过 inode 号标识。</p></blockquote><h2 id="5-6-压缩与解压缩"><a href="#5-6-压缩与解压缩" class="headerlink" title="5.6 压缩与解压缩"></a>5.6 压缩与解压缩</h2><p>区分压缩协议好坏, 可以参考三个维度: 压缩速度(写)，解压速度(读)，压缩后文件占比。</p><h3 id="5-6-1-tar"><a href="#5-6-1-tar" class="headerlink" title="5.6.1 tar"></a>5.6.1 tar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [-c -x -f -v -z] 目标文件 源文件或目录<br>-c   # create，创建新的归档文件（打包）<br>-x   # extract，解压归档文件<br>-f   # file，指定归档文件名（必须直接跟文件名，如 -f archive.tar）<br>-v   # verbose，显示操作过程的详细信息<br>-z   # gzip，使用 gzip 压缩/解压（生成 .tar.gz 或 .tgz 文件），文件更小<br>-C   # directory，指定解压到的目录（需放在选项最后）<br></code></pre></td></tr></table></figure><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf 压缩包名.tar 要被压缩的文件1 文件2 文件夹        # 打包文件不压缩<br>tar -zcvf 压缩包名.tar.gz 要被压缩的文件1 文件2 文件夹    # 打包并用 gzip 压缩<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不指定 -C 默认解压到当前路径</span><br>tar -xvf 压缩包名.tar [-C 解压路径]      # 解压 tar 压缩包<br>tar -zxvf 压缩包名.tar.gz [-C 解压路径]  # 解压 tar.gz 压缩包<br></code></pre></td></tr></table></figure><h3 id="5-6-2-zip"><a href="#5-6-2-zip" class="headerlink" title="5.6.2 zip"></a>5.6.2 zip</h3><ul><li>压缩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip [-r] 压缩包名.zip 要被压缩的文件1 文件2 文件夹<br>-r    # 被压缩的包含文件夹的时候，需要使用-r选项<br></code></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip 压缩包名.zip [-d 解压路径]<br>-d    # 不指定 -d 默认解压到当前路径<br></code></pre></td></tr></table></figure><h1 id="6-远程连接虚拟机"><a href="#6-远程连接虚拟机" class="headerlink" title="6 远程连接虚拟机"></a>6 远程连接虚拟机</h1><ul><li>vim 编辑 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 文件</li></ul><p><img src="/../../../tool_assets/Pasted%20image%2020250731141856.png"></p><ul><li>修改 VMware 的信息</li></ul><p><img src="/../../../tool_assets/1717040397072.png"></p><ul><li>修改本机 VMNet8 网卡信息</li></ul><p><img src="/../../../tool_assets/1717041247890.png"></p><ul><li>FinalShell 新建连接</li></ul><p><img src="/../../../tool_assets/1717041411950.png"></p><p>另外要确保 <code>services.msc</code> 中 Vmware 的 DHCP 和 NAT 服务在启动状态。</p><p><img src="/../../../tool_assets/Pasted%20image%2020250731142125.png"></p>]]></content>
    
    
    <categories>
      
      <category>研发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Seaborn基本图表</title>
    <link href="/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/"/>
    <url>/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/09_Seaborn%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Seaborn 是对 Matplotlib 进行了更高级的封装，而且也能和 Pandas 无缝整合，可以用更少的代码构建出更好的统计图表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 联网加载官方的小费数据集</span><br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> ssl<br><br>ssl._create_default_https_context = ssl._create_unverified_context<br><br>tips_df = sns.load_dataset(<span class="hljs-string">&#x27;tips&#x27;</span>)<br>tips_df.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 244 entries, 0 to 243Data columns (total 7 columns): #   Column      Non-Null Count  Dtype---  ------      --------------  -----0   total_bill  244 non-null    float64 1   tip         244 non-null    float64 2   sex         244 non-null    category 3   smoker      244 non-null    category 4   day         244 non-null    category 5   time        244 non-null    category 6   size        244 non-null    int64dtypes: category(4), float64(2), int64(1)memory usage: 7.4 KB</code></pre><p>首先设置主题更好看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.set_theme()<br></code></pre></td></tr></table></figure><h1 id="1-直方图"><a href="#1-直方图" class="headerlink" title="1 直方图"></a>1 直方图</h1><p>Seaborn中的方法非常统一，基本上都可以直接给数据集，通过 <code>x</code>&#x2F;<code>y</code>设置坐标轴数据来源，大多数也可以使用 <code>hue</code>参数对某一字段进行分组聚合，通过 <code>palette</code>参数设置颜色搭配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, palette=<span class="hljs-string">&#x27;Dark2&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_6_1.png" alt="png"></p><p>直方图设置 <code>kde=True</code>参数可以得到核密度估计图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.histplot(tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, kde=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Count&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_8_2.png" alt="png"></p><h1 id="2-核密度图"><a href="#2-核密度图" class="headerlink" title="2 核密度图"></a>2 核密度图</h1><p>核密度估计图（KDE，Kernel Density Estimate Plot）是一种用于显示数据分布的统计<br>图表，它通过平滑直方图的方法来估计数据的概率密度函数，使得分布图看起来更加<br>连续和平滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.kdeplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;Density&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_11_1.png" alt="png"></p><h1 id="3-散点图"><a href="#3-散点图" class="headerlink" title="3 散点图"></a>3 散点图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.scatterplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_13_1.png" alt="png"></p><p>通过 <code>regplot()</code>函数绘制散点图，同时会拟合回归曲线，这个函数不支持使用 <code>hue</code>进行分组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.regplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;total_bill&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_15_1.png" alt="png"></p><p>可以通过 <code>lmplot()</code>函数绘制分组回归曲线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.lmplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.FacetGrid at 0x169a85210&gt;</code></pre><p><img src="/../../../../ai_assets/output_17_1.png" alt="png"></p><p>通过 <code>jointplot()</code>函数绘制在每个轴上包含单个变量的散点图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.jointplot(data=tips_df, x=<span class="hljs-string">&#x27;total_bill&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.JointGrid at 0x16b18afe0&gt;</code></pre><p><img src="/../../../../ai_assets/output_19_1.png" alt="png"></p><h1 id="4-箱线图"><a href="#4-箱线图" class="headerlink" title="4 箱线图"></a>4 箱线图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.boxplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;total_bill&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;total_bill&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_21_1.png" alt="png"></p><h1 id="5-小提琴图"><a href="#5-小提琴图" class="headerlink" title="5 小提琴图"></a>5 小提琴图</h1><p>相较于箱线图，小提琴图没有标注异常点而是显示了数据的整个范围，另一方面，小提琴图很好的展示了数据的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_24_1.png" alt="png"></p><p>按性别分组统计使用颜色区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.violinplot(data=tips_df, x=<span class="hljs-string">&#x27;day&#x27;</span>, y=<span class="hljs-string">&#x27;tip&#x27;</span>, hue=<span class="hljs-string">&#x27;sex&#x27;</span>, split=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: xlabel=&#39;day&#39;, ylabel=&#39;tip&#39;&gt;</code></pre><p><img src="/../../../../ai_assets/output_26_1%201.png" alt="png"></p><h1 id="6-成对关系图"><a href="#6-成对关系图" class="headerlink" title="6 成对关系图"></a>6 成对关系图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.pairplot(data=tips_df, hue=<span class="hljs-string">&#x27;sex&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;seaborn.axisgrid.PairGrid at 0x175b91570&gt;</code></pre><p><img src="/../../../../ai_assets/output_28_1.png" alt="png"></p><h1 id="7-自定义颜色"><a href="#7-自定义颜色" class="headerlink" title="7 自定义颜色"></a>7 自定义颜色</h1><p>使用Seaborn自带的调色板设置颜色，上述的绘图函数都可以设置 <code>palette</code>参数进行设置。</p><p><img src="/../../../../ai_assets/output_31_1.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Seaborn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Matplotlib数据可视化</title>
    <link href="/2024/08/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2024/08/20/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/08_Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绘图流程"><a href="#1-绘图流程" class="headerlink" title="1 绘图流程"></a>1 绘图流程</h1><ol><li>创建画布 <code>plt.figure()</code></li><li>绘制图像 <code>plt.plot(x, y)</code>等</li><li>显示图像 <code>plt.show()</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_2_0.png" alt="svg"></p><p>使用以下魔法方法可以在画图的时候生成矢量图，图片更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">%config InlineBackend.figure_format=<span class="hljs-string">&#x27;svg&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="2-常用图形"><a href="#2-常用图形" class="headerlink" title="2 常用图形"></a>2 常用图形</h1><h2 id="2-1-折线图"><a href="#2-1-折线图" class="headerlink" title="2.1 折线图"></a>2.1 折线图</h2><p>绘制连续数据的折线图，适用于显示随时间或序列变化的趋势。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>&#x2F;<code>y</code>：横纵坐标数据</li><li><code>linestyle</code>：线的样式<ul><li><code>&#39;-&#39;</code></li><li><code>&#39;--&#39;</code></li><li><code>&#39;-.&#39;</code></li><li><code>&#39;:&#39;</code></li></ul></li><li><code>marker</code>：标记点的样式<ul><li><code>&#39;o&#39;</code></li><li><code>&#39;s&#39;</code></li><li><code>&#39;^&#39;</code></li></ul></li><li><code>color</code>：线的颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>]<br><br>plt.plot(x, y, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_8_0.png" alt="svg"></p><h2 id="2-2-柱形图"><a href="#2-2-柱形图" class="headerlink" title="2.2 柱形图"></a>2.2 柱形图</h2><p>绘制垂直的柱状图，用于比较不同类别的数量或数值大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.bar(x, height, width=<span class="hljs-number">0.8</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>：柱子横坐标</li><li><code>height</code>：柱子的高度</li><li><code>width</code>：柱子宽度（0~1）</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br>height = [<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>]<br><br>plt.bar(x, height, color=<span class="hljs-string">&#x27;b&#x27;</span>, width=<span class="hljs-number">0.5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_11_0.png" alt="svg"></p><h2 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 条形图</h2><p>绘制横向的柱状图，在类别名称较长时更清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.barh(y, width, color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>y</code>: 柱子的纵坐标</li><li><code>width</code>: 柱子的长度</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">y = [<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>]<br>width = [<span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">50</span>]<br><br>plt.barh(y, width)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_14_0.png" alt="svg"></p><h2 id="2-4-直方图"><a href="#2-4-直方图" class="headerlink" title="2.4 直方图"></a>2.4 直方图</h2><p>用于展示数据的分布情况，将数据分成若干个区间 (bin)，并统计每个区间内的数据数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.hist(data, bins=<span class="hljs-number">10</span>, color=<span class="hljs-string">&#x27;purple&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>data</code>：一维数据集</li><li><code>bins</code>：分组数量</li><li><code>color</code>：柱子颜色</li><li><code>label</code>：图例标签（配合 <code>plt.legend()</code>使用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>data = np.random.randn(<span class="hljs-number">1000</span>)<br><br>plt.hist(data, bins=<span class="hljs-number">20</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_17_0.png" alt="svg"></p><h2 id="2-5-饼图"><a href="#2-5-饼图" class="headerlink" title="2.5 饼图"></a>2.5 饼图</h2><p>用于展示不同类别在总体中所占的比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.pie(sizes, labels=labels, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>, explode=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>sizes</code>：各部分的数值</li><li><code>labels</code>：各部分的名称</li><li><code>autopct</code>：显示百分比的格式字符串</li><li><code>explode</code>：突出显示指定扇形，控制凸起程度</li><li><code>pctdistance</code>：百分比离圆心的距离，单位为半径</li><li><code>labeldistance</code>：标签离圆心的距离，单位为半径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">lan = [<span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C#&#x27;</span>, <span class="hljs-string">&#x27;Others&#x27;</span>]<br>rate = [<span class="hljs-number">8.84</span>, <span class="hljs-number">24.45</span>, <span class="hljs-number">8.35</span>, <span class="hljs-number">1.92</span>, <span class="hljs-number">1.38</span>, <span class="hljs-number">9.29</span>, <span class="hljs-number">6.94</span>, <span class="hljs-number">38.83</span>]<br>ex = [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>plt.pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_20_0.png" alt="svg"></p><h2 id="2-6-散点图"><a href="#2-6-散点图" class="headerlink" title="2.6 散点图"></a>2.6 散点图</h2><p>用于展示两个变量之间的关系，每个数据点在图上表示为一个点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, s=<span class="hljs-number">50</span>, alpha=<span class="hljs-number">0.6</span>, label=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>x</code>&#x2F;<code>y</code>：横纵坐标</li><li><code>color</code>：点的颜色（只能指定一个）</li><li><code>c</code>：可以使用颜色列表</li><li><code>s</code>：点的大小</li><li><code>alpha</code>：点的透明度</li><li><code>label</code>：图例</li><li><code>cmap</code>: 颜色映射，将数值映射到颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">sx = np.random.rand(<span class="hljs-number">100</span>)<br>sy = np.random.rand(<span class="hljs-number">100</span>)<br>colors = np.random.rand(<span class="hljs-number">100</span>)<br>sizes = <span class="hljs-number">100</span> * np.random.rand(<span class="hljs-number">100</span>)<br><br>plt.scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_23_0.png" alt="svg"></p><h2 id="2-7-箱线图"><a href="#2-7-箱线图" class="headerlink" title="2.7 箱线图"></a>2.7 箱线图</h2><p>箱线图又叫箱型图或盒须图，是一种用于展示一组数据分散情况的统计图表。</p><ul><li>箱子中间线：中位数（Median）</li><li>箱子上边界：上四分位（Q3）</li><li>箱子下边界：下四分位（Q1）</li><li>箱子的长度：四分位距离（IQR）</li><li>“最大值”：其实是上须（upper whisker），不被离群值影响的范围，Q3+1.5*IQR</li><li>“最小值”：下须（lower whisker），Q1-1.5*IQR</li><li>离群值：异常值，超出须的点</li></ul><p><img src="/../../../../ai_assets/output_26_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">box_data = &#123;  <br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">82</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">70</span>, <span class="hljs-number">90</span>, <span class="hljs-number">76</span>, <span class="hljs-number">84</span>, <span class="hljs-number">83</span>, <span class="hljs-number">95</span>],  <br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">79</span>, <span class="hljs-number">93</span>, <span class="hljs-number">88</span>, <span class="hljs-number">82</span>, <span class="hljs-number">87</span>, <span class="hljs-number">89</span>, <span class="hljs-number">92</span>],  <br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">72</span>, <span class="hljs-number">68</span>, <span class="hljs-number">65</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>]  <br>&#125;  <br>  <br>plt.boxplot(box_data.values(), tick_labels=box_data.keys())  <br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_27_0.png"></p><h1 id="3-图表元素"><a href="#3-图表元素" class="headerlink" title="3 图表元素"></a>3 图表元素</h1><h2 id="3-1-中文问题"><a href="#3-1-中文问题" class="headerlink" title="3.1 中文问题"></a>3.1 中文问题</h2><p>Matplotlib中文兼容有问题，可以使用SimSun（宋体），SimHei（黑体），Kaiti（楷体）等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># plt.rcParams[&#x27;font.family&#x27;] = [&#x27;Microsoft YaHei&#x27;]  # Windows正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># Mac正常显示中文  </span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 正常显示负号</span><br></code></pre></td></tr></table></figure><h2 id="3-2-图表标题与网格线"><a href="#3-2-图表标题与网格线" class="headerlink" title="3.2 图表标题与网格线"></a>3.2 图表标题与网格线</h2><ul><li><code>plt.title()</code>：设置图表标题<ul><li><code>fontdict</code>：设置字体</li><li><code>loc</code>：设置标题位置</li></ul></li><li><code>plt.grid()</code>：设置网格线<ul><li><code>axis</code>：控制轴向，有 <code>x</code>、<code>y</code>、<code>both</code></li><li><code>linestyle</code>：线的样式，<code>:</code>、<code>--</code>、<code>-.</code>、<code>-</code></li><li><code>linewidth</code>：线的粗细</li><li><code>alpha</code>：透明度</li><li><code>color</code>：颜色</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.title(<span class="hljs-string">&#x27;趋势图&#x27;</span>, loc=<span class="hljs-string">&#x27;left&#x27;</span>)<br>plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_30_0.png" alt="svg"></p><h2 id="3-3-坐标轴相关"><a href="#3-3-坐标轴相关" class="headerlink" title="3.3 坐标轴相关"></a>3.3 坐标轴相关</h2><ul><li><code>plt.xlabel()</code>：设置x轴标题</li><li><code>plt.ylabel()</code>：设置y轴标题</li><li><code>plt.xlim()</code>：设置x轴范围</li><li><code>plt.ylim()</code>：设置y轴范围</li><li><code>plt.xticks(&#39;刻度位置（数值）&#39;, &#39;显示值&#39;)</code>：设置x轴显示的刻度值</li><li><code>plt.yticks(&#39;刻度位置&#39;, &#39;显示值&#39;)</code>：设置y轴显示的刻度值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xlabel(<span class="hljs-string">&#x27;月份&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;销售额&#x27;</span>)<br><br>idx = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br>mon = [<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;月&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)]<br><br>plt.xticks(idx, mon)<br>plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">13</span>)<br>plt.ylim(<span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(10000.0, 100000.0)</code></pre><p><img src="/../../../../ai_assets/output_33_1.png" alt="svg"></p><h2 id="3-4-显示图例"><a href="#3-4-显示图例" class="headerlink" title="3.4 显示图例"></a>3.4 显示图例</h2><p>设置完 <code>label</code>参数之后，使用 <code>plt.legend()</code>才能显示图例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成数据</span><br>x1 = np.arange(-<span class="hljs-number">1</span>*np.pi, np.pi, <span class="hljs-number">0.05</span>)<br>y1 = np.sin(x1)<br>y2 = np.cos(x1)<br><br><span class="hljs-comment"># 设置x轴刻度</span><br>plt.xticks([-<span class="hljs-number">1</span>*np.pi, -<span class="hljs-number">0.5</span>*np.pi, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>*np.pi, np.pi],<br>           [<span class="hljs-string">&#x27;-π&#x27;</span>, <span class="hljs-string">&#x27;-1/2π&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1/2π&#x27;</span>, <span class="hljs-string">&#x27;π&#x27;</span>])<br><br><span class="hljs-comment"># 作图</span><br>plt.plot(x1, y1, label=<span class="hljs-string">&#x27;y1=sin(x)&#x27;</span>)<br>plt.plot(x1, y2, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>,label=<span class="hljs-string">&#x27;y2=cos(x)&#x27;</span>)<br><br>plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x1e60c67bf70&gt;</code></pre><p><img src="/../../../../ai_assets/output_36_1.png" alt="svg"></p><h1 id="4-一图多表"><a href="#4-一图多表" class="headerlink" title="4 一图多表"></a>4 一图多表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, figsize=(width, height))<br></code></pre></td></tr></table></figure><ul><li>nrows：子图的行数</li><li>ncols：子图的列数</li><li>figsize：画布的大小</li><li>fig：返回的画布对象，用于调整整体的属性</li><li>axs：返回的子图数组，用于绘制各个子图，是一个Numpy数组，可以通过 <code>axs[0, 1]</code>访问特定子图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_39_0.png" alt="svg"></p><p>上一章的图形依次放入子图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].barh(y, width)<br>axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].pie(rate, labels=lan, explode=ex, autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>, pctdistance=<span class="hljs-number">0.8</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].hist(data, bins=<span class="hljs-number">20</span>)<br>axs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].scatter(sx, sy, c=colors, s=sizes, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.collections.PathCollection at 0x1e60cec4880&gt;</code></pre><p>为了精确地控制子图，使用对象式写法 <code>axs.set_方法名</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">axs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;语言占比图&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;语言占比图&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig<br></code></pre></td></tr></table></figure><p><img src="/../../../../ai_assets/output_44_0.png" alt="svg"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Pandas数据操作和清洗</title>
    <link href="/2024/08/18/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/"/>
    <url>/2024/08/18/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/07_Pandas%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E6%B8%85%E6%B4%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本数据操作"><a href="#1-基本数据操作" class="headerlink" title="1 基本数据操作"></a>1 基本数据操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df1 = pd.read_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(df1)<br>df2 = pd.DataFrame(data=&#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;钱七&#x27;</span>], <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">66</span>], <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">99</span>], <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">77</span>]&#125;)<br><span class="hljs-built_in">print</span>(df2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60   姓名  语文  数学  英语0  赵六  50  88  201  钱七  66  99  77</code></pre><h2 id="1-1-新增列-行"><a href="#1-1-新增列-行" class="headerlink" title="1.1 新增列&#x2F;行"></a>1.1 新增列&#x2F;行</h2><p>增加列使用 <code>df[&#39;新列名&#39;] = 新列值</code>，会在原数据上直接添加，如果列名已存在则会覆盖原列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;历史&#x27;</span>] = [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>  </tbody></table></div><p>使用 <code>df.loc[&#39;新索引&#39;] = 新行值</code>，会在原数据上直接添加，如果索引已存在则会覆盖原索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[<span class="hljs-number">1001</span>] = [<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">199</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">66</span>]<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><p>使用 <code>assign()</code>方法实现列的新增，返回一个新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(<br>    新列<span class="hljs-number">1</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">111</span>,<span class="hljs-number">1111</span>],<br>    新列<span class="hljs-number">2</span>=[<span class="hljs-number">6</span>, <span class="hljs-number">66</span>, <span class="hljs-number">666</span>, <span class="hljs-number">6666</span>]  <br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>      <th>新列1</th>      <th>新列2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>      <td>1</td>      <td>6</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>      <td>11</td>      <td>66</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>      <td>111</td>      <td>666</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>      <td>1111</td>      <td>6666</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.assign(加权分=<span class="hljs-keyword">lambda</span> x: df1[<span class="hljs-string">&#x27;语文&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;数学&#x27;</span>]*<span class="hljs-number">0.4</span> + df1[<span class="hljs-string">&#x27;英语&#x27;</span>]*<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>      <td>84.0</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>      <td>129.6</td>    </tr>  </tbody></table></div><h2 id="1-2-删除列-行"><a href="#1-2-删除列-行" class="headerlink" title="1.2 删除列&#x2F;行"></a>1.2 删除列&#x2F;行</h2><p>使用 <code>drop</code>函数删除，默认沿着0轴，也就是行进行删除，使用 <code>axis=1</code>表示对列操作，返回新的DataFrame对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-string">&#x27;历史&#x27;</span>, axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop(<span class="hljs-number">1001</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>  </tbody></table></div><h2 id="1-3-修改元素值"><a href="#1-3-修改元素值" class="headerlink" title="1.3 修改元素值"></a>1.3 修改元素值</h2><h3 id="1-3-1-直接修改"><a href="#1-3-1-直接修改" class="headerlink" title="1.3.1 直接修改"></a>1.3.1 直接修改</h3><p>通过索引操作会直接修改原表的值，一般不建议在原表直接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[df1[<span class="hljs-string">&#x27;姓名&#x27;</span>] == <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>] = <span class="hljs-number">666</span><br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><h3 id="1-3-2-replace函数"><a href="#1-3-2-replace函数" class="headerlink" title="1.3.2 replace函数"></a>1.3.2 replace函数</h3><p><code>replace()</code>：替换指定值（任意类型都可以），返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.replace(val, new_val, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.replace(<span class="hljs-number">80</span>, <span class="hljs-number">999</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>999</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>999</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><p>Pandas字符串和Python原生字符串的操作几乎一致，只需要在操作前加上一个 <code>.str</code>即可。</p><p><code>str.replace()</code>：替换指定字符串，只能是字符串，返回新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.<span class="hljs-built_in">str</span>.replace(<span class="hljs-built_in">str</span>, new_str, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;姓名&#x27;</span>].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;朱八八&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0        张三1       朱八八2        王五1001    猪猪侠Name: 姓名, dtype: object</code></pre><blockquote><p><code>str</code>中只包含文本对象，而 <code>object</code>中什么类型（数字、文本、布尔）都能往里装，实际应用中当做字符串处理即可</p></blockquote><h2 id="1-4-选取数据"><a href="#1-4-选取数据" class="headerlink" title="1.4 选取数据"></a>1.4 选取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66</td>    </tr>  </tbody></table></div><h3 id="1-4-1-使用索引"><a href="#1-4-1-使用索引" class="headerlink" title="1.4.1 使用索引"></a>1.4.1 使用索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>88</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>82</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>80</td>      <td>60</td>    </tr>    <tr>      <th>1001</th>      <td>199</td>      <td>50</td>    </tr>  </tbody></table></div><h3 id="1-4-2-有条件筛选"><a href="#1-4-2-有条件筛选" class="headerlink" title="1.4.2 有条件筛选"></a>1.4.2 有条件筛选</h3><p>使用 <code>loc</code>筛选出语文大于80并且数学比最低分高的人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.loc[(df1[<span class="hljs-string">&#x27;语文&#x27;</span>] &gt; <span class="hljs-number">80</span>) &amp; (df1[<span class="hljs-string">&#x27;数学&#x27;</span>] &gt; df1[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50</td>    </tr>  </tbody></table></div><h1 id="2-合并与连接"><a href="#2-合并与连接" class="headerlink" title="2 合并与连接"></a>2 合并与连接</h1><h2 id="2-1-纵向连接"><a href="#2-1-纵向连接" class="headerlink" title="2.1 纵向连接"></a>2.1 纵向连接</h2><p><code>concat()</code>：多表连接，默认按照列字段连接，类似SQL中的UNION。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span>, 表<span class="hljs-number">3</span>], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&#x27;outer&#x27;</span>, ignore_index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认纵向连接</li><li>join：对不齐的标签如何处理<ul><li><code>&#39;outer&#39;</code>：默认值，取并集</li><li><code>&#39;inner&#39;</code>：取交集</li></ul></li><li>ignore_index：是否重建索引，默认False，不重建可能有重复索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([df1, df2])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>历史</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>80.0</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>666</td>      <td>52</td>      <td>50.0</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>70.0</td>    </tr>    <tr>      <th>1001</th>      <td>猪猪侠</td>      <td>199</td>      <td>100</td>      <td>50</td>      <td>66.0</td>    </tr>    <tr>      <th>0</th>      <td>赵六</td>      <td>50</td>      <td>88</td>      <td>20</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>钱七</td>      <td>66</td>      <td>99</td>      <td>77</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="2-2-横向连接"><a href="#2-2-横向连接" class="headerlink" title="2.2 横向连接"></a>2.2 横向连接</h2><p><code>merge()</code>：类似SQL的JOIN，需要指定连接依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">merge(left, right, how=<span class="hljs-string">&#x27;inner&#x27;</span>, on=<span class="hljs-literal">None</span>, left_on=<span class="hljs-literal">None</span>, right_on=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>left&#x2F;right：要连接的左表和右表</li><li>how：连接方式<ul><li><code>&#39;inner&#39;</code>：内连接（默认）</li><li><code>&#39;left&#39;</code>：左连接</li><li><code>&#39;right&#39;</code>：右连接</li><li><code>&#39;outer&#39;</code>：外连接</li></ul></li><li>on：两边都有的列名，作为连接键</li><li>left_on&#x2F;right_on：两表列名不一样时使用</li><li>left_index&#x2F;right_index：都设置为True，使用索引作为连接键</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>,<span class="hljs-number">58</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>,<span class="hljs-number">70</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>,<span class="hljs-number">88</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>,<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>])<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">76</span>],<span class="hljs-string">&#x27;舞蹈&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;李华&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-string">&#x27;铁蛋&#x27;</span>,<span class="hljs-string">&#x27;刘强&#x27;</span>])<br>display(df1)<br>display(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>  </tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>93</td>      <td>87</td>    </tr>    <tr>      <th>王明</th>      <td>80</td>      <td>99</td>    </tr>    <tr>      <th>铁蛋</th>      <td>85</td>      <td>95</td>    </tr>    <tr>      <th>刘强</th>      <td>76</td>      <td>85</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 内连接</span><br>pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;inner&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93</td>      <td>87</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80</td>      <td>99</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85</td>      <td>95</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 左连接</span><br>df3 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 全连接</span><br>df4 = pd.merge(df1, df2, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>, how=<span class="hljs-string">&#x27;outer&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h1 id="3-排序与TOP-N"><a href="#3-排序与TOP-N" class="headerlink" title="3 排序与TOP-N"></a>3 排序与TOP-N</h1><h2 id="3-1-索引排序与值排序"><a href="#3-1-索引排序与值排序" class="headerlink" title="3.1 索引排序与值排序"></a>3.1 索引排序与值排序</h2><p><code>sort_index()</code>：按照索引排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp_df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>, <span class="hljs-number">85</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">97</span>,<span class="hljs-number">65</span>]&#125;,<br>                        index = [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Cathy&#x27;</span>, <span class="hljs-string">&#x27;David&#x27;</span>])<br>display(tmp_df)<br>display(tmp_df.sort_index())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>Bob</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>Alice</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>Cathy</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>David</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>  </tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>Alice</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>Bob</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>Cathy</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>David</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>  </tbody></table></div><p><code>sort_values()</code>：按每一列或多列的值进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.sort_values(by, ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>by：列名或列名列表</li><li>ascending：排序规则<ul><li><code>True</code>：升序排序（默认）</li><li><code>False</code>：降序排序</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文升序排序，语文相同按照数学降序排序</span><br>sort_df3 = df3.sort_values([<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>], ascending=[<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])<br>sort_df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="3-2-TOP-N问题"><a href="#3-2-TOP-N问题" class="headerlink" title="3.2 TOP-N问题"></a>3.2 TOP-N问题</h2><p>排序之后使用 <code>head(n)</code>可以完成TOP-N问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sort_df3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>  </tbody></table></div><p>解决TOP-N问题时，并不需要对所有数据进行排序，使用 <code>nlargest()</code>和 <code>nsmallest()</code>更加高效：</p><ul><li><code>nlargest(n, 列)</code>：返回指定列最大的前n项</li><li><code>nsmallest(n, 列)</code>：返回指定列最小的前n项</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nlargest(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;数学&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.nsmallest(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;语文&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>  </tbody></table></div><h2 id="3-3-rank函数"><a href="#3-3-rank函数" class="headerlink" title="3.3 rank函数"></a>3.3 rank函数</h2><p>类似MySQL的开窗函数，用于新增一列排名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank = pd.concat([df1, df1])<br>df_rank<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_rank[<span class="hljs-string">&#x27;排名&#x27;</span>] = df_rank.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).rank(method=<span class="hljs-string">&#x27;min&#x27;</span>)<br>df_rank.sort_values(<span class="hljs-string">&#x27;排名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>排名</th>    </tr>  </thead>  <tbody>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>1.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>1.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>3.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>3.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>5.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>5.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>7.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>7.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>9.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>9.0</td>    </tr>  </tbody></table></div><h1 id="4-特殊值处理"><a href="#4-特殊值处理" class="headerlink" title="4 特殊值处理"></a>4 特殊值处理</h1><h2 id="4-1-缺失值处理"><a href="#4-1-缺失值处理" class="headerlink" title="4.1 缺失值处理"></a>4.1 缺失值处理</h2><h3 id="4-1-1-识别缺失值"><a href="#4-1-1-识别缺失值" class="headerlink" title="4.1.1 识别缺失值"></a>4.1.1 识别缺失值</h3><p><code>isna()</code>：返回布尔值，标记缺失值位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.isna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>True</td>      <td>True</td>      <td>True</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>李华</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>李雷</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>True</td>      <td>True</td>    </tr>    <tr>      <th>王明</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>铁蛋</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>      <td>False</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>False</td>      <td>False</td>      <td>False</td>      <td>True</td>      <td>True</td>    </tr>  </tbody></table></div><h3 id="4-1-2-删除缺失值"><a href="#4-1-2-删除缺失值" class="headerlink" title="4.1.2 删除缺失值"></a>4.1.2 删除缺失值</h3><p><code>dropna()</code>：删除缺失值所在行或列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.dropna(axis=<span class="hljs-number">0</span>, how=<span class="hljs-string">&#x27;any&#x27;</span>, subset=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>axis：默认为0删除行，1表示删除列</li><li>how：<ul><li><code>&#39;any&#39;</code>：只要有一个NaN就删除（默认）</li><li><code>&#39;all&#39;</code>：全部为NaN才删除</li></ul></li><li>subset：指定在哪些列上检查是否为NaN，多列需要使用 <code>[]</code></li><li>inplace：是否在原表修改，默认为False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p>返回新对象，如需修改原数据需设置 <code>inplace</code>参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除所有出现空值的行</span><br>df4.dropna()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>通过设置 <code>subset</code>参数删除指定列出现空值的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只删除语文和数学列出现空值的行</span><br>df4.dropna(subset=[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h3 id="4-1-3-填充空缺值"><a href="#4-1-3-填充空缺值" class="headerlink" title="4.1.3 填充空缺值"></a>4.1.3 填充空缺值</h3><p><code>fillna()</code>将空缺值填充为指定值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.fillna(value=<span class="hljs-literal">None</span>, method=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>value：数值或字典</li><li>method：基于近邻值填充<ul><li><code>&#39;ffill&#39;</code>：用前一个值填充</li><li><code>&#39;bfill&#39;</code>：用后一个值填充</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>全部填充为指定值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.fillna(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>0.0</td>      <td>0.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>0.0</td>      <td>0.0</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p><code>fillna(&#123;&#39;列名1&#39;: 值1, &#39;列名2&#39;, 值2...&#125;)</code>可以设定每个列的空值如何填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 篮球填充为50，舞蹈填充为平均值</span><br>df3.fillna(&#123;<span class="hljs-string">&#x27;篮球&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;舞蹈&#x27;</span>: df3[<span class="hljs-string">&#x27;舞蹈&#x27;</span>].mean()&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>韩梅梅</th>      <td>93</td>      <td>87</td>      <td>80</td>      <td>50.0</td>      <td>93.666667</td>    </tr>    <tr>      <th>李雷</th>      <td>80</td>      <td>99</td>      <td>85</td>      <td>50.0</td>      <td>93.666667</td>    </tr>    <tr>      <th>李华</th>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.000000</td>    </tr>    <tr>      <th>王明</th>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.000000</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.000000</td>    </tr>  </tbody></table></div><h2 id="4-2-去除重复项"><a href="#4-2-去除重复项" class="headerlink" title="4.2 去除重复项"></a>4.2 去除重复项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = pd.DataFrame(&#123;<span class="hljs-string">&#x27;语文&#x27;</span>:[<span class="hljs-number">93</span>,<span class="hljs-number">80</span>],<span class="hljs-string">&#x27;数学&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">99</span>],<span class="hljs-string">&#x27;英语&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">85</span>]&#125;,<br>                    index = [<span class="hljs-string">&#x27;韩梅梅&#x27;</span>,<span class="hljs-string">&#x27;李雷&#x27;</span>])<br>df5 = pd.concat([df3, tmp])<br>df5.reset_index(names=<span class="hljs-string">&#x27;姓名&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>6</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p><code>drop_duplicates()</code>：删除重复行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.drop_duplicates(subset=<span class="hljs-literal">None</span>, keep=<span class="hljs-string">&#x27;first&#x27;</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>subset：指定在哪些列上检查是否重复，多列需要使用 <code>[]</code>，默认为所有列</li><li>keep：保留哪个重复项<ul><li><code>&#39;first&#39;</code>：保留第一次出现的（默认）</li><li><code>&#39;last&#39;</code>：保留最后一次出现的</li><li><code>False</code>：重复项全部删除</li></ul></li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除完全重复的行</span><br>df5.drop_duplicates()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><p>按照姓名的重复值进行删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>韩梅梅</td>      <td>93</td>      <td>87</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><p>保留最后一个出现的重复值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.drop_duplicates(subset=<span class="hljs-string">&#x27;姓名&#x27;</span>, keep=<span class="hljs-string">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>李华</td>      <td>85</td>      <td>95</td>      <td>97</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>3</th>      <td>王明</td>      <td>85</td>      <td>85</td>      <td>65</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>4</th>      <td>铁蛋</td>      <td>58</td>      <td>70</td>      <td>88</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>5</th>      <td>韩梅梅</td>      <td>93</td>      <td>100</td>      <td>80</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>6</th>      <td>李雷</td>      <td>80</td>      <td>99</td>      <td>85</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h1 id="5-类型转换与数据变形"><a href="#5-类型转换与数据变形" class="headerlink" title="5 类型转换与数据变形"></a>5 类型转换与数据变形</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>篮球</th>      <th>舞蹈</th>    </tr>  </thead>  <tbody>    <tr>      <th>刘强</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>      <td>76.0</td>      <td>85.0</td>    </tr>    <tr>      <th>李华</th>      <td>85.0</td>      <td>95.0</td>      <td>97.0</td>      <td>93.0</td>      <td>87.0</td>    </tr>    <tr>      <th>李雷</th>      <td>80.0</td>      <td>99.0</td>      <td>85.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>王明</th>      <td>85.0</td>      <td>85.0</td>      <td>65.0</td>      <td>80.0</td>      <td>99.0</td>    </tr>    <tr>      <th>铁蛋</th>      <td>58.0</td>      <td>70.0</td>      <td>88.0</td>      <td>85.0</td>      <td>95.0</td>    </tr>    <tr>      <th>韩梅梅</th>      <td>93.0</td>      <td>87.0</td>      <td>80.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="5-1-数据类型转换"><a href="#5-1-数据类型转换" class="headerlink" title="5.1 数据类型转换"></a>5.1 数据类型转换</h2><ul><li><code>dtypes</code>：查看每列的数据类型</li><li><code>astype()</code>：转换数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果有空值，转换为int会报错，需要先处理</span><br>display(df4.dtypes)<br>df4[<span class="hljs-string">&#x27;篮球&#x27;</span>] = df4[<span class="hljs-string">&#x27;篮球&#x27;</span>].fillna(<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;i4&#x27;</span>)<br>display(df4.dtypes)<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文    float64数学    float64英语    float64篮球    float64舞蹈    float64dtype: object语文    float64数学    float64英语    float64篮球      int32舞蹈    float64dtype: object</code></pre><ul><li><code>to_datetime()</code>: 将字符串转换为日期时间类型</li><li><code>round(n)</code>：保留n位小数</li><li><code>astype(&#39;category&#39;)</code>：转换为分类数据类型</li></ul><p>有一种特殊的数据类型 <code>category</code> 对应于统计学中的分类变量。这种变量的特点是：</p><ul><li>有限且固定：取值是有限的、通常是固定的一组可能的值</li><li>标签或名称：数据本质上是标签或名称，而不是可以进行数学运算的数值</li></ul><p>常见例子： 性别（男&#x2F;女）、血型（A&#x2F;B&#x2F;O&#x2F;AB）、等级（高&#x2F;中&#x2F;低）、国家名称等。</p><p><code>category</code> 对于每种类别存储一次，然后用较小的整数来表示 Series 中的每个值，并映射回实际的类别名称，可以大大节省内存并且提高性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;列&#x27;</span>].astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-2-行列转置"><a href="#5-2-行列转置" class="headerlink" title="5.2 行列转置"></a>5.2 行列转置</h2><p>行变列，列变行，使用 <code>df.T</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.T<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>韩梅梅</th>      <th>李雷</th>      <th>李华</th>      <th>王明</th>      <th>铁蛋</th>    </tr>  </thead>  <tbody>    <tr>      <th>语文</th>      <td>93.0</td>      <td>80.0</td>      <td>85.0</td>      <td>85.0</td>      <td>58.0</td>    </tr>    <tr>      <th>数学</th>      <td>87.0</td>      <td>99.0</td>      <td>95.0</td>      <td>85.0</td>      <td>70.0</td>    </tr>    <tr>      <th>英语</th>      <td>80.0</td>      <td>85.0</td>      <td>97.0</td>      <td>65.0</td>      <td>88.0</td>    </tr>    <tr>      <th>篮球</th>      <td>NaN</td>      <td>NaN</td>      <td>93.0</td>      <td>80.0</td>      <td>85.0</td>    </tr>    <tr>      <th>舞蹈</th>      <td>NaN</td>      <td>NaN</td>      <td>87.0</td>      <td>99.0</td>      <td>95.0</td>    </tr>  </tbody></table></div><h2 id="5-3-分列操作"><a href="#5-3-分列操作" class="headerlink" title="5.3 分列操作"></a>5.3 分列操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Full_Name&#x27;</span>: [<span class="hljs-string">&#x27;Alice Smith&#x27;</span>, <span class="hljs-string">&#x27;Bob Johnson&#x27;</span>, <span class="hljs-string">&#x27;Charlie Brown&#x27;</span>]&#125;)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie Brown</td>    </tr>  </tbody></table></div><p>利用字符串方法按分隔符拆分字符串列，生成多列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分割，返回列表</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      [Alice, Smith]1      [Bob, Johnson]2    [Charlie, Brown]Name: Full_Name, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用expand参数变成多列</span><br>df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[[<span class="hljs-string">&#x27;First_Name&#x27;</span>, <span class="hljs-string">&#x27;Last_Name&#x27;</span>]] =  df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27; &#x27;</span>, expand=<span class="hljs-literal">True</span>)<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>      <th>First_Name</th>      <th>Last_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice Smith</td>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>Bob Johnson</td>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>Charlie Brown</td>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><h1 id="6-文本与分箱处理"><a href="#6-文本与分箱处理" class="headerlink" title="6 文本与分箱处理"></a>6 文本与分箱处理</h1><h2 id="6-1-文本数据处理"><a href="#6-1-文本数据处理" class="headerlink" title="6.1 文本数据处理"></a>6.1 文本数据处理</h2><p>Pandas中文本数据使用 <code>object</code>类型存储，先使用一个 <code>.str</code>把其当做 <code>str</code>进行处理，然后就和Python原生的字符串处理方式一致了，字符串处理函数会对<strong>每个元素单独进行处理</strong>。常用字符串处理函数：</p><ul><li><code>lower()</code>：转换为小写</li><li><code>upper()</code>：转换为大写</li><li><code>replace(old, new)</code>：替换指定字符串</li><li><code>split(sep)</code>：按指定分隔符拆分字符串，返回一个列表</li><li><code>strip()</code>：去除字符串两端的空白字符</li><li><code>contains(sub)</code>：判断是否包含指定子字符串，返回布尔值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;First_Name&#x27;</span>].<span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.strings.accessor.StringMethods at 0x2be226bf700&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>] = df6[<span class="hljs-string">&#x27;Full_Name&#x27;</span>].<span class="hljs-built_in">str</span>.upper()<br>df6<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Full_Name</th>      <th>First_Name</th>      <th>Last_Name</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>ALICE SMITH</td>      <td>Alice</td>      <td>Smith</td>    </tr>    <tr>      <th>1</th>      <td>BOB JOHNSON</td>      <td>Bob</td>      <td>Johnson</td>    </tr>    <tr>      <th>2</th>      <td>CHARLIE BROWN</td>      <td>Charlie</td>      <td>Brown</td>    </tr>  </tbody></table></div><h2 id="6-2-数据分箱"><a href="#6-2-数据分箱" class="headerlink" title="6.2 数据分箱"></a>6.2 数据分箱</h2><p><code>cut</code>：把数据离散化，用于一维数组的分类和打标，返回一个Series区间对象，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.cut(x, bins, right=<span class="hljs-literal">True</span>, labels=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>x：要分箱的序列</li><li>bins：分箱方式<ul><li>整数：等宽分为几段</li><li>列表：自定义分箱边界</li></ul></li><li>right：是否包含右边界，默认包含</li><li>labels：给分箱结果贴标签</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df7 = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;班级&#x27;</span>: [<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;一班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>,<span class="hljs-string">&#x27;二班&#x27;</span>],<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;小刚&#x27;</span>,<span class="hljs-string">&#x27;小李&#x27;</span>,<span class="hljs-string">&#x27;小张&#x27;</span>,<span class="hljs-string">&#x27;小赵&#x27;</span>],<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: [<span class="hljs-number">70</span>, <span class="hljs-number">35</span>, <span class="hljs-number">83</span>, <span class="hljs-number">45</span>, <span class="hljs-number">95</span>, <span class="hljs-number">72</span>],<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">92</span>],<br>    <span class="hljs-string">&#x27;英语&#x27;</span>: [<span class="hljs-number">95</span>, <span class="hljs-number">80</span>, <span class="hljs-number">78</span>, <span class="hljs-number">85</span>, <span class="hljs-number">88</span>, <span class="hljs-number">90</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">level = pd.cut(df7[<span class="hljs-string">&#x27;语文&#x27;</span>], bins=[<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>], labels=[<span class="hljs-string">&#x27;不及格&#x27;</span>, <span class="hljs-string">&#x27;及格&#x27;</span>, <span class="hljs-string">&#x27;中等&#x27;</span>, <span class="hljs-string">&#x27;良好&#x27;</span>, <span class="hljs-string">&#x27;优秀&#x27;</span>])<br>level<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     及格1    不及格2     良好3    不及格4     优秀5     中等Name: 语文, dtype: categoryCategories (5, object): [&#39;不及格&#39; &lt; &#39;及格&#39; &lt; &#39;中等&#39; &lt; &#39;良好&#39; &lt; &#39;优秀&#39;]</code></pre><p>给原数组加上一列分箱区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>] = level<br>df7<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>语文水平</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>一班</td>      <td>小明</td>      <td>70</td>      <td>90</td>      <td>95</td>      <td>及格</td>    </tr>    <tr>      <th>1</th>      <td>一班</td>      <td>小红</td>      <td>35</td>      <td>85</td>      <td>80</td>      <td>不及格</td>    </tr>    <tr>      <th>2</th>      <td>一班</td>      <td>小刚</td>      <td>83</td>      <td>88</td>      <td>78</td>      <td>良好</td>    </tr>    <tr>      <th>3</th>      <td>二班</td>      <td>小李</td>      <td>45</td>      <td>75</td>      <td>85</td>      <td>不及格</td>    </tr>    <tr>      <th>4</th>      <td>二班</td>      <td>小张</td>      <td>95</td>      <td>80</td>      <td>88</td>      <td>优秀</td>    </tr>    <tr>      <th>5</th>      <td>二班</td>      <td>小赵</td>      <td>72</td>      <td>92</td>      <td>90</td>      <td>中等</td>    </tr>  </tbody></table></div><h1 id="7-数据透视"><a href="#7-数据透视" class="headerlink" title="7 数据透视"></a>7 数据透视</h1><h2 id="7-1-分组"><a href="#7-1-分组" class="headerlink" title="7.1 分组"></a>7.1 分组</h2><p><code>groupby()</code>：按照列进行分组，对每组应用聚合函数，多列参数需要使用 <code>[]</code>括住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002BE22601180&gt;</code></pre><p>分组得到的是一个分组对象，分组对象本身不返回结果，分组对象有以下属性和方法可以使用：</p><ul><li><code>groups</code>：查看分组数据</li><li><code>get_group(name)</code>：获取某个组的数据</li><li><code>size()</code>：返回各组的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各组数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).groups)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一班数据：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).get_group(<span class="hljs-string">&#x27;一班&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各班人数：\n&#x27;</span>, df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).size())<br></code></pre></td></tr></table></figure><pre><code class="hljs">各组数据： &#123;&#39;一班&#39;: [0, 1, 2], &#39;二班&#39;: [3, 4, 5]&#125;一班数据：    班级  姓名  语文  数学  英语 语文水平0  一班  小明  70  90  95   及格1  一班  小红  35  85  80  不及格2  一班  小刚  83  88  78   良好各班人数： 班级一班    3二班    3dtype: int64</code></pre><p>进一步可以使用聚合函数，类似SQL的聚合函数，常用：</p><ul><li><code>sum()</code>：求和</li><li><code>mean()</code>：平均值</li><li><code>max()</code>：最大值</li><li><code>min()</code>：最小值</li><li><code>median()</code>：中位数</li><li><code>var()</code>：方差</li><li><code>std()</code>：标准差</li><li><code>size()</code>：所有元素个数</li><li><code>count()</code>：非空元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby(分组字段)[聚合字段].聚合函数()<br></code></pre></td></tr></table></figure><p>聚合函数指定 <code>numeric_only=True</code>参数，可以只对数值型数据进行聚合计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">sum</span>(numeric_only=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>188</td>      <td>263</td>      <td>253</td>    </tr>    <tr>      <th>二班</th>      <td>212</td>      <td>247</td>      <td>263</td>    </tr>  </tbody></table></div><p>还可以对指定列进行分组聚合，通过列表传入，聚合的依据列默认会变为索引，可以使用 <code>as_index=False</code>使其不变成索引，保留为普通列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>, as_index=<span class="hljs-literal">False</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].mean()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>语文</th>      <th>数学</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>一班</td>      <td>62.666667</td>      <td>87.666667</td>    </tr>    <tr>      <th>1</th>      <td>二班</td>      <td>70.666667</td>      <td>82.333333</td>    </tr>  </tbody></table></div><h2 id="7-2-聚合"><a href="#7-2-聚合" class="headerlink" title="7.2 聚合"></a>7.2 聚合</h2><p><code>agg()</code>：对分组后的数据应用多个聚合函数，使分组聚合更加灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([<span class="hljs-string">&#x27;列名1&#x27;</span>, <span class="hljs-string">&#x27;列名2&#x27;</span>]).agg(&#123;<br>    <span class="hljs-string">&#x27;指定列1&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列2&#x27;</span>: <span class="hljs-string">&#x27;聚合函数&#x27;</span>, <br>    <span class="hljs-string">&#x27;指定列3&#x27;</span>: [<span class="hljs-string">&#x27;聚合函数1&#x27;</span>, <span class="hljs-string">&#x27;聚合函数2&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对语文数学同时计算最小值和最大值</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]].agg(&#123;<span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead tr th &#123;    text-align: left;&#125;.dataframe thead tr:last-of-type th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr>      <th></th>      <th colspan="2" halign="left">语文</th>      <th colspan="2" halign="left">数学</th>    </tr>    <tr>      <th></th>      <th>min</th>      <th>max</th>      <th>min</th>      <th>max</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>35</td>      <td>83</td>      <td>85</td>      <td>90</td>    </tr>    <tr>      <th>二班</th>      <td>45</td>      <td>95</td>      <td>75</td>      <td>92</td>    </tr>  </tbody></table></div><p>不同列使用不同聚合函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 语文计算平均分，数学计算最高分和最低分</span><br>df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;mean&#x27;</span>,<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: [<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead tr th &#123;    text-align: left;&#125;.dataframe thead tr:last-of-type th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr>      <th></th>      <th>语文</th>      <th colspan="2" halign="left">数学</th>    </tr>    <tr>      <th></th>      <th>mean</th>      <th>max</th>      <th>min</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>62.666667</td>      <td>90</td>      <td>85</td>    </tr>    <tr>      <th>二班</th>      <td>70.666667</td>      <td>92</td>      <td>75</td>    </tr>  </tbody></table></div><p>另外 <code>agg()</code>当中也可以使用自定义函数，或者直接使用lambda函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>)[<span class="hljs-string">&#x27;数学&#x27;</span>].agg(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">班级一班     5二班    17Name: 数学, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).agg(&#123;<br>    <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>()<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>数学</th>    </tr>    <tr>      <th>班级</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>5</td>    </tr>    <tr>      <th>二班</th>      <td>17</td>    </tr>  </tbody></table></div><h2 id="7-3-过滤"><a href="#7-3-过滤" class="headerlink" title="7.3 过滤"></a>7.3 过滤</h2><p>根据分组后的统计信息对组进行筛选，<code>filter()</code>接收一个函数作为参数，该函数接收每个组，返回 <code>True</code>或 <code>False</code>决定是否保留该组，结果返回的是符合过滤条件的组内所有成员，而不是仅返回符合条件的组的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df7.groupby(<span class="hljs-string">&#x27;班级&#x27;</span>).<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>].mean() &gt; <span class="hljs-number">65</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>班级</th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>语文水平</th>    </tr>  </thead>  <tbody>    <tr>      <th>3</th>      <td>二班</td>      <td>小李</td>      <td>45</td>      <td>75</td>      <td>85</td>      <td>不及格</td>    </tr>    <tr>      <th>4</th>      <td>二班</td>      <td>小张</td>      <td>95</td>      <td>80</td>      <td>88</td>      <td>优秀</td>    </tr>    <tr>      <th>5</th>      <td>二班</td>      <td>小赵</td>      <td>72</td>      <td>92</td>      <td>90</td>      <td>中等</td>    </tr>  </tbody></table></div><h2 id="7-4-交叉表"><a href="#7-4-交叉表" class="headerlink" title="7.4 交叉表"></a>7.4 交叉表</h2><p>交叉表是一种特殊的透视表，主要用于计算两个或多个分类变量的频率分布（计数），统计行中每一个唯一值对应的列每一个唯一值分组个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(index, columns, margins=<span class="hljs-literal">False</span>, normalize=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>margins：是否添加行和列的总计</li><li>normalize：是否将频率转化为百分比</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>语文水平</th>      <th>不及格</th>      <th>及格</th>      <th>中等</th>      <th>良好</th>      <th>优秀</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>1</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>二班</th>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(df7[<span class="hljs-string">&#x27;班级&#x27;</span>], df7[<span class="hljs-string">&#x27;语文水平&#x27;</span>], margins=<span class="hljs-literal">True</span>, normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>语文水平</th>      <th>不及格</th>      <th>及格</th>      <th>中等</th>      <th>良好</th>      <th>优秀</th>      <th>All</th>    </tr>    <tr>      <th>班级</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>一班</th>      <td>0.166667</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.5</td>    </tr>    <tr>      <th>二班</th>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.000000</td>      <td>0.166667</td>      <td>0.5</td>    </tr>    <tr>      <th>All</th>      <td>0.333333</td>      <td>0.166667</td>      <td>0.166667</td>      <td>0.166667</td>      <td>0.166667</td>      <td>1.0</td>    </tr>  </tbody></table></div><h2 id="7-5-透视表"><a href="#7-5-透视表" class="headerlink" title="7.5 透视表"></a>7.5 透视表</h2><p>透视表更加灵活，不只是计数，可以使用各种聚合函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.pivot_table(values, index, columns, aggfunc=<span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>values：要聚合计算的数值列</li><li>index：要作为行的分类变量</li><li>columns：要作为列的分类变量</li><li>aggfunc：聚合函数，默认为 <code>mean</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>df = pd.DataFrame(data = &#123;<br>    <span class="hljs-string">&#x27;销售人员&#x27;</span>: [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>],<br>    <span class="hljs-string">&#x27;地区&#x27;</span>: [<span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;北区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>, <span class="hljs-string">&#x27;南区&#x27;</span>],<br>    <span class="hljs-string">&#x27;销售额&#x27;</span>: [<span class="hljs-number">150</span>, <span class="hljs-number">200</span>, <span class="hljs-number">250</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>]<br>    &#125;<br>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>销售人员</th>      <th>地区</th>      <th>销售额</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Alice</td>      <td>北区</td>      <td>150</td>    </tr>    <tr>      <th>1</th>      <td>Bob</td>      <td>南区</td>      <td>200</td>    </tr>    <tr>      <th>2</th>      <td>Alice</td>      <td>南区</td>      <td>250</td>    </tr>    <tr>      <th>3</th>      <td>Bob</td>      <td>北区</td>      <td>300</td>    </tr>    <tr>      <th>4</th>      <td>Alice</td>      <td>南区</td>      <td>100</td>    </tr>    <tr>      <th>5</th>      <td>Bob</td>      <td>南区</td>      <td>400</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(values=<span class="hljs-string">&#x27;销售额&#x27;</span>, index=<span class="hljs-string">&#x27;销售人员&#x27;</span>, columns=<span class="hljs-string">&#x27;地区&#x27;</span>, aggfunc=<span class="hljs-string">&#x27;max&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>地区</th>      <th>北区</th>      <th>南区</th>    </tr>    <tr>      <th>销售人员</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>Alice</th>      <td>150</td>      <td>250</td>    </tr>    <tr>      <th>Bob</th>      <td>300</td>      <td>400</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Pandas索引运算</title>
    <link href="/2024/08/16/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/"/>
    <url>/2024/08/16/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/06_Pandas%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>Pandas索引操作有两种常见类型：</p><ul><li>基于位置的索引（Position-based Indexing）</li><li>基于标签的索引（Label-based Indexing）</li></ul><p>实际操作中，第二种操作更常用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h1 id="1-DataFrame结构"><a href="#1-DataFrame结构" class="headerlink" title="1 DataFrame结构"></a>1 DataFrame结构</h1><h2 id="1-1-column-index-value"><a href="#1-1-column-index-value" class="headerlink" title="1.1 column&#x2F;index&#x2F;value"></a>1.1 column&#x2F;index&#x2F;value</h2><p>DataFrame主要包含以下三个部分：</p><ul><li><code>column</code>：列标签（Index对象）</li><li><code>index</code>：行标签（Index对象）</li><li><code>value</code>：数据域</li></ul><p>基于标签定位就是靠 <code>Index</code>对象，在此之外还有动态映射出来的虚拟列号和行号，可以直接基于数组下标进行定位，也就是基于位置定位。</p><p><img src="/../../../../ai_assets/output_5_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_excel(<span class="hljs-string">&#x27;data/source_data.xlsx&#x27;</span>)<br>df.index = np.arange(<span class="hljs-number">1001</span>, <span class="hljs-number">1008</span>)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="1-2-单独取列-行"><a href="#1-2-单独取列-行" class="headerlink" title="1.2 单独取列&#x2F;行"></a>1.2 单独取列&#x2F;行</h2><p><code>DataFrame</code>的行和列单独取出来都是一个 <code>Series</code>对象，事实上，<code>DataFrame</code>对象就是将多个 <code>Series</code>对象组合到一起的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一列，两种方式</span><br><span class="hljs-built_in">print</span>(df[<span class="hljs-string">&#x27;客单价&#x27;</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.客单价)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float641001    58.791002    86.641003     0.281004    64.121005    92.911006    89.331007    56.04Name: 客单价, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单独取一行，两种方式</span><br><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-number">1005</span>], end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object流量级别          一级投放地区          C区访客数         3769支付转化率      5.73%客单价        92.91支付金额     20068.2Name: 1005, dtype: object</code></pre><h1 id="2-基于位置定位"><a href="#2-基于位置定位" class="headerlink" title="2 基于位置定位"></a>2 基于位置定位</h1><p>基于位置索引使用 <code>iloc[行号, 列号]</code>进行选取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><p>DataFrame索引方式大体分为下面四种，其中行和列类似Numpy的索引运算，可以使用切片索引、花式索引、布尔索引。</p><ul><li><code>df[列][行]</code>：先选列再选行，链式索引，不推荐</li><li><code>df.loc[行][列]/df.iloc[行][列]</code>：先取行再取列，链式索引可能产生副本，修改不会反映到原对象，不推荐</li><li><code>df.loc[行, 列]</code>：标签方式一次性定位，推荐！</li><li><code>df.iloc[行, 列]</code>：位置方式一次性定位，推荐！</li></ul><h2 id="2-1-行选取"><a href="#2-1-行选取" class="headerlink" title="2.1 行选取"></a>2.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 连续选取，使用切片索引</span><br>df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>  </tbody></table></div><p>花式索引需要构造列表，将列表作为单个参数传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 跨行选取，使用花式索引</span><br>df.iloc[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="2-2-列选取"><a href="#2-2-列选取" class="headerlink" title="2.2 列选取"></a>2.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[:, <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>    </tr>  </tbody></table></div><h2 id="2-3-行列交叉选取"><a href="#2-3-行列交叉选取" class="headerlink" title="2.3 行列交叉选取"></a>2.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>C区</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>20068.20</td>    </tr>  </tbody></table></div><h1 id="3-基于标签定位"><a href="#3-基于标签定位" class="headerlink" title="3 基于标签定位"></a>3 基于标签定位</h1><p>基于标签定位使用 <code>loc[&#39;行标签&#39;, &#39;列标签&#39;]</code>进行选取。</p><p>注意：<code>loc</code>的切片是包含结束值的！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>一级</td>      <td>A区</td>      <td>44300</td>      <td>11.78%</td>      <td>58.79</td>      <td>306887.83</td>    </tr>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.10</td>    </tr>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.60</td>    </tr>    <tr>      <th>1007</th>      <td>一级</td>      <td>C区</td>      <td>2412</td>      <td>8.21%</td>      <td>56.04</td>      <td>11096.42</td>    </tr>  </tbody></table></div><h2 id="3-1-行选取"><a href="#3-1-行选取" class="headerlink" title="3.1 行选取"></a>3.1 行选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[<span class="hljs-number">1003</span>: <span class="hljs-number">1005</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>一级</td>      <td>C区</td>      <td>18389</td>      <td>2.50%</td>      <td>0.28</td>      <td>129.58</td>    </tr>    <tr>      <th>1004</th>      <td>一级</td>      <td>B区</td>      <td>4509</td>      <td>10.73%</td>      <td>64.12</td>      <td>31035.14</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.20</td>    </tr>  </tbody></table></div><p>结合布尔索引将判断结果作为掩码可以进行筛选数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; <span class="hljs-number">80</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.1</td>    </tr>    <tr>      <th>1005</th>      <td>一级</td>      <td>C区</td>      <td>3769</td>      <td>5.73%</td>      <td>92.91</td>      <td>20068.2</td>    </tr>    <tr>      <th>1006</th>      <td>一级</td>      <td>A区</td>      <td>2424</td>      <td>22.07%</td>      <td>89.33</td>      <td>47791.6</td>    </tr>  </tbody></table></div><h2 id="3-2-列选取"><a href="#3-2-列选取" class="headerlink" title="3.2 列选取"></a>3.2 列选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>58.79</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>92.91</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>89.33</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>56.04</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[:, [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>A区</td>      <td>58.79</td>    </tr>    <tr>      <th>1002</th>      <td>B区</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>92.91</td>    </tr>    <tr>      <th>1006</th>      <td>A区</td>      <td>89.33</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>56.04</td>    </tr>  </tbody></table></div><h2 id="3-3-行列交叉选取"><a href="#3-3-行列交叉选取" class="headerlink" title="3.3 行列交叉选取"></a>3.3 行列交叉选取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;B区&#x27;</span>) | (df[<span class="hljs-string">&#x27;投放地区&#x27;</span>] == <span class="hljs-string">&#x27;C区&#x27;</span>), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>56.04</td>    </tr>  </tbody></table></div><h3 id="3-3-1-query函数"><a href="#3-3-1-query函数" class="headerlink" title="3.3.1 query函数"></a>3.3.1 query函数</h3><p><code>query(exp, inplace=False</code>)&#96;：可以使用Python布尔表达式进行选取符合条件的行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&quot;访客数 &gt; 3000 and 访客数 &lt; 20000&quot;</span>)[[<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>  </tbody></table></div><h3 id="3-3-2-isin函数"><a href="#3-3-2-isin函数" class="headerlink" title="3.3.2 isin函数"></a>3.3.2 isin函数</h3><p><code>isin()</code>函数：判断是否等于列表中的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;投放地区&#x27;</span>].isin([<span class="hljs-string">&#x27;B区&#x27;</span>, <span class="hljs-string">&#x27;C区&#x27;</span>]), [<span class="hljs-string">&#x27;投放地区&#x27;</span>, <span class="hljs-string">&#x27;访客数&#x27;</span>, <span class="hljs-string">&#x27;客单价&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>投放地区</th>      <th>访客数</th>      <th>客单价</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>B区</td>      <td>30612</td>      <td>86.64</td>    </tr>    <tr>      <th>1003</th>      <td>C区</td>      <td>18389</td>      <td>0.28</td>    </tr>    <tr>      <th>1004</th>      <td>B区</td>      <td>4509</td>      <td>64.12</td>    </tr>    <tr>      <th>1005</th>      <td>C区</td>      <td>3769</td>      <td>92.91</td>    </tr>    <tr>      <th>1007</th>      <td>C区</td>      <td>2412</td>      <td>56.04</td>    </tr>  </tbody></table></div><h2 id="3-4-多条件索引"><a href="#3-4-多条件索引" class="headerlink" title="3.4 多条件索引"></a>3.4 多条件索引</h2><p>在使用索引筛选出数据之后，只需要加个统计函数的尾巴就可以直接算出统计数值。</p><ul><li><code>mean()</code>  #计算均值</li><li><code>std()</code>  #计算标准差</li><li><code>median()</code>  #计算中位数</li><li><code>max()</code>  #计算最大值</li><li><code>min()</code>  #计算最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;客单价平均值&#x27;</span>, df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">客单价平均值 64.01571428571428</code></pre><p>搭配布尔索引进一步进行统计筛选，使用 <code>&amp;</code>、<code>|</code>时，表达式注意必须要用括号 <code>()</code>括起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[(df[<span class="hljs-string">&#x27;访客数&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;访客数&#x27;</span>].mean()) &amp; (df[<span class="hljs-string">&#x27;客单价&#x27;</span>] &gt; df[<span class="hljs-string">&#x27;客单价&#x27;</span>].mean())]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>流量级别</th>      <th>投放地区</th>      <th>访客数</th>      <th>支付转化率</th>      <th>客单价</th>      <th>支付金额</th>    </tr>  </thead>  <tbody>    <tr>      <th>1002</th>      <td>一级</td>      <td>B区</td>      <td>30612</td>      <td>13.85%</td>      <td>86.64</td>      <td>367338.1</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Pandas数据结构</title>
    <link href="/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/03%20Pandas%E5%9F%BA%E7%A1%80/05_Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>Numpy和Pandas的关系：就像先掌握算术才能学代数一样，NumPy就是数据分析的”算术基础”，虽然可以直接用计算器（Pandas），但理解底层原理才能走得更远。</p><p>Pandas 核心数据机构是 <code>Series</code>(数据系列)、<code>DataFrame</code>(数据窗&#x2F;数据框)，<code>Series</code>可以看做表中的一列，<code>DataFrame</code>则是整个表格，由多个列构成。除此之外还有一个特殊的 <code>Index</code>类，为 <code>Series</code>和 <code>DataFrame</code>提供索引功能。</p><h1 id="1-Series对象"><a href="#1-Series对象" class="headerlink" title="1 Series对象"></a>1 Series对象</h1><h2 id="1-1-创建-Series-对象"><a href="#1-1-创建-Series-对象" class="headerlink" title="1.1 创建 Series 对象"></a>1.1 创建 Series 对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p><code>Series</code>对象内部结构：一个ndarray用来保存数据，一个index用来保存索引。类似Numpy的一维数组，但是增加了“标签”，具有数据和索引。</p><p><img src="/../../../../ai_assets/output_5_1%201.png" alt="png"></p><ul><li>通过列表和数组创建<ul><li><code>data</code>：数据</li><li><code>index</code>：索引</li><li><code>name</code>：名称</li></ul></li></ul><p>其中 <code>name</code>的作用：</p><ol><li>创建 <code>DataFrame</code>时自动变成列名</li><li>合并时作为对齐依据</li><li>导出csv时成为列名</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 = pd.Series(data=np.arange(<span class="hljs-number">4</span>), index=[<span class="hljs-string">&#x27;春&#x27;</span>, <span class="hljs-string">&#x27;夏&#x27;</span>, <span class="hljs-string">&#x27;秋&#x27;</span>, <span class="hljs-string">&#x27;冬&#x27;</span>], name=<span class="hljs-string">&#x27;季节&#x27;</span>)<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    0夏    1秋    2冬    3Name: 季节, dtype: int64</code></pre><ul><li>通过字典创建<ul><li>字典的键就是索引</li><li>字典的值就是数据</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=&#123;<span class="hljs-string">&#x27;春&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;夏&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;秋&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;冬&#x27;</span>: <span class="hljs-number">4</span>&#125;)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    1夏    2秋    3冬    4dtype: int64</code></pre><h2 id="1-2-Series-的运算"><a href="#1-2-Series-的运算" class="headerlink" title="1.2 Series 的运算"></a>1.2 Series 的运算</h2><p>由于 Pandas 是基于 Numpy 开发的，所以很多性质和数组是一样的，比如<strong>矢量化运算和广播</strong>。</p><h3 id="1-2-1-标量运算"><a href="#1-2-1-标量运算" class="headerlink" title="1.2.1 标量运算"></a>1.2.1 标量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += <span class="hljs-number">10</span><br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    10夏    11秋    12冬    13Name: 季节, dtype: int64</code></pre><h3 id="1-2-2-矢量运算"><a href="#1-2-2-矢量运算" class="headerlink" title="1.2.2 矢量运算"></a>1.2.2 矢量运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1 += ser2<br>ser1<br></code></pre></td></tr></table></figure><pre><code class="hljs">春    11夏    13秋    15冬    17Name: 季节, dtype: int64</code></pre><h2 id="1-3-Series-的属性"><a href="#1-3-Series-的属性" class="headerlink" title="1.3 Series 的属性"></a>1.3 Series 的属性</h2><ul><li><code>dtype</code>：返回 <code>Series</code>对象的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;int64&#39;)</code></pre><ul><li><code>size</code>：返回 <code>Series</code>对象中元素的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.size<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><ul><li><code>index</code>：返回 <code>Series</code>对象的索引 <code>Index</code>对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;索引对象&#x27;</span>, ser1.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体索引&#x27;</span>, ser1.index[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">索引对象 Index([&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;], dtype=&#39;object&#39;)通过下标取出具体索引 春</code></pre><ul><li><code>values</code>：以 <code>ndarray</code>的形式返回 <code>Series</code>对象的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ser1.values)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过下标取出具体值&#x27;</span>, ser1.values[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">[11 13 15 17]通过下标取出具体值 11</code></pre><h2 id="1-4-Series-的方法"><a href="#1-4-Series-的方法" class="headerlink" title="1.4 Series 的方法"></a>1.4 Series 的方法</h2><h3 id="1-4-1-描述性统计"><a href="#1-4-1-描述性统计" class="headerlink" title="1.4.1 描述性统计"></a>1.4.1 描述性统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;计数：&#x27;</span>, ser1.count())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;求和：&#x27;</span>, ser1.<span class="hljs-built_in">sum</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;均值：&#x27;</span>, ser1.mean())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;中位数：&#x27;</span>, ser1.median())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最小值：&#x27;</span>, ser1.<span class="hljs-built_in">min</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最大值：&#x27;</span>, ser1.<span class="hljs-built_in">max</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;标准差：&#x27;</span>, ser1.std())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方差：&#x27;</span>, ser1.var())<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数： 4求和： 56均值： 14.0中位数： 14.0最小值： 11最大值： 17标准差： 2.581988897471611方差： 6.666666666666667</code></pre><ul><li><code>describe()</code>：获取描述性统计信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser1.describe()<br></code></pre></td></tr></table></figure><pre><code class="hljs">count     4.000000mean     14.000000std       2.581989min      11.00000025%      12.50000050%      14.00000075%      15.500000max      17.000000Name: 季节, dtype: float64</code></pre><p><code>describe()</code>返回的是一个 <code>Series</code>对象，所以可以通过索引访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均值：&#x27;</span>, ser1.describe()[<span class="hljs-string">&#x27;mean&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值，最小值：\n<span class="hljs-subst">&#123;ser1.describe()[[<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>]]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均值： 14.0最大值，最小值：max    17.0min    11.0Name: 季节, dtype: float64</code></pre><h3 id="1-4-2-处理数据"><a href="#1-4-2-处理数据" class="headerlink" title="1.4.2 处理数据"></a>1.4.2 处理数据</h3><ul><li><code>isnull()</code>：空值判断</li><li><code>notnull()</code>：非空值判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2 = pd.Series(data=[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, np.nan, <span class="hljs-number">30</span>, np.nan])<br>ser2.isnull()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2     True3    False4     Truedtype: bool</code></pre><ul><li><code>dropna()</code>：删除空值</li><li><code>fillna()</code>：填充空值</li></ul><p>处理数据的方法都有一个 <code>inplace</code>参数，默认为 <code>False</code>。</p><ul><li><code>inplace=False</code>：处理完成返回新的对象</li><li><code>inplace=True</code>：在原对象上进行处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.dropna()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.fillna(<span class="hljs-number">66</span>, inplace=<span class="hljs-literal">True</span>)<br>ser2<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.04    66.0dtype: float64</code></pre><ul><li><code>duplicated()</code>：检测重复数据</li><li><code>drop_duplicates()</code>：删除重复数据</li><li><code>unique</code>：去除重复数据，返回一个数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.duplicated()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    False3    False4     Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.drop_duplicates()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    10.01    20.02    66.03    30.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser2.unique()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 20., 66., 30.])</code></pre><h3 id="1-4-3-排序"><a href="#1-4-3-排序" class="headerlink" title="1.4.3 排序"></a>1.4.3 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用 <code>ascending=False</code>参数可以实现降序排列，排序结果返回一个新的 <code>Series</code> 对象，原对象不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3 = pd.Series(data=[<span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>], index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_index()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Bob      30Eve      10Jack     50John     20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.sort_values(ascending=<span class="hljs-literal">False</span>, inplace=<span class="hljs-literal">True</span>)<br>ser3<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack     50Bob      30John     20Alice    10Eve      10dtype: int64</code></pre><ul><li><code>head(n)</code>：返回前 n 个元素，默认 n&#x3D;5</li><li><code>tail(n)</code>：返回后 n 个元素，默认 n&#x3D;5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Jack    50Bob     30John    20dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.tail(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Alice    10Eve      10dtype: int64</code></pre><h3 id="1-4-4-绘制图表"><a href="#1-4-4-绘制图表" class="headerlink" title="1.4.4 绘制图表"></a>1.4.4 绘制图表</h3><p><code>Series</code>对象可以直接绘制图表，默认绘制折线图，还可以绘制柱状图、饼图等，只需指定 <code>kind</code>参数即可。默认会使用索引作为横坐标，值作为纵坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ser3.plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;Axes: &gt;</code></pre><p><img src="/../../../../ai_assets/output_53_1.png" alt="png"></p><h1 id="2-DataFrame-对象"><a href="#2-DataFrame-对象" class="headerlink" title="2 DataFrame 对象"></a>2 DataFrame 对象</h1><p><code>DataFrame</code>是一个二维的表格型数据结构，既有行索引，也有列索引，可以将其看作由多个 <code>Series</code>按列组成的一个字典。是 Pandas 中最常用的数据结构，可以用来保存和处理异质的二维数据，每个列可以是不同的数据类型，这也是和 NumPy 数组的最大区别。</p><p>数据表格三要素贯穿 Pandas 数据分析的始终：</p><ul><li><code>column</code>：对应着列名，也就是列索引</li><li><code>index</code>：代表行索引</li><li><code>value</code>：则指代具体的数据值</li></ul><h2 id="2-1-创建-DataFrame-对象"><a href="#2-1-创建-DataFrame-对象" class="headerlink" title="2.1 创建 DataFrame 对象"></a>2.1 创建 DataFrame 对象</h2><h3 id="2-1-1-通过二维数组-列表创建"><a href="#2-1-1-通过二维数组-列表创建" class="headerlink" title="2.1.1 通过二维数组&#x2F;列表创建"></a>2.1.1 通过二维数组&#x2F;列表创建</h3><p><code>data</code>指定数据，<code>columns</code>指定列名，<code>index</code>指定行索引。<br>如果没有指定索引，则默认从 0 开始。如果没有指定列名，则默认从 0 开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">score = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, size=(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br>course = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]<br>stu_id = [<span class="hljs-string">&#x27;1001&#x27;</span>, <span class="hljs-string">&#x27;1002&#x27;</span>, <span class="hljs-string">&#x27;1003&#x27;</span>, <span class="hljs-string">&#x27;1004&#x27;</span>, <span class="hljs-string">&#x27;1005&#x27;</span>]<br>df1 = pd.DataFrame(data=score, columns=course, index=stu_id)<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>1001</th>      <td>89</td>      <td>98</td>      <td>58</td>    </tr>    <tr>      <th>1002</th>      <td>15</td>      <td>48</td>      <td>24</td>    </tr>    <tr>      <th>1003</th>      <td>48</td>      <td>42</td>      <td>60</td>    </tr>    <tr>      <th>1004</th>      <td>62</td>      <td>17</td>      <td>46</td>    </tr>    <tr>      <th>1005</th>      <td>18</td>      <td>54</td>      <td>71</td>    </tr>  </tbody></table></div><h3 id="2-1-2-通过字典创建"><a href="#2-1-2-通过字典创建" class="headerlink" title="2.1.2 通过字典创建"></a>2.1.2 通过字典创建</h3><p>字典嵌套列表：按照列名进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">info1 = &#123;<br>    <span class="hljs-string">&#x27;姓名&#x27;</span>: [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>],<br>    <span class="hljs-string">&#x27;年龄&#x27;</span>: [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>],<br>    <span class="hljs-string">&#x27;性别&#x27;</span>: [<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>]<br>&#125;<br>df2 = pd.DataFrame(data=info1)<br>df2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>年龄</th>      <th>性别</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>18</td>      <td>男</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>19</td>      <td>女</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>20</td>      <td>男</td>    </tr>    <tr>      <th>3</th>      <td>赵六</td>      <td>21</td>      <td>女</td>    </tr>  </tbody></table></div><p>列表嵌套列表：按照行进行创建 <code>DataFrame</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">info2 = [<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;姓名&#x27;</span>: <span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>: <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;性别&#x27;</span>: <span class="hljs-string">&#x27;女&#x27;</span>&#125;<br>]<br>df3 = pd.DataFrame(data=info2)<br>df3<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>年龄</th>      <th>性别</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>18</td>      <td>男</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>19</td>      <td>女</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>20</td>      <td>男</td>    </tr>    <tr>      <th>3</th>      <td>赵六</td>      <td>21</td>      <td>女</td>    </tr>  </tbody></table></div><h2 id="2-2-数据读取和存储"><a href="#2-2-数据读取和存储" class="headerlink" title="2.2 数据读取和存储"></a>2.2 数据读取和存储</h2><p>实际应用中，单独创建数据结构的情况较少，更多的是通过读取外部数据文件来创建数据结构。</p><h3 id="2-2-1-读取-Excel"><a href="#2-2-1-读取-Excel" class="headerlink" title="2.2.1 读取 Excel"></a>2.2.1 读取 Excel</h3><p>通过 <code>read_excel</code>读取 Excel 文件，默认读取第一个 sheet，可以通过 <code>sheet_name</code>参数指定读取的 sheet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>张三</th>      <th>88</th>      <th>100</th>      <th>90</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>1</th>      <td>王五</td>      <td>80</td>      <td>92</td>      <td>60</td>    </tr>  </tbody></table></div><p>Pandas 默认会将第一行数据作为列名，如果想自定义列名，可以将 <code>header=None</code>告诉Pandas数据中没有表头，然后通过 <code>names</code>参数指定列名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_excel(<span class="hljs-string">&#x27;data/data1.xlsx&#x27;</span>, header=<span class="hljs-literal">None</span>, names=[<span class="hljs-string">&#x27;姓名&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>92</td>      <td>60</td>    </tr>  </tbody></table></div><p>此外读取数据还有很多参数，比如：</p><ul><li><code>index_col</code>：指定哪一列作为行索引</li><li><code>usecols</code>：指定读取哪些列</li><li><code>nrows</code>：指定读取多少行</li><li><code>dtype</code>：指定列的数据类型</li></ul><h3 id="2-2-2-读取-CSV"><a href="#2-2-2-读取-CSV" class="headerlink" title="2.2.2 读取 CSV"></a>2.2.2 读取 CSV</h3><p>通过 <code>read_csv</code>函数可以读取 CSV 和 TSV 文件，默认使用UTF-8编码格式，如果是其他编码格式，可以通过 <code>encoding</code>参数指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4 = pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>  </tbody></table></div><p>大多数CSV文件以逗号分隔，如果是其他字符分<br>隔，可以通过 <code>sep</code>参数指定分隔符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>, sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在某些Python版本读取中文路径会报错，因为默认读取引擎是C语言，可以通过 <code>engine</code>参数指定为Python引擎。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;data/data2.csv&#x27;</span>mengine=<span class="hljs-string">&#x27;python&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-3-连接MySQL"><a href="#2-2-3-连接MySQL" class="headerlink" title="2.2.3 连接MySQL"></a>2.2.3 连接MySQL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要安装pymysql，部分版本需要额外安装sqlalchemy</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+pymysql://root:123456@127.0.0.1:3306/sql_practice03?charset=utf8&#x27;</span>)<br><span class="hljs-comment"># mysql 表示数据库类型</span><br><span class="hljs-comment"># pymysql 表示python操作数据库的包</span><br><span class="hljs-comment"># root:123456 表示数据库的账号和密码，用冒号连接</span><br><span class="hljs-comment"># 127.0.0.1:3306/sql_practice03 表示数据库的ip和端口，以及名叫sql_practice03的库</span><br><span class="hljs-comment"># charset=utf8 规定编码格式</span><br></code></pre></td></tr></table></figure><p>数据库读取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取整张表</span><br>pd.read_sql(<span class="hljs-string">&#x27;dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>DEPTNO</th>      <th>DNAME</th>      <th>LOC</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>10</td>      <td>ACCOUNTING</td>      <td>NEW YORK</td>    </tr>    <tr>      <th>1</th>      <td>20</td>      <td>RESEARCH</td>      <td>DALLAS</td>    </tr>    <tr>      <th>2</th>      <td>30</td>      <td>SALES</td>      <td>CHICAGO</td>    </tr>    <tr>      <th>3</th>      <td>40</td>      <td>OPERATIONS</td>      <td>BOSTON</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SQL语句查询指定内容</span><br>pd.read_sql(<span class="hljs-string">&#x27;select DEPTNO, DNAME from dept&#x27;</span>, engine)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>DEPTNO</th>      <th>DNAME</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>10</td>      <td>ACCOUNTING</td>    </tr>    <tr>      <th>1</th>      <td>20</td>      <td>RESEARCH</td>    </tr>    <tr>      <th>2</th>      <td>30</td>      <td>SALES</td>    </tr>    <tr>      <th>3</th>      <td>40</td>      <td>OPERATIONS</td>    </tr>  </tbody></table></div><p>写入数据到数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_sql(<span class="hljs-string">&#x27;df_score_table&#x27;</span>, engine, index=<span class="hljs-literal">False</span>, if_exists=<span class="hljs-string">&#x27;append&#x27;</span>)<br><span class="hljs-comment"># index：是否将index写入数据库</span><br><span class="hljs-comment"># if_exists：如果表存在如何操作 </span><br><span class="hljs-comment">#     append：追加  </span><br><span class="hljs-comment">#     replace：覆盖</span><br><span class="hljs-comment">#     fail：报错</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">3</code></pre><h3 id="2-2-4-读取其他文件"><a href="#2-2-4-读取其他文件" class="headerlink" title="2.2.4 读取其他文件"></a>2.2.4 读取其他文件</h3><p>Excel和CSV是最常用的，其他文件读取简单了解，读取文件的大部分参数是通用的。</p><ul><li><code>read_table()</code>： 读取文本文件</li><li><code>read_json()</code>： 读取 JSON 文件</li></ul><h3 id="2-2-5-存储数据"><a href="#2-2-5-存储数据" class="headerlink" title="2.2.5 存储数据"></a>2.2.5 存储数据</h3><p>在Pandas中存储数据直接使用 <code>to_xxx()</code>方法即可，默认会把索引也存储进去，如果不需要索引，可以通过 <code>index=False</code>参数去掉索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.to_excel(<span class="hljs-string">&#x27;data/new_data2.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="2-3-DataFrame-的属性"><a href="#2-3-DataFrame-的属性" class="headerlink" title="2.3 DataFrame 的属性"></a>2.3 DataFrame 的属性</h2><ul><li><code>columns</code>：列索引</li><li><code>index</code>：行索引</li><li><code>values</code>：数据值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df4)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n列索引：&#x27;</span>, df4.columns)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;行索引：&#x27;</span>, df4.index)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据值：\n&#x27;</span>, df4.values)<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名  语文   数学  英语0  张三  88  100  901  李四  82   65  522  王五  80  100  60列索引： Index([&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;], dtype=&#39;object&#39;)行索引： RangeIndex(start=0, stop=3, step=1)数据值： [[&#39;张三&#39; 88 100 90] [&#39;李四&#39; 82 65 52] [&#39;王五&#39; 80 100 60]]</code></pre><ul><li><code>dtypes</code>：每一列的数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.dtypes<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    object语文     int64数学     int64英语     int64dtype: object</code></pre><ul><li><code>ndim</code>：维度</li><li><code>shape</code>：形状</li><li><code>size</code>：元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;维度&#x27;</span>, df4.ndim)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;形状&#x27;</span>, df4.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;元素个数&#x27;</span>, df4.size)<br></code></pre></td></tr></table></figure><pre><code class="hljs">维度 2形状 (3, 4)元素个数 12</code></pre><h2 id="2-4-DataFrame-的方法"><a href="#2-4-DataFrame-的方法" class="headerlink" title="2.4 DataFrame 的方法"></a>2.4 DataFrame 的方法</h2><h3 id="2-4-1-快速查看"><a href="#2-4-1-快速查看" class="headerlink" title="2.4.1 快速查看"></a>2.4.1 快速查看</h3><ul><li><code>info()</code>：查看DataFrame的基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 3 entries, 0 to 2Data columns (total 4 columns): #   Column  Non-Null Count  Dtype---  ------  --------------  ----- 0   姓名      3 non-null      object 1   语文      3 non-null      int64 2   数学      3 non-null      int64 3   英语      3 non-null      int64dtypes: int64(3), object(1)memory usage: 224.0+ bytes</code></pre><ul><li><code>describe()</code>：获取统计性描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>3.000000</td>      <td>3.000000</td>      <td>3.000000</td>    </tr>    <tr>      <th>mean</th>      <td>83.333333</td>      <td>88.333333</td>      <td>67.333333</td>    </tr>    <tr>      <th>std</th>      <td>4.163332</td>      <td>20.207259</td>      <td>20.033306</td>    </tr>    <tr>      <th>min</th>      <td>80.000000</td>      <td>65.000000</td>      <td>52.000000</td>    </tr>    <tr>      <th>25%</th>      <td>81.000000</td>      <td>82.500000</td>      <td>56.000000</td>    </tr>    <tr>      <th>50%</th>      <td>82.000000</td>      <td>100.000000</td>      <td>60.000000</td>    </tr>    <tr>      <th>75%</th>      <td>85.000000</td>      <td>100.000000</td>      <td>75.000000</td>    </tr>    <tr>      <th>max</th>      <td>88.000000</td>      <td>100.000000</td>      <td>90.000000</td>    </tr>  </tbody></table></div><ul><li><code>head(n)</code>：查看前n行数据，默认n&#x3D;5</li><li><code>tail(n)</code>：查看后n行数据，默认n&#x3D;5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.head(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.tail(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>  </tbody></table></div><ul><li><code>value_counts()</code>：统计每一个唯一值出现的次数，索引为唯一值，值为出现的次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;数学&#x27;</span>].value_counts()<br></code></pre></td></tr></table></figure><pre><code class="hljs">数学100    265     1Name: count, dtype: int64</code></pre><h3 id="2-4-2-描述性统计"><a href="#2-4-2-描述性统计" class="headerlink" title="2.4.2 描述性统计"></a>2.4.2 描述性统计</h3><p>DataFrame也有很多统计性描述信息的方法，和Series一致，不过多了一个 <code>axis</code>参数控制聚合轴向：</p><ul><li><code>axis=0</code>：按列进行统计（默认）</li><li><code>axis=1</code>：按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计数：\n<span class="hljs-subst">&#123;df4.count()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;求和：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;均值：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].mean(axis=<span class="hljs-number">1</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;中位数：\n<span class="hljs-subst">&#123;df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].median()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">计数：姓名    3语文    3数学    3英语    3dtype: int64求和：姓名    张三李四王五语文       250数学       265英语       202dtype: object均值：0    92.6666671    66.3333332    80.000000dtype: float64中位数：语文     82.0数学    100.0英语     60.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最小值：\n<span class="hljs-subst">&#123;df4[<span class="hljs-string">&#x27;数学&#x27;</span>].<span class="hljs-built_in">min</span>()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大值：\n<span class="hljs-subst">&#123;df4.<span class="hljs-built_in">max</span>(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;标准差：\n<span class="hljs-subst">&#123;df4.std(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;方差：\n<span class="hljs-subst">&#123;df4.var(numeric_only=<span class="hljs-literal">True</span>)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最小值：65最大值：语文     88数学    100英语     90dtype: int64标准差：语文     4.163332数学    20.207259英语    20.033306dtype: float64方差：语文     17.333333数学    408.333333英语    401.333333dtype: float64</code></pre><ul><li><code>idxmax()</code>：求最大值位置</li><li><code>idxmin()</code>：求最小值位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">display(df4.idxmax())<br>display(df4.idxmin())<br></code></pre></td></tr></table></figure><pre><code class="hljs">姓名    2语文    0数学    0英语    0dtype: int64姓名    0语文    2数学    1英语    1dtype: int64</code></pre><h3 id="2-4-3-累计运算"><a href="#2-4-3-累计运算" class="headerlink" title="2.4.3 累计运算"></a>2.4.3 累计运算</h3><ul><li><code>cumsum()</code>：累计和</li><li><code>cumprod()</code>：累计积</li><li><code>cummax()</code>：累计最大值</li><li><code>cummin()</code>：累计最小值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cumsum()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>张三李四</td>      <td>170</td>      <td>165</td>      <td>142</td>    </tr>    <tr>      <th>2</th>      <td>张三李四王五</td>      <td>250</td>      <td>265</td>      <td>202</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.cummin()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>    <tr>      <th>1</th>      <td>张三</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>张三</td>      <td>80</td>      <td>65</td>      <td>52</td>    </tr>  </tbody></table></div><ul><li><code>diff()</code>：计算与上一个值的差值</li><li><code>pct_change()</code>：计算与上一个值的百分比变化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].diff()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>-6.0</td>      <td>-35.0</td>      <td>-38.0</td>    </tr>    <tr>      <th>2</th>      <td>-2.0</td>      <td>35.0</td>      <td>8.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].pct_change()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>NaN</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>1</th>      <td>-0.068182</td>      <td>-0.350000</td>      <td>-0.422222</td>    </tr>    <tr>      <th>2</th>      <td>-0.024390</td>      <td>0.538462</td>      <td>0.153846</td>    </tr>  </tbody></table></div><h3 id="2-4-4-排序"><a href="#2-4-4-排序" class="headerlink" title="2.4.4 排序"></a>2.4.4 排序</h3><ul><li><code>sort_index()</code>：根据索引排序，默认升序</li><li><code>sort_values()</code>：根据值排序，默认升序</li></ul><p>使用 <code>ascending=False</code>参数可以实现降序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_index(ascending=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.sort_values(<span class="hljs-string">&#x27;英语&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>    </tr>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>    </tr>  </tbody></table></div><h3 id="2-4-5-apply自定义函数"><a href="#2-4-5-apply自定义函数" class="headerlink" title="2.4.5 apply自定义函数"></a>2.4.5 apply自定义函数</h3><p>可以将一个函数应用（apply）到 Series 的每个元素上，或者 DataFrame 的每一行或每一列上。</p><p>当作用于 Series（DataFrame 的一列）时，apply() 会将函数依次作用于 Series 中的每一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_score</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">80</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;高&#x27;</span><br>    <span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">60</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;中&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;低&#x27;</span><br>  <br>df4[<span class="hljs-string">&#x27;英语&#x27;</span>].apply(check_score)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    高1    低2    中Name: 英语, dtype: object</code></pre><p>当作用于 DataFrame 时，apply() 可以将函数作用于每一列或每一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.apply(func, axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>func：要应用的函数</li><li>axis：指定函数应用方向<ul><li><code>0</code>：默认值，将函数应用到每一列，接收对象是Series</li><li><code>1</code>：将函数应用到每一行，接收对象是Series</li></ul></li></ul><p>沿列应用时，函数接收到的一列数据，通常用于聚合（如求和、最大值等）或对整列进行转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算每一科最高分和最低分的差值</span><br>df4[[<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]].apply(<span class="hljs-keyword">lambda</span> x: x.<span class="hljs-built_in">max</span>() - x.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><pre><code class="hljs">语文     8数学    35英语    38dtype: int64</code></pre><p>沿行应用时，函数接收到的是一行数据，索引为列名，通常用于使用多列计算新值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4[<span class="hljs-string">&#x27;加权分&#x27;</span>] = df4.apply(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;语文&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;数学&#x27;</span>] * <span class="hljs-number">0.4</span> + x[<span class="hljs-string">&#x27;英语&#x27;</span>] * <span class="hljs-number">0.2</span>, axis=<span class="hljs-number">1</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><h1 id="3-Index-对象"><a href="#3-Index-对象" class="headerlink" title="3 Index 对象"></a>3 Index 对象</h1><p><code>Index</code>用来唯一标识 DataFrame 中的每一行数据，就像数据库表中的主键一样，但它不强制要求是唯一的，类似于一维数组，存储着用于标记各行数据的标签。</p><h2 id="3-1-Index-的特点"><a href="#3-1-Index-的特点" class="headerlink" title="3.1 Index 的特点"></a>3.1 Index 的特点</h2><ol><li>标签：作为行标签使用，用来访问特定行 <code>df.loc[行标签]</code></li><li>对齐：两个 <code>DataFrame</code>之间运算（比如加法、合并等）时，Pandas根据 <code>Index</code>和 <code>Column</code>自动将数据对齐，而不需要行和列的顺序相同</li><li>不可变性：<code>Index</code>对象一旦创建，不允许被修改，所有修改索引必须整体修改</li></ol><h2 id="3-2-Index-常用操作"><a href="#3-2-Index-常用操作" class="headerlink" title="3.2 Index 常用操作"></a>3.2 Index 常用操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>index</code>：查看index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.index<br></code></pre></td></tr></table></figure><pre><code class="hljs">RangeIndex(start=0, stop=3, step=1)</code></pre><p><code>set_index()</code>：将普通列设为行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.set_index(keys, drop=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>keys：新索引的列名或列名列表</li><li>drop：用于创建新索引的列是否从表中删除，默认为True</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df5 = df4.set_index(<span class="hljs-string">&#x27;姓名&#x27;</span>)<br>df5<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>    <tr>      <th>姓名</th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>张三</th>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>李四</th>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>王五</th>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>reset_index</code>：<code>set_index</code>的逆操作，将索引重置为普通列，并且创建一个新的 <code>RangeIndex</code>作为索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.reset_index(drop=<span class="hljs-literal">False</span>, name=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>drop：是否删除原有索引，不转化为普通列，默认为False</li><li>names：指定转为为普通列之后的名称</li><li>inplace：是否在原表修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df5.reset_index(names=<span class="hljs-string">&#x27;大名&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>大名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><p><code>rename()</code>：重命名行索引或列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.rename(columns=<span class="hljs-literal">None</span>, index=<span class="hljs-literal">None</span>, axis=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li>columns：重命名列索引，{‘旧列名’: ‘新列名’, …}</li><li>index：重命名行索引，{‘旧行名’: ‘新行名’, …}</li><li>axis：指定重命名行索引还是列索引，0或’index’表示行索引，1或’columns’表示列索引，默认0</li><li>inplace：是否在原数据上修改，默认False表示不修改原数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>语文</th>      <th>数学</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(columns=&#123;<span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-string">&#x27;Math&#x27;</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>Chinese</th>      <th>Math</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df4.rename(index=&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1001</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>df4<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;`&lt;/style&gt;`</code></pre><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>姓名</th>      <th>Chinese</th>      <th>Math</th>      <th>英语</th>      <th>加权分</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>张三</td>      <td>88</td>      <td>100</td>      <td>90</td>      <td>93.2</td>    </tr>    <tr>      <th>1001</th>      <td>李四</td>      <td>82</td>      <td>65</td>      <td>52</td>      <td>69.2</td>    </tr>    <tr>      <th>2</th>      <td>王五</td>      <td>80</td>      <td>100</td>      <td>60</td>      <td>84.0</td>    </tr>  </tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Numpy结构化数组</title>
    <link href="/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <url>/2024/08/15/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/04_Numpy%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建结构化数组"><a href="#1-创建结构化数组" class="headerlink" title="1 创建结构化数组"></a>1 创建结构化数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p>类似C++的结构体，但更加强大，数组的每个元素可以包含多个字段，可以单独处理数组的每一个字段。</p><h2 id="1-1-字典方式"><a href="#1-1-字典方式" class="headerlink" title="1.1 字典方式"></a>1.1 字典方式</h2><p><code>dtype</code>的参数是一个字典：</p><ul><li><code>names</code>：指定字段名称</li><li><code>formats</code>：指定数据类型，可以使用Python类型或Numpy类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dtype = &#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;<br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=my_dtype)<br>arr.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><h2 id="1-2-列表元组方式"><a href="#1-2-列表元组方式" class="headerlink" title="1.2 列表元组方式"></a>1.2 列表元组方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype([<br>    (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;U10&#x27;</span>),<br>    (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">int</span>),<br>    (<span class="hljs-string">&#x27;weight&#x27;</span>, <span class="hljs-string">&#x27;f8&#x27;</span>),<br>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;name&#39;, &#39;&lt;U10&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f8&#39;)])</code></pre><p>如果类型名称不重要可以省略，仅仅指定数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.dtype(<span class="hljs-string">&#x27;U10, i8, f8&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype([(&#39;f0&#39;, &#39;&lt;U10&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;), (&#39;f2&#39;, &#39;&lt;f8&#39;)])</code></pre><p>Numpy数据类型符号表：</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="center"><strong>‘b’</strong></td><td align="center">字节型 (Boolean or raw bytes)</td><td align="left"><code>np.dtype(&#39;b&#39;)</code></td></tr><tr><td align="center"><strong>‘i’</strong></td><td align="center">有符号整型 (Signed integer)</td><td align="left"><code>np.dtype(&#39;i4&#39;) == np.int32</code></td></tr><tr><td align="center"><strong>‘u’</strong></td><td align="center">无符号整型 (Unsigned integer)</td><td align="left"><code>np.dtype(&#39;u1&#39;) == np.uint8</code></td></tr><tr><td align="center"><strong>‘f’</strong></td><td align="center">浮点型 (Floating-point)</td><td align="left"><code>np.dtype(&#39;f8&#39;) == np.float64</code></td></tr><tr><td align="center"><strong>‘c’</strong></td><td align="center">复数浮点型 (Complex floating-point)</td><td align="left"><code>np.dtype(&#39;c16&#39;) == np.complex128</code></td></tr><tr><td align="center"><strong>‘S’, ‘a’</strong></td><td align="center">字节字符串 (Byte string)</td><td align="left"><code>np.dtype(&#39;S5&#39;)</code></td></tr><tr><td align="center"><strong>‘U’</strong></td><td align="center">Unicode编码字符串 (Unicode string)</td><td align="left"><code>np.dtype(&#39;U&#39;) == np.str_</code></td></tr><tr><td align="center"><strong>‘V’</strong></td><td align="center">原生数据 (Raw data, void)</td><td align="left"><code>np.dtype(&#39;V&#39;) == np.void</code></td></tr></tbody></table><h1 id="2-访问结构化数组"><a href="#2-访问结构化数组" class="headerlink" title="2 访问结构化数组"></a>2 访问结构化数组</h1><p>数组的每一个字段依然是一个数组，可以用索引、聚合等操作。这里的操作有点像SQL，字段名像列，索引号像行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建结构化数组</span><br>arr = np.zeros(<span class="hljs-number">4</span>, dtype=&#123;<br>    <span class="hljs-string">&#x27;names&#x27;</span>: (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>),<br>    <span class="hljs-string">&#x27;formats&#x27;</span>: (<span class="hljs-string">&#x27;U10&#x27;</span>, <span class="hljs-built_in">int</span>, <span class="hljs-string">&#x27;f8&#x27;</span>)<br>&#125;)<br><br>arr[<span class="hljs-string">&#x27;name&#x27;</span>] = [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>]<br>arr[<span class="hljs-string">&#x27;age&#x27;</span>] = [<span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">20</span>, <span class="hljs-number">35</span>]<br>arr[<span class="hljs-string">&#x27;weight&#x27;</span>] = [<span class="hljs-number">110.2</span>, <span class="hljs-number">125.3</span>, <span class="hljs-number">103.1</span>, <span class="hljs-number">159.6</span>]<br>arr[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;赵六&#39;], dtype=&#39;&lt;U10&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;arr：&#x27;</span>, arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n通过字段名访问age列表：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通过索引访问第一个元素：&#x27;</span>, arr[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;组合字段和索引访问第一个人的名字：&#x27;</span>, arr[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>], arr[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr： [(&#39;张三&#39;, 18, 110.2) (&#39;李四&#39;, 28, 125.3) (&#39;王五&#39;, 20, 103.1) (&#39;赵六&#39;, 35, 159.6)]通过字段名访问age列表： [18 28 20 35]通过索引访问第一个元素： (&#39;张三&#39;, 18, 110.2)组合字段和索引访问第一个人的名字： 张三 张三</code></pre><p>结合布尔索引可以对元素进行筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 年龄小于25岁的人</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>])<br><br><span class="hljs-comment"># 年龄小于25岁的人的姓名和年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;年龄小于25岁的人的信息&#x27;</span>, arr[arr[<span class="hljs-string">&#x27;age&#x27;</span>] &lt; <span class="hljs-number">25</span>][[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>]])<br></code></pre></td></tr></table></figure><pre><code class="hljs">年龄小于25岁的人的信息 [(&#39;张三&#39;, 18, 110.2) (&#39;王五&#39;, 20, 103.1)]年龄小于25岁的人的信息 [(&#39;张三&#39;, 18) (&#39;王五&#39;, 20)]</code></pre><p>结合描述统计方法对字段进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算平均年龄</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;平均年龄：&#x27;</span>, arr[<span class="hljs-string">&#x27;age&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">平均年龄： 25.25</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Numpy数组运算和函数</title>
    <link href="/2024/08/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2024/08/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/03_Numpy%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Numpy非常重要的一个特性就是<strong>矢量化</strong>，对数组进行运算时，所有运算会自动作用于数组中的每一个成员，而不需要编写循环。</p><h1 id="1-数组和标量的运算"><a href="#1-数组和标量的运算" class="headerlink" title="1 数组和标量的运算"></a>1 数组和标量的运算</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>数组和数值进行加减乘除、取模求幂等运算，对应的运算会作用到数组的每一个元素上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr + 10为：<span class="hljs-subst">&#123;arr + <span class="hljs-number">10</span>&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr * 2为：<span class="hljs-subst">&#123;arr * <span class="hljs-number">2</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr + 10为：[10 11 12 13 14 15 16 17 18 19]arr * 2为：[ 0  2  4  6  8 10 12 14 16 18]</code></pre><p>数组还可以和数值进行关系运算，在布尔索引中也有所应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr % 2 == 0为：<span class="hljs-subst">&#123;arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr % 2 == 0为：[ True False  True False  True False  True False  True False]</code></pre><p>使用 <code>数组.T</code>可以很方便的对矩阵进行转置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr转置数组：\n<span class="hljs-subst">&#123;arr.T&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr转置数组：[[ 0  5 10] [ 1  6 11] [ 2  7 12] [ 3  8 13] [ 4  9 14]]</code></pre><h1 id="2-数组和数组的运算"><a href="#2-数组和数组的运算" class="headerlink" title="2 数组和数组的运算"></a>2 数组和数组的运算</h1><h2 id="2-1-相同形状运算"><a href="#2-1-相同形状运算" class="headerlink" title="2.1 相同形状运算"></a>2.1 相同形状运算</h2><p>数组和数组之间的运算会作用到两个数组对应的元素上，要求两个数组的形状相同。</p><p>注意：<code>a * b</code>不是矩阵乘法，而是逐元素相乘，也就是哈达玛积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>)<br>arr2 = np.full(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 * arr2为：\n<span class="hljs-subst">&#123;arr1 * arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以直接应用于布尔索引</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 &lt; arr2为：\n<span class="hljs-subst">&#123;arr1 &lt; arr2&#125;</span>\n&#x27;</span>)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[ 0  1  2  3  4  5  6  7  8  9 10]arr2为：[10 10 10 10 10 10 10 10 10 10 10]arr1 + arr2为：[10 11 12 13 14 15 16 17 18 19 20]arr1 * arr2为：[  0  10  20  30  40  50  60  70  80  90 100]arr1 &lt; arr2为：[ True  True  True  True  True  True  True  True  True  True False]</code></pre><h2 id="2-2-矩阵乘法"><a href="#2-2-矩阵乘法" class="headerlink" title="2.2 矩阵乘法"></a>2.2 矩阵乘法</h2><p>矩阵乘法有前提条件，A的列数必须和B的行数相等，也就是两个矩阵必须有<strong>相同的内维</strong>。</p><ul><li>A的形状为(m, n)，B的形状为(n, p)，n就是内维</li><li>内维 &#x3D; A的列数 &#x3D; B的行数（内维必须相等，乘积才有定义）</li><li>外维 &#x3D; m × p（外维是AB乘积结果的形状）</li><li>矩阵乘积AB存在，但BA不一定存在，即便存在，AB和BA通常也不同</li></ul><p>$$<br>\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \ a_{21} &amp; a_{22} &amp; a_{23} \end{bmatrix} \times \begin{bmatrix} b_{11} &amp; b_{12} \ b_{21} &amp; b_{22} \ b_{31} &amp; b_{32} \end{bmatrix} &#x3D; \begin{bmatrix} (a_{11}b_{11} + a_{12}b_{21} + a_{13}b_{31}) &amp; (a_{11}b_{12} + a_{12}b_{22} + a_{13}b_{32}) \ (a_{21}b_{11} + a_{22}b_{21} + a_{23}b_{31}) &amp; (a_{21}b_{12} + a_{22}b_{22} + a_{23}b_{32}) \end{bmatrix}<br>$$</p><p>矩阵乘法 C&#x3D;A×B 的核心运算就是在对 A 的行向量和 B 的列向量进行点积。</p><p><img src="/../../../../ai_assets/02_matrix_multi.png" alt="png"></p><p>在Numpy中可以使用矩阵乘法运算符 <code>arr1 @ arr2</code>或函数 <code>np.dot(arr1, arr2)</code>的方式计算矩阵乘法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2*3矩阵 × 3*2矩阵</span><br>arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>arr2 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 推荐矩阵乘法运算符</span><br><span class="hljs-built_in">print</span>(arr1 @ arr2, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 函数方式</span><br><span class="hljs-built_in">print</span>(np.dot(arr1, arr2))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[22 28] [49 64]][[22 28] [49 64]]</code></pre><h2 id="2-3-广播机制"><a href="#2-3-广播机制" class="headerlink" title="2.3 广播机制"></a>2.3 广播机制</h2><p>两个数组之间做二元运算，并不必须是完全相同的形状，通过Numpy的广播机制，将原本形状不同的数组变成形状相同的数组，也可以进行二元运算。</p><p>广播机制：在数组之间运算时，自动扩展维度较小的数组，使其形状和维度与较大数组匹配，从而进行运算。</p><ul><li>虚拟扩展<ul><li>Numpy的扩展不是真的复制，而是逻辑上的扩展</li></ul></li><li>维度对齐<ul><li>从尾部维度逐个比较，如果维度相同，继续向前比较</li><li>如果维度不同，但其中一个数组在这个维度上大小为1，则可以扩展为较大的数组，</li><li>否则不能对齐则报错</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br>arr2 = np.full((<span class="hljs-number">5</span>), <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为：\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]arr2为：[1 1 1 1 1]arr1 + arr2为：[[ 1  2  3  4  5] [ 6  7  8  9 10] [11 12 13 14 15]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1*3 和 3*1 的矩阵运算</span><br>arr1 = np.full((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>)<br>arr2 = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为:\n<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2为:\n<span class="hljs-subst">&#123;arr2&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1 + arr2为：\n<span class="hljs-subst">&#123;arr1 + arr2&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr1为:[[1 1 1]]arr2为:[[1] [1] [1]]arr1 + arr2为：[[2 2 2] [2 2 2] [2 2 2]]</code></pre><p><img src="/../../../../ai_assets/02_ndarray_broad.png" alt="png"></p><h1 id="3-通用函数"><a href="#3-通用函数" class="headerlink" title="3 通用函数"></a>3 通用函数</h1><h2 id="3-1-一元函数"><a href="#3-1-一元函数" class="headerlink" title="3.1 一元函数"></a>3.1 一元函数</h2><p>一元函数的参数是一个数组对象，函数会矢量化地对数组每一个元素进行运算。</p><ul><li><code>abs()</code>&#x2F;<code>fabs()</code>：求绝对值</li><li><code>sqrt()</code>：求平方根，相当于 <code>arr ** 0.5</code></li><li><code>square()</code>：求平方，相当于 <code>arr ** 2</code></li><li><code>exp()</code>：求${e^x}$的函数</li><li><code>log()</code>&#x2F;<code>log10()</code>&#x2F;<code>log2()</code>：对数函数</li><li><code>sign()</code>：求元素的符号（1：正数；0：零；-1：负数）</li><li><code>isnan()</code>：判断元素是否为NaN，NaN对应 <code>True</code>，否则为 <code>False</code></li><li><code>ceil()</code>&#x2F;<code>floor()</code>：上取整&#x2F;下取整</li><li><code>sin()</code>&#x2F;<code>cos()</code>&#x2F;<code>tan()</code>：三角函数</li><li><code>arcsin()</code>&#x2F;<code>arccos()</code>&#x2F;<code>arctan()</code>：反三角函数</li><li><code>rint()</code>：四舍五入函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;abs函数：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">abs</span>(arr)&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;square函数：<span class="hljs-subst">&#123;np.square(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;exp函数：<span class="hljs-subst">&#123;np.exp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;sign函数：<span class="hljs-subst">&#123;np.sign(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[ 0  1  2 -3 -5  6  7 -8]abs函数：[0 1 2 3 5 6 7 8]square函数：[ 0  1  4  9 25 36 49 64]exp函数：[1.00000000e+00 2.71828183e+00 7.38905610e+00 4.97870684e-02 6.73794700e-03 4.03428793e+02 1.09663316e+03 3.35462628e-04]sign函数：[ 0  1  1 -1 -1  1  1 -1]</code></pre><h2 id="3-2-二元函数"><a href="#3-2-二元函数" class="headerlink" title="3.2 二元函数"></a>3.2 二元函数</h2><p>二元函数的参数是两个数组对象，函数会对两个数组的对应元素进行运算。</p><ul><li><code>add(x, y)</code>&#x2F;<code>subtract(x, y)</code>：加法函数&#x2F;减法函数</li><li><code>multiply(x, y)</code>&#x2F;<code>divide(x, y)</code>：乘法函数&#x2F;除法函数</li><li><code>floor_divide(x, y)</code>&#x2F;<code>mod(x, y)</code>：整除函数&#x2F;求模函数</li><li><code>power(x, y)</code>：求${x^y}$</li></ul><p><code>axis</code>指定的是数组<strong>将会被折叠的维度，而不是将要返回的维度</strong>，因此 <code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合值。</p><ul><li><code>cumsum()</code>：返回一维数组，计算累加和</li><li><code>cumpord()</code>：返回一维数组，计算累乘积</li></ul><p>多维数组默认统计全部维度，如果想要按指定轴进行统计，可以设置 <code>axis</code>参数，0按列统计，值为1按行统计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum累加：\n<span class="hljs-subst">&#123;np.cumsum(arr)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿0轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumsum沿1轴累加：\n<span class="hljs-subst">&#123;np.cumsum(arr, axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;cumprod累乘：\n<span class="hljs-subst">&#123;np.cumprod(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]cumsum累加：[ 1  3  6 10 15 21 28 36 45 55 66 78]cumsum沿0轴累加：[[ 1  2  3  4] [ 6  8 10 12] [15 18 21 24]]cumsum沿1轴累加：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]cumprod累乘：[        1         2         6        24       120       720      5040     40320    362880   3628800  39916800 479001600]</code></pre><ul><li><code>reduce()</code>：对数据进行聚合</li><li><code>accumulate()</code>：显示每一个元素的聚合过程</li></ul><p>可以对 <code>add()</code>&#x2F;<code>subtract()</code>等运算进行聚合，可以使用 <code>axis</code>指定聚合维度，默认折叠0轴，按列进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;默认add聚合：<span class="hljs-subst">&#123;np.add.reduce(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add使用axis=1聚合：<span class="hljs-subst">&#123;np.add.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add累加过程：\n<span class="hljs-subst">&#123;np.add.accumulate(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;multiply使用axis=1聚合：<span class="hljs-subst">&#123;np.multiply.reduce(arr, axis=<span class="hljs-number">1</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]]默认add聚合：[15 18 21 24]add使用axis=1聚合：[10 26 42]add累加过程：[[ 1  3  6 10] [ 5 11 18 26] [ 9 19 30 42]]multiply使用axis=1聚合：[   24  1680 11880]</code></pre><h2 id="3-3-其他函数"><a href="#3-3-其他函数" class="headerlink" title="3.3 其他函数"></a>3.3 其他函数</h2><p><code>where(condition, x, y)</code>：相当于 <code>x if condition else y</code>，只不过是矢量化对数组每一个元素操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;where之后为：\n<span class="hljs-subst">&#123;np.where(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-number">66</span>, <span class="hljs-number">11</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]where之后为：[[66 11 66 11 66] [11 66 11 66 11] [66 11 66 11 66]]</code></pre><ul><li><code>all()</code>：判断数组是否都是True，全为True返回True，否则返回False</li><li><code>any()</code>：判断数组是否存在True，有True返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.all(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;np.any(arr)为：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr)&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[87 73 24 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Truenp.any(arr)为：True[87 73  0 65 51 17 91 12 63  2 11  2 58 86 22 21  1  9 25 99]np.all(arr)为：Falsenp.any(arr)为：True</code></pre><p>结合布尔逻辑，判断是否存在符合条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 是否存在大于90的元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">any</span>(arr &gt; <span class="hljs-number">90</span>)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 是否全都大于10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;np.<span class="hljs-built_in">all</span>(arr &gt; <span class="hljs-number">10</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">TrueFalse</code></pre><ul><li><code>concatenate([arr1, arr2, arr3])</code>：拼接数组，要求维度相同</li><li><code>vstack()</code>&#x2F;<code>hstack()</code>：按列拼接，按行拼接</li></ul><p>二维数组拼接时，<code>axis</code>默认为0，沿行的方向按列拼接，1为按行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一维数组拼接：&#x27;</span>, np.concatenate([arr1, arr2]), end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br>arr3 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>arr4 = np.arange(<span class="hljs-number">10</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组1：\n&#x27;</span>, arr3, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组2：\n&#x27;</span>, arr4, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;二维数组拼接：\n&#x27;</span>, np.concatenate([arr3, arr4]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\naxis=1拼接：\n&#x27;</span>, np.concatenate([arr3, arr3], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">一维数组拼接： [1 2 3 4 5 6]数组1： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]数组2： [[0 1 2 3 4] [5 6 7 8 9]]二维数组拼接： [[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14] [ 0  1  2  3  4] [ 5  6  7  8  9]]axis=1拼接： [[ 0  1  2  3  4  0  1  2  3  4] [ 5  6  7  8  9  5  6  7  8  9] [10 11 12 13 14 10 11 12 13 14]]</code></pre><ul><li><code>split(arr, [断点位置])</code>：分割数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维数组</span><br>arr1 = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;分割点3, 5：&#x27;</span>, np.split(arr1, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]))<br><br><span class="hljs-comment"># 二维数组</span><br>arr2 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n按行平均分成3个数组：\n&#x27;</span>, np.split(arr2, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第3行分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">2</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n从第2列分割：\n&#x27;</span>, np.split(arr2, [<span class="hljs-number">1</span>], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">分割点3, 5： [array([0, 1, 2]), array([3, 4]), array([5, 6, 7, 8, 9])]按行平均分成3个数组： [array([[0, 1, 2, 3, 4]]), array([[5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第3行分割： [array([[0, 1, 2, 3, 4],       [5, 6, 7, 8, 9]]), array([[10, 11, 12, 13, 14]])]从第2列分割： [array([[ 0],       [ 5],       [10]]), array([[ 1,  2,  3,  4],       [ 6,  7,  8,  9],       [11, 12, 13, 14]])]</code></pre><ul><li><code>unique()</code>：去除重复元素，返回有序数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>np.unique(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 3, 5, 6])</code></pre><ul><li><code>copy()</code>：返回拷贝后的新数组，拷贝后的数组是独立的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>new_arr = np.copy(arr)<br>new_arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ul><li><code>append()</code>：数组末尾追加元素，返回新的数组</li><li><code>insert()</code>：指定位置插入元素，返回新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.append(arr, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;尾部追加元素：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br><br>new_arr = np.insert(arr, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;在下标2插入一个10：<span class="hljs-subst">&#123;new_arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[0 1 2 3 4]尾部追加元素：[ 0  1  2  3  4 10]在下标2插入一个10：[ 0  1 10  2  3  4]</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Numpy索引和布尔逻辑</title>
    <link href="/2024/08/13/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/"/>
    <url>/2024/08/13/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/02_Numpy%E7%B4%A2%E5%BC%95%E5%92%8C%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1 普通索引"></a>1 普通索引</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>和Python中的 <code>list</code>索引类似，在多维数组中有特色用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0][1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[-1][1]为：<span class="hljs-subst">&#123;arr[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 在一个[]内使用逗号分割</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[0, 1]为：<span class="hljs-subst">&#123;arr[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>) <span class="hljs-comment"># 等价于 arr[0][1]</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1 2 3] [4 5 6] [7 8 9]]arr[0][1]为：2arr[-1][1]为：8arr[0, 1]为：2</code></pre><h1 id="2-切片索引"><a href="#2-切片索引" class="headerlink" title="2 切片索引"></a>2 切片索引</h1><p>对于一维数组来说，切片索引与 <code>list</code>非常相似，语法为 <code>[起始索引, 结束索引, 步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:6:2]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5 6 7 8 9]arr[1:6:2]为：[2 4 6]</code></pre><p>对于二维数组来说，切片有些不同，语法为 <code>[起始行:结束行:步长, 起始列:结束列:步长]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[1:3, 0:3]为：\n<span class="hljs-subst">&#123;arr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">0</span>:<span class="hljs-number">3</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[1:3, 0:3]为：[[4 5 6] [7 8 9]]</code></pre><blockquote><p>注意：切片得到的是视图，而不是复制。</p></blockquote><h1 id="3-花式索引"><a href="#3-花式索引" class="headerlink" title="3 花式索引"></a>3 花式索引</h1><p>花式索引：将索引数组作为一个 <code>ndarray</code>的索引，这个索引数组可以是 <code>ndarray</code>，也可以是Python中的 <code>list</code>，<code>tuple</code>等可迭代类型。</p><p>一维数组就是依次取对应索引的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[1, -1, 2]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3 4 5]arr[[1, -1, 2]]为：[2 5 3]</code></pre><p>对于二维数组来说，需要两个数组参数，每个数组代表一个轴上的索引，按照两个轴的索引一一对应，取出对应值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 索引为[0, 1], [1, 2], [3, 0]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 3], [1, 2, 0]]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 如果其中一个轴的值一样，可以简化为一个值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[[0, 1, 2, 3], 1]为：\n<span class="hljs-subst">&#123;arr[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 1  2  3] [ 4  5  6] [ 7  8  9] [10 11 12]]arr[[0, 1, 3], [1, 2, 0]]为：[ 2  6 10]arr[[0, 1, 2, 3], 1]为：[ 2  5  8 11]</code></pre><p>对多个维度同样适用，和标准的索引一样，第一个索引指的是行，第二个索引指的是列。利用花哨的索引获得的<strong>结果形状与索引数组的形状一致</strong>，而不是与被索引数据的形状一致</p><p>花式索引结合切片索引，非常灵活，见下图：</p><p><img src="/../../../../ai_assets/02_slice_index.png" alt="png"></p><h1 id="4-布尔索引"><a href="#4-布尔索引" class="headerlink" title="4 布尔索引"></a>4 布尔索引</h1><p>布尔索引就是利用布尔数组作为掩码，利用数组的矢量化特性，选出原数组中所有 <code>True</code>对应的元素，而 <code>False</code>对应的元素不会被选中。布尔数组除了手动构造之外，还可以通过表达式生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br><br><span class="hljs-comment"># 指定布尔值</span><br>arr1 = arr[[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1为：<span class="hljs-subst">&#123;arr1&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 通过表达式生成</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr &gt; 5 为：\n<span class="hljs-subst">&#123;arr &gt; <span class="hljs-number">5</span>&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[arr &gt; 5]为：\n<span class="hljs-subst">&#123;arr[arr &gt; <span class="hljs-number">5</span>]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0 1 2 3 4 5 6 7 8 9]arr1为：[0 1 4 7 9]arr &gt; 5 为：[False False False False False False  True  True  True  True]arr[arr &gt; 5]为：[6 7 8 9]</code></pre><p><code>~</code>可以对布尔数组进行取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;~(arr &gt; 5)为：\n<span class="hljs-subst">&#123;~(arr &gt; <span class="hljs-number">5</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[~(arr &gt; 5)]为：\n<span class="hljs-subst">&#123;arr[~(arr &gt; <span class="hljs-number">5</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">~(arr &gt; 5)为：[ True  True  True  True  True  True False False False False]arr[~(arr &gt; 5)]为：[0 1 2 3 4 5]</code></pre><p>可以使用比较运算 <code>&gt; &lt;=</code>等，搭配逻辑运算 <code>&amp; |</code>筛选出符合条件的布尔数组，再将布尔数组作为掩码取出满足条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;(arr &gt; 5) &amp; (arr % 2 == 0)为：\n<span class="hljs-subst">&#123;(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) &amp; (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr[(arr &gt; 5) | (arr % 2 == 0)]为：\n<span class="hljs-subst">&#123;arr[(arr &gt; <span class="hljs-number">5</span>) | (arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(arr &gt; 5) &amp; (arr % 2 == 0)为：[False False False False False False  True False  True False]arr[(arr &gt; 5) &amp; (arr % 2 == 0)]为：[6 8]arr[(arr &gt; 5) | (arr % 2 == 0)]为：[0 2 4 6 7 8 9]</code></pre><p>搭配 <code>where()</code>函数，保留想要的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br>np.where(arr &gt; <span class="hljs-number">5</span>, arr, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 大于5的保留，否则替换为-1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([-1, -1, -1, -1, -1, -1,  6,  7,  8,  9])</code></pre><p>结合 <code>sum()</code>函数，统计符合条件的元素个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">5</code></pre><h1 id="5-内存关系"><a href="#5-内存关系" class="headerlink" title="5 内存关系"></a>5 内存关系</h1><ul><li>切片索引虽然创建了新的数组对象，但是新数组和原数组实际指向同一块内存，存在数据共享。</li><li>花式索引和布尔索引也会创建新的数组对象，不过新数组会完全复制原数组的元素，不存在数据共享。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br>arr_slice = arr[<span class="hljs-number">2</span>: <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 切片数组修改会影响原数组</span><br>arr_slice[<span class="hljs-number">2</span>] = <span class="hljs-number">66</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice为：<span class="hljs-subst">&#123;arr_slice&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 可以使用base查看来源</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_slice来源于：<span class="hljs-subst">&#123;arr_slice.base&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr来源于：<span class="hljs-subst">&#123;arr.base&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[0 1 2 3 4 5 6 7 8 9]arr_slice为：[2 3 4 5]arr为：[ 0  1  2  3 66  5  6  7  8  9]arr_slice为：[ 2  3 66  5]arr_slice来源于：[ 0  1  2  3 66  5  6  7  8  9]arr来源于：None</code></pre><h1 id="6-图像案例"><a href="#6-图像案例" class="headerlink" title="6 图像案例"></a>6 图像案例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/123.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b124cbb80&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 反向切片，反转图像</span><br>plt.imshow(img[::-<span class="hljs-number">1</span>, ::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b125bdcc0&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57_rev.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片抠图</span><br>plt.imshow(img[<span class="hljs-number">430</span>:<span class="hljs-number">610</span>, <span class="hljs-number">350</span>:<span class="hljs-number">510</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128501c0&gt;</code></pre><p><img src="/../../../../ai_assets/02_su57_big.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = plt.imread(<span class="hljs-string">r&#x27;assets/F35C.jpg&#x27;</span>)<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b128c2860&gt;</code></pre><p><img src="/../../../../ai_assets/02_f35.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片步长降采样</span><br>plt.imshow(img[<span class="hljs-number">3400</span>:<span class="hljs-number">4200</span>:<span class="hljs-number">15</span>, <span class="hljs-number">8000</span>:<span class="hljs-number">8300</span>:<span class="hljs-number">15</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x18b12954f70&gt;</code></pre><p><img src="/../../../../ai_assets/02_f35_big.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Numpy基础属性和方法</title>
    <link href="/2024/08/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2024/08/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/02%20Numpy%E5%9F%BA%E7%A1%80/01_Numpy%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>命令模式下的快捷键：</p><ul><li>Alt + Enter运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter运行当前单元格</li><li>j &#x2F; k、Shift + j &#x2F; Shift + k选中下方&#x2F;上方单元格、连续选中下方&#x2F;上方单元格</li><li>a &#x2F; b在下方&#x2F;上方插入新的单元格</li><li>c &#x2F; x复制单元格 &#x2F; 剪切单元格</li><li>v &#x2F; Shift + v在下方&#x2F;上方粘贴单元格</li><li>dd &#x2F; z删除单元格 &#x2F; 恢复删除的单元格</li><li>Shift + l显示或隐藏当前&#x2F;所有单元格行号</li><li>Space &#x2F; Shift + Space向下&#x2F;向上滚动页面</li></ul><p>编辑模式下的快捷键：</p><ul><li>Shift + Tab获得提示信息</li><li>Ctrl + ]&#x2F; Ctrl + [增加&#x2F;减少缩进</li><li>Alt + Enter运行当前单元格并在下面插入新的单元格</li><li>Shift + Enter运行当前单元格并选中下方的单元格</li><li>Ctrl + Enter运行当前单元格</li><li>Ctrl + Left &#x2F; Right光标移到行首&#x2F;行尾</li><li>Ctrl + Up &#x2F; Down光标移动代码开头&#x2F;结尾处</li><li>Up &#x2F; Down光标上移&#x2F;下移一行或移到上&#x2F;下一个单元格</li></ul><h1 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1 数组的创建"></a>1 数组的创建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><ol><li>使用 <code>array</code>函数，通过 <code>list</code>创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># array(list)</span><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>arr, <span class="hljs-built_in">type</span>(arr)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(array([1, 2, 3, 4, 5]), numpy.ndarray)</code></pre><ol start="2"><li>使用 <code>arange</code>函数，指定范围生成数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># arange(起始值, 结束值, 步长)</span><br>arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)  <br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><ol start="3"><li>使用 <code>linspace</code>函数，生成等差数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># linspace(起始值, 结束值, 元素个数)</span><br>arr = np.linspace(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 10.,  20.,  30.,  40.,  50.,  60.,  70.,  80.,  90., 100.])</code></pre><ol start="4"><li>使用 <code>logspace</code>函数，生成等比数列，元素为浮点型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># logspace(起始指数, 结束指数, num=元素个数, base=底数)</span><br><span class="hljs-comment"># 由起始指数、结束指数和底数确定起始值和结束值，在范围内根据元素个数自动推算公比</span><br>arr = np.logspace(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, num=<span class="hljs-number">5</span>, base=<span class="hljs-number">2</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([   4.,   16.,   64.,  256., 1024.])</code></pre><ol start="5"><li>使用 <code>fromstring</code>函数，从字符串提取数据创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fromstring(str, sep=’分隔符&#x27;, [dtype=&#x27;数据类型&#x27;])</span><br>arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1., 2., 3., 4., 5.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.fromstring(<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3, 4, 5])</code></pre><ol start="6"><li>使用 <code>random</code>函数生成随机数，创建数组对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># randint: 生成随机整数</span><br><span class="hljs-comment"># random.randint(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, size=<span class="hljs-number">5</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([8, 1, 3, 8, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uniform: 生成随机浮点数</span><br><span class="hljs-comment"># random.uniform(起始值, 结束值, size=形状)，size=可省略</span><br>arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[8.89013018, 9.11208169, 2.86415079, 1.87278992, 9.49237558],       [2.72498312, 2.42432246, 1.96473966, 5.23585378, 5.84650235],       [9.42765155, 7.01779665, 3.07567507, 6.34309282, 4.26517489]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># rand: 生成[0, 1)内的随机浮点数</span><br><span class="hljs-comment"># random.rand(数组形状shape)</span><br>arr = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0.25282566, 0.93635239, 0.02265436, 0.89447073],       [0.81152905, 0.70119062, 0.96435302, 0.53702331],       [0.34787245, 0.58961185, 0.61218228, 0.07453859]])</code></pre><ol start="7"><li>填充指定值的数组</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zeros: 填充为0</span><br>arr = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0., 0.],       [0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ones: 填充为1</span><br>arr = np.ones(<span class="hljs-number">10</span>, dtype=<span class="hljs-string">&#x27;i8&#x27;</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># full: 填充为指定值</span><br>arr = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">66</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[66, 66, 66, 66],       [66, 66, 66, 66],       [66, 66, 66, 66]])</code></pre><ol start="8"><li>使用 <code>eye</code>函数创建单位矩阵</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># eye(矩阵边长)</span><br>arr = np.eye(<span class="hljs-number">4</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1., 0., 0., 0.],       [0., 1., 0., 0.],       [0., 0., 1., 0.],       [0., 0., 0., 1.]])</code></pre><p>创建数组时可以通过 <code>dtype</code>指定数组内元素类型，Numpy的每种数据类型有不同位数的版本，可以使用首字母＋字节数简写，如 <code>i8</code>是占用8字节的 <code>int64</code>。</p><ul><li>有符号整数 <code>int</code></li><li>无符号整数 <code>uint</code></li><li>浮点数 <code>float</code></li><li>复数 <code>complex</code></li><li>布尔 <code>bool</code></li><li>字符串 <code>string_</code>或 <code>S</code></li><li>Python对象 <code>object</code></li><li>结构化数据类型 <code>void</code></li></ul><h1 id="2-数组的属性"><a href="#2-数组的属性" class="headerlink" title="2 数组的属性"></a>2 数组的属性</h1><p><code>size</code>：获取数组的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的size为：<span class="hljs-subst">&#123;arr1.size&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的size为：<span class="hljs-subst">&#123;arr2.size&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的size为：3[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的size为：12</code></pre><p><code>shape</code>：获取数组的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的shape为：<span class="hljs-subst">&#123;arr1.shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的shape为：<span class="hljs-subst">&#123;arr2.shape&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1 2 3]arr1的shape为：(3,)[[1 7 3 5] [3 1 5 4] [1 5 5 3]]arr2的shape为：(3, 4)</code></pre><p><code>dtype</code>：获取数组元素的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br>arr2 = np.random.rand(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的dtype为：<span class="hljs-subst">&#123;arr1.dtype&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的dtype为：<span class="hljs-subst">&#123;arr2.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的dtype为：int64[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的dtype为：float64</code></pre><p><code>ndim</code>：获取数组的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的ndim为：<span class="hljs-subst">&#123;arr1.ndim&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的ndim为：<span class="hljs-subst">&#123;arr2.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的ndim为：1[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的ndim为：2</code></pre><p><code>itemsize</code>：获取数组内每个元素所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的itemsize为：<span class="hljs-subst">&#123;arr1.itemsize&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的itemsize为：<span class="hljs-subst">&#123;arr2.itemsize&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的itemsize为：8[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的itemsize为：8</code></pre><p><code>nbytes</code>：获取数组所占空间的字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr1的nbytes为：<span class="hljs-subst">&#123;arr1.nbytes&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr2的nbytes为：<span class="hljs-subst">&#123;arr2.nbytes&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8 7 1]arr1的nbytes为：24[[0.31894463 0.32346793 0.66778377] [0.91600881 0.34240614 0.86570086]]arr2的nbytes为：48</code></pre><h1 id="3-数组的方法"><a href="#3-数组的方法" class="headerlink" title="3 数组的方法"></a>3 数组的方法</h1><h2 id="3-1-描述性统计"><a href="#3-1-描述性统计" class="headerlink" title="3.1 描述性统计"></a>3.1 描述性统计</h2><p>Numpy中很多常用方法既可以写成对象的方法调用，也可以写成模块函数的调用。</p><p><code>arr.method()</code>和 <code>np.function(arr)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,        27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,        40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,        53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,        66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,        79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,        92,  93,  94,  95,  96,  97,  98,  99, 100])</code></pre><ul><li><code>sum()</code>：求总和</li><li><code>mean()</code>：求算术平均值</li><li><code>median()</code>：求中位数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">sum</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;总和：<span class="hljs-subst">&#123;np.<span class="hljs-built_in">sum</span>(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;算术平均值：<span class="hljs-subst">&#123;np.mean(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中位数：<span class="hljs-subst">&#123;np.median(arr)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">总和：5050总和：5050算术平均值：50.5中位数：50.5</code></pre><ul><li><code>amax()</code>&#x2F;<code>max()</code>：求最大值</li><li><code>amin()</code>&#x2F;<code>min()</code>：求最小值</li><li><code>ptp()</code>：求全距，即最大值-最小值。</li><li><code>quantile(arr, 分位点)</code>：求分位数。比如0.5表示计算50%分位数，也就是中位数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">max</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值：<span class="hljs-subst">&#123;np.amax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;arr.<span class="hljs-built_in">min</span>()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值：<span class="hljs-subst">&#123;np.amin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;全距：<span class="hljs-subst">&#123;np.ptp(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;分位数：<span class="hljs-subst">&#123;np.quantile(arr, <span class="hljs-number">0.4</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">最大值：100最大值：100最小值：1最小值：1全距：99分位数：40.6</code></pre><ul><li><code>var()</code>：求方差</li><li><code>std()</code>：求标准差</li><li><code>arr.std() / arr.mean()</code>：求变异系数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;arr.var()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;方差：<span class="hljs-subst">&#123;np.var(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;arr.std()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;标准差：<span class="hljs-subst">&#123;np.std(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;变异系数：<span class="hljs-subst">&#123;arr.std() / arr.mean()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">方差：833.25方差：833.25标准差：28.86607004772212标准差：28.86607004772212变异系数：0.5716053474796459</code></pre><ul><li><code>argmax()</code>：返回最大值索引</li><li><code>argmin()</code>：返回最小值索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">66</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr为：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;np.argmax(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大值索引为：<span class="hljs-subst">&#123;arr.argmax()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;np.argmin(arr)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最小值索引为：<span class="hljs-subst">&#123;arr.argmin()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr为：[12  5 66  9  1]最大值索引为：2最大值索引为：2最小值索引为：4最小值索引为：4</code></pre><p>可以使用 <code>axis</code>对指定维度进行聚合，<code>axis</code>指定的是数组将会被折叠的维度，而不是将要返回的维度，因此 <code>axis=0</code>意味着沿着行方向的轴会被折叠，得到的是每列的聚合。</p><p><img src="/../../../../ai_assets/02_axis.png" alt="png"></p><p><code>axis</code>的值就是 <code>shape</code>中对应下标的维度。</p><p>一维数组中 <code>axis=0</code>：0向维度折叠，也就是按整个数组聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br>arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">np.int64(45)</code></pre><p>二维数组中：</p><ul><li><code>axis=0</code>：0向维度折叠，也就是把行折叠，按列进行统计</li><li><code>axis=1</code>：1向维度折叠，也就是把列折叠，按行进行统计</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按列统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按行统计：&#x27;</span>, arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]按列统计： [15 18 21 24 27]按行统计： [10 35 60]</code></pre><h2 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h2><ul><li><code>reshape()</code>：调整数组形状，注意返回的是原数组的视图，而不是拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：\n<span class="hljs-subst">&#123;arr&#125;</span>\n&#x27;</span>)<br><br>arr_shape = arr.reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_shape数组：\n<span class="hljs-subst">&#123;arr_shape&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单列数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单列数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br><span class="hljs-comment"># 变为二维单行数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;二维单行数组：\n<span class="hljs-subst">&#123;arr.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>)&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342 9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]arr_shape数组：[[3.16428678 1.85703697 8.08660982 3.30281002] [1.65160879 6.65371342 9.35288329 2.33650475] [5.72465209 9.37121035 9.87604912 4.20079867]]二维单列数组：[[3.16428678] [1.85703697] [8.08660982] [3.30281002] [1.65160879] [6.65371342] [9.35288329] [2.33650475] [5.72465209] [9.37121035] [9.87604912] [4.20079867]]二维单行数组：[[3.16428678 1.85703697 8.08660982 3.30281002 1.65160879 6.65371342  9.35288329 2.33650475 5.72465209 9.37121035 9.87604912 4.20079867]]</code></pre><ul><li><code>astype(数据类型)</code>：将数组元素转换为指定类型，返回一个新的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>, end=<span class="hljs-string">&#x27;\n\n&#x27;</span>)<br>arr_int = arr.astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr类型：<span class="hljs-subst">&#123;arr.dtype&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr_int类型：<span class="hljs-subst">&#123;arr_int.dtype&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原类型：float64arr类型：float64arr_int类型：int64</code></pre><ul><li><code>fill()</code>：向数组填充指定元素，修改数组本身</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr.fill(<span class="hljs-number">10</span>)<br>arr<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.])</code></pre><ul><li><code>sort()</code>：对原数组进行就地排序<ul><li><code>数组.sort()</code>：就地排序</li><li><code>np.sort(数组)</code>：排序返回新数组，原数组不变</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><br>arr_st = np.sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用np.sort()后的新数组：<span class="hljs-subst">&#123;arr_st&#125;</span>&#x27;</span>)<br><br>arr.sort()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;使用数组.sort()的原数组：<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的原数组：[7 2 7 7 8 5 6 6 7 5]使用np.sort()后的新数组：[2 5 5 6 6 7 7 7 7 8]使用数组.sort()的原数组：[2 5 5 6 6 7 7 7 7 8]</code></pre><ul><li><code>flatten()</code>：将多维数组扁平化为一维数组，返回一个新数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr原数组为：\n<span class="hljs-subst">&#123;arr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr.ndim&#125;</span>\n&#x27;</span>)<br><br>arr_f = arr.flatten()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;扁平化数组为：\n<span class="hljs-subst">&#123;arr_f&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;维度：<span class="hljs-subst">&#123;arr_f.ndim&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">arr原数组为：[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]维度：2扁平化数组为：[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]维度：1</code></pre><ul><li><code>tolist()</code>：将数组转化为 <code>list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = arr.tolist()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ls))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;list&#39;&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2024/08/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01%20MySQL%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/08/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/03%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/01%20MySQL%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据定义语言DDL"><a href="#1-数据定义语言DDL" class="headerlink" title="1 数据定义语言DDL"></a>1 数据定义语言DDL</h1><p>Data Definition Language：数据定义语言，用来定义数据库对象(数据库，表，字段)。</p><h2 id="1-1-库操作"><a href="#1-1-库操作" class="headerlink" title="1.1 库操作"></a>1.1 库操作</h2><p><strong>创建数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [CHARSET <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;utf8&#x27;</span>];<br></code></pre></td></tr></table></figure><p><strong>显示所有库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure><p><strong>使用指定数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure><p><strong>删除指定数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名<br></code></pre></td></tr></table></figure><h2 id="1-2-表操作"><a href="#1-2-表操作" class="headerlink" title="1.2 表操作"></a>1.2 表操作</h2><h3 id="1-2-1-创建表"><a href="#1-2-1-创建表" class="headerlink" title="1.2.1 创建表"></a>1.2.1 创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>    字段名<span class="hljs-number">1</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">1</span>注释],<br>    字段名<span class="hljs-number">2</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">2</span>注释],<br>    字段名<span class="hljs-number">3</span> 数据类型 [约束] [COMMENT 字段<span class="hljs-number">3</span>注释]<br>) [COMMENT 表注释]<br></code></pre></td></tr></table></figure><p>常用主键自增 <code>AUTO_INCREMENT</code>。</p><ul><li>常用数据类型：<ul><li>整数：<code>INT</code></li><li>字符串：<code>VARCHAR(长度)</code></li><li>小数：<code>DECIMAL(总位数, 小数位)</code></li><li>时间：<code>DATETIME</code></li></ul></li><li>常用约束<ul><li>主键：<code>PRIMARY KEY</code></li><li>非空：<code>NOT NULL</code></li><li>唯一：<code>UNIQUE</code></li><li>默认：<code>DEFAULT</code></li><li>外键：<code>FOREIGN KEY</code>（影响效率）</li></ul></li></ul><h3 id="1-2-2-查询表"><a href="#1-2-2-查询表" class="headerlink" title="1.2.2 查询表"></a>1.2.2 查询表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询当前数据库所有表<br><span class="hljs-keyword">SHOW</span> TABLES;<br><br># 查询表结构<br><span class="hljs-keyword">DESC</span> 表名;<br><br># 查询建表语句<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h3 id="1-2-3-修改表"><a href="#1-2-3-修改表" class="headerlink" title="1.2.3 修改表"></a>1.2.3 修改表</h3><p><strong>增加字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 [约束];<br></code></pre></td></tr></table></figure><p><strong>删除字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br></code></pre></td></tr></table></figure><p><strong>修改字段类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 MODIFY 字段名 新类型;<br></code></pre></td></tr></table></figure><p><strong>修改字段名和类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 [约束];<br></code></pre></td></tr></table></figure><p><strong>修改表名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 旧表名 RENAME 新表名;<br></code></pre></td></tr></table></figure><h3 id="1-2-4-删除表"><a href="#1-2-4-删除表" class="headerlink" title="1.2.4 删除表"></a>1.2.4 删除表</h3><p><strong>删除整个表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>删除数据保留表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 主键自增序列不清零<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名;<br><br># 主键自增序列清零<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h1 id="2-数据操作语言DML"><a href="#2-数据操作语言DML" class="headerlink" title="2 数据操作语言DML"></a>2 数据操作语言DML</h1><p>Data Manipulation Language：数据操作语言，用来对数据库中表的数据记录进行增、删、改操作。</p><h2 id="2-1-增加INSERT"><a href="#2-1-增加INSERT" class="headerlink" title="2.1 增加INSERT"></a>2.1 增加INSERT</h2><p><strong>向指定字段添加数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>全部字段添加数据：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p><strong>批量添加数据（指定字段）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>批量添加数据（全部字段）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> 表名 <span class="hljs-keyword">VALUES</span> <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), <br>    (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><h2 id="2-2-删除DELETE"><a href="#2-2-删除DELETE" class="headerlink" title="2.2 删除DELETE"></a>2.2 删除DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h2 id="2-3-修改UPDATE"><a href="#2-3-修改UPDATE" class="headerlink" title="2.3 修改UPDATE"></a>2.3 修改UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span> , 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span><br>[<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h1 id="3-数据查询语言DQL"><a href="#3-数据查询语言DQL" class="headerlink" title="3 数据查询语言DQL"></a>3 数据查询语言DQL</h1><p>Data Query Language：数据查询语言，用来查询数据库表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br><span class="hljs-keyword">HAVING</span> 分组后条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 排序字段<br>LIMIT 分页参数;<br></code></pre></td></tr></table></figure><ol><li><code>FROM</code> 加载数据</li><li><code>WHERE</code> 对加载后的数据进行筛选</li><li><code>GROUP BY</code> 对筛选后的数据进行分组</li><li><code>HAVING</code> 对分组后的数据进行筛选</li><li><code>SELECT</code> 返回要查询的字段</li><li><code>ORDER BY</code> 对结果进行排序</li><li><code>LIMIT</code> 限制返回结果</li></ol><h2 id="3-1-基础查询"><a href="#3-1-基础查询" class="headerlink" title="3.1 基础查询"></a>3.1 基础查询</h2><p><strong>通用格式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure><p><strong>查询所有字段：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>查询结果去重：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>比较运算符 <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code>都和Python相同，另有不同的有如下：<ul><li><code>字段 BETWEEN 最小值 AND 最大值</code>：在最小值和最大值范围内即可</li><li><code>字段 IN (值1, 值2...)</code>：在 <code>()</code>内满足任意即可</li><li><code>字段 LIKE &quot;占位符&quot;</code>：模糊查询，可以用 <code>_</code>代表一个字符，<code>%</code>代表任意个字符</li><li><code>IS NULL</code>：判空专用</li></ul></li><li>逻辑运算符：<ul><li><code>AND</code></li><li><code>OR</code></li><li><code>NOT</code></li></ul></li></ul><h2 id="3-2-聚合查询"><a href="#3-2-聚合查询" class="headerlink" title="3.2 聚合查询"></a>3.2 聚合查询</h2><p>前面的查询都是横向查询，根据条件一行一行的进行判断。<br>聚合函数查询是纵向查询，它将一列数据作为一个整体，进行纵向计算，然后返回一个结果值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>：按照列统计数量</li><li><code>MAX()</code>：按照列计算最大值</li><li><code>MIN()</code>：按照列计算最小值</li><li><code>AVG()</code>：按照列计算平均值</li><li><code>SUM()</code>：按照列计算数值和</li></ul><h2 id="3-3-分组查询"><a href="#3-3-分组查询" class="headerlink" title="3.3 分组查询"></a>3.3 分组查询</h2><p>按列进行分类，把相同的数据归为一类，然后可以对分类完的数据进行合并计算。</p><p>通常和聚合函数联合使用：</p><ol><li>先分组：把表数据按照指定列的值进行划分，值相同的数据划分到同一个组</li><li>再聚合：分别针对每一组数据使用聚合函数进行统计</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [聚合函数, 分组字段]<br>[<span class="hljs-keyword">WHERE</span> 条件]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段<br>[<span class="hljs-keyword">HAVING</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><p><code>WHERE</code>与 <code>HAVING</code>区别：</p><ul><li>执行时机不同：<ul><li><code>WHERE</code>是分组之前进行过滤，不满足 <code>WHERE</code>条件，不参与分组</li><li><code>HAVING</code> 是分组之后对结果进行过滤</li></ul></li><li>判断条件不同：<ul><li><code>WHERE</code> 不能对聚合函数进行判断</li><li><code>HAVING</code> 可以对聚合函数进行判断</li></ul></li></ul><h2 id="3-4-排序查询"><a href="#3-4-排序查询" class="headerlink" title="3.4 排序查询"></a>3.4 排序查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式, 字段<span class="hljs-number">2</span> 排序方式;<br></code></pre></td></tr></table></figure><p>排序方式：<br><code>ASC</code>：升序（默认值）<br><code>DESC</code>：降序</p><h2 id="3-5-分页查询"><a href="#3-5-分页查询" class="headerlink" title="3.5 分页查询"></a>3.5 分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br>LIMIT [起始行数,] 总行数;<br></code></pre></td></tr></table></figure><h1 id="4-多表查询"><a href="#4-多表查询" class="headerlink" title="4 多表查询"></a>4 多表查询</h1><p>多表查询 <code>SELECT 字段 FROM 表1, 表2</code>会产生笛卡尔积，也就是两个表的所有组合情况。要想消除笛卡尔积，只需要给多表查询加上连接查询的条件即可。</p><h2 id="4-1-连接查询"><a href="#4-1-连接查询" class="headerlink" title="4.1 连接查询"></a>4.1 连接查询</h2><h3 id="4-1-1-内连接"><a href="#4-1-1-内连接" class="headerlink" title="4.1.1 内连接"></a>4.1.1 内连接</h3><p><strong>隐式内连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>], 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p><strong>显式内连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br>[<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>内连接只能返回两个表中都存在匹配的行。</p><h3 id="4-1-2-外连接"><a href="#4-1-2-外连接" class="headerlink" title="4.1.2 外连接"></a>4.1.2 外连接</h3><p><strong>左外连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>左外连接是以左表为中心，返回左表所有行，以及右表匹配的行。即使右表没有匹配，则对应列显示 <code>NULL</code>。</p><p><strong>右外连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>]<br><span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> [[<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span>]<br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p>右外连接是以右表为中心，返回右表所有行，以及左表匹配的行。即使左表没有匹配，则对应列显示 <code>NULL</code>。<br><img src="/../../../../ai_assets/Pasted%20image%2020250925231426.png"></p><h3 id="4-1-3-全连接"><a href="#4-1-3-全连接" class="headerlink" title="4.1.3 全连接"></a>4.1.3 全连接</h3><p>全连接 <code>FULL OUTER JOIN</code>是取两个表的并集，MySQL本身并不支持全连接，但可以借助 <code>UNION</code>实现。</p><p><code>UNION</code>合并，并且去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><p><code>UNION ALL</code>合并但不去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><blockquote><p>在多表连接中，如果两个表的连接字段名相同，可以不使用 <code>ON a.id = b.id</code>，而使用更简洁的 <code>USING(id)</code>代替。</p></blockquote><h2 id="4-2-子查询"><a href="#4-2-子查询" class="headerlink" title="4.2 子查询"></a>4.2 子查询</h2><p>将查询的结果作为外部<strong>查询的条件、字段或表</strong>来使用，称为嵌套查询，又称子查询。子查询用来提供值、集合或表给外查询作比较或进一步处理。</p><h3 id="4-2-1-常见分类"><a href="#4-2-1-常见分类" class="headerlink" title="4.2.1 常见分类"></a>4.2.1 常见分类</h3><ul><li>相关子查询（Correlated Subquery）<ul><li>子查询<strong>内部引用外查询的列</strong>，子查询需要对外查询的每一行重新计算，每行执行效率较低</li></ul></li><li>非相关子查询（Non-correlated）<ul><li>子查询<strong>独立于外查询</strong>，单独执行一次得到结果，外查询再使用该结果</li></ul></li><li>按返回结果类型<ul><li>标量子查询（Scalar）：返回单个值（单行单列）。可用于 <code>= (子查询)</code>、<code>SELECT (子查询)</code> 等场景，若返回多行则报错</li><li>单行多列子查询：返回一行，通常用 <code>(a, b) = (SELECT x, y ...)</code> 方式比较</li><li>多行单列子查询：返回多行，通常用 <code>IN</code>、<code>ANY</code>、<code>SOME</code>、<code>EXISTS</code></li><li>多行多列子查询：返回多行多列，用 <code>(a, b) IN (SELECT x, y ...)</code> 方式比较，或<strong>当做派生表</strong>处理</li></ul></li></ul><h3 id="4-2-2-常用关键字"><a href="#4-2-2-常用关键字" class="headerlink" title="4.2.2 常用关键字"></a>4.2.2 常用关键字</h3><ul><li><code>IN</code>：判断一个值<strong>是否在集合</strong>里<ul><li><code>salary IN (SELECT salary FROM …)</code></li></ul></li><li><code>EXISTS</code>：判断是否存在<strong>至少一行</strong>结果<ul><li><code>EXISTS (SELECT 1 FROM …)</code></li></ul></li><li><code>ANY/SOME</code>：和集合中<strong>至少一个值</strong>比较<ul><li><code>salary &gt; ANY (SELECT salary FROM …)</code></li></ul></li><li><code>ALL</code>：和集合中<strong>所有值</strong>比较<ul><li><code>salary &gt; ALL (SELECT salary FROM …)</code></li></ul></li></ul><blockquote><p><code>NOT IN</code> 与 <code>NULL</code> 会导致结果为空集，常用 <code>NOT EXISTS</code> 来代替 <code>NOT IN</code>。</p></blockquote><h3 id="4-2-3-示例"><a href="#4-2-3-示例" class="headerlink" title="4.2.3 示例"></a>4.2.3 示例</h3><p><strong>标量子查询：</strong> 子查询只返回一个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 非相关标量子查询<br># 查询工资高于平均工资的员工姓名和工作<br><span class="hljs-keyword">SELECT</span> <br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <br>        <span class="hljs-keyword">FROM</span> emp<br>    );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 相关标量子查询<br># 查询工资高于本部门平均工资的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span> <br>    emp <span class="hljs-keyword">AS</span> e<br><span class="hljs-keyword">WHERE</span><br>    salary <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-operator">=</span> e.dept_id  # 子查询内部引用外部列<br>    );<br></code></pre></td></tr></table></figure><p><strong>多行多列子查询：</strong> 子查询返回多行多列数据，通常需要与 <code>IN</code>搭配使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span><br>    name,<br>    salary<br><span class="hljs-keyword">FROM</span><br>    emp<br><span class="hljs-keyword">WHERE</span><br>    (dept, salary) <span class="hljs-keyword">IN</span> (<br>        <span class="hljs-keyword">SELECT</span> dept, <span class="hljs-built_in">MAX</span>(salary)<br>        <span class="hljs-keyword">FROM</span> emp<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept<br>    );<br></code></pre></td></tr></table></figure><p><strong>派生表：</strong> 子查询结果作为派生表使用，通常需要起别名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询每个部门工资最高的员工姓名和工资<br><span class="hljs-keyword">SELECT</span> e.name, e.dept_id, e.salary<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> dept_id, <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">AS</span> max_salary<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_id<br>) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">ON</span> e.dept_id <span class="hljs-operator">=</span> t.dept_id<br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-operator">=</span> t.max_salary;<br></code></pre></td></tr></table></figure><h1 id="5-开窗函数"><a href="#5-开窗函数" class="headerlink" title="5 开窗函数"></a>5 开窗函数</h1><p>MySQL 窗口函数（Window Functions）是 MySQL 8.0 引入的一项强大功能，窗口函数的作用类似于聚合函数，但它并不会像 <code>GROUP BY</code> 那样把多行聚合成一行，它会在原有表基础上，为<strong>每一行添加一个新列</strong>，返回计算结果。</p><ul><li><code>PARTITION BY</code>：将查询结果分成若干个<strong>独立的窗口（分区）</strong>，窗口函数会分别在每个分区上进行计算，类似于 <code>GROUP BY</code>，但它不合并行。</li><li><code>ORDER BY</code>：确定窗口内的顺序，对排名 &#x2F; 偏移函数非常重要。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqlFIRST_VAL">SELECT 字段列表,<br>函数() OVER(<br>    [PARTITION BY 分区列表]<br>    [ORDER BY 排序列表]<br>) [[AS] 别名]<br></code></pre></td></tr></table></figure><p>每加一个开窗函数，就可以在原有表基础上新增一列，具体取决于选用什么函数。</p><ul><li>排名函数<ul><li><code>ROW_NUMBER()</code>：为分区的每一行分配一个<strong>唯一</strong>的连续整数。1 2 3 4</li><li><code>RANK()</code>：为分区每一行分配排名，有相同排名，但会<strong>跳过后续排名</strong>。 1 2 2 4</li><li><code>DENSE_RANK()</code>：为分区每一行分配排名，有相同排名且<strong>连续</strong>。1 2 2 3</li></ul></li><li>分析&#x2F;位移函数<ul><li><code>LAG(expr, N)</code>：返回当前行<strong>前面第N行</strong>的 <code>expr</code>值，比如计算销售额与前N天的差异。</li><li><code>LEAD(expr, N)</code>：返回当前行<strong>后面第N行</strong>的 <code>expr</code>值，比如计算销售额与后N天的差异。</li><li><code>FIRST_VALUE(expr)</code>：返回窗口框架中<strong>第一行</strong>的 <code>expr</code>值，比如找出每个部门的最高薪水。</li><li><code>LAST_VALUE(expr)</code>：返回窗口框架中<strong>最后一行</strong>的 <code>expr</code>值，比如找出每个部门的最低薪水。</li></ul></li><li>聚合函数<ul><li><code>SUM()</code>：计算窗口内的总和</li><li><code>AVG()</code>：计算窗口内的平均值</li><li>…</li></ul></li></ul><p>窗口函数<strong>只能出现在 <code>SELECT</code>列表和 <code>ORDER BY</code>中</strong>（不能在 <code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code> 中直接使用，因为这些子句在 <code>SELECT</code>之前就执行了，而窗口函数是在 <code>SELECT</code>阶段才计算的）。</p><p>如果需要对窗口结果做过滤，应该使用子查询或 CTE。</p><p><strong>经典TOP-N问题：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> id, name, dept, salary,<br>    <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> dept <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span><br>    ) <span class="hljs-keyword">AS</span> rn<br>    <span class="hljs-keyword">FROM</span> employees<br>) t<br><span class="hljs-keyword">WHERE</span> rn <span class="hljs-operator">&lt;=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h1 id="6-CTE"><a href="#6-CTE" class="headerlink" title="6 CTE"></a>6 CTE</h1><p><strong>CTE（Common Table Expression，公共表表达式）</strong>就是<strong>临时结果集</strong>，可以在一个查询里先把它定义出来，在后续查询中使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cte_name  <span class="hljs-keyword">AS</span> (<br>    子查询<br>)<br><br><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> cte_name<br><span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据处理与分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13_Python数据结构与算法</title>
    <link href="/2024/08/08/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/08/08/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/13_Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>鉴于C++章节已做详细说明，本节只做记录，不做详细讲解。</p><h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h1><h2 id="1-1-栈"><a href="#1-1-栈" class="headerlink" title="1.1 栈"></a>1.1 栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;栈顶-&gt; &#x27;</span> + <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items[::-<span class="hljs-number">1</span>]))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断栈是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入栈&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;栈为空，不能执行 top 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    st = Stack()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取栈顶&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、返回栈的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、遍历栈&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入栈的元素：&#x27;</span>).strip()<br>                    st.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出栈</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出栈成功，当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取栈顶</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = st.top()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈顶元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> st.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前栈非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 返回栈的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;栈中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(st)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 遍历栈</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前栈为：<span class="hljs-subst">&#123;st&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-2-队列"><a href="#1-2-队列" class="headerlink" title="1.2 队列"></a>1.2 队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队列为空&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;队首-&gt; &#x27;</span> + <span class="hljs-string">&#x27;-&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.items)) + <span class="hljs-string">&#x27; &lt;-队尾&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断队列是否为空</span><br><span class="hljs-string">        :return: 空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;入队&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.items.append(data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;出队&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 pop 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">front</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队首元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 front 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;队列为空，不能执行 rear 操作！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、入队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、出队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、取队首&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、取队尾&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、判断是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、返回队列的大小&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、遍历队列&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 入队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要入队列的元素：&#x27;</span>).strip()<br>                    q.push(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;入队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 出队</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.pop()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;元素<span class="hljs-subst">&#123;x&#125;</span>出队成功，当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 取队首</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.front()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队首元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 取队尾</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = q.rear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队尾元素为：<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 判断是否为空</span><br>                <span class="hljs-keyword">if</span> q.empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前队列非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 返回队列的大小</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;队列中有<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(q)&#125;</span>个元素&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 遍历队列</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前队列为：<span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-3-单链表"><a href="#1-3-单链表" class="headerlink" title="1.3 单链表"></a>1.3 单链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        elem = [data <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>]  <span class="hljs-comment"># 借助 迭代器 使用 列表推导式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, elem)) + <span class="hljs-string">&#x27;-&gt;None&#x27;</span> <span class="hljs-keyword">if</span> elem <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;空链表&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">yield</span> current.data<br>            current = current.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            <span class="hljs-variable language_">self</span>.tail.<span class="hljs-built_in">next</span> = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prepend</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;链表头部添加元素&quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head:  <span class="hljs-comment"># 有头结点</span><br>            new_node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-variable language_">self</span>.head = new_node<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 无头结点，空链表</span><br>            <span class="hljs-variable language_">self</span>.head = new_node<br>            <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, data, pos</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        向链表指定下标插入元素</span><br><span class="hljs-string">        :param data: 要插入的元素值</span><br><span class="hljs-string">        :param pos: 要插入的下标，从0开始</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 处理越界问题</span><br>        <span class="hljs-keyword">if</span> pos &gt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>) <span class="hljs-keyword">or</span> pos &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;索引超出界限！&#x27;</span>)<br><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 处理插入头结点和空链表插入的特殊情况</span><br>        <span class="hljs-keyword">if</span> pos == <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.prepend(data)<br>        <span class="hljs-comment"># 其他情况</span><br>        <span class="hljs-keyword">else</span>:<br>            current = <span class="hljs-variable language_">self</span>.head<br>            <span class="hljs-comment"># 遍历到要插入位置的前一个节点</span><br>            <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pos - <span class="hljs-number">1</span>):<br>                current = current.<span class="hljs-built_in">next</span><br><br>            new_node.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span> = new_node<br><br>            <span class="hljs-comment"># 如果插入到了尾节点，维护tail</span><br>            <span class="hljs-keyword">if</span> new_node.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-variable language_">self</span>.tail = new_node<br><br>        <span class="hljs-comment"># 更新链表长度</span><br>        <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        删除链表中值为data的指定数量的节点</span><br><span class="hljs-string">        :param data: 要删除的值</span><br><span class="hljs-string">        :param num: 要删除的数量，1为默认，0表示删除所有</span><br><span class="hljs-string">        :return: 返回删除成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 1、处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法删除！&#x27;</span>)<br><br>        <span class="hljs-comment"># 已删节点数</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 2、处理头结点为目标值的情况</span><br>        <span class="hljs-comment"># 有头结点 且 头结点数据=要删除的数据 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.head.data == data <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-variable language_">self</span>.head = <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span><br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 更新链表长度</span><br>            <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 3、链表被删除为空，更新尾节点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 4、处理后续节点为目标值的情况</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空 且 有下一个节点 且 （要删除所有 或 已删除数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>.data == data:<br>                <span class="hljs-comment"># 删除下一个节点，导致当前节点的下一个节点已经改变</span><br>                current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 更新链表长度</span><br>                <span class="hljs-variable language_">self</span>.size -= <span class="hljs-number">1</span><br><br>                <span class="hljs-comment"># 如果删除了尾结点，需要更新当前节点为尾结点</span><br>                <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-variable language_">self</span>.tail = current<br>            <span class="hljs-comment"># 只有没删除节点时才移动</span><br>            <span class="hljs-keyword">else</span>:<br>                current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">replace</span>(<span class="hljs-params">self, data, new_data, num=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        修改并替换链表中的指定值为新值</span><br><span class="hljs-string">        :param data: 要修改的值</span><br><span class="hljs-string">        :param new_data: 修改后的新值</span><br><span class="hljs-string">        :param num: 修改num个，1为默认，0表示替换所有</span><br><span class="hljs-string">        :return: 返回修改成功的数目</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 处理链表为空的情况</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前链表为空，无法修改！&#x27;</span>)<br><br>        cnt = <span class="hljs-number">0</span><br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-comment"># 当前节点非空  且 （要替换所有 或 已替换数目&lt;要删除数目）</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> (num == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt &lt; num):<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                current.data = new_data<br>                cnt += <span class="hljs-number">1</span><br>            current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data, <span class="hljs-built_in">all</span>=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        查找链表指定元素的位置</span><br><span class="hljs-string">        :param data: 要查找的元素</span><br><span class="hljs-string">        :param all: 是否要查询所有符合条件的下标，True表示查询所有，False只查询一个，默认为False</span><br><span class="hljs-string">        :return: 返回下标位置，没找到抛出ValueError错误</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        idx = <span class="hljs-number">0</span><br>        idxes = []<br>        current = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">if</span> current.data == data:<br>                <span class="hljs-comment"># 查找全部符合条件的下标</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>:<br>                    idxes.append(idx)<br>                <span class="hljs-comment"># 只查一个下标</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> idx<br>            current = current.<span class="hljs-built_in">next</span><br>            idx += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> idxes:<br>            <span class="hljs-keyword">return</span> idxes<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;未找到值为<span class="hljs-subst">&#123;data&#125;</span>的节点！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        判断链表是否为空</span><br><span class="hljs-string">        :return: 为空返回True，否则返回False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;清空当前链表&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ls = LinkedList()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、链表尾部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、链表头部插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、指定下标插入元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、删除链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、修改链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找链表元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、显示链表长度&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、显示所有元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、查询链表是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;10、清空链表&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 链表尾部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.append(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 链表头部插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>)<br>                    ls.prepend(x)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 指定下标插入元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    x, pos = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值和下标（从0开始）：&#x27;</span>).strip().split()<br>                    ls.insert(x, <span class="hljs-built_in">int</span>(pos))<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;插入成功，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 删除链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要删除的元素值 [可选：删除个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">1</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.remove(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功删除<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 修改链表元素</span><br>                <span class="hljs-keyword">try</span>:<br>                    elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要替换的元素值和替换后的新值 [可选：替换个数]：&#x27;</span>).strip().split()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">3</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(elems[<span class="hljs-number">2</span>]))<br>                    <span class="hljs-keyword">else</span>:<br>                        n = ls.replace(elems[<span class="hljs-number">0</span>], elems[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;成功将<span class="hljs-subst">&#123;n&#125;</span>个值为<span class="hljs-subst">&#123;elems[<span class="hljs-number">0</span>]&#125;</span>的节点替换为<span class="hljs-subst">&#123;elems[<span class="hljs-number">1</span>]&#125;</span>，当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找链表元素</span><br>                elems = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素 [可选：是否查询所有]：&#x27;</span>).strip().split()<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">2</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>], <span class="hljs-literal">True</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        i = ls.find(elems[<span class="hljs-number">0</span>])<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功！该元素下标为<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 显示链表长度</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;链表长度为：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(ls)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 显示所有元素</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前链表为：<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 查询链表是否为空</span><br>                <span class="hljs-keyword">if</span> ls.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表为空！&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前链表非空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;10&#x27;</span>:  <span class="hljs-comment"># 清空链表</span><br>                <span class="hljs-keyword">try</span>:<br>                    ls.clear()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;链表清空成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.upper() == <span class="hljs-string">&#x27;Y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="1-4-二叉树"><a href="#1-4-二叉树" class="headerlink" title="1.4 二叉树"></a>1.4 二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-comment"># 闭包捕获异常</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exception</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;错误：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        <span class="hljs-variable language_">self</span>.val = val<br>        <span class="hljs-variable language_">self</span>.left = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.right = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Node(<span class="hljs-subst">&#123;self.val&#125;</span>)&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Node(val=<span class="hljs-subst">&#123;self.val&#125;</span>, left=<span class="hljs-subst">&#123;self.left.val <span class="hljs-keyword">if</span> self.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>, right=<span class="hljs-subst">&#123;self.right.val <span class="hljs-keyword">if</span> self.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>)&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        向二叉树插入新元素，以逐层遍历的方式找到第一个出现的叶子结点插入</span><br><span class="hljs-string">        只用此方法构建二叉树，会构建出完全二叉树</span><br><span class="hljs-string">        :param data: 要插入的值</span><br><span class="hljs-string">        :return: 无</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_node = Node(data)<br><br>        <span class="hljs-comment"># 空树特殊处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-variable language_">self</span>.root = new_node<br>            <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 用队列实现逐层遍历，先将根节点入队</span><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])  <span class="hljs-comment"># 借助双端队列实现</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 取出队首元素</span><br>            node = queue.popleft()  <span class="hljs-comment"># O(1)时间完成</span><br><br>            <span class="hljs-comment"># 左子树非空，则将左子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-comment"># 左子树为空，将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.left = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-comment"># 右子树非空，则将右子树入队等待搜索</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br>            <span class="hljs-comment"># 右子树为空，则将新节点放入该位置，返回</span><br>            <span class="hljs-keyword">else</span>:<br>                node.right = new_node<br>                <span class="hljs-variable language_">self</span>.size += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;广度优先搜索，逐层遍历&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        res = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 取出当前节点</span><br>            node = queue.popleft()<br>            res.append(node.val)<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入队列，等待访问</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__preorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__preorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;私有方法，执行递归逻辑。先序遍历，根左右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 遍历结果放入列表</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__preorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__inorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__inorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;中序遍历，左根右顺序&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.left, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__inorder(root.right, res)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;包装方法，处理初始调用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        <span class="hljs-comment"># 存放遍历结果</span><br>        res = []<br>        <span class="hljs-variable language_">self</span>.__postorder(<span class="hljs-variable language_">self</span>.root, res)<br><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__postorder</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-comment"># 有左子树访问左子树</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.left, res)<br>        <span class="hljs-comment"># 有右子树访问右子树</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            <span class="hljs-variable language_">self</span>.__postorder(root.right, res)<br>        <span class="hljs-comment"># 输出当前节点的值</span><br>        res.append(root.val)<br><br><span class="hljs-meta">    @catch_exception</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在二叉树查找指定元素</span><br><span class="hljs-string">        :param data: 待查找的元素</span><br><span class="hljs-string">        :return: 返回该元素所在节点</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_empty():<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;当前树为空！&#x27;</span>)<br><br>        queue = deque([<span class="hljs-variable language_">self</span>.root])<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            node = queue.popleft()<br><br>            <span class="hljs-comment"># 查找到目标元素，返回该节点</span><br>            <span class="hljs-keyword">if</span> node.val == data:<br>                <span class="hljs-keyword">return</span> node<br><br>            <span class="hljs-comment"># 有左子树，将左子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br><br>            <span class="hljs-comment"># 有右子树，将右子树加入搜索队列</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;找不到该元素！&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size == <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    bt = BinaryTree()<br>    bt.add(<span class="hljs-string">&#x27;10&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;15&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;20&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;30&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;45&#x27;</span>)<br>    bt.add(<span class="hljs-string">&#x27;65&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、二叉树添加节点&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、逐层遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、先序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4、中序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;5、后序遍历&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;6、查找元素&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;7、返回节点数&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;8、树是否为空&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;9、清空树&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0、退出程序&#x27;</span>)<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要执行的操作：&#x27;</span>).strip()<br>        <span class="hljs-keyword">match</span> op:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:  <span class="hljs-comment"># 二叉树添加节点</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要插入的元素值：&#x27;</span>).strip()<br>                flag = bt.add(x)<br>                <span class="hljs-keyword">if</span> flag:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;插入成功！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:  <span class="hljs-comment"># 逐层遍历</span><br>                ls = bt.bfs()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;逐层遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:  <span class="hljs-comment"># 先序遍历</span><br>                ls = bt.preorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;先序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:  <span class="hljs-comment"># 中序遍历</span><br>                ls = bt.inorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;中序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:  <span class="hljs-comment"># 后序遍历</span><br>                ls = bt.postorder()<br>                <span class="hljs-keyword">if</span> ls:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;后序遍历的结果为：<span class="hljs-subst">&#123;<span class="hljs-string">&quot;-&gt;&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ls))&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:  <span class="hljs-comment"># 查找元素</span><br>                x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要查找的元素值：&#x27;</span>).strip()<br>                addr = bt.find(x)<br>                <span class="hljs-keyword">if</span> addr:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;查找成功，该元素所在节点为：<span class="hljs-subst">&#123;addr&#125;</span>&#x27;</span>)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;左孩子值为：<span class="hljs-subst">&#123;addr.left.val <span class="hljs-keyword">if</span> addr.left <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>  右孩子值为：<span class="hljs-subst">&#123;addr.right.val <span class="hljs-keyword">if</span> addr.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:  <span class="hljs-comment"># 返回节点数</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;当前节点数：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(bt)&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:  <span class="hljs-comment"># 树是否为空</span><br>                <span class="hljs-keyword">if</span> bt.is_empty():<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树为空&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树非空&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:  <span class="hljs-comment"># 清空树</span><br>                bt.clear()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前树已清空！&#x27;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 退出程序</span><br>                con = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;确认要退出吗？(y/n)&#x27;</span>)<br>                <span class="hljs-keyword">if</span> con.lower() == <span class="hljs-string">&#x27;y&#x27;</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该操作不存在！&#x27;</span>)<br><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h1 id="2-排序"><a href="#2-排序" class="headerlink" title="2 排序"></a>2 排序</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>        swaped = <span class="hljs-literal">False</span>  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - i - <span class="hljs-number">1</span>):  <br>            <span class="hljs-keyword">if</span> ls[j] &gt; ls[j + <span class="hljs-number">1</span>]:  <br>                ls[j], ls[j + <span class="hljs-number">1</span>] = ls[j + <span class="hljs-number">1</span>], ls[j]  <br>                swaped = <span class="hljs-literal">True</span>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> swaped:  <br>            <span class="hljs-keyword">break</span>  <br></code></pre></td></tr></table></figure><h2 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):  <br>        idx = i  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):  <br>            <span class="hljs-keyword">if</span> ls[j] &lt; ls[idx]:  <br>                idx = j  <br>        ls[idx], ls[i] = ls[i], ls[idx]  <br></code></pre></td></tr></table></figure><h2 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_sort</span>(<span class="hljs-params">n</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):  <br>        x = ls[i]  <br>        j = i - <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x &lt; ls[j]:  <br>            ls[j + <span class="hljs-number">1</span>] = ls[j]  <br>            j -= <span class="hljs-number">1</span>  <br>        ls[j + <span class="hljs-number">1</span>] = x  <br></code></pre></td></tr></table></figure><h2 id="2-4-桶排序"><a href="#2-4-桶排序" class="headerlink" title="2.4 桶排序"></a>2.4 桶排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bucket_sort</span>(<span class="hljs-params">n</span>):  <br>    bucket = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)]  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:  <br>        bucket[i] += <span class="hljs-number">1</span>  <br>  <br>    ls.clear()  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        <span class="hljs-keyword">if</span> bucket[i] != <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bucket[i]):  <br>                ls.append(i)  <br></code></pre></td></tr></table></figure><h2 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a>2.5 快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    i = l - <span class="hljs-number">1</span>  <br>    j = r + <span class="hljs-number">1</span>  <br>    pivot = ls[l + r &gt;&gt; <span class="hljs-number">1</span>]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt; j:  <br>        i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[i] &lt; pivot:  <br>            i += <span class="hljs-number">1</span>  <br>        j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">while</span> ls[j] &gt; pivot:  <br>            j -= <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">if</span> i &lt; j:  <br>            ls[i], ls[j] = ls[j], ls[i]  <br>  <br>    quick_sort(l, j)  <br>    quick_sort(j + <span class="hljs-number">1</span>, r)  <br></code></pre></td></tr></table></figure><h2 id="2-6-归并排序"><a href="#2-6-归并排序" class="headerlink" title="2.6 归并排序"></a>2.6 归并排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">l, r</span>):  <br>    <span class="hljs-keyword">if</span> l &gt;= r:  <br>        <span class="hljs-keyword">return</span>  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>  <br>    merge_sort(l, mid)  <br>    merge_sort(mid + <span class="hljs-number">1</span>, r)  <br>  <br>    k = l  <br>    i = l  <br>    j = mid + <span class="hljs-number">1</span>  <br>    tmp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= r:  <br>        <span class="hljs-keyword">if</span> ls[i] &lt;= ls[j]:  <br>            tmp[k] = ls[i]  <br>            k += <span class="hljs-number">1</span>  <br>            i += <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">else</span>:  <br>            tmp[k] = ls[j]  <br>            k += <span class="hljs-number">1</span>  <br>            j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">while</span> i &lt;= mid:  <br>        tmp[k] = ls[i]  <br>        k += <span class="hljs-number">1</span>  <br>        i += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">while</span> j &lt;= r:  <br>        tmp[k] = ls[j]  <br>        k += <span class="hljs-number">1</span>  <br>        j += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):  <br>        ls[i] = tmp[i]  <br></code></pre></td></tr></table></figure><h1 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3 二分查找"></a>3 二分查找</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]  <br><span class="hljs-built_in">print</span>(ls)  <br>x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;要查找的元素：&#x27;</span>))  <br>  <br>l, r = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ls)  <br><span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:  <br>    mid = l + r &gt;&gt; <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">if</span> ls[mid] &lt; x:  <br>        l = mid  <br>    <span class="hljs-keyword">else</span>:  <br>        r = mid  <br>  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一次出现<span class="hljs-subst">&#123;x&#125;</span>的下标为<span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12_Python面向对象高级</title>
    <link href="/2024/08/07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2024/08/07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/12_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-slots-限制属性"><a href="#1-slots-限制属性" class="headerlink" title="1 __slots__限制属性"></a>1 <code>__slots__</code>限制属性</h1><p>Python可以通过 <code>对象.属性</code>的方式很方便的添加属性值，但是这种方式太自由了，Python可以定义一个特殊的变量 <code>__slots__</code>来限制类的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;__age&#x27;</span>)  <br>    <span class="hljs-comment"># __slots__ = [&#x27;name&#x27;, &#x27;__age&#x27;]  这样也可以</span><br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br>    p1.age = <span class="hljs-number">20</span>  <br>    <span class="hljs-built_in">print</span>(p1.age)  <br><br>    <span class="hljs-comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;gender&#x27;</span><br>    p1.gender = <span class="hljs-string">&#x27;男&#x27;</span><br></code></pre></td></tr></table></figure><p><code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的，除非在子类中也定义 <code>__slots__</code>，这样，子类实例允许定义的属性就是自身的 <code>__slots__</code>加上父类的 <code>__slots__</code>。</p><h1 id="2-property方法当属性"><a href="#2-property方法当属性" class="headerlink" title="2 @property方法当属性"></a>2 @property方法当属性</h1><p>如果直接把属性暴露出去，可以直接修改属性，但是没办法对值的合法性进行检验，所以可以将属性设为私有属性，然后通过 <code>getter</code>方法和 <code>setter</code>方法进行私有属性的获取和设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())  <br>    p1.set_age(<span class="hljs-number">20</span>)  <br>    <span class="hljs-built_in">print</span>(p1.get_age())<br></code></pre></td></tr></table></figure><p>但是调用方法终归是略显复杂，没有直接使用属性简单，作为追求简单的Python语言，内置的 <code>property</code>可以将方法当做属性使用，常用于 <code>getter</code>方法和 <code>setter</code>方法。<strong>既能检查参数，又可以用类似属性的简单方式来访问类的变量</strong>。</p><h2 id="2-1-装饰器方法"><a href="#2-1-装饰器方法" class="headerlink" title="2.1 装饰器方法"></a>2.1 装饰器方法</h2><ul><li><code>@property</code>修饰获取值的方法</li><li><code>获取值方法名.setter</code>修饰设置值的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br><span class="hljs-meta">    @property  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br><span class="hljs-meta">    @age.setter  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age<br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><blockquote><p>通过 <code>@property</code> 装饰器，创建了一个名为 <code>age</code> 的“公共接口”或“属性”。这个属性在外部看起来就像一个普通属性，可以用 <code>p1.age</code> 来访问它，但实际上，这个访问背后调用的是 <code>age()</code> 方法，而赋值时调用的则是 <code>age()</code> 方法下的 <code>age.setter</code>。</p></blockquote><h2 id="2-2-类属性方法"><a href="#2-2-类属性方法" class="headerlink" title="2.2 类属性方法"></a>2.2 类属性方法</h2><p><code>属性名 = property(获取值方法名, 设置值方法名)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):  <br>        <span class="hljs-variable language_">self</span>.name = name  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__age  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>):  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄必须为整数&#x27;</span>)  <br>        <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;年龄不能为负&#x27;</span>)  <br>        <span class="hljs-variable language_">self</span>.__age = age  <br>  <br>    age = <span class="hljs-built_in">property</span>(get_age, set_age)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <br>    <span class="hljs-built_in">print</span>(p1.age)  <span class="hljs-comment"># 可以像访问普通属性一样</span><br>    p1.age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 像修改普通属性一样</span><br>    <span class="hljs-built_in">print</span>(p1.age)<br></code></pre></td></tr></table></figure><h1 id="3-枚举类"><a href="#3-枚举类" class="headerlink" title="3 枚举类"></a>3 枚举类</h1><p>枚举类就是一种实例有限且固定的特殊类，当需要定义一组命名常量时，可以选择枚举类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum  <br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Week</span>(<span class="hljs-title class_ inherited__">Enum</span>):  <br>    Mon = <span class="hljs-number">1</span>  <br>    Tue = <span class="hljs-number">2</span>  <br>    Wed = <span class="hljs-number">3</span>  <br>    Thu = <span class="hljs-number">4</span>  <br>    Fri = <span class="hljs-number">5</span>  <br>    Sat = <span class="hljs-number">6</span>  <br>    Sun = <span class="hljs-number">7</span>  <br>  <br><br><span class="hljs-comment"># 枚举类可以迭代</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> Week:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;item&#125;</span>---<span class="hljs-subst">&#123;item.name&#125;</span>的值为：<span class="hljs-subst">&#123;item.value&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Week.Mon---Mon的值为：1</span><br><span class="hljs-string">Week.Tue---Tue的值为：2</span><br><span class="hljs-string">Week.Wed---Wed的值为：3</span><br><span class="hljs-string">Week.Thu---Thu的值为：4</span><br><span class="hljs-string">Week.Fri---Fri的值为：5</span><br><span class="hljs-string">Week.Sat---Sat的值为：6</span><br><span class="hljs-string">Week.Sun---Sun的值为：7</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 直接访问枚举成员</span><br><span class="hljs-built_in">print</span>(Week.Mon)  <span class="hljs-comment"># Week.Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.name)  <span class="hljs-comment"># Mon</span><br><span class="hljs-built_in">print</span>(Week.Mon.value) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>枚举类正常情况下允许成员有重复值，如果使用 <code>@unique</code>可以控制枚举成员不能有重复值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<br><br><br><span class="hljs-meta">@unique</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    RED = <span class="hljs-number">1</span><br>    GREEN = <span class="hljs-number">2</span><br>    BLUE = <span class="hljs-number">3</span><br>    CRIMSON = <span class="hljs-number">1</span> <span class="hljs-comment"># 这里的重复会引发 ValueError</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11_Python网络编程</title>
    <link href="/2024/08/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/08/06/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/11_Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络协议"><a href="#1-网络协议" class="headerlink" title="1 网络协议"></a>1 网络协议</h1><p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰 互联网协议入门（一）</a> 自下而上讲解互联网如何构成<br><a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">阮一峰 互联网协议入门（二）</a> 自上而下讲解互联网如何应用</p><h1 id="2-编解码"><a href="#2-编解码" class="headerlink" title="2 编解码"></a>2 编解码</h1><p>从网络或磁盘上读取字节流，读到的数据是 <code>bytes</code>。要把 <code>bytes</code>变为 <code>str</code>，就需要用 <code>decode()</code>方法，如果想要将 <code>str</code>转为 <code>bytes</code>，就需要使用 <code>encode()</code>方法。</p><ul><li><code>s.encode(码表)</code>编码，默认码表为 UTF-8</li><li><code>s.decode(码表)</code>解码，默认码表为 UTF-8</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;文件编码&#x27;</span>  <br>bs = s.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <br><br><span class="hljs-comment"># b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span><br><span class="hljs-built_in">print</span>(bs)<br><br><span class="hljs-comment"># 文件编码</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">b&#x27;\xe6\x96\x87\xe4\xbb\xb6\xe7\xbc\x96\xe7\xa0\x81&#x27;</span>.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>有一种特殊的编码方式，对于ASCII码表中的字符，可以使用 <code>b&#39;&#39;</code>包围字符串进行编码，但是注意不能对中文进行编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">b&#x27;hello python&#x27;</span>))<br></code></pre></td></tr></table></figure><h1 id="3-网络编程-收发一句话"><a href="#3-网络编程-收发一句话" class="headerlink" title="3 网络编程-收发一句话"></a>3 网络编程-收发一句话</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250918204805.png"></p><p><strong>只要确定主机和端口，我们就能实现程序之间的交流。</strong> 因此，Unix系统就把主机+端口，叫做”套接字”（<code>socket</code>）。有了它，就可以进行网络应用程序开发了。</p><p>TCP服务器端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br><span class="hljs-comment"># family：地址族，默认AF_INET（IPV4）  AF_INET6(IPV6)</span><br><span class="hljs-comment"># type：socket类型，默认SOCK_STREAM（TCP） SOCK_DGRAM(UDP)</span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号，注意参数必须为元组</span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制</span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息，阻塞到客户连接</span><br>sock, client = serve_socket.accept()  <br><br><span class="hljs-comment"># 5、编码并发送数据</span><br>sock.send(<span class="hljs-string">&#x27;你好我是服务器，欢迎来到socket&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 6、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = sock.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;服务器端收到来自：<span class="hljs-subst">&#123;client&#125;</span>的消息：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 7、释放资源，关闭当前连接，一般服务器不需要关闭</span><br>sock.close()<br></code></pre></td></tr></table></figure><p>TCP客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器的ip和端口号</span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2025</span>))  <br>  <br><span class="hljs-comment"># 3、接收数据并解码，设定每次接收数据限制为1024  </span><br>data = client_socket.recv(<span class="hljs-number">1024</span>).decode()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;客户端收到：<span class="hljs-subst">&#123;data&#125;</span>&#x27;</span>)  <br>  <br><span class="hljs-comment"># 4、编码并发送数据 </span><br>client_socket.send(<span class="hljs-string">&#x27;我是客户端&#x27;</span>.encode())  <br>  <br><span class="hljs-comment"># 5、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure><h1 id="4-网络编程-收发文件"><a href="#4-网络编程-收发文件" class="headerlink" title="4 网络编程-收发文件"></a>4 网络编程-收发文件</h1><p>TCP服务器端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>serve_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、设定服务器端的ip和端口号  </span><br>serve_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、设置监听数限制，也就是排队的客户端数量限制  </span><br>serve_socket.listen(<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 4、等待连接，返回代表该连接的套接字信息和连接者的地址信息  </span><br>sock, client = serve_socket.accept()  <br>  <br><span class="hljs-comment"># 5、使用二进制写，接收数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rev_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:      <br>        data = sock.recv(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>      <br>        f.write(data)  <span class="hljs-comment"># 将接收数据写入本地文件</span><br>  <br><span class="hljs-comment"># 6、释放资源  </span><br>sock.close()<br></code></pre></td></tr></table></figure><p>TCP客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket  <br>  <br><span class="hljs-comment"># 1、创建socket对象  </span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <br>  <br><span class="hljs-comment"># 2、请求连接服务器ip和端口号  </span><br>client_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">2200</span>))  <br>  <br><span class="hljs-comment"># 3、使用二进制读，发送数据  </span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;send_msg.jpg&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:      <br>        data = f.read(<span class="hljs-number">8192</span>)  <span class="hljs-comment"># 文件稍大一些</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:  <span class="hljs-comment"># 没数据就停止</span><br>            <span class="hljs-keyword">break</span>     <br>        client_socket.send(data)  <span class="hljs-comment"># 将本地文件发送出去</span><br>  <br><span class="hljs-comment"># 4、释放资源  </span><br>client_socket.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_Python正则表达式</title>
    <link href="/2024/08/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/08/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/10_Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1 匹配规则"></a>1 匹配规则</h1><h2 id="1-普通字符"><a href="#1-普通字符" class="headerlink" title="1. 普通字符"></a>1. 普通字符</h2><p>大多数字符（字母、数字、汉字）就是普通字符，它们匹配自己。</p><ul><li><code>abc</code> 匹配字符串中的 <code>&quot;abc&quot;</code></li><li><code>你好</code> 匹配字符串中的 <code>&quot;你好&quot;</code></li></ul><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><ul><li><strong><code>.</code> (点号)<strong>：匹配</strong>任意一个</strong>字符（除了换行符 <code>\n</code>）。<ul><li><code>a.c</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;a@c&quot;</code>, <code>&quot;a c&quot;</code></li></ul></li><li><strong><code>\d</code><strong>：匹配任意一个</strong>数字</strong>。等价于 <code>[0-9]</code>。<ul><li><code>\d\d</code> 匹配 <code>&quot;12&quot;</code>, <code>&quot;05&quot;</code></li></ul></li><li><strong><code>\w</code><strong>：匹配任意一个</strong>字母、数字或下划线</strong>。等价于 <code>[A-Za-z0-9_]</code>。<ul><li><code>\w\w</code> 匹配 <code>&quot;Ab&quot;</code>, <code>&quot;a1&quot;</code>, <code>&quot;_x&quot;</code></li></ul></li><li><strong><code>\s</code><strong>：匹配任意一个</strong>空白字符</strong>（包括空格、制表符 <code>\t</code>、换行符 <code>\n</code> 等）。</li><li><strong><code>\D</code>, <code>\W</code>, <code>\S</code><strong>：分别是 <code>\d</code>, <code>\w</code>, <code>\s</code> 的</strong>反面</strong>。<ul><li><code>\D</code> 匹配<strong>非数字</strong>的任意字符。</li></ul></li><li><strong><code>[...]</code> (字符组)<strong>：匹配方括号内的</strong>任意一个</strong>字符。<ul><li><code>[aeiou]</code> 匹配任意一个元音字母。</li><li><code>[a-z]</code> 匹配任意一个小写字母（<code>-</code> 表示范围）。</li><li><code>[0-9a-fA-F]</code> 匹配一个十六进制数字。</li></ul></li><li><strong><code>[^...]</code> (否定字符组)<strong>：匹配</strong>不在</strong>方括号内的任意一个字符。<ul><li><code>[^0-9]</code> 匹配任意一个非数字字符。</li></ul></li></ul><h2 id="3-量词-控制字符出现的次数"><a href="#3-量词-控制字符出现的次数" class="headerlink" title="3. 量词 - 控制字符出现的次数"></a>3. 量词 - 控制字符出现的次数</h2><ul><li><strong><code>*</code><strong>：匹配</strong>零次或多次</strong>。<ul><li><code>ab*c</code> 匹配 <code>&quot;ac&quot;</code> (0次b), <code>&quot;abc&quot;</code> (1次b), <code>&quot;abbc&quot;</code> (多次b)</li></ul></li><li><strong><code>+</code><strong>：匹配</strong>一次或多次</strong>。<ul><li><code>ab+c</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;abbc&quot;</code>，但不匹配 <code>&quot;ac&quot;</code></li></ul></li><li><strong><code>?</code><strong>：匹配</strong>零次或一次</strong>（即可选的）。<ul><li><code>colou?r</code> 匹配 <code>&quot;color&quot;</code> 和 <code>&quot;colour&quot;</code> (u出现0次或1次)</li></ul></li><li>**<code>&#123;n&#125;</code>**：匹配确定的 <strong>n 次</strong>。<ul><li><code>\d&#123;4&#125;</code> 匹配恰好4个数字，如 <code>&quot;2024&quot;</code></li></ul></li><li><strong><code>&#123;n,&#125;</code><strong>：匹配</strong>至少 n 次</strong>。<ul><li><code>\d&#123;2,&#125;</code> 匹配至少2个数字，如 <code>&quot;12&quot;</code>, <code>&quot;123&quot;</code></li></ul></li><li><strong><code>&#123;n,m&#125;</code><strong>：匹配</strong>至少 n 次，最多 m 次</strong>。<ul><li><code>\d&#123;2,4&#125;</code> 匹配2到4个数字，如 <code>&quot;12&quot;</code>, <code>&quot;123&quot;</code>, <code>&quot;2024&quot;</code></li></ul></li></ul><h2 id="4-位置锚点-匹配位置，而不是字符"><a href="#4-位置锚点-匹配位置，而不是字符" class="headerlink" title="4. 位置锚点 - 匹配位置，而不是字符"></a>4. 位置锚点 - 匹配位置，而不是字符</h2><ul><li><strong><code>^</code><strong>：匹配字符串的</strong>开始</strong>位置。<ul><li><code>^Hello</code> 匹配以 <code>&quot;Hello&quot;</code> 开头的字符串。</li></ul></li><li><strong><code>$</code><strong>：匹配字符串的</strong>结束</strong>位置。<ul><li><code>world!$</code> 匹配以 <code>&quot;world!&quot;</code> 结尾的字符串。</li></ul></li><li><strong><code>\b</code><strong>：匹配一个</strong>单词的边界</strong>（即单词开头或结尾的空隙）。<ul><li><code>\bcat\b</code> 匹配单词 <code>&quot;cat&quot;</code>，但不匹配 <code>&quot;category&quot;</code> 或 <code>&quot;scatter&quot;</code> 中的 <code>&quot;cat&quot;</code>。</li></ul></li></ul><h2 id="5-分组与捕获"><a href="#5-分组与捕获" class="headerlink" title="5. 分组与捕获"></a>5. 分组与捕获</h2><ul><li>**<code>(...)</code>**：<ol><li><strong>分组</strong>：将多个字符组合成一个整体，以便对其使用量词。<ul><li><code>(abc)+</code> 匹配 <code>&quot;abc&quot;</code>, <code>&quot;abcabc&quot;</code>。</li></ul></li><li><strong>捕获</strong>：提取匹配到的内容，供后续使用或替换。<ul><li>在替换操作中，可以用 <code>$1</code>, <code>$2</code> 来引用被括号捕获的内容。</li></ul></li></ol></li><li><strong><code>(?:...)</code><strong>：</strong>非捕获分组</strong>。只分组，不捕获，提高效率。</li></ul><h2 id="6-选择符"><a href="#6-选择符" class="headerlink" title="6. 选择符"></a>6. 选择符</h2><ul><li>**<code>|</code>**：表示“或”关系。<ul><li><code>cat|dog</code> 匹配 <code>&quot;cat&quot;</code> 或 <code>&quot;dog&quot;</code>。</li><li><code>gr(a|e)y</code> 匹配 <code>&quot;gray&quot;</code> 或 <code>&quot;grey&quot;</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-comment"># []表示范围，只匹配一个字符</span><br>[abc]           只能是 a b c 其中之一<br>[a-zA-Z]        a到z 或 A到Z<br><br><br><span class="hljs-comment"># ^ 表示 非</span><br>[^abc]          除 a b c 之外的任何字符<br><br><br><span class="hljs-comment"># &amp;&amp; 表示 且</span><br>[a-z&amp;&amp;[^e-g]]   a 到 z 且 除了 e 到 g（等同于[a-dh-z]）<br><br><br><span class="hljs-comment"># | 表示 或</span><br>[a-z|A-Z]       小写字母或大写字母<br><br><br><span class="hljs-comment"># 预定义字符</span><br>.    任何字符<br>\d   数字<br>\s   空白字符<br>\w   英文字母、数字、下划线<br><br>\D   非数字<br>\S   非空白字符<br>\W   非英文字母、数字、下划线<br><br><br><span class="hljs-comment"># 数量词</span><br>x?       <span class="hljs-number">0</span>个或<span class="hljs-number">1</span>个x<br>x*       <span class="hljs-number">0</span>个或多个x<br>x+       <span class="hljs-number">1</span>个或多个x<br>x&#123;n&#125;     正好n个x<br>x&#123;n,&#125;    至少n个x<br>x&#123;n, m&#125;  n到m个x<br><br><br><span class="hljs-comment"># \ 转义字符</span><br>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]\-[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]   数字-数字<br><br><span class="hljs-comment"># ^ 必须是开头  $ 必须是结尾</span><br>^hello    可以匹配 hello world  不能匹配 say hello<br>world$    可以匹配 hello world  不能匹配 world peace<br></code></pre></td></tr></table></figure><h1 id="2-Python应用"><a href="#2-Python应用" class="headerlink" title="2 Python应用"></a>2 Python应用</h1><h2 id="2-1-re模块"><a href="#2-1-re模块" class="headerlink" title="2.1 re模块"></a>2.1 re模块</h2><p><code>re</code>模块中包含正则表达式的所有功能，因为Python本来也有转义字符 <code>\</code>，所以 <code>\\</code>才能表示 <code>\</code>，为了方便，我们可以直接使用 <code>r&#39;&#39;</code>去除转义功能。<br>使用 <code>re.match()</code>方法判断是否匹配，如果匹配成功，返回一个 <code>Match</code>对象，否则返回 <code>None</code>。常见的判断方法就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">if</span> re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;failed&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-2-字符串分割"><a href="#2-2-字符串分割" class="headerlink" title="2.2 字符串分割"></a>2.2 字符串分割</h2><p>使用正则表达式分割字符串比常规的 <code>split()</code>方法更加强大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通split()</span><br><span class="hljs-string">&#x27;1   2 3  4&#x27;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>)   <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;]</span><br><br><span class="hljs-comment"># 正则split()</span><br>re.split(<span class="hljs-string">r&#x27;正则表达式&#x27;</span>, <span class="hljs-built_in">str</span>)<br><br>re.split(<span class="hljs-string">r&#x27;\s+&#x27;</span>, <span class="hljs-string">&#x27;1   2 3   4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br><br>re.split(<span class="hljs-string">r&#x27;[\s,;]+&#x27;</span>, <span class="hljs-string">&#x27;1  , 2,;, 3 ,4&#x27;</span>)  <span class="hljs-comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="2-3-分组"><a href="#2-3-分组" class="headerlink" title="2.3 分组"></a>2.3 分组</h2><p><code>()</code>表示要提取的分组，如果正则表达式中定义了组，就可以在 <code>Match</code>对象上用 <code>group()</code>方法提取出子串来。<br><code>group()</code>和 <code>group(0)</code>表示匹配的完整字符串，<code>group(1)</code>和 <code>group(2)</code>依次代表第1、第2个子串，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re  <br>  <br>qq = <span class="hljs-string">&#x27;qq:12345678&#x27;</span>  <br>reg = <span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>  <br>m = re.<span class="hljs-keyword">match</span>(reg, qq)  <br><span class="hljs-built_in">print</span>(m)  <br><span class="hljs-built_in">print</span>(m.group())  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))  <span class="hljs-comment"># qq:12345678</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))  <span class="hljs-comment"># qq</span><br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 12345678</span><br></code></pre></td></tr></table></figure><h2 id="2-4-预编译"><a href="#2-4-预编译" class="headerlink" title="2.4 预编译"></a>2.4 预编译</h2><p>如果一个正则表达式要用很多次，可以使用预编译。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 预编译</span><br>re_qq = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(qq):([1-9]\d&#123;4,9&#125;)$&#x27;</span>)<br><br><span class="hljs-comment"># 使用</span><br><span class="hljs-built_in">print</span>(re_qq.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;qq:41532531&#x27;</span>).group(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09_Python多进程和多线程</title>
    <link href="/2024/08/03/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/08/03/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/09_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-多任务"><a href="#1-多任务" class="headerlink" title="1 多任务"></a>1 多任务</h1><p>对于操作系统来说，一个任务就是一个<strong>进程（Process）</strong>，比如打开一个浏览器就是启动一个浏览器进程，打开两个记事本就启动了两个记事本进程，</p><p>有些进程内部要同时干多件事，比如Word同时进行打字和拼写检查，需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为<strong>线程（Thread）</strong>。线程是最小执行单元，一个进程至少有一个线程。</p><ul><li>串行：多个任务依次执行</li><li>并发：对于单核CPU，多个任务快速切换执行，看起来好像是多个任务一起执行的</li><li>并行：对于多核CPU，真正实现了多个任务同时执行</li></ul><p>多进程和多线程由操作系统进行调度，执行顺序具有随机性。</p><h1 id="2-多进程"><a href="#2-多进程" class="headerlink" title="2 多进程"></a>2 多进程</h1><h2 id="2-1-multiprocessing"><a href="#2-1-multiprocessing" class="headerlink" title="2.1 multiprocessing"></a>2.1 multiprocessing</h2><p>Windows可以使用跨平台的 <code>multiprocessing</code>，模块中提供了 <code>Process</code>类代表一个进程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;p-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有 <code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为进程起的名字，可以通过 <code>进程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>首音乐&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>  <br><br><span class="hljs-comment"># 没有 __name__ == &#x27;__main__&#x27; 的保护会导致无限递归</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-comment"># 实例化进程对象</span><br>    p1 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;)  <br><br>    <span class="hljs-comment"># 启动进程</span><br>    p1.start()  <br>    p2.start()  <br><br>    <span class="hljs-comment"># 等待子进程结束后，再继续执行主进程</span><br>    p1.join()  <br>    p2.join()<br></code></pre></td></tr></table></figure><h2 id="2-2-获取进程编号"><a href="#2-2-获取进程编号" class="headerlink" title="2.2 获取进程编号"></a>2.2 获取进程编号</h2><p>每个程序（进程）在设备上都有唯一的进程编号（PID），程序释放时进程编号也会释放，实现了进程编号的重复利用。</p><ul><li>获取当前PID的方式：<ul><li>方式一：<code>os.getpid()</code></li><li>方式二：<code>multiprocessing.current_process().pid</code></li></ul></li><li>获取父进程PID的方式：<ul><li><code>os.getppid()</code></li></ul></li></ul><blockquote><p>在 <code>main</code>中创建的进程，如果没有指定，则它的父进程都是 <code>main</code>进程，而 <code>main</code>的父进程是 <code>Pycharm</code>程序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time, os  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f1的pid：34568, 34568 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br><br>    <span class="hljs-comment"># f2的pid：40356, 40356 父进程的pid：32240</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=coding, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>))  <br>    p2 = multiprocessing.Process(target=music, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, kwargs=&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;)  <br><br>    <span class="hljs-comment"># process-1 process-2</span><br>    <span class="hljs-built_in">print</span>(p1.name, p2.name)  <br>  <br>    p1.start()  <br>    p2.start()  <br>  <br>    <span class="hljs-comment"># main的pid:32240, 32240 父进程：35464</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;main的pid:<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3 数据隔离"></a>2.3 数据隔离</h2><p>多进程有以下特点：</p><ol><li>进程之间执行是<strong>无序</strong>的</li><li>进程之间有<strong>数据隔离</strong></li><li>主进程会<strong>等待所有子进程执行结束</strong>再结束</li></ol><p>每个进程都有自己独立的内存空间，进程之间的<strong>数据是相互隔离</strong>的，子进程中的资源是父进程资源的拷贝，互不影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>)  <br>    p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>)  <br>  <br>    ls = [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>] <br><br>    <span class="hljs-comment"># 主进程中的ls为[8, 7, 6, 5, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)<br>  <br>    p1.start()  <br>    p2.start()<br></code></pre></td></tr></table></figure><h2 id="2-4-守护进程"><a href="#2-4-守护进程" class="headerlink" title="2.4 守护进程"></a>2.4 守护进程</h2><p>注意这个词的描述非常不准确。<br>正常来说，<strong>主进程会等待所有子进程执行结束之后才结束</strong>，但是有时候想要关闭主进程的同时关闭所有子进程，这个时候需要守护进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正常情况</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了努力工作中</span><br><span class="hljs-string"></span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果想要实现子进程和主进程同步关闭，有两种实现方法：</p><ol><li>设置子进程为守护进程，将属性 <code>daemon</code>设为 <code>True</code></li><li>手动杀死子进程，不过会导致子进程变为僵尸进程，会交由Python解释器自动回收</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 守护进程</span><br><span class="hljs-keyword">import</span> multiprocessing <span class="hljs-keyword">as</span> mp, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    p1 = mp.Process(target=work)  <br><br>    <span class="hljs-comment"># 子进程p1设为了守护进程</span><br>    p1.daemon = <span class="hljs-literal">True</span>  <br>    p1.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-comment"># 注意这里程序没有真的结束，只是为了演示主进程还在等待子进程执行  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束了&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">努力工作中</span><br><span class="hljs-string">主进程结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-5-Manager实现数据共享"><a href="#2-5-Manager实现数据共享" class="headerlink" title="2.5 Manager实现数据共享"></a>2.5 Manager实现数据共享</h2><p>在多进程中数据共享可以使用 <code>multiprocessing</code>模块中的 <code>Manager()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    <span class="hljs-keyword">with</span> multiprocessing.Manager() <span class="hljs-keyword">as</span> manager:  <br>        <span class="hljs-comment"># 这个 ls 就可以共享</span><br>        ls = manager.<span class="hljs-built_in">list</span>()  <br>        p1 = multiprocessing.Process(target=write, name=<span class="hljs-string">&#x27;process-1&#x27;</span>, args=(ls, ))  <br>        p2 = multiprocessing.Process(target=read, name=<span class="hljs-string">&#x27;process-2&#x27;</span>, args=(ls, ))<br></code></pre></td></tr></table></figure><h1 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3 多线程"></a>3 多线程</h1><h2 id="3-1-threading"><a href="#3-1-threading" class="headerlink" title="3.1 threading"></a>3.1 threading</h2><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。进程是CPU分配资源的基本单位，线程是CPU调度资源的最小单位，线程是依附于进程的，一个进程至少含有一个线程。</p><p>多线程之间有以下特点：</p><ol><li>线程之间执行是<strong>无序</strong>的</li><li>统一进程下的多线程之间<strong>共享</strong>全局变量</li><li>主线程会<strong>等待所有子线程执行结束</strong>再结束</li></ol><p>使用 <code>threading</code>模块中的 <code>Thread</code>类创建线程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = threading.Thread(target=coding, args=(name1, age1))  <br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要执行的函数名（注意没有 <code>()</code>，否则会直接调用）</li><li><code>[name]</code>：为线程起的名字，可以通过 <code>线程对象.name</code>访问</li><li><code>参数</code>：为函数所需参数传值<ul><li><code>args</code>：传入元组，按照位置参数进行传值</li><li><code>kwargs</code>：传入字典，按照键值对进行匹配传参</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time, os, multiprocessing  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coding</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在写第<span class="hljs-subst">&#123;i&#125;</span>行代码&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f1的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">music</span>(<span class="hljs-params">name, age</span>):  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;age&#125;</span>岁的<span class="hljs-subst">&#123;name&#125;</span>正在听第<span class="hljs-subst">&#123;i&#125;</span>首歌&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;f2的pid：<span class="hljs-subst">&#123;os.getpid()&#125;</span>, <span class="hljs-subst">&#123;multiprocessing.current_process().pid&#125;</span> 父进程的pid：<span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)  <br>  <br>  <br>name1, age1 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>name2, age2 = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入姓名和年龄：&#x27;</span>).split()  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t1 = threading.Thread(target=coding, args=(name1, age1))  <br>    t2 = threading.Thread(target=music, args=(name2, age2))  <br>  <br>    t1.start()  <br>    t2.start()<br></code></pre></td></tr></table></figure><h2 id="3-2-数据共享"><a href="#3-2-数据共享" class="headerlink" title="3.2 数据共享"></a>3.2 数据共享</h2><p>多线程之间共用内存空间，数据是共享的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>ls = []  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <br>        ls.append(i)  <br><br>    <span class="hljs-comment"># write函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;write函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>():  <br>    time.sleep(<span class="hljs-number">3</span>)  <br><br>    <span class="hljs-comment"># read函数中的ls为[0, 1, 2, 3, 4]</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;read函数中的ls为<span class="hljs-subst">&#123;ls&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=write)  <br>t2 = threading.Thread(target=read)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><h2 id="3-3-守护线程"><a href="#3-3-守护线程" class="headerlink" title="3.3 守护线程"></a>3.3 守护线程</h2><p>和进程类似，主线程会等待所有子线程结束再结束，如果想要让子线程随主进程结束而结束，应该设置守护线程，<code>线程.daemon = True</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;努力工作中&#x27;</span>)  <br>        time.sleep(<span class="hljs-number">0.2</span>)  <br>  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <br>    t = threading.Thread(target=work)  <br>  <br>    t.daemon = <span class="hljs-literal">True</span>  <br>    t.start()  <br>  <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-互斥锁"><a href="#3-4-互斥锁" class="headerlink" title="3.4 互斥锁"></a>3.4 互斥锁</h2><p>多线程中<strong>所有变量都由所有线程共享</strong>，最大的危险在于多个线程同时修改同一变量，内容就会出现紊乱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多次运行结果不同</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">add1函数中的num为1451039</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string">-----------------------</span><br><span class="hljs-string">add1函数中的num为1727878</span><br><span class="hljs-string">add2函数中的num为2000000</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">import</span> threading, time  <br>  <br>num = <span class="hljs-number">0</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>在上述案例中，<code>num += 1</code>并不是原子操作，而是分为以下几步交由CPU执行：</p><ol><li>读取当前 <code>num</code> 的值到寄存器</li><li>将寄存器中的值加1</li><li>将结果写回 <code>num</code> 变量</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">时间点 | 线程1              | 线程2              | num的值<br>----------------------------------------------------------------<br>t1    | 读取 num=0         |                    | 0<br>t2    | 计算 0+1=1         |                    | 0  <br>t3    |                    | 读取 num=0         | 0<br>t4    |                    | 计算 0+1=1         | 0<br>t5    | 写入 num=1         |                    | 1<br>t6    |                    | 写入 num=1         | 1 ← 错误！应该是2<br></code></pre></td></tr></table></figure><hr><p>为了确保计算正确，就要给两个 <code>add()</code>函数<strong>上个锁</strong>，当某个线程获得了该锁，其他线程就不能同时执行，而要等待直到获得该锁的线程释放锁，并获得该锁。由于锁只有一个，同一时间只有一个线程可以持有该锁，就不会造成修改的冲突。</p><p>通过 <code>threading.Lock()</code>可以创建一个锁对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>  <br>num = <span class="hljs-number">0</span>  <br><span class="hljs-comment"># 创建一个锁对象</span><br>lock = threading.Lock()  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add2</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>        num += <span class="hljs-number">1</span>  <br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add2函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>    lock.release()  <span class="hljs-comment"># 执行完释放锁</span><br>  <br>  <br>t1 = threading.Thread(target=add1)  <br>t2 = threading.Thread(target=add2)  <br>  <br>t1.start()  <br>t2.start()<br></code></pre></td></tr></table></figure><p>当多个线程同时执行 <code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用 <code>try...finally</code>来确保锁一定会被释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 上述代码的全局变量改为 num = &#x27;0&#x27; 就会形成死线程，采用try...finally可以解决</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>():  <br>    <span class="hljs-keyword">global</span> num  <br>    lock.acquire()  <span class="hljs-comment"># 先获取锁</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):  <br>            num += <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;add1函数中的num为<span class="hljs-subst">&#123;num&#125;</span>&#x27;</span>)  <br>        lock.release()  <span class="hljs-comment"># 不管是否成功执行，一定要释放锁</span><br></code></pre></td></tr></table></figure><blockquote><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p></blockquote><h1 id="4-进程和线程的区别"><a href="#4-进程和线程的区别" class="headerlink" title="4 进程和线程的区别"></a>4 进程和线程的区别</h1><ol><li>线程是依附于进程的，<strong>没有进程就没有线程</strong></li><li>一个进程<strong>最少有一个线程</strong>，进程可以创建多个线程</li><li>进程之间<strong>数据隔离</strong>，线程之间<strong>共享全局变量</strong>（使用互斥锁解决资源竞争问题）</li><li>进程是<strong>操作系统分配资源</strong>的基本单位，线程是<strong>CPU调度</strong>的基本单位</li><li>进程更消耗资源，相对更稳定；线程更轻量级，相对更灵活</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08_Python函数式编程</title>
    <link href="/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/08_Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1 高阶函数"></a>1 高阶函数</h1><p><strong>Python 中的函数是“一等函数”</strong>，所谓“一等函数”指的就是函数可以赋值给变量，函数可以作为函数的参数，函数也可以作为函数的返回值。把一个函数作为其他函数的参数或返回值的用法，我们通常称之为“高阶函数”。</p><p>在Python中，<code>func()</code>是函数调用，<code>func</code>是函数本身，可以把函数本身赋值给变量，也就是：<strong>变量指向函数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">1</span>))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>)  <span class="hljs-comment"># &lt;built-in function abs&gt;</span><br><br>f = <span class="hljs-built_in">abs</span>  <span class="hljs-comment"># f指向了abs函数</span><br><span class="hljs-built_in">print</span>(f(-<span class="hljs-number">5</span>))  <span class="hljs-comment"># 5  现在f等价于abs</span><br></code></pre></td></tr></table></figure><p>其实函数名本身也是变量，函数名指向函数。<br><img src="/../../../ai_assets/Pasted%20image%2020250911095842.png"></p><hr><p>函数能接收变量，变量可以指向函数，所以函数可以接受函数，这时传递的不是数据，而是<strong>计算逻辑</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):  <br>    <span class="hljs-keyword">return</span> x + y  <br><br><br>func(add, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)  <br></code></pre></td></tr></table></figure><h2 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1.1 map()"></a>1.1 map()</h2><p><code>map()</code>接收两个参数，一个是函数，一个是可迭代对象 <code>Iterable</code>，<code>map()</code>将函数依次作用到可迭代对象的每个元素，并将结果作为一个新的迭代器对象 <code>Iterator</code>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br><span class="hljs-comment"># 将f作用到列表中的每一个元素</span><br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(r))<br></code></pre></td></tr></table></figure><p>上述代码中，由于 <code>map()</code>返回的是一个惰性序列 <code>Iterator</code>，所以通过 <code>list()</code>把整个序列算出来返回一个 <code>list</code>。</p><p>输入一行数据作为列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27; &#x27;</span>)))<br></code></pre></td></tr></table></figure><h2 id="1-2-reduce"><a href="#1-2-reduce" class="headerlink" title="1.2 reduce()"></a>1.2 reduce()</h2><p><code>reduce()</code>把一个函数作用到一个序列中，其中这个函数必须<strong>接收两个参数</strong>，<code>reduce()</code>将计算结果继续和下一个元素累计计算。<br>使用 <code>reduce()</code>需要导入 <code>from functools import reduce</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><br><span class="hljs-built_in">print</span>(reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))  <span class="hljs-comment"># 累加求和 55</span><br><br><span class="hljs-comment"># 使用lambda匿名函数</span><br><span class="hljs-built_in">print</span>(reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-3-filter"><a href="#1-3-filter" class="headerlink" title="1.3 filter()"></a>1.3 filter()</h2><p><code>filter</code>接收一个函数一个序列，把传入的函数作用到每一个元素上，根据返回值决定是否保留，<code>True</code>保留元素，<code>False</code>丢弃元素。最终结果作为 <code>Iterator</code>返回，也就是一个惰性序列，需要使用 <code>list()</code>获取所有计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># 求出0~100的所有偶数</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(f, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)]))<br></code></pre></td></tr></table></figure><h2 id="1-4-sorted"><a href="#1-4-sorted" class="headerlink" title="1.4 sorted()"></a>1.4 sorted()</h2><p><code>sorted()</code>可以对序列进行排序，返回一个新的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = <span class="hljs-built_in">sorted</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>还可以接收一个 <code>key</code>函数实现自定义排序，<code>key</code>将指定函数作用到序列的每一个值上，并按照返回值进行排序。另外还可以使用 <code>reverse=True</code>表示逆序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><br><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br><br><span class="hljs-comment"># 按照第二个元素分数进行排序</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=f)<br><br><span class="hljs-comment"># 使用lambda并且逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h1 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2 匿名函数"></a>2 匿名函数</h1><ul><li><code>def</code> 关键字，可以定义带有名称的函数</li><li><code>lambda</code> 关键字，可以定义匿名函数（无名称）</li></ul><p>有名称的函数，可以基于名称重复使用。无名称的匿名函数，只可<strong>临时</strong>使用一次。<br>表达式内容自动成为返回值，不可使用 <code>return</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 传入参数: 函数体（一行代码）<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">compute, x, y</span>):  <br>    <span class="hljs-built_in">print</span>(compute(x, y))  <br><br><br><span class="hljs-comment"># 传入一个一次性的函数</span><br>func(<span class="hljs-keyword">lambda</span> x, y: x * y, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h1 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3 闭包"></a>3 闭包</h1><h2 id="3-1-闭包的定义"><a href="#3-1-闭包的定义" class="headerlink" title="3.1 闭包的定义"></a>3.1 闭包的定义</h2><p>调用了外部函数变量的内部函数就称之为<strong>闭包（Closure）</strong>，闭包可以增强安全性，将原本的全局变量变为外部函数的参数，对于内层函数来说这个变量又是外部变量。</p><p>闭包的三个必要条件：</p><ol><li>有嵌套：函数嵌套</li><li>有引用：内部函数引用外部函数变量</li><li>有返回：外部函数返回内部函数名（对象）</li></ol><p>银行取款非闭包写法：这种写法余额 <code>initial_value</code>是全局变量，有被修改的风险。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">initial_value = <span class="hljs-number">10000</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>    <span class="hljs-keyword">if</span> flag:  <br>        initial_value += value  <br>    <span class="hljs-keyword">else</span>:  <br>        initial_value -= value  <br><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment">#  存款1000，变为11000</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款2000，变为9000</span><br></code></pre></td></tr></table></figure><p>闭包写法：<code>initial_value</code>变成了外部函数 <code>count()</code>的参数，外部无法访问。想在内部函数引用外部变量需要使用 <code>nonlocal</code>声明，否则会被认为是内部函数局部变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">initial_value=<span class="hljs-number">0</span></span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">atm</span>(<span class="hljs-params">value, flag=<span class="hljs-literal">True</span></span>):  <br>        <span class="hljs-keyword">nonlocal</span> initial_value  <span class="hljs-comment"># 声明为外部变量</span><br>        <span class="hljs-keyword">if</span> flag:  <br>            initial_value += value  <br>        <span class="hljs-keyword">else</span>:  <br>            initial_value -= value  <br>  <br>    <span class="hljs-keyword">return</span> atm  <br>  <br><br><span class="hljs-comment"># 现在 fn 存储的是 atm() 函数，并且保存了 initial_value = 10000 的状态</span><br>fn = count(<span class="hljs-number">10000</span>)  <br><br><span class="hljs-comment"># 使用 fn 可以调用 atm() 函数</span><br>atm(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 存款</span><br>atm(<span class="hljs-number">2000</span>, <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款</span><br></code></pre></td></tr></table></figure><h2 id="3-2-闭包的原理"><a href="#3-2-闭包的原理" class="headerlink" title="3.2 闭包的原理"></a>3.2 闭包的原理</h2><p>闭包有点类的思想，外层函数中的参数像类的元素一样被保留了下来。实际上在Python的函数对象中存储了一些属性：</p><ul><li><code>__code__</code>：保存函数的字节码。</li><li><code>__globals__</code>：保存全局作用域引用。</li><li><code>__closure__</code>：保存了被捕获的自由变量（也就是闭包变量）。</li></ul><p>在上述案例中 <code>fn = count(10000)</code>执行后，<code>fn</code>是 <code>atm</code>这个函数对象。所以 <code>initial_value=10000</code> 这个变量其实是保存在 <code>fn.__closure__</code> 里的，Python会把它包装为一个<strong>cell object</strong>（细胞对象），用来存活并保持可变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">可以访问到 initial_value 的值</span><br><span class="hljs-string">fn.__closure__ 是一个元组，里面的元素就是 cell 对象</span><br><span class="hljs-string">cell_contents 就是捕获到的变量值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(fn.__closure__[<span class="hljs-number">0</span>].cell_contents)  <span class="hljs-comment"># 10000</span><br></code></pre></td></tr></table></figure><h1 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4 装饰器"></a>4 装饰器</h1><h2 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h2><p><strong>装饰器（Decorator）</strong> 就是创建一个闭包函数，在闭包函数内调用目标函数，可以达到不改变目标函数的同时，增加额外的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我开始了&#x27;</span>)  <span class="hljs-comment"># 执行前扩展</span><br>        func()  <span class="hljs-comment"># 原函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我结束了&#x27;</span>)  <span class="hljs-comment"># 执行后扩展</span><br><br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 将 demo 函数对象传入 outer()，fn 现在是保存了 func 状态的 inner 函数对象</span><br>fn = outer(demo)<br><br>fn()  <span class="hljs-comment"># 其实执行的就是 inner() 函数的内容</span><br></code></pre></td></tr></table></figure><p>上述写法还不够优雅，可以使用 <code>@函数名</code>的方式，也叫语法糖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># @outer 放在函数定义处相当于执行了 demo = outer(demo)</span><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;函数执行了&#x27;</span>)<br><br><br><span class="hljs-comment"># 此时执行 demo() 已经是扩展之后的功能了</span><br>demo()<br></code></pre></td></tr></table></figure><blockquote><p>原来的 <code>demo()</code>函数仍然存在，只是同名 <code>demo</code>变量指向了新的函数，于是调用 <code>demo()</code>会执行扩展后的函数，其实就是保存了 <code>func</code> 状态的 <code>inner()</code>函数。</p></blockquote><h2 id="4-2-带参有返回值"><a href="#4-2-带参有返回值" class="headerlink" title="4.2 带参有返回值"></a>4.2 带参有返回值</h2><p>要被装饰的原函数带参有返回值，并且原函数接收不定长参数，有一些细节需要注意。</p><ul><li><code>fn(args, kwargs)</code>是位置参数：相当于 <code>get_sum((1,2,3,4), &#123;&#39;math&#39;:18&#125;)</code></li><li><code>fn(*args, **kwargs)</code>是不定长参数：相当于 <code>get_sum(1,2,3,4, math=18)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):  <span class="hljs-comment"># 接收过来 args 已经是元组， kwargs 是字典  </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始计算...&#x27;</span>)  <br>        <span class="hljs-comment"># return fn (args, kwargs)  # 这种写法是错误的，被当做位置参数了</span><br>        <span class="hljs-keyword">return</span> fn(*args, **kwargs)  <span class="hljs-comment"># 现成的容器传入不定长需要 * 和 **  </span><br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sum</span>(<span class="hljs-params">*args, **kwargs</span>):  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(args) + <span class="hljs-built_in">sum</span>(kwargs.values())  <br>  <br>  <br>a = get_sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, math=<span class="hljs-number">10</span>, eng=<span class="hljs-number">30</span>)  <br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">开始计算...</span><br><span class="hljs-string">50</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="4-3-多个装饰器"><a href="#4-3-多个装饰器" class="headerlink" title="4.3 多个装饰器"></a>4.3 多个装饰器</h2><p>多个装饰器一层一层进入函数，再一层一层返回，装饰器的应用顺序是：<strong>自下而上，依次包裹</strong>。</p><ul><li>执行顺序是由外到内（先进入 <code>outer1</code>，再进入 <code>outer2</code>，再执行原函数）</li><li>返回顺序是由内到外（先从 <code>outer2</code> 返回，再从 <code>outer2</code> 返回）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer1</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器1结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer2</span>(<span class="hljs-params">fn</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2开始&#x27;</span>)  <br>        fn()  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;装饰器2结束&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> inner  <br>  <br>  <br><span class="hljs-meta">@outer1  </span><br><span class="hljs-meta">@outer2  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是猪猪侠&#x27;</span>)  <br>  <br>  <br>hello()<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">装饰器1开始</span><br><span class="hljs-string">装饰器2开始</span><br><span class="hljs-string">测试函数</span><br><span class="hljs-string">装饰器2结束</span><br><span class="hljs-string">装饰器1结束</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码的两个装饰器相当于 <code>hello = outer1(outer2(hello))</code>。</p><ol><li><code>hello</code>先被 <code>outer2</code>装饰，返回一个新函数</li><li>这个新函数再被 <code>outer1</code>装饰，又得到一个新函数</li></ol><blockquote><p>多个装饰器有点递归或者栈调用的感觉，只不过多个装饰器是采用多层函数嵌套，并没有无限调用自己，只是采用了类似的套娃结构。</p><p>如果说递归是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是……<br>递归是：无限重复的同一个壳。</p><p>那么多个装饰器是：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事！故事是…… 从前有条河，河里有条船，船上有个老船员，正在给小船员讲故事！故事是……<br>多个装饰器是：多层不同的外壳。</p></blockquote><h2 id="4-4-带参装饰器"><a href="#4-4-带参装饰器" class="headerlink" title="4.4 带参装饰器"></a>4.4 带参装饰器</h2><p>在普通装饰器中 <code>@outer 相当于 demo = outer(demo)</code>，默认接收一个被装饰的函数参数，这里所说的带参装饰器是在 <code>@outer</code>的参数，语法糖的格式<strong>只允许接收一个参数</strong>，所以要使用三层函数嵌套来进行额外的传参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">name</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">msg</span>):   <span class="hljs-comment"># 可以接收参数</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我开始执行了&#x27;</span>)<br>            fn(msg)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:我执行结束了&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:测试返回值&#x27;</span>   <span class="hljs-comment"># 可以返回值</span><br>        <span class="hljs-keyword">return</span> inner<br>    <span class="hljs-keyword">return</span> outer<br><br><br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&#x27;猪猪侠&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-built_in">print</span>(msg)<br><br><br>hello(<span class="hljs-string">&#x27;大家好啊&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">大家好</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(hello(<span class="hljs-string">&#x27;hhh&#x27;</span>))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">猪猪侠:我开始执行了</span><br><span class="hljs-string">hhh</span><br><span class="hljs-string">猪猪侠:我执行结束了</span><br><span class="hljs-string">猪猪侠:测试返回值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>在上述代码中，<code>@deco(&#39;猪猪侠&#39;)</code>相当于 <code>hello = deco(&#39;猪猪侠&#39;)(hello)</code>，<code>hello</code>实际是一个指向 <code>inner</code>函数的变量。</p><ul><li>第一次调用 <code>deco(&#39;猪猪侠&#39;)</code>，返回一个真正的装饰器函数，也就是 <code>outer</code>函数</li><li>第二次相当于是 <code>outer(hello)</code>，和之前的普通装饰器一样</li></ul><blockquote><p>如果使用传统格式，而不使用语法糖，也可以直接在外层函数传参，而不需要三层函数，用法为 <code>hello = outer(hello, name)</code>。</p></blockquote><h1 id="5-偏函数"><a href="#5-偏函数" class="headerlink" title="5 偏函数"></a>5 偏函数</h1><p>Python的 <code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。<br>偏函数可以<strong>固定函数的某些参数</strong>，生成一个新的函数，在调用时可以减少重复参数的输入，降低调用难度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># int()默认将字符串按照10进制进行转换，可以通过base设置进制</span><br><span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;152&#x27;</span>, base=<span class="hljs-number">8</span>)<br><br><span class="hljs-comment"># 固定base参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int2</span>(<span class="hljs-params">x, base=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x, base)<br><br><span class="hljs-comment"># functools.partial可以很方便地构造偏函数</span><br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07_Python生成器和迭代器</title>
    <link href="/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/07_Python%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1 迭代"></a>1 迭代</h1><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 可迭代对象:<br>代码块<br></code></pre></td></tr></table></figure><h1 id="2-推导式（生成式）"><a href="#2-推导式（生成式）" class="headerlink" title="2 推导式（生成式）"></a>2 推导式（生成式）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h1 id="3-生成器"><a href="#3-生成器" class="headerlink" title="3 生成器"></a>3 生成器</h1><p>受到内存限制，列表的容量是有限的，存储大量数据要占用大量的空间。</p><p>生成器解决了这个问题，<strong>生成器（generator）允许按需生成值，而不是一次性在内存中创建并存储整个序列。</strong><br>在每次请求时（使用 <code>next()</code> 或在 <code>for</code> 循环中）才计算并返回一个值。计算完一个值后，它会“暂停”执行，保存当前的状态（包括局部变量），直到下一次请求到来时再“唤醒”并从暂停的地方继续执行。这种方式被称为<strong>惰性求值</strong>。</p><h2 id="3-1-生成器表达式"><a href="#3-1-生成器表达式" class="headerlink" title="3.1 生成器表达式"></a>3.1 生成器表达式</h2><p>生成器表达式在语法上类似于列表推导式，把 <code>[]</code>改成 <code>()</code>就创建了一个 <code>generator</code>。</p><ul><li><strong>列表推导式</strong>：立即生成所有元素，并存储在内存中。</li><li><strong>生成器表达式</strong>：返回一个生成器对象，按需生成元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br><span class="hljs-built_in">print</span>(g)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x00000280B9CA04A0&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(g))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-生成器函数"><a href="#3-2-生成器函数" class="headerlink" title="3.2 生成器函数"></a>3.2 生成器函数</h2><p>推导算法复杂的时候可以使用函数实现，这是最常见的方法，写法和普通函数类似，不过使用 <code>yield</code> 语句而不是 <code>return</code> 语句来返回值。</p><ul><li><code>return</code>：函数遇到 <code>return</code> 会立即终止，并返回一个值。每次调用函数都会从第一行代码重新开始执行。</li><li><code>yield</code>：函数遇到 <code>yield</code> 会暂停执行，将值返回给调用者，并<strong>记住函数当前的所有状态</strong>。下次调用时，函数会从上次返回的 <code>yield</code>语句继续执行。</li></ul><p>如果一个函数定义中包含 <code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个 <code>generator</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无限序列生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> count<br>        count += <span class="hljs-number">1</span><br><br>f = counter() <br><span class="hljs-built_in">print</span>(f)  <span class="hljs-comment"># &lt;generator object counter at 0x0000018E4602B610&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>generator</code>函数会创建一个 <code>generator</code>对象，多次调用 <code>generator</code>函数会创建多个相互独立的 <code>generator</code>，所以正确做法是创建一个 <code>generator</code>对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">f = counter()  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(f))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(counter()))  <span class="hljs-comment"># 0  创建了新的generator对象</span><br></code></pre></td></tr></table></figure><h2 id="3-3-生成器的访问"><a href="#3-3-生成器的访问" class="headerlink" title="3.3 生成器的访问"></a>3.3 生成器的访问</h2><p>如果要访问生成器，可以使用 <code>next()</code>函数。<code>generator</code>保存的是算法，每次调用 <code>next()</code>就计算 <code>g</code>的下一个值，直到计算到最后一个元素，没有更多的元素时，抛出 <code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>不过一般不会使用 <code>next()</code>，由于 <code>generator</code>也是可迭代对象，可以通过 <code>for</code>循环去迭代它，并且不用担心相关 <code>StopIteration</code>的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代generator对象</span><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:<br><span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4 迭代器"></a>4 迭代器</h1><h2 id="4-1-可迭代对象"><a href="#4-1-可迭代对象" class="headerlink" title="4.1 可迭代对象"></a>4.1 可迭代对象</h2><p>可以直接作用于 <code>for</code>循环的对象统称为<strong>可迭代对象（Iterable）</strong>，包括：</p><ul><li>集合数据类型（都是 <code>Iterable</code>，但不是 <code>Iterator</code>，可以使用 <code>iter()</code>函数转化为迭代器）<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器（都是 <code>Iterable</code>，又是 <code>Iterator</code>）<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>可以使用 <code>isinstance</code>方法判断是否为<strong>可迭代对象</strong> <code>Iterable</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure><h2 id="4-2-迭代器对象"><a href="#4-2-迭代器对象" class="headerlink" title="4.2 迭代器对象"></a>4.2 迭代器对象</h2><p>生成器不但可以作用于 <code>for</code>循环，还可以被 <code>next()</code>函数不断调用并返回下一个值，直到最后抛出 <code>StopIteration</code>错误表示无法继续返回下一个值了。<br>迭代器是一个实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象，可以被 <code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器（Iterator）</strong>。</p><p>也可以使用 <code>isinstance</code>方法判断是否为<strong>迭代器对象</strong> <code>Iterator</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>((i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator))  <span class="hljs-comment"># True，迭代器</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>([], Iterator))  <span class="hljs-comment"># False，列表不是迭代器</span><br></code></pre></td></tr></table></figure><p>生成器都是 <code>Iterator</code>对象，但 <code>list</code>、<code>dict</code>、<code>str</code>虽然是 <code>Iterable</code>，却不是 <code>Iterator</code>。<br>把 <code>list</code>、<code>dict</code>、<code>str</code>等 <code>Iterable</code>变成 <code>Iterator</code>可以使用 <code>iter()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]  <br>ls = <span class="hljs-built_in">iter</span>(ls)  <span class="hljs-comment"># 转换为了Iterator</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(ls, Iterator))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><ul><li>凡是可作用于 <code>for</code>循环的对象都是 <code>Iterable</code>类型</li><li>凡是可作用于 <code>next()</code>函数的对象都是 <code>Iterator</code>类型，它们表示一个惰性计算的序列</li></ul><blockquote><p>为什么 <code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是 <code>Iterator</code>？<br>这是因为Python的 <code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被 <code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出 <code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 <code>next()</code>函数实现按需计算下一个数据，所以 <code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p></blockquote><p>Python的 <code>for</code>循环本质上就是通过不断调用 <code>next()</code>函数实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下面两种方式完全等价</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 首先获得Iterator对象: </span><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <br><span class="hljs-comment"># 循环: </span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <br><span class="hljs-keyword">try</span>:       <br><span class="hljs-comment"># 获得下一个值:       </span><br>x = <span class="hljs-built_in">next</span>(it)   <br><span class="hljs-keyword">except</span> StopIteration:      <br><span class="hljs-comment"># 遇到StopIteration就退出循环       </span><br><span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06_Python赋值与深浅拷贝</title>
    <link href="/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/06_Python%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-可变对象和不可变对象"><a href="#1-可变对象和不可变对象" class="headerlink" title="1 可变对象和不可变对象"></a>1 可变对象和不可变对象</h1><p>可变对象和不可变对象的划分依据：<strong>在不改变地址的前提下，元素值能否修改</strong>。</p><ul><li>可变对象：该对象所指内存的值可以被改变<ul><li>列表 <code>list</code></li><li>集合 <code>set</code></li><li>字典 <code>dict</code></li><li>自定义对象</li></ul></li><li>不可变对象：该对象所指向的内存中的值不能被改变，一旦创建就<strong>不可修改</strong>，想要修改对象的值，需要复制一份后再改变，会返回一个新地址<ul><li>数字 <code>int</code> <code>float</code></li><li>字符串 <code>str</code></li><li>元组 <code>tuple</code></li><li>布尔 <code>bool</code></li></ul></li></ul><p>可以通过 <code>id()</code>查看对象的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不可变对象：改变元素值本质是创建了一个新的对象，指向了新的对象</span><br>a = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202913808</span><br>a = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1537202914128，内容修改，地址也变了</span><br><br><span class="hljs-comment"># 可变对象：</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536</span><br>ls[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ls))  <span class="hljs-comment"># 1995083673536，内容修改，地址不变</span><br></code></pre></td></tr></table></figure><h1 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2 赋值"></a>2 赋值</h1><p>与C++不同，Python的赋值 <code>=</code>属于<strong>引用赋值</strong>，只是了创建对象的另一个<strong>引用（别名）</strong>，新旧变量指向同一个内存对象，通过任一引用修改对象（需要可变），其他引用都会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引用赋值，a和b都指向同一内存空间</span><br>a = <span class="hljs-number">10</span><br>b = a<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1437435953680</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 1437435953680</span><br><br><span class="hljs-comment"># c和d也指向同一内存空间</span><br>c = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>d = c<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 2028769177536</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(d))  <span class="hljs-comment"># 2028769177536</span><br></code></pre></td></tr></table></figure><p>Python解释器在执行 <code>a = 10</code>赋值时做以下操作：</p><ol><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p>把一个变量 <code>a</code>赋值给另一个变量 <code>b</code>，这个操作实际上是把变量 <code>b</code>指向变量 <code>a</code>所指向的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br>b = a<br>a = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250909100211.png"></p><h1 id="3-浅拷贝"><a href="#3-浅拷贝" class="headerlink" title="3 浅拷贝"></a>3 浅拷贝</h1><p>浅拷贝和深拷贝使用需要导入 <code>import copy</code>模块，它们的区别是拷贝层级不同，都可以操作可变对象和不可变对象，但是一般不会操作不可变对象。</p><blockquote><p>不论是深拷贝还是浅拷贝，针对不可变类型的拷贝，都不会开辟新的空间，而是拷贝对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b = copy.copy(a)<br>c = copy.deepcopy(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1553475958912</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># 1553475958912</span><br></code></pre></td></tr></table></figure></blockquote><p>浅拷贝 <code>copy.copy()</code>会创建新对象，<strong>复制最外层的数据</strong>，但内部容器仍然是引用。</p><ul><li>外层独立：外层修改互不影响</li><li>共享内层：嵌套对象的修改会影响所有拷贝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]<br>b = copy.copy(a)  <span class="hljs-comment"># 实际拷贝了 [1, 2, 3, 地址]</span><br><br><span class="hljs-comment"># 外层在新的对象中</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 2785582893824</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 2785582894016</span><br><br><span class="hljs-comment"># 内层还是原来的引用</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 2785582896960</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span><br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [66, 5, 6]]，外层独立，内层仍然是旧引用</span><br></code></pre></td></tr></table></figure><p>在最外层只暴露了深层的引用，浅拷贝只会拷贝这个地址，而不会拷贝深层数据。<br><img src="/../../../ai_assets/Pasted%20image%2020250906180358.png"></p><h1 id="4-深拷贝"><a href="#4-深拷贝" class="headerlink" title="4 深拷贝"></a>4 深拷贝</h1><p>深拷贝 <code>copy.deepcopy()</code>会创建新的对象，并且<strong>完全独立</strong>的，会递归复制所有嵌套对象。</p><ul><li>完全隔离：任何修改都不会影响其他拷贝</li><li>内存开销：需要更多内存，因为创建所有对象的副本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy  <br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]  <br>b = copy.deepcopy(a)  <br><br><span class="hljs-comment"># 外层是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))  <span class="hljs-comment"># 1823162354432</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))  <span class="hljs-comment"># 1823162354624</span><br><br><span class="hljs-comment"># 内层也是独立的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357568</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">3</span>]))  <span class="hljs-comment"># 1823162357952</span><br>  <br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>  <br>  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [66, 2, 3, [66, 5, 6]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 6]]，完全独立，不受影响</span><br></code></pre></td></tr></table></figure><h1 id="5-总结区分"><a href="#5-总结区分" class="headerlink" title="5 总结区分"></a>5 总结区分</h1><p><strong>普通赋值和浅拷贝：</strong><br><img src="/../../../ai_assets/Pasted%20image%2020250906194615.png"></p><p><strong>浅拷贝和深拷贝：</strong></p><ul><li>浅拷贝只拷贝第一层中的数据并开辟空间存储</li><li>深拷贝拷贝所有的数据并开辟对应的空间存储</li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250906201908.png"></p><p><strong>拷贝不可变类型：</strong><br>深浅拷贝对于不可变类型来说，非常类似普通的赋值，只是复制了引用。<br><img src="/../../../ai_assets/Pasted%20image%2020250906202301.png"></p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05_Python面向对象</title>
    <link href="/2024/07/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/07/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/02%20Python%E8%BF%9B%E9%98%B6/05_Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象就是老板思想，需要什么工作就派给什么职位（类）的员工，对于相同的职位都有相同的特征，每一种职位都有很多不同的人（对象）在岗位上，而每一个人又有自己的特点（属性）和技能（方法）。</p><h1 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1 类和对象"></a>1 类和对象</h1><ul><li>类：<strong>抽象的模板</strong>，是对一群有相同特征或行为的事物的统称，不能直接使用。（比如学生类）<ul><li><strong>属性</strong>：这类事物具有什么样的<strong>特征</strong></li><li><strong>方法</strong>：这类事物具有什么样的<strong>行为</strong></li></ul></li><li>对象：<strong>具体的实体</strong>，是由类创建出来的一个具体存在，可以直接使用。（比如张三）</li></ul><h2 id="1-1-定义类和创建对象"><a href="#1-1-定义类和创建对象" class="headerlink" title="1.1 定义类和创建对象"></a>1.1 定义类和创建对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义类，类名一般使用大驼峰</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">方法名</span>:<br>...<br>...<br><br><span class="hljs-comment"># 如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 创建对象</span><br>对象名 = 类名()<br><br><span class="hljs-comment"># 通过对象名调用内部方法</span><br>对象名.方法名()<br></code></pre></td></tr></table></figure><blockquote><p>在Python中，<strong>函数</strong>是独立的代码块，可以在任何地方定义和调用。<strong>方法</strong>是定义在类内部的函数，通常用于操作类的实例或类本身。</p></blockquote><p><code>self</code>关键字：类似Java的 <code>this</code><br>为了在类的内部区分是哪个对象调用了类的方法，哪一个对象调用的方法，<code>self</code>就是哪一个对象的引用。调用方法时，不需要传递 <code>self</code>参数。在方法内部：</p><ul><li>通过 <code>self.</code>访问对象的属性</li><li>通过 <code>self.</code>调用对象的其他方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 谁调用就是谁</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;self是<span class="hljs-subst">&#123;self&#125;</span>&#x27;</span>)  <br>  <br>  <br>car = Car()  <br>car.run()  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;car对象<span class="hljs-subst">&#123;car&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>实例方法的第一个参数必须为 <code>self</code>！</p></blockquote><h2 id="1-2-属性的增加与访问"><a href="#1-2-属性的增加与访问" class="headerlink" title="1.2 属性的增加与访问"></a>1.2 属性的增加与访问</h2><p>与Java不同的是，Python可以在类的外面直接添加属性，但<strong>不推荐</strong>这种方式，属性应该封装到类的内部，参考下一节的 <code>__init__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 增加属性</span><br>对象名.属性名 = 属性值<br></code></pre></td></tr></table></figure><blockquote><p>由于这种方法的存在，和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，同一个类的不同实例，拥有的变量名称可能不同</p></blockquote><p>属性的访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类外部访问</span><br>对象名.属性名<br><br><span class="hljs-comment"># 类内部访问</span><br><span class="hljs-variable language_">self</span>.属性名<br></code></pre></td></tr></table></figure><h2 id="1-3-获取对象信息"><a href="#1-3-获取对象信息" class="headerlink" title="1.3 获取对象信息"></a>1.3 获取对象信息</h2><p><code>dir(对象)</code>可以查看该对象有哪些属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>使用 <code>dir()</code>只能把属性和方法列出来，搭配 <code>getattr()</code>、<code>setattr()</code>以及 <code>hasattr()</code>可以改变对象的属性和方法。</p><ul><li><code>hasattr()</code>查看是否有指定属性</li><li><code>getattr()</code>获取指定属性</li><li><code>setattr()</code>设置指定属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看是否有name属性，返回True和False</span><br><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br><br><span class="hljs-comment"># 获取指定属性，如果没有则抛出AttributeError的错误</span><br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>)<br>name = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">404</span>)  <span class="hljs-comment"># 如果属性不存在返回指定值，自行设定</span><br><br><span class="hljs-comment"># 设置指定属性值，可以是之前没有的</span><br><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><blockquote><p>只有在不知道对象信息的时候，我们才会去获取对象信息，否则直接使用 <code>对象.属性</code>即可。</p></blockquote><h2 id="1-4-身份运算符is、is-not"><a href="#1-4-身份运算符is、is-not" class="headerlink" title="1.4 身份运算符is、is not"></a>1.4 身份运算符is、is not</h2><p>身份运算符 <code>is</code>、<code>is not</code>用于<strong>比较两个对象的内存地址</strong>是否一致——是否是对同一个对象的引用。</p><ul><li><code>is</code>用于判断两个变量<strong>引用对象</strong>是否为同一个</li><li><code>==</code>用于判断<strong>引用变量的值</strong>是否相等</li></ul><blockquote><p>针对 <code>None</code>的比较，建议使用 <code>is</code>。</p></blockquote><h1 id="2-魔法方法"><a href="#2-魔法方法" class="headerlink" title="2 魔法方法"></a>2 魔法方法</h1><p>魔法方法使用 <code>__xx__</code>双下划线包围，在特殊情况下会自动调用。</p><h2 id="2-1-init-方法"><a href="#2-1-init-方法" class="headerlink" title="2.1 __init__方法"></a>2.1 <code>__init__</code>方法</h2><p><code>__init__</code>就是Python的<strong>构造方法</strong>，也用来声明<strong>实例属性</strong>，创建对象时自动触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><br><br><span class="hljs-comment"># 有参方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><span class="hljs-variable language_">self</span>.age = age<br></code></pre></td></tr></table></figure><h2 id="2-2-str-方法"><a href="#2-2-str-方法" class="headerlink" title="2.2 __str__方法"></a>2.2 <code>__str__</code>方法</h2><p>使用 <code>print()</code>打印对象时，默认是打印对象的内存地址，如果不想要输出内存地址，就需要定义 <code>__str__</code>方法。<code>__str__</code>方法的<strong>返回值必须是字符串</strong>，打印时将会打印其返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;name: <span class="hljs-subst">&#123;self.name&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-3-repr-方法"><a href="#2-3-repr-方法" class="headerlink" title="2.3 __repr__方法"></a>2.3 <code>__repr__</code>方法</h2><ul><li><code>__str__</code>：面向<strong>用户</strong>，强调可读性，在print时会调用</li><li><code>__repr__</code>：面向<strong>开发者</strong>，强调更准确、更标准的对象表示形式，通常是调试用的，交互式解释器中会调用</li></ul><p>如果只写 <code>__repr__</code> 而没写 <code>__str__</code>，那 <code>print(obj)</code> 也会退回调用 <code>__repr__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.item = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack(top-&gt; &quot;</span> + <span class="hljs-string">&quot;, &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-variable language_">self</span>.item[::-<span class="hljs-number">1</span>])) + <span class="hljs-string">&quot;)&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Stack(<span class="hljs-subst">&#123;self.item!r&#125;</span>)&quot;</span><br><br><br><span class="hljs-built_in">print</span>(st)     <span class="hljs-comment"># 调用 __str__，输出：Stack(top-&gt; 3, 2, 1)</span><br>st            <span class="hljs-comment"># 调用 __repr__，输出：Stack([1, 2, 3])</span><br></code></pre></td></tr></table></figure><h2 id="2-4-del-方法"><a href="#2-4-del-方法" class="headerlink" title="2.4 __del__方法"></a>2.4 <code>__del__</code>方法</h2><p>  当删除对象时，会自动调用 <code>__del__</code>方法，让对象在销毁前做一些事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-variable language_">self</span>.name = name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span>被销毁了&#x27;</span>)<br><br>stu = Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>)<br><br><span class="hljs-comment"># 使用del手动删除对象，执行__del__方法，否则在对象自然销毁时执行</span><br><span class="hljs-keyword">del</span> stu<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-5-len-方法"><a href="#2-5-len-方法" class="headerlink" title="2.5 __len__方法"></a>2.5 <code>__len__</code>方法</h2><p>定义调用 <code>len(对象)</code>函数时，返回的长度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size<br></code></pre></td></tr></table></figure><h2 id="2-6-iter-方法"><a href="#2-6-iter-方法" class="headerlink" title="2.6 __iter__方法"></a>2.6 <code>__iter__</code>方法</h2><p>通过实现 <code>__iter__</code>方法，使用 <code>yield</code>关键字，可以使自定义类成为可迭代对象，方便使用 <code>for</code>循环进行遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.head = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.tail = <span class="hljs-literal">None</span>  <br>        <span class="hljs-variable language_">self</span>.size = <span class="hljs-number">0</span>  <br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <br>        current = <span class="hljs-variable language_">self</span>.head  <br>        <span class="hljs-keyword">while</span> current:  <br>            <span class="hljs-keyword">yield</span> current.data  <br>            current = current.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="3-封装"><a href="#3-封装" class="headerlink" title="3 封装"></a>3 封装</h1><p>根据职责将属性和方法封装到一个抽象的类中，外界使用类创建对象，让对象使用属性、调用方法，<strong>对象方法的细节都被封装在类的内部</strong>。</p><p>私有属性和私有方法只能在类的内部使用，在类的外部使用需要通过公共接口。</p><h2 id="3-1-私有属性"><a href="#3-1-私有属性" class="headerlink" title="3.1 私有属性"></a>3.1 私有属性</h2><p>格式：在属性名前面加两个下划线 <code>__</code>。<br>用法：和Java一样，定义公有方法 <code>get_xxx</code>获取私有属性、<code>set_xxx</code>设置私有属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__属性名<br></code></pre></td></tr></table></figure><h2 id="3-2-私有方法"><a href="#3-2-私有方法" class="headerlink" title="3.2 私有方法"></a>3.2 私有方法</h2><p>格式：在方法名前面加两个下划线 <code>__</code>。<br>用法：定义公有方法调用私有方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__方法名</span>():<br>...<br></code></pre></td></tr></table></figure><blockquote><p>了解：其实Python中没有真正的私有，在外部使用 <code>类名.__属性</code>、<code>类名.__方法</code>也可以访问，但<strong>不要这样做</strong>。<br>实际上Python内部只是将私有成员改了一个名，<code>__属性</code>变成了 <code>_类名__属性</code>，<code>__方法</code>变成了 <code>_类名__方法</code>。</p></blockquote><h2 id="3-3-dict-属性"><a href="#3-3-dict-属性" class="headerlink" title="3.3 __dict__属性"></a>3.3 <code>__dict__</code>属性</h2><p><code>___dict___</code> 是 Python 中的一个特殊属性，用于存储对象的所有属性及其对应的值。它以字典形式呈现，键为属性名，值为属性值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.gender = gender<br><br><br>p = Person(<span class="hljs-string">&#x27;猪猪侠&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;男&#x27;</span>)  <br><span class="hljs-built_in">print</span>(p.__dict__)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;猪猪侠&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>在文件写入中可以使用 <code>__dict__</code>将对象转为字典，再将字典转为字符串进行写入。</p><h1 id="4-继承"><a href="#4-继承" class="headerlink" title="4 继承"></a>4 继承</h1><h2 id="4-1-继承的定义"><a href="#4-1-继承的定义" class="headerlink" title="4.1 继承的定义"></a>4.1 继承的定义</h2><ul><li>父类：也叫作基类</li><li>子类：也叫作派生类或扩展类</li></ul><p>子类默认继承父类所有的属性和方法，Python 的子类<strong>不会直接继承</strong>父类的私有属性和私有方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(<span class="hljs-title class_ inherited__">父类名</span>):<br>...<br><br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>(父类名<span class="hljs-number">1</span>, 父类名<span class="hljs-number">2</span>):<br>...<br></code></pre></td></tr></table></figure><p>当多个父类中存在相同名字的属性或方法，默认使用第一个父类的同名属性和方法，可以使用 <code>__mro__</code>属性或 <code>mro()</code>方法查看先后顺序。<br>MRO(Method Resolution Order)：方法解析顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(类名.__mro__)<br><span class="hljs-built_in">print</span>(类名.mro())<br></code></pre></td></tr></table></figure><p>在Python中，<code>object</code>是所有类的基类，即所有Python对象的根源。如果没有指定父类，会默认使用 <code>object</code>作为该类的基类（可以使用 <code>dir</code>函数查看）。</p><h2 id="4-2-重写"><a href="#4-2-重写" class="headerlink" title="4.2 重写"></a>4.2 重写</h2><p>父类方法不满足子类需求时，可以<strong>重写（override）</strong>，直接在子类中使用和父类相同名字的属性和方法即可进行重写。重写之后会调用子类的方法，而不是父类的。</p><h3 id="4-2-1-“覆盖”父类"><a href="#4-2-1-“覆盖”父类" class="headerlink" title="4.2.1 “覆盖”父类"></a>4.2.1 “覆盖”父类</h3><p>子类方法和父类方法完全不同，在子类中写一个和父类同名的方法实现即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工作&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CowHorse</span>(<span class="hljs-title class_ inherited__">Person</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 当牛马就行了</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当牛马&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-2-2-“扩展”父类"><a href="#4-2-2-“扩展”父类" class="headerlink" title="4.2.2 “扩展”父类"></a>4.2.2 “扩展”父类</h3><p>方式一：<code>父类名.父类方法(self)</code></p><p>这种方法可以精准访问指定的父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        School.__init__(<span class="hljs-variable language_">self</span>)  <span class="hljs-comment"># 将当前实例传给父类的__init__方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>煎饼果子&#x27;</span>)  <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 现代煎饼果子</span><br></code></pre></td></tr></table></figure><p>方式二：<code>super().父类方法()</code>（更常用）</p><p><code>super()</code> 实际上返回的是一个 <strong>代理对象（super object）</strong>。这个代理对象知道两件事：</p><ol><li>当前是哪个类（<code>__class__</code>）</li><li>当前实例的 MRO 是什么</li></ol><p>只能访问最近的父类，有就用，没有就往后找，找不到再报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从当前类的 MRO 中，从当前类的下一个开始，依次查找 __init__ 方法 ，并调用第一个</span><br><span class="hljs-built_in">super</span>().__init__()<br></code></pre></td></tr></table></figure><p><code>super()</code>零参数时，Python 解释器会自动填充两个参数：</p><ul><li><code>__class__</code>：当前正在定义的类。</li><li><code>self</code>：当前实例。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;古法&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>Master煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;现代&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.skill&#125;</span>School煎饼果子&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Peo</span>(Master, School):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-variable language_">self</span>.skill = <span class="hljs-string">&#x27;融合&#x27;</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 会自动填充当前实例的self和当前类</span><br>        <span class="hljs-built_in">super</span>().make() <br>  <br>  <br>p1 = Peo()  <br><span class="hljs-built_in">print</span>(p1.skill)  <span class="hljs-comment"># 融合</span><br>p1.make()  <span class="hljs-comment"># 古法Master煎饼果子</span><br></code></pre></td></tr></table></figure><blockquote><p>在Python中 <code>super</code>是一个特殊的类，<code>super()</code>是使用 <code>super</code>类创建出来的对象。使⽤<code>super() </code>可以⾃动查找⽗类，适合单继承使⽤，多继承不建议使用。</p></blockquote><h1 id="5-多态"><a href="#5-多态" class="headerlink" title="5 多态"></a>5 多态</h1><h2 id="5-1-多态的定义"><a href="#5-1-多态的定义" class="headerlink" title="5.1 多态的定义"></a>5.1 多态的定义</h2><p>当我们定义一个 <code>class</code>的时候，我们实际上就定义了一种数据类型，判断一个变量是否是某个类型可以用 <code>isinstance()</code>判断。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(dog, Dog)  <span class="hljs-comment"># True，Dog类型</span><br><span class="hljs-built_in">isinstance</span>(cat, Cat)  <span class="hljs-comment"># True，Cat类型</span><br><span class="hljs-built_in">isinstance</span>(dog, Animal)  <span class="hljs-comment"># True，既是Dog类型，又是Animal类型</span><br></code></pre></td></tr></table></figure><p>多态指的是<strong>同一函数对于传入的不同对象做出不同的响应</strong>。多态的好处在于，当我们需要传入 <code>Dog</code>、<code>Cat</code>等等时，我们只需要接收 <code>Animal</code>这个父类类型就可以，并且原有的函数对于新增的 <code>Animal</code>子类也生效，这就是多态的含义。</p><p>实现多态的条件：</p><ol><li>有继承（子类继承父类）</li><li>有方法重写（子类重写父类方法）</li><li>父类引用指向子类对象（子类对象传给父类对象调用者）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;动物叫&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;汪汪汪&#x27;</span>  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;喵喵喵&#x27;</span>  <br>  <br>    <span class="hljs-comment"># 注意没有继承Animal  </span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">object</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>  <br>  <br>  <br><span class="hljs-comment"># 这个函数不关心传入的是什么类型，只关心是否有 speak 方法  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br><span class="hljs-comment"># 显式写出类型，但实际没有作用  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">animal: Animal</span>):  <br>    <span class="hljs-built_in">print</span>(animal.speak())  <br>  <br>  <br>dog = Dog()  <br>cat = Cat()  <br>car = Car()  <br>sound(dog)  <br>sound(cat)  <br>  <br><span class="hljs-comment"># 鸭子类型的体现，car虽然不是Animal，但是有speak方法  </span><br><span class="hljs-comment"># 注意这个不叫多态，因为多态的条件是有继承有重写  </span><br>sound(car)<br></code></pre></td></tr></table></figure><p>对于静态语言Java来说，多态需要继承同一父类或接口，在刚刚的例子中必须是 <code>Animal</code>或其子类。而在Python中，<strong>不关心对象的类型，只关心对象的行为</strong>（即它有什么方法）。只要一个对象具有所需的方法和属性，它就可以被当作预期的类型来使用，在刚刚的例子中比如一个 <code>Car</code>类，只要有 <code>speak</code>方法，就可以实现多态。</p><p>Python的多态最大的特点是：<strong>鸭子类型（Duck Typing）</strong>。“如果它走起路来像鸭子，叫起来像鸭子，那么它就是鸭子。”</p><h2 id="5-2-多态的应用"><a href="#5-2-多态的应用" class="headerlink" title="5.2 多态的应用"></a>5.2 多态的应用</h2><h3 id="5-2-1-方法重写（最常见的形式）"><a href="#5-2-1-方法重写（最常见的形式）" class="headerlink" title="5.2.1 方法重写（最常见的形式）"></a>5.2.1 方法重写（最常见的形式）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">pass</span><br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):  <br>        <span class="hljs-variable language_">self</span>.width = width  <br>        <span class="hljs-variable language_">self</span>.height = height  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.width * <span class="hljs-variable language_">self</span>.height  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Shape</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):  <br>        <span class="hljs-variable language_">self</span>.radius = radius  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>  <br>  <br>  <br><span class="hljs-comment"># 多态的体现  </span><br>shapes = [Square(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>), Circle(<span class="hljs-number">3</span>), Square(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)]  <br>  <br><span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes:  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;面积: <span class="hljs-subst">&#123;shape.area()&#125;</span>&quot;</span>)  <span class="hljs-comment"># 同样的方法调用，不同的结果</span><br></code></pre></td></tr></table></figure><h3 id="5-2-2-运算符重载"><a href="#5-2-2-运算符重载" class="headerlink" title="5.2.2 运算符重载"></a>5.2.2 运算符重载</h3><p>相同的运算符（如 <code>+</code>, <code>*</code>）对不同类型的对象有不同的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># + 运算符的多态</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)        <span class="hljs-comment"># 数字加法: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; World&quot;</span>)  <span class="hljs-comment"># 字符串拼接: Hello World</span><br><span class="hljs-built_in">print</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])     <span class="hljs-comment"># 列表合并: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="5-2-3-内置函数的多态"><a href="#5-2-3-内置函数的多态" class="headerlink" title="5.2.3 内置函数的多态"></a>5.2.3 内置函数的多态</h3><p>像 <code>len()</code> 这样的函数可以对多种类型的对象工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello&quot;</span>))     <span class="hljs-comment"># 字符串长度: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))   <span class="hljs-comment"># 列表元素个数: 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;))  <span class="hljs-comment"># 字典键值对数量: 2</span><br></code></pre></td></tr></table></figure><h2 id="5-3-抽象类（接口）"><a href="#5-3-抽象类（接口）" class="headerlink" title="5.3 抽象类（接口）"></a>5.3 抽象类（接口）</h2><p>在Python中，抽象类和接口是一个东西，方法体是<strong>空实现的</strong>（<code>pass</code>）称之为<strong>抽象方法</strong>，<strong>含有抽象方法的类</strong>称之为<strong>抽象类</strong>。</p><ul><li>父类用来确定有哪些方法（<strong>父类制定接口标准</strong>）</li><li>具体的方法实现有子类来实现（<strong>子类实现接口标准</strong>）</li></ul><p>在Python中，抽象类的子类并不是必须要实现所有的抽象方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&#x27;&#x27;&#x27;吃&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&#x27;&#x27;&#x27;工作&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># Person的子类要去实现eat和work两个方法</span><br></code></pre></td></tr></table></figure><h1 id="6-其他特性"><a href="#6-其他特性" class="headerlink" title="6 其他特性"></a>6 其他特性</h1><h2 id="6-1-实例属性和实例方法"><a href="#6-1-实例属性和实例方法" class="headerlink" title="6.1 实例属性和实例方法"></a>6.1 实例属性和实例方法</h2><p>使用 <code>类名()</code>创建对象，创建对象的动作有两步：</p><ol><li>在内存中为对象分配空间</li><li>调用初始化方法 <code>__init__</code>为对象初始化</li></ol><p>对象创建后，内存中就有了一个对象的实实在在的存在——<strong>实例</strong>。</p><ul><li>创建出来的对象叫做<strong>类的实例</strong>，创建对象的动作叫做<strong>实例化</strong></li><li>对象的属性叫做<strong>实例属性</strong>，对象的方法叫做<strong>实例方法</strong></li></ul><p>对象各自拥有自己的实例属性，可以通过 <code>self.</code>  访问自己的属性、调用自己的方法。</p><blockquote><p>每一个对象都有自己<strong>独立的内存空间，保存各自不同的属性</strong>。<br>多个对象的方法，在内存中只有一份，调用方法时，需要把对象的引用传递到方法的内部。</p></blockquote><h2 id="6-2-类属性和类方法"><a href="#6-2-类属性和类方法" class="headerlink" title="6.2 类属性和类方法"></a>6.2 类属性和类方法</h2><ul><li>在程序运行时，类同样会被加载到内存，在Python中，类是一个特殊的对象——<strong>类对象</strong>。</li><li>在程序运行时，类对象在内存中<strong>只有一份</strong>，使用一个类可以创建出<strong>很多个对象的实例</strong>。</li></ul><p>除了封装<strong>实例的属性和方法</strong>外，类对象还可以拥有<strong>自己的属性和方法</strong>——<strong>类属性、类方法</strong>。</p><ul><li>类属性：给类对象定义的属性，与具体对象无关，用来记录<strong>类对象的相关特征</strong></li><li>类方法：给类对象定义的方法，可以访问类对象或调用其他类方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-comment"># 定义类属性，描述学生数量</span><br>count = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 定义类方法，使用@classmethod标识</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>(<span class="hljs-params">cls</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;学生的数量为<span class="hljs-subst">&#123;cls.count&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>类方法第一个参数必须为类对象，通常用 <code>cls</code>表示，类似实例方法中的 <code>self</code>，不需要传值。<br>在类方法中，哪个类调用的方法，<code>cls</code>就是哪个类的引用，可以通过 <code>cls.</code>访问类属性或调用类方法。</p></blockquote><p><img src="/../../../ai_assets/Pasted%20image%2020250904191238.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 访问类属性</span><br>类名.类属性  <span class="hljs-comment"># 推荐</span><br>对象名.类属性 <br><br><span class="hljs-comment"># 调用类方法   </span><br>类名.类方法  <span class="hljs-comment"># 推荐</span><br>对象名.类方法<br></code></pre></td></tr></table></figure><h2 id="6-3-静态方法"><a href="#6-3-静态方法" class="headerlink" title="6.3 静态方法"></a>6.3 静态方法</h2><p>既不需要访问实例属性和实例方法，又不需要访问类属性和类方法，就可以使用<strong>静态方法</strong>，使用装饰器 <code>@staticmethod</code>来标识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>():  <span class="hljs-comment"># 不需要self</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>)<br><br><span class="hljs-comment"># 调用静态方法</span><br>类.静态方法()   <span class="hljs-comment"># 推荐</span><br>对象.静态方法()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04_Python异常与模块</title>
    <link href="/2024/07/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/07/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/04_Python%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1 异常处理"></a>1 异常处理</h1><h2 id="1-1-异常的捕获"><a href="#1-1-异常的捕获" class="headerlink" title="1.1 异常的捕获"></a>1.1 异常的捕获</h2><p>世界上没有完美的程序，程序运行都可能出现异常，出现异常有下面两种情况：</p><ol><li>整个程序因为一个BUG停止运行</li><li>对BUG进行提醒，整个程序继续运行</li></ol><p>实际开发更多是第2种情况，就需要<strong>捕获异常</strong>，它的作用在于：提前假设某处会出现异常，提前做好准备，当真的出现异常的时候，可以有后续手段，一般 <code>try</code> 下方只放一行尝试执行的代码。</p><ul><li><code>try</code>：只有在 <code>try</code> 内部的代码，才会被捕获异常</li><li><code>except</code>：匹配机制，用来匹配特定异常</li><li><code>else</code>：没有异常的时候执行</li><li><code>finally</code>：有没有异常都会执行</li></ul><p>用 <code>try</code>来运行可能出错的代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至 <code>except</code>语句块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 别名:<br>    出现异常的处理代码<br><span class="hljs-keyword">else</span>:<br>    没有异常的处理代码<br><span class="hljs-keyword">finally</span>:<br>    有没有异常都会执行的代码<br></code></pre></td></tr></table></figure><hr><p>捕获常规异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span>:<br>出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获指定异常：如果异常类型和要捕获的异常类型不一致，则无法捕获异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> 变量:<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获多个异常：在except后使用元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能有异常的代码<br><span class="hljs-keyword">except</span> (异常类型<span class="hljs-number">1</span>, 异常类型<span class="hljs-number">2</span>):<br>    出现异常的处理代码<br></code></pre></td></tr></table></figure><p>捕获异常并输出描述信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span> 异常类型 <span class="hljs-keyword">as</span> e:<br>pirnt(e)<br></code></pre></td></tr></table></figure><p>捕获所有异常：<code>Exception</code> 是所有异常的父类，任何异常都可以用 <code>Exception</code> 抓住</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>可能有异常的代码<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>pirnt(e)<br></code></pre></td></tr></table></figure><p><code>except</code>不仅会捕获指定异常，还会将其子类一网打尽，常见错误类型和继承关系：<br><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><h2 id="1-2-异常的记录与抛出"><a href="#1-2-异常的记录与抛出" class="headerlink" title="1.2 异常的记录与抛出"></a>1.2 异常的记录与抛出</h2><p>记录错误，使用Python内置的 <code>logging</code>模块可以很方便的记录异常信息，打印完错误信息程序还会继续正常执行。通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    logging.exception(e)<br></code></pre></td></tr></table></figure><p>异常本质上也是一个 <code>class</code>，捕获异常就是捕获该类的一个实例。异常不是凭空产生的，而是有意创造的并抛出的。必要时我们可以定义一个异常 <code>class</code>，并选择好合适的继承关系，用 <code>raise</code>进行抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):  <br>    <span class="hljs-keyword">pass</span>  <br><br><br>a = <span class="hljs-number">10</span>  <br>b = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">&#x27;分母为0&#x27;</span>)  <br><span class="hljs-built_in">print</span>(a / b)<br></code></pre></td></tr></table></figure><h1 id="2-异常的传递"><a href="#2-异常的传递" class="headerlink" title="2  异常的传递"></a>2  异常的传递</h1><p>当函数 <code>func01</code> 中发生异常, 并且没有捕获处理这个异常的时候, 异常会传递到函数 <code>func02</code>, 当 <code>func02</code> 也没有捕获处理这个异常的时候，<code>main</code> 函数会捕获这个异常,  这就是异常的传递性。<br><strong>当所有函数都没有捕获异常的时候, 程序就会报错</strong>。</p><p><img src="/../../../ai_assets/Pasted%20image%2020250901212333.png"></p><blockquote><p>利用异常具有传递性的特点，当我们想要保证程序不会因为异常崩溃的时候，就可以在 <code>main</code> 函数中设置异常捕获，由于无论在整个程序哪里发生异常, 最终都会传递到 <code>main</code> 函数中，这样就可以确保所有的异常都会被捕获。</p></blockquote><h1 id="3-模块与包"><a href="#3-模块与包" class="headerlink" title="3 模块与包"></a>3 模块与包</h1><h2 id="3-1-模块基本用法"><a href="#3-1-模块基本用法" class="headerlink" title="3.1 模块基本用法"></a>3.1 模块基本用法</h2><p>模块就是一个Python文件，里面有类、函数、变量等，可以导入模块去使用，类似C++的头文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">from</span> 包|模块] <span class="hljs-keyword">import</span> 包|模块|函数|变量|类... [<span class="hljs-keyword">as</span> 别名]<br></code></pre></td></tr></table></figure><p>实例：<br>代码文件 <code>B.py</code> 中有函数：<code>B1</code> <code>B2</code> <code>B3</code>，在代码文件A中使用，可以有如下写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法一</span><br><span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 别名</span><br><span class="hljs-keyword">import</span> B <span class="hljs-keyword">as</span> b<br>b.B1()<br>b.B2()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 方法二</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> B1, B2<br>B1()<br>B2()<br><span class="hljs-comment"># B3没有导入，不能使用</span><br><br><span class="hljs-comment"># 导入B中所有函数，但不推荐，因为没有方法一可读性强，归属关系不清楚</span><br><span class="hljs-keyword">from</span> B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br>B3()<br></code></pre></td></tr></table></figure><h2 id="3-2-Python内置变量"><a href="#3-2-Python内置变量" class="headerlink" title="3.2 Python内置变量"></a>3.2 Python内置变量</h2><p><code>__name__</code>变量：<br>任何一个Python代码中，都隐式附带这个变量。</p><ul><li>当这个代码文件直接执行的时候，此变量记录值是：<code>__main__</code></li><li>当这个代码文件，作为模块被其它代码文件导入的时候，此变量记录值是：<code>代码文件名本身</code></li></ul><p>基于这个特性，我们可以区分这个文件是执行了还是被导入了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ...       <span class="hljs-comment"># 在测试的时候，可以避免其他文件导入时该文件时，都执行测试代码</span><br></code></pre></td></tr></table></figure><p><code>__all__</code>变量：<br>表示的是如果文件被 <code>from 模块 import *</code>导入，则内部的哪些函数可以被 <code>*</code>导入。<br>默认是全部导入，如果不想要全部的话，可以手动赋值此变量。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># B3不会被其他文件导入</span><br>__all__ = [<span class="hljs-string">&quot;B1&quot;</span>, <span class="hljs-string">&quot;B2&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B1</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B2</span>():<br>    ...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B3</span>():<br>    ...<br></code></pre></td></tr></table></figure><h2 id="3-3-包"><a href="#3-3-包" class="headerlink" title="3.3 包"></a>3.3 包</h2><p>概念：Python的包是一个特殊文件夹，这个文件夹内包含：</p><ol><li><code>__init__.py</code>的文件（用来控制模块的导入行为）</li><li>其它模块（<code>.py</code>）文件</li></ol><p>包可以帮助我们<strong>管理模块</strong>, 包的作用就是包含多个模块，但包的本质依然是模块。<br><img src="/../../../ai_assets/Pasted%20image%2020250902103509.png"></p><p>实例：<br>文件夹 <code>my_package</code>内有：</p><ul><li><code>__init__.py</code>文件</li><li>有 <code>A.py</code> <code>C.py</code> 模块文件</li><li>有 <code>B.py</code> 模块文件，这个模块内提供 <code>B1</code> <code>B2</code> <code>B3</code> 三个函数</li></ul><p>方式一：不受 <code>__init__.py</code>控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不推荐，不好写</span><br><span class="hljs-keyword">import</span> my_package.B<br>my_package.B.B1()<br>my_package.B.B2()<br></code></pre></td></tr></table></figure><p>方式二：受到 <code>__init__.py</code>控制<br>在 <code>__init__.py</code> 文件内写上：<code>__all__ = [&quot;A&quot;, &quot;B&quot;]</code> ，则可以使用A和B两个模块，无法用C这个模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> B<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> *<br>B.B1()<br>B.B2()<br><br><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> B1<br>B1()    <span class="hljs-comment"># 无法使用B2和B3</span><br><br><span class="hljs-comment"># 不推荐，可读性差</span><br><span class="hljs-keyword">from</span> my_package.B <span class="hljs-keyword">import</span> *<br>B1()<br>B2()<br></code></pre></td></tr></table></figure><h2 id="3-4-安装第三方包"><a href="#3-4-安装第三方包" class="headerlink" title="3.4 安装第三方包"></a>3.4 安装第三方包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install 包名称<br></code></pre></td></tr></table></figure><p>如果网络不好可以用清华镜像，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称<br></code></pre></td></tr></table></figure><p>在Pycharm直接安装<br><img src="/../../../ai_assets/Pasted%20image%2020250902110216.png"></p><h2 id="3-5-Anaconda"><a href="#3-5-Anaconda" class="headerlink" title="3.5 Anaconda"></a>3.5 Anaconda</h2><p>Anaconda内置了非常多的第三方库，可以用来管理Python模块。<br>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在 <code>sys</code>模块的 <code>path</code>变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习\\试学班&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\@DevCode\\PyProject\\Python学习&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_display&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\python310.zip&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\DLLs&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env&#x27;, </span><br><span class="hljs-string">&#x27;D:\\Develop\\Anaconda\\envs\\my_project_env\\lib\\site-packages&#x27;, </span><br><span class="hljs-string">&#x27;D:\\PyCharm 2023.2.3\\plugins\\python\\helpers\\pycharm_matplotlib_backend&#x27;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>可以设置环境变量 <code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。</p>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03_Python文件操作</title>
    <link href="/2024/07/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/07/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/03_Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件打开"><a href="#1-文件打开" class="headerlink" title="1 文件打开"></a>1 文件打开</h1><p><code>open</code>函数，可以打开已存在的文件，或创建一个新文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(name, mode, encoding)<br></code></pre></td></tr></table></figure><ul><li><code>name</code>：文件路径</li><li><code>mode</code>：工作模式：只读、写入、追加等</li><li><code>encoding</code>：编码格式（推荐UTF-8）</li></ul><p>工作模式：</p><ul><li><code>r</code> ：只读（默认）</li><li><code>rb</code>：读取非文本文件（内部是01），否则会被默认按UTF-8编码）</li><li><code>wb</code>：写入非文本文件（01）</li><li><code>w</code> ：覆盖写入，原有内容会被删除</li><li><code>a</code> ：追加写入，在原有内容后追加</li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250901145332.png"></p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于encoding的位置不是第三个，所以要用关键字参数显式指明</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;python.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment"># 此时f是open函数的文件对象，拥有属性和方法</span><br></code></pre></td></tr></table></figure><h1 id="2-文件关闭"><a href="#2-文件关闭" class="headerlink" title="2 文件关闭"></a>2 文件关闭</h1><p><code>close()</code>关闭文件对象，和打开文件是配套操作。如果不关闭，文件会被Python一直占用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.close()  <span class="hljs-comment"># 同时会自动调用 文件对象.flush() </span><br></code></pre></td></tr></table></figure><h1 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3 文件读取"></a>3 文件读取</h1><p>文件读取的前置要求是文件要先打开。</p><p><code>read()</code>方法：<br>读取文件，返回一个<strong>字符串</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.read(num)<br><span class="hljs-comment"># num表示读取的长度（单位字节），没有传入num默认读取文件所有数据</span><br></code></pre></td></tr></table></figure><p><code>readlines()</code>方法：<br>读取整个文件，按照行进行切分，返回一个<strong>列表</strong>，每一行数据作为一个元素，末尾添加 <code>\n</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readlines()<br></code></pre></td></tr></table></figure><p><code>readline()</code>方法：<br>调用一次读取一行内容，返回<strong>字符串</strong>，末尾带有 <code>\n</code>。如需读取多行，需要多次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.readline()<br></code></pre></td></tr></table></figure><blockquote><p>读取文件有指针标记位置，使用 <code>f.seek(0)</code>回拨指针到开头。</p></blockquote><p>循环读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式一</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象:<br>...     <span class="hljs-comment"># line是每一行的字符串</span><br><br><span class="hljs-comment"># 方式二</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> 文件对象.readlines():<br>...     <span class="hljs-comment"># line是每一行的字符串</span><br></code></pre></td></tr></table></figure><p><code>with open</code>：<br>这是一种包含打开、操作、关闭的快捷操作方式，在 <code>with open</code>的语句块中完成文件操作，操作完成后自动关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(...) <span class="hljs-keyword">as</span> 文件对象:<br>文件对象.read()<br>...<br><br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>ls = f.readlines()<br><span class="hljs-built_in">print</span>(ls)<br></code></pre></td></tr></table></figure><h1 id="4-文件写入"><a href="#4-文件写入" class="headerlink" title="4 文件写入"></a>4 文件写入</h1><p>覆盖写入：</p><ul><li>调用 <code>write</code>时内容并未真正写入文件，而是会积攒在程序的内存中，称之为<strong>缓冲区</strong></li><li>当调用 <code>flush</code> 的时候，内容才会真正写入文件</li><li>这样做可以避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写入磁盘）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-comment"># 2、覆盖写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入文件，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure><p>追加写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、打开文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-comment"># 2、追加写入</span><br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-comment"># 3、内容刷新</span><br>f.flush()   <span class="hljs-comment"># 可以立即将缓冲区数据写入目的地，而不是等缓冲区满或程序结束</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01_Python基础语法</title>
    <link href="/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/01_Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h1><ul><li>单行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br></code></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">多行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>Python不区分单双引号，都可以。</p></blockquote><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><p>Python的变量与C++不同，<strong>变量本身没有类型</strong>，但存储的数据本身是有类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;哈哈哈&#x27;</span><br>name = <span class="hljs-number">666</span><br><span class="hljs-built_in">print</span>(name)  <span class="hljs-comment"># name 内的值变成了666</span><br></code></pre></td></tr></table></figure><blockquote><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，例如Java和C++。</p></blockquote><p>Python变量一般不使用驼峰命名法，而是使用<strong>全小写加下划线</strong>。<br>变量命名规则：</p><ol><li>字母、数字、下划线组成</li><li>不能以数字开头</li><li>区分大小写</li><li>不能使用关键字</li></ol><p>Python中可以把任何数据都看成一个“对象”，而变量就是在程序中用来<strong>指向这些数据对象</strong>的，对变量赋值就是把数据和变量给关联起来。</p><p>Python解释器在执行 <code>a = 10</code>赋值时做以下操作：</p><ol><li>创建变量 a</li><li>创建一个对象(分配一块内存)，来存储值10</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p><img src="/../../../ai_assets/Pasted%20image%2020250909101046.png"></p><h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250831105835.png"></p><p>可以使用 <code>type()</code>查看变量内存储的是什么类型。</p><p>数据类型转换：</p><ul><li><code>int()</code>转换为整数</li><li><code>float()</code>转换为浮点数</li><li><code>str()</code>转换为字符串</li><li><code>bool</code>转化为布尔</li><li><code>list()</code>转换为列表</li><li>…</li></ul><p>字符处理相关：</p><ul><li><code>ord()</code>获取字符的整数表示</li><li><code>chr()</code>把编码转换为对应的字符</li></ul><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4 运算符"></a>4 运算符</h1><p><strong>算术运算符</strong></p><ul><li><code>+</code> 加法</li><li><code>-</code> 减法</li><li><code>*</code> 乘法</li><li><code>/</code> 除法</li><li><code>//</code> 整除</li><li><code>%</code> 取余</li><li><code>**</code> 乘方</li></ul><p><strong>赋值运算符</strong></p><ul><li><code>=</code> 将右侧结果赋予左侧变量</li></ul><p><strong>复合赋值运算符</strong></p><ul><li><code>a?=b</code> 相当于：<code>a = a?b</code> ，这个 <code>?</code> 可以是任何的算术运算符</li></ul><p><strong>比较运算符</strong></p><ul><li><code>==</code> 相等</li><li><code>!=</code> 不相等</li><li><code>&gt;</code> 大于</li><li><code>&lt;</code> 小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li></ul><p><strong>逻辑运算符</strong></p><ul><li><code>and</code> 全真为真</li><li><code>or</code> 全假为假</li><li><code>not</code> 取反</li></ul><h1 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5 输入输出"></a>5 输入输出</h1><h2 id="5-1-print输出"><a href="#5-1-print输出" class="headerlink" title="5.1 print输出"></a>5.1 print输出</h2><p><code>print()</code> 语句（函数）可以向屏幕内一次性输出多份内容，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以空格分隔，内容可以是：字面量、变量、表达式。</span><br><span class="hljs-built_in">print</span>(内容<span class="hljs-number">1</span>, 内容<span class="hljs-number">2</span>, ... ,..., 内容N)<br><br><span class="hljs-comment"># 默认以回车结束，可以使用end设置</span><br><span class="hljs-built_in">print</span>(内容, end = <span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>格式化输出：</strong><br>两种方法变量的位置都可以填写表达式，Python会先计算再填入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5-2-input输入"><a href="#5-2-input输入" class="headerlink" title="5.2 input输入"></a>5.2 input输入</h2><p><code>input()</code> 可以获取用户的键盘录入数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>()  <span class="hljs-comment"># 从键盘输入内容，赋值给name变量  </span><br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)  <span class="hljs-comment"># 输入前会输出指定的提示</span><br></code></pre></td></tr></table></figure><p>注意：<code>input</code> 输入的内容会自动转换为<strong>字符串</strong>类型，如果需要输入数字类型，要自行转换类型。</p><p><strong>在同一行输入多个内容：</strong><br><code>map()</code> 的作用是：将一个函数应用到可迭代对象（如列表、元组等）的每一个元素上，并返回一个包含所有结果的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原理：input()输入进来是字符串，split()默认按照空格分割，返回一个字符串列表</span><br><span class="hljs-comment"># map将int()函数应用到列表里的每一个元素，返回一个迭代器，可以使用变量分别接收</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>name, pwd = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure><p><strong>一行内输入列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将map返回的迭代器转换为列表</span><br>ls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure><p><strong>连续输入多行数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：逐行读取</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = []  <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <br>    row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))  <br>    mp.append(row)<br><br><span class="hljs-comment"># 特殊的字符矩阵</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>mp = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().strip())  <span class="hljs-comment"># 将输入的字符串处理空行换行之后转为列表</span><br>mp.append(row)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：列表推导式</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())  <br>mp = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><h1 id="6-分支语句"><a href="#6-分支语句" class="headerlink" title="6 分支语句"></a>6 分支语句</h1><h2 id="6-1-if-elif-else"><a href="#6-1-if-elif-else" class="headerlink" title="6.1 if-elif-else"></a>6.1 if-elif-else</h2><p><code>else if</code> 可以简写为 <code>elif</code>。<br>特殊地，Python不同于C++，<code>a &gt; 1 and a &lt; 100</code>可以简写为 <code>1 &lt; a &lt; 100</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件<span class="hljs-number">1</span>:<br>代码块<span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">2</span>:<br>代码块<span class="hljs-number">2</span><br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">3</span>:<br>代码块<span class="hljs-number">3</span><br><span class="hljs-keyword">else</span>:<br>代码块<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>Python通过缩进区分代码块，缩进需要严格准确。缩进可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，Python对缩进极其依赖，<strong>不要使用制表键（Tab键）来缩进代码</strong>，可以在编辑器中设置Tab为4个空格。</p></blockquote><p>Python中为了简化 <code>if-else</code>结构，也引入了三元运算符，结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">真值结果 <span class="hljs-keyword">if</span> 条件 <span class="hljs-keyword">else</span> 假值结果<br>num = <span class="hljs-number">10</span><br>res = <span class="hljs-string">&#x27;偶数&#x27;</span> <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;奇数&#x27;</span><br><span class="hljs-built_in">print</span>(res)  <span class="hljs-comment"># 偶数</span><br></code></pre></td></tr></table></figure><h2 id="6-2-match-case"><a href="#6-2-match-case" class="headerlink" title="6.2 match-case"></a>6.2 match-case</h2><p>类似C++的 <code>switch-case</code>，但有所差别，不像C++遇到 <code>break</code>才停止，而是只执行匹配条件的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">alp = <span class="hljs-string">&#x27;a&#x27;</span>  <br>  <br><span class="hljs-keyword">match</span> alp:  <br>    <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= x &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:  <span class="hljs-comment"># 使用条件，并且返回匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;小写字母<span class="hljs-subst">&#123;x&#125;</span>&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写A&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span> | <span class="hljs-string">&#x27;C&#x27;</span> | <span class="hljs-string">&#x27;D&#x27;</span>:  <span class="hljs-comment"># 多个匹配值</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大写B C D&#x27;</span>)  <br>    <span class="hljs-keyword">case</span> _:  <span class="hljs-comment"># _ 代表其他情况，类似C++的default</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;其他情况&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="7-循环语句"><a href="#7-循环语句" class="headerlink" title="7 循环语句"></a>7 循环语句</h1><h2 id="7-1-while循环"><a href="#7-1-while循环" class="headerlink" title="7.1 while循环"></a>7.1 while循环</h2><p>与C++不同的是，Python有独特的 <code>循环-else</code>结构：</p><ul><li><code>else</code> 子句只在循环正常完成时执行</li><li>如果循环被 <code>break</code> 中断，<code>else</code> 部分不会执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 条件:<br>代码块<br><span class="hljs-keyword">else</span>:<br>代码块<br></code></pre></td></tr></table></figure><h2 id="7-2-for循环"><a href="#7-2-for循环" class="headerlink" title="7.2 for循环"></a>7.2 for循环</h2><p><code>for</code>循环与C++有所不同，从待处理数据集中，挨个取出内容，将其赋给临时变量，然后执行循环语句，循环往复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 待处理数据集:<br>代码块<br><span class="hljs-keyword">else</span>:<br>代码块<br></code></pre></td></tr></table></figure><p><code>for</code>循环这种遍历方式叫做<strong>迭代（Iteration）</strong>，上述语法的待处理数据集，本质上应当是：<strong>可迭代对象</strong>，可以使用 <code>isinstance</code>方法判断是否为可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable))  <span class="hljs-comment"># True，字符串可迭代</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable))  <span class="hljs-comment"># False，整数不可迭代</span><br></code></pre></td></tr></table></figure><p>可迭代对象（类型）：<strong>其内容可以一个个依次取出的一种类型</strong>，包括：</p><ul><li>集合数据类型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li><li>集合</li></ul></li><li>生成器<ul><li>生成器表达式</li><li>生成器函数</li></ul></li><li><code>range</code>序列</li></ul><p>和C++相同，Python可以使用 <code>continue</code>跳过本轮循环，使用 <code>break</code>中断整个循环。</p><blockquote><p>在Python中，变量作用域有些特殊，在for循环的外部访问临时变量，<strong>实际上可以访问到，但在编程规范上不建议这样做。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br><span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>在规范中，Python通过 <code>:</code>和缩进控制作用域，实现C++中 <code>&#123;&#125;</code>的作用。</p></blockquote><hr><p><code>range()</code>可以生成数字序列，生成的数字序列是<strong>可迭代对象</strong>，与列表类似，但不是列表类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成从0开始，到num结束（但不包括num），也就是 [0, num)</span><br><span class="hljs-built_in">range</span>(num) <br><br><span class="hljs-comment"># 从num1开始，到num2结束（不包括num2），为[num1, num2)</span><br><span class="hljs-built_in">range</span>(num1, num2)<br><br><span class="hljs-comment"># 和上一个范围一样，但步长由step决定</span><br><span class="hljs-built_in">range</span>(num1, num2, step)<br></code></pre></td></tr></table></figure><p><code>range()</code>可以和 <code>for</code>循环进行搭配，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br><span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-comment"># 等价于以下C++代码</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>另外Python还可以使用 <code>zip</code>将多个可迭代对象放在一个循环内进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]<br><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(x, y):<br>    <span class="hljs-built_in">print</span>(i, j)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1 10</span><br><span class="hljs-string">2 11</span><br><span class="hljs-string">3 12</span><br><span class="hljs-string">4 13</span><br><span class="hljs-string">5 14</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8 函数"></a>8 函数</h1><h2 id="8-1-语法格式"><a href="#8-1-语法格式" class="headerlink" title="8.1 语法格式"></a>8.1 语法格式</h2><p>参数和返回值可以省略，函数必须先定义再调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">[形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2.</span>..]</span>):<br>函数内容<br>[<span class="hljs-keyword">return</span> 返回值]<br><span class="hljs-comment"># Python PEP8规范：函数定义的前后分别空两行</span><br><br><span class="hljs-comment"># 调用函数</span><br>函数名([实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2.</span>..])<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br><span class="hljs-keyword">return</span> a + b + c<br><br><span class="hljs-built_in">sum</span> = add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 形参和实参一一对应，与C++不同的是，实参的传入类型不受限制。</span><br>add(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在Python中函数可以有多个返回值，并且可以是不同类型，按照返回值顺序，用多个变量接收即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">18</span>   <span class="hljs-comment"># 本质是返回了一个元组 (&quot;zhangsan&quot;, 18)</span><br><br>name, age = test()          <span class="hljs-comment"># 等同于 name, age = (&quot;zhangsan&quot;, 18)</span><br></code></pre></td></tr></table></figure><p>Python是动态强类型语言，函数中可以显式声明接收的数据类型，但是没有实际作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 规定num接收int类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(func(<span class="hljs-string">&#x27;哈哈哈&#x27;</span>))  <span class="hljs-comment"># 甚至可以传字符串</span><br></code></pre></td></tr></table></figure><h3 id="8-1-1-位置参数"><a href="#8-1-1-位置参数" class="headerlink" title="8.1.1 位置参数"></a>8.1.1 位置参数</h3><p>就是C++最普通的函数传值方式， 传递的参数和定义的参数<strong>一一对应</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>...<br><br><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 数量一致，顺序一致，一一对应</span><br></code></pre></td></tr></table></figure><h3 id="8-1-2-关键字参数"><a href="#8-1-2-关键字参数" class="headerlink" title="8.1.2 关键字参数"></a>8.1.2 关键字参数</h3><p>通过<strong>键值对形式</strong>显式指明形参的名称，由于会自动匹配，所以可以不按照顺序进行传入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):<br>...<br><br><br>func(x=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>, y=<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 和位置参数混用的时候，关键字传参必须在位置参数的后面，否则无法对应</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, z=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="8-1-3-默认参数"><a href="#8-1-3-默认参数" class="headerlink" title="8.1.3 默认参数"></a>8.1.3 默认参数</h3><p>默认参数也叫缺省参数，在定义函数时<strong>提供默认值</strong>，调用该函数时如果不传该参数则使用默认参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意有默认值的参数要在无默认值参数的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name, age=<span class="hljs-number">18</span></span>):<br>...<br><br><br>func(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>func(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：缺省参数必须指向不可变对象！因为可变对象在函数内部可能会被修改，而导致和默认值不同。</p></blockquote><h3 id="8-1-4-不定长参数"><a href="#8-1-4-不定长参数" class="headerlink" title="8.1.4 不定长参数"></a>8.1.4 不定长参数</h3><p>不定长参数也叫可变参数，用于在调用时<strong>参数数量不确定</strong>，可以使用元组接收或字典接收。</p><ul><li>使用元组接收：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以传入元组或列表，但args都接收为元组类型，在函数内不可变</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, *args</span>):<br>...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个元组，接收3, 4, 5, 6</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 已经有现成元组或列表，传入时可以加上 * 变成不定长参数</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, *ls)  <span class="hljs-comment"># x接收1，y接收2，args接收列表内的元素</span><br></code></pre></td></tr></table></figure><ul><li>使用字典接收：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, **kwargs</span>):<br>...<br><br><br><span class="hljs-comment"># x接收1，y接收2，z是一个字典，内部有三个键值对</span><br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>, name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 已经有现成字典，传入时可以加上 ** 变成不定长参数</span><br>d = &#123;name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, age: <span class="hljs-number">18</span>&#125;<br>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, **d)  <span class="hljs-comment"># x接收1，y接收2，kwargs接收字典内的元素</span><br><br><span class="hljs-comment"># kwargs只是d的拷贝，在函数内修改kwargs不会影响d的内容</span><br></code></pre></td></tr></table></figure><h2 id="8-2-None"><a href="#8-2-None" class="headerlink" title="8.2 None"></a>8.2 None</h2><p>在Python中有一个数据类型：<code>NoneType</code> ，它只有一个字面量：<code>None</code>，并且不可变。<br>函数如果没有写 <code>return</code>，则默认返回值是 <code>None</code>，或者也可以显式写 <code>return None</code>。</p><p>作用：</p><ul><li>用在 <code>if</code> 判断中， <code>None</code> 等同于 <code>False</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">score</span>):<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;good&#x27;</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 本行也可以省略</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check(<span class="hljs-number">59</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不及格&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>用在变量声明时，暂不需要初始值可以使用 <code>None</code> 代替</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>  age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-comment"># 为了避免作用域问题，age需要在for循环外部定义</span><br><span class="hljs-comment"># for循环外定义的时候，不需要初始值，可以以None代替</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最后一个同学的年龄是：%d &quot;</span> % age)<br></code></pre></td></tr></table></figure><ul><li>用于函数无返回值时</li></ul><h2 id="8-3-函数规范注释"><a href="#8-3-函数规范注释" class="headerlink" title="8.3 函数规范注释"></a>8.3 函数规范注释</h2><p>使用多行注释，在函数体之前为函数进行说明解释，在Pycharm中调用函数时通过鼠标悬停可以显示函数的说明文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    函数说明文本</span><br><span class="hljs-string">    :param 参数1: 参数1的说明</span><br><span class="hljs-string">    :param 参数2: 参数2的说明</span><br><span class="hljs-string">    :return: 返回值的说明</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    函数体<br>    <span class="hljs-keyword">return</span> ...<br></code></pre></td></tr></table></figure><h2 id="8-4-变量作用域"><a href="#8-4-变量作用域" class="headerlink" title="8.4 变量作用域"></a>8.4 变量作用域</h2><p>局部变量：写在函数内部的是局部变量，其作用范围只在函数内部有效。<br>全局变量：写在函数外部的是全局变量，其作用范围在函数内外都生效。</p><p><code>global</code>关键字：可以<strong>在函数内部将局部变量声明为全局变量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span>  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():  <br>    <span class="hljs-keyword">global</span> a  <br>    a = <span class="hljs-number">100</span>  <span class="hljs-comment"># 使用global声明后，可以在函数内部修改全局变量</span><br>  <br>  <br>fun()  <br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出为100</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02_Python数据容器</title>
    <link href="/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/07/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/01%20Python%E5%9F%BA%E7%A1%80/02_Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-列表-list"><a href="#1-列表-list" class="headerlink" title="1 列表(list)"></a>1 列表(list)</h1><h2 id="1-1-列表的创建与访问"><a href="#1-1-列表的创建与访问" class="headerlink" title="1.1 列表的创建与访问"></a>1.1 列表的创建与访问</h2><p>列表类似C++的数组，不过列表中的数据可以为<strong>不同的数据类型</strong>，并且可以嵌套，嵌套时类似C++的多维数组。<br>列表定义用 <code>[]</code>包围，以 <code>,</code>分割，正向下标从0开始，有<strong>反向索引</strong>，从-1开始，从后往前，依次递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = []   <span class="hljs-comment"># 空列表</span><br><br>demo_list = [<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;哈哈&#x27;</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>]]<br><span class="hljs-comment"># 正向索引    0      1     2       3 </span><br><span class="hljs-comment"># 反向索引   -4     -3    -2      -1</span><br><br>demo[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 得到 &#x27;哈哈&#x27;</span><br>demo[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 得到 1</span><br></code></pre></td></tr></table></figure><p>列表可以使用 <code>+</code>拼接或使用 <code>*</code>实现重复计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ls1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] * <span class="hljs-number">2</span><br>ls2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-built_in">print</span>(ls1)  <span class="hljs-comment"># [1, 2, 1, 2]</span><br><span class="hljs-built_in">print</span>(ls1 + ls2)  <span class="hljs-comment"># [1, 2, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="1-2-列表生成式"><a href="#1-2-列表生成式" class="headerlink" title="1.2 列表生成式"></a>1.2 列表生成式</h2><p>列表生成式的效率很高，<strong>强烈建议使用列表生成式来创建列表</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">要生成的元素 循环 过滤条件<br><br><span class="hljs-comment"># 将表达式按照特定条件依次放到列表中，生成了1~10</span><br>ls = [i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <br><br><span class="hljs-comment"># 等价于以下循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>ls.append(i + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 有条件的列表推导式</span><br>ls = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># 生成0~99的偶数列表</span><br><br><span class="hljs-comment"># 多重循环的列表推导式</span><br>ls = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <span class="hljs-comment"># 生成x，y坐标</span><br></code></pre></td></tr></table></figure><blockquote><p>推导式可以用来生成列表、集合、字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>: <span class="hljs-number">15</span>, <span class="hljs-string">&#x27;zhaoliu&#x27;</span>: <span class="hljs-number">16</span>&#125;  <br><br><span class="hljs-comment"># 生成字典</span><br>dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic1.items() <span class="hljs-keyword">if</span> v &gt;= <span class="hljs-number">18</span>&#125;  <span class="hljs-comment"># 过滤大于18岁的人</span><br><br><span class="hljs-comment"># 生成集合</span><br>st1 = &#123;k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic1.keys() <span class="hljs-keyword">if</span> dic1[k] &gt;= <span class="hljs-number">18</span>&#125;  <br></code></pre></td></tr></table></figure><h2 id="1-3-列表的遍历"><a href="#1-3-列表的遍历" class="headerlink" title="1.3 列表的遍历"></a>1.3 列表的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># while方式</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(my_list):<br><span class="hljs-built_in">print</span>(my_list[i])<br>i++<br><br><span class="hljs-comment"># for方式</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250904170517.png"></p><h1 id="2-元组-tuple"><a href="#2-元组-tuple" class="headerlink" title="2 元组(tuple)"></a>2 元组(tuple)</h1><h2 id="2-1-元组的创建与访问"><a href="#2-1-元组的创建与访问" class="headerlink" title="2.1 元组的创建与访问"></a>2.1 元组的创建与访问</h2><p>元组与列表类似，不同之处在于元组的元素<strong>不能修改</strong>，元组使用 <code>()</code>，列表使用 <code>[]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = ()    <span class="hljs-comment"># 空元组</span><br><br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># 元组内只有一个元素时，需要有逗号在内，否则小括号会识别为运算符</span><br>nums = (<span class="hljs-number">1</span>,)  √<br>nums = (<span class="hljs-number">1</span>)   ×<br><br><span class="hljs-comment"># 元组的访问和列表完全一样，通过下标访问，支持反向下标</span><br>nums[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-2-元组的“可变”"><a href="#2-2-元组的“可变”" class="headerlink" title="2.2 元组的“可变”"></a>2.2 元组的“可变”</h2><p>元组内有 <code>list</code>的时候，元组依然遵循元素不可变，但 <code>list</code>内的元素可以修改。这是因为元组存储的时候本质上存的是 <code>list</code>的地址，只要地址不变，元组元素就没有修改，而所指内容是否变化和元组无关。正因为如此，替换为别的 <code>list</code>也是不被允许的，因为地址发生了改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>nums = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, 地址)<br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250909114917.png"></p><h2 id="2-3-打包和解包"><a href="#2-3-打包和解包" class="headerlink" title="2.3 打包和解包"></a>2.3 打包和解包</h2><p>当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打包操作</span><br>a = <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><br><br><span class="hljs-comment"># 解包操作</span><br>i, j, k = a<br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 10 100</span><br></code></pre></td></tr></table></figure><blockquote><p>解包操作对所有序列的成立，包括列表、元组、字符串、<code>range</code>都可以使用解包操作。</p></blockquote><p>解包时元素个数和变量个数不匹配会引发 <code>ValueError</code>异常，不过我们可以使用星号表达式解决变量少于元素个数的情况，让一个变量接收多个值。</p><ol><li>星号修饰的变量会变成一个列表，可以存放0个或多个元素</li><li>解包语法中，只能有一个型号表达式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]  <br><br><span class="hljs-comment"># 可以改变型号表达式的位置，会自动匹配</span><br>i, j, *k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># 1 2 [3, 4, 5, 6]</span><br>  <br>*i, j, k = ls  <br><span class="hljs-built_in">print</span>(i, j, k)  <span class="hljs-comment"># [1, 2, 3, 4] 5 6</span><br></code></pre></td></tr></table></figure><blockquote><p><code>a, b = b, a</code>和 <code>a, b, c = b, c, a</code>实际并没有用到打包解包语法，而是有特定的字节码指令实现这两个操作，效率非常高，在三个以上的变量交换时需要使用打包解包。</p></blockquote><h2 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250831194646.png"></p><h1 id="3-字符串-str"><a href="#3-字符串-str" class="headerlink" title="3 字符串(str)"></a>3 字符串(str)</h1><h2 id="3-1-字符串的创建和访问"><a href="#3-1-字符串的创建和访问" class="headerlink" title="3.1 字符串的创建和访问"></a>3.1 字符串的创建和访问</h2><p>字符串同列表、元组一样，可以通过下标和反向下标进行访问。不过和C++非常不同的一点是，字符串是<strong>无法修改</strong>的容器。也就是说如果要完成修改操作，只能得到一个新的字符串，旧的字符串是无法修改的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字符串可以使用单引号、双引号、三引号进行定义，使用三引号时可以跨行。</span><br><br>s = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment"># 空字符串</span><br><br>s = <span class="hljs-string">&#x27;hhh&#x27;</span><br>s = <span class="hljs-string">&quot;hhh&quot;</span><br>s = <span class="hljs-string">&quot;&quot;&quot;hhh</span><br><span class="hljs-string">hhhh</span><br><span class="hljs-string">hh</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 单引号里面可以包双引号，双引号里面可以包单引号</span><br>s = <span class="hljs-string">&quot;人工&#x27;智&#x27;能&quot;</span><br>s = <span class="hljs-string">&#x27;人工&quot;智&quot;能&#x27;</span><br><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><ul><li>字符串内部使用 <code>\</code>进行转义，比如 <code>\n</code>换行、<code>\t</code>缩进，又或者转义 <code>\ &#39; &quot;</code>这些特殊字符</li><li>Python中以 <code>r</code>或 <code>R</code>开头的字符串叫做原始字符串，字符串内都是本来的含义，没有所谓转义字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 很多字符需要转义需要很多\，可以使用r&#x27;&#x27;或R&#x27;&#x27;表示内部字符串默认不转义</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)  <span class="hljs-comment"># \\</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>) <span class="hljs-comment"># \\\t\\</span><br></code></pre></td></tr></table></figure><h2 id="3-2-字符串的运算"><a href="#3-2-字符串的运算" class="headerlink" title="3.2 字符串的运算"></a>3.2 字符串的运算</h2><ul><li>字符串比较时按照字典序从前往后，只要其中一位大，后面就不用比较了</li><li>可以使用 <code>+</code>进行拼接，还可以使用 <code>*</code>将字符串重复</li></ul><h2 id="3-3-字符串的格式化"><a href="#3-3-字符串的格式化" class="headerlink" title="3.3 字符串的格式化"></a>3.3 字符串的格式化</h2><p>两种方法变量的位置都可以填写表达式，Python会先计算再填入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：使用占位符</span><br><span class="hljs-string">&quot;名字：%s&quot;</span> % name<br><span class="hljs-string">&quot;名字：%s 年龄：%d 分数：%.2f&quot;</span> % (name, age, score)<br><br>%md %mf   限制m位宽度（小数点也算一位）<br>%.nf      保留n位小数 <br>%m.nf     限制m位宽度，并保留n位小数<br><br><span class="hljs-comment"># 想要打出 %，可以使用%%</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.2f%%&quot;</span> % <span class="hljs-number">82.5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法二：f-string格式化，默认不理会类型，也不做精度控制</span><br><span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;name&#125;</span> 年龄：<span class="hljs-subst">&#123;age&#125;</span> 分数：<span class="hljs-subst">&#123;score&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 这种方式也可以控制精度</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;变量:m.n f | d&#125;</span>&quot;</span><br><span class="hljs-string">f&quot;分数<span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-4-常用方法"><a href="#3-4-常用方法" class="headerlink" title="3.4 常用方法"></a>3.4 常用方法</h2><p>由于字符串<strong>不可变</strong>，所以使用字符串的方法并不会改变原来的字符串，而是产生新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 转大写</span><br>su = s.upper()<br><br><span class="hljs-comment"># 转小写</span><br>sl = s.lower()<br><br><span class="hljs-comment"># replace用法，生成新的字符串，原字符串不变</span><br>s = <span class="hljs-string">&quot;Python好玩真好玩&quot;</span><br>new_s = s.replace(<span class="hljs-string">&quot;好玩&quot;</span>, <span class="hljs-string">&quot;有趣&quot;</span>)<br><span class="hljs-built_in">print</span>(s)      <span class="hljs-comment"># 结果还是  Python好玩真好玩</span><br><span class="hljs-built_in">print</span>(new_s)  <span class="hljs-comment"># 修改后的  Python有趣真有趣</span><br><br><span class="hljs-comment"># split用法，原字符串不变，生成一个新列表</span><br>name = <span class="hljs-string">&quot;Python-Java-C++&quot;</span><br>name_list = name.split(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-built_in">print</span>(name)        <span class="hljs-comment"># Python-Java-C++</span><br><span class="hljs-built_in">print</span>(name_list)   <span class="hljs-comment"># [&#x27;Python&#x27;, &#x27;Java&#x27;, &#x27;C++&#x27;]</span><br><br><span class="hljs-comment"># strip用法，去除前后指定字符串</span><br>demo = <span class="hljs-string">&quot;   hhhh  &quot;</span><br>new1 = demo.strip()       <span class="hljs-comment"># 默认去除前后空格和换行符</span><br>demo = <span class="hljs-string">&quot;1211哈哈哈21121&quot;</span><br>new2 = demo.strip(<span class="hljs-string">&quot;12&quot;</span>)   <span class="hljs-comment"># 按照单个字符，&#x27;1&#x27;和&#x27;2&#x27;都会删除</span><br><span class="hljs-built_in">print</span>(new2)    <span class="hljs-comment"># 哈哈哈</span><br></code></pre></td></tr></table></figure><p><img src="/../../../ai_assets/Pasted%20image%2020250831200302.png"></p><h1 id="4-序列的切片"><a href="#4-序列的切片" class="headerlink" title="4 序列的切片"></a>4 序列的切片</h1><p>序列是指：<strong>内容连续、有序，可使用下标索引</strong>的一类数据容器。<br>上述的列表、元组、字符串都是序列。序列支持切片操作，切片就是从原序列中取出一个子序列。</p><p>语法：<code>序列[起始下标:结束下标:步长]</code>（类似 <code>range</code>序列，<code>[起始,结束)</code>范围内指定步长）<br>表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。</p><ul><li>起始下标表示从何处开始，可以留空，留空视作从头开始</li><li>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾</li><li>步长表示依次取元素的间隔（可以为负，反向走，起始下标也要在结束下标右边）</li></ul><p><strong>注意，此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</strong></p><h1 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5 字典(dict)"></a>5 字典(dict)</h1><h2 id="5-1-字典的创建和访问"><a href="#5-1-字典的创建和访问" class="headerlink" title="5.1 字典的创建和访问"></a>5.1 字典的创建和访问</h2><p>字典使用 <code>&#123;&#125;</code>包围，存储的元素是<strong>键值对</strong> <code>key:value</code>，并且 <code>key</code>不可重复，重复会覆盖原有数据。</p><ul><li><code>key</code> 数据类型<strong>必须为不可变类型</strong>，不可为字典、列表，一般类型用：字符串、整数</li><li><code>value</code> 数据类型随意，不限制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;&#125;      <span class="hljs-comment"># 空字典</span><br>d = <span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># 空字典</span><br><br>d = &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&quot;lisi&quot;</span>:<span class="hljs-number">59</span>&#125;<br><br><span class="hljs-comment"># 集合不可用下标进行访问，但可以使用key来取得对应的value</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-string">&quot;zhangsan&quot;</span>])  <span class="hljs-comment"># 结果为100</span><br></code></pre></td></tr></table></figure><p>字典访问到不存在的 <code>key</code>会报错，可以使用 <code>in</code>或 <code>字典.get(键, 返回值)</code>来检验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 in 检验</span><br>d = &#123;<span class="hljs-string">&#x27;zhangsan&#x27;</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span> <span class="hljs-keyword">in</span> d:  <span class="hljs-comment"># 相反还有 not in</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在字典&#x27;</span>)<br><br><span class="hljs-comment"># 使用 字典.get(键, 返回值) 方法</span><br><span class="hljs-comment"># 键存在则返回值，键不存在默认返回 None，也可以指定返回值</span><br><span class="hljs-keyword">if</span> d.get(<span class="hljs-string">&#x27;lisi&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># d.get(&#x27;lisi&#x27;, 1) == 1 作用一样  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不在字典&#x27;</span>)<br><br><span class="hljs-comment"># 可以用get()很方便地统计出现次数</span><br>s = <span class="hljs-built_in">input</span>()  <br>counter = &#123;&#125;  <br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:  <br>    <span class="hljs-keyword">if</span> c.isalpha():  <br>        counter[c] = counter.get(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>  <span class="hljs-comment"># 存在返回已有值，不存在返回0</span><br></code></pre></td></tr></table></figure><blockquote><p>字典通过哈希算法计算 <code>key</code>的位置，所以字典的<strong>查找和插入操作极快</strong>。由于要保证hash的正确性，作为 <code>key</code>的对象就不能变。在Python中，字符串和整数都不可变，可以放心用作 <code>key</code>，<code>list</code>可变不能作为 <code>key</code>。</p></blockquote><h2 id="5-2-字典的遍历"><a href="#5-2-字典的遍历" class="headerlink" title="5.2 字典的遍历"></a>5.2 字典的遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代字典的键</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> d.keys():  <span class="hljs-comment"># 等同于 for i in d:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;名字：<span class="hljs-subst">&#123;k&#125;</span> 分数：<span class="hljs-subst">&#123;d[k]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 迭代字典的值</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> d.values():<br><span class="hljs-built_in">print</span>(v)<br><br><span class="hljs-comment"># 迭代字典的键值对</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items():  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;k&#125;</span>: <span class="hljs-subst">&#123;v&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-3-常用方法"><a href="#5-3-常用方法" class="headerlink" title="5.3 常用方法"></a>5.3 常用方法</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250901085204.png"></p><h1 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6 集合(set)"></a>6 集合(set)</h1><h2 id="6-1-集合的创建"><a href="#6-1-集合的创建" class="headerlink" title="6.1 集合的创建"></a>6.1 集合的创建</h2><p><code>set</code>和 <code>dict</code>类似也是一组 <code>key</code>的集合，但不存储 <code>value</code>，由于 <code>key</code>不能重复，所以在 <code>set</code>中没有重复的 <code>key</code>。集合内部是<strong>去重并且无序</strong>的，使用 <code>&#123;&#125;</code>包围。因为无序，所以集合不可用下标进行访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 空集合，s = &#123;&#125; 不是空集合，而是空字典</span><br><br>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <br></code></pre></td></tr></table></figure><p><code>set</code>和 <code>dict</code>底层原理一样，唯一的区别仅仅在于没有存储 <code>value</code>，<code>key</code>是唯一的保证了 <code>set</code>内部不会有重复元素，由于无法判断两个可变对象是否相等，所以<strong>不能存放可变对象</strong>。</p><blockquote><p>注意与C++非常不同的是，<strong>集合不会自动排序</strong>，<code>dict</code> 和 <code>set</code> 的底层哈希表会让它看起来好像有顺序，但这不是排序，只是哈希存储的结果，顺序不稳定）</p></blockquote><h2 id="6-2-集合的运算"><a href="#6-2-集合的运算" class="headerlink" title="6.2 集合的运算"></a>6.2 集合的运算</h2><p><code>set</code>之间有很方便的取交集 <code>&amp;</code>和取并集 <code>|</code>运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>s2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-built_in">print</span>(s1 &amp; s2)  <span class="hljs-comment"># 交集 &#123;1, 2&#125;</span><br><span class="hljs-built_in">print</span>(s1 | s2)  <span class="hljs-comment"># 并集 &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-3-集合的遍历"><a href="#6-3-集合的遍历" class="headerlink" title="6.3 集合的遍历"></a>6.3 集合的遍历</h2><p>由于集合不支持下标访问，所以不能使用 <code>while</code>循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="6-4-常用操作"><a href="#6-4-常用操作" class="headerlink" title="6.4 常用操作"></a>6.4 常用操作</h2><p><img src="/../../../ai_assets/Pasted%20image%2020250901084030.png"></p><h1 id="7-容器对比"><a href="#7-容器对比" class="headerlink" title="7 容器对比"></a>7 容器对比</h1><p>列表、元组字符串为序列类型，集合、字典为非序列类型。</p><ul><li>是否支持下标索引<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否支持重复元素：<ul><li>支持：列表、元组、字符串</li><li>不支持：集合、字典</li></ul></li><li>是否可以修改<ul><li>支持：列表、集合、字典</li><li>不支持：元组、字符串</li></ul></li></ul><p><img src="/../../../ai_assets/Pasted%20image%2020250901090126.png"></p><h1 id="8-容器通用操作"><a href="#8-容器通用操作" class="headerlink" title="8 容器通用操作"></a>8 容器通用操作</h1><p><img src="/../../../ai_assets/Pasted%20image%2020250901090833.png"></p><ul><li><code>sorted</code>：接收任意可迭代对象（<code>list、tuple、set、dict、str</code>等），返回一个<strong>新的列表</strong>（不修改原对象）。</li><li><code>.sort()</code>：<code>list</code>专属方法，<strong>直接在原列表上排序</strong>，不会返回新列表（返回 <code>None</code>）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tp = (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>tp_ls = <span class="hljs-built_in">sorted</span>(tp)  <span class="hljs-comment"># 返回值为列表</span><br><br>ls = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br>ls.sort()  <span class="hljs-comment"># 直接对ls本身进行排序</span><br></code></pre></td></tr></table></figure><p><code>sorted</code>有类似C++中的 <code>cmp</code>函数，可以自定义排序规则，并且支持 <code>lambda</code>匿名函数，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 默认以第一个元素作为依据进行排序</span><br>ls = [(<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">70</span>), (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">80</span>), (<span class="hljs-string">&#x27;carl&#x27;</span>, <span class="hljs-number">100</span>)]<br>ls = <span class="hljs-built_in">sorted</span>(ls)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># x 是需要排序容器的一个元素，sorted 会把每个元素传入自定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">x</span>):<br><span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 自定义排序规则</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, key=cmp)<br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;bob&#x27;, 70), (&#x27;alice&#x27;, 80), (&#x27;carl&#x27;, 100)]</span><br><br><span class="hljs-comment"># lambda函数＋逆序排列</span><br>ls = <span class="hljs-built_in">sorted</span>(ls, reverse=<span class="hljs-literal">True</span>, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <br><span class="hljs-built_in">print</span>(ls)  <span class="hljs-comment"># [(&#x27;carl&#x27;, 100), (&#x27;alice&#x27;, 80), (&#x27;bob&#x27;, 70)]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
