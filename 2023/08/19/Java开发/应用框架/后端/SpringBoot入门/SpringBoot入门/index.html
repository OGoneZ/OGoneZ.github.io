

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://img.zhubaoduo.com/logo_mini.png">
  <link rel="icon" href="https://img.zhubaoduo.com/logo_mini.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#191E23">
  <meta name="author" content="baoduozhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. Spring 简介 在正式学习 SpringBoot 之前，我们要先来了解下什么是 Spring。打开 Spring 的官网Spring | Home，看一下Spring的简介：Spring makes Java simple。 Spring 发展到今天已经形成了一种开发生态圈，Spring 提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot入门">
<meta property="og:url" content="http://example.com/2023/08/19/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/SpringBoot%E5%85%A5%E9%97%A8/SpringBoot%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="朱宝铎的技术专栏">
<meta property="og:description" content="1. Spring 简介 在正式学习 SpringBoot 之前，我们要先来了解下什么是 Spring。打开 Spring 的官网Spring | Home，看一下Spring的简介：Spring makes Java simple。 Spring 发展到今天已经形成了一种开发生态圈，Spring 提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.zhubaoduo.com/springboot.png">
<meta property="article:published_time" content="2023-08-18T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-05T12:05:04.221Z">
<meta property="article:author" content="baoduozhu">
<meta property="article:tag" content="SpingBoot">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.zhubaoduo.com/springboot.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>SpringBoot入门 - 朱宝铎的技术专栏</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zhubd</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://img.zhubaoduo.com/j35.gif') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="SpringBoot入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-19 00:00" pubdate>
          2023年8月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          88 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Web开发"
        id="heading-3b451acfb78b69289662a6dd4d9d042c" role="tab" data-toggle="collapse" href="#collapse-3b451acfb78b69289662a6dd4d9d042c"
        aria-expanded="true"
      >
        Web开发
        <span class="list-group-count">(7)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-3b451acfb78b69289662a6dd4d9d042c"
           role="tabpanel" aria-labelledby="heading-3b451acfb78b69289662a6dd4d9d042c">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/08/07/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="HTTP协议与Tomcat服务器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">HTTP协议与Tomcat服务器</span>
        </a>
      
    
      
      
        <a href="/2023/08/05/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" title="Maven使用教程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Maven使用教程</span>
        </a>
      
    
      
      
        <a href="/2023/08/16/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MyBatis%E6%95%99%E7%A8%8B/MyBatis%E6%95%99%E7%A8%8B/" title="MyBatis教程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">MyBatis教程</span>
        </a>
      
    
      
      
        <a href="/2023/08/10/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/MySQL%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/" title="MySQL简易教程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">MySQL简易教程</span>
        </a>
      
    
      
      
        <a href="/2023/08/19/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/SpringBoot%E5%85%A5%E9%97%A8/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">SpringBoot入门</span>
        </a>
      
    
      
      
        <a href="/2023/08/01/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="Web前端开发"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Web前端开发</span>
        </a>
      
    
      
      
        <a href="/2023/08/22/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/" title="文件上传和阿里云OSS"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">文件上传和阿里云OSS</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">SpringBoot入门</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="spring-简介">1. Spring 简介</h1>
<p>在正式学习 SpringBoot 之前，我们要先来了解下什么是 Spring。打开
Spring 的官网<a target="_blank" rel="noopener" href="https://spring.io/">Spring |
Home</a>，看一下Spring的简介：<strong>Spring makes Java
simple</strong>。</p>
<p>Spring 发展到今天已经形成了一种开发生态圈，Spring
提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套
Spring 家族的技术，来解决对应领域的问题，我们称这一套技术为
<strong>Spring 全家桶</strong>。</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-1.1.png" srcset="/img/loading.gif" lazyload /></p>
<p>Spring 家族旗下这么多的技术，最基础、最核心的是
SpringFramework。其他的 Spring 家族的技术，都是基于 SpringFramework
的，SpringFramework
中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p>
<p>直接基于 SpringFramework
进行开发，存在两个问题：配置繁琐、入门难度大。 通过 SpringBoot
可以快速的帮我们构建应用程序，SpringBoot
最大的特点就是简化配置和快速开发。</p>
<h1 id="springboot-快速开始">2. SpringBoot 快速开始</h1>
<h2 id="入门程序">2.1 入门程序</h2>
<ol type="1">
<li>创建 SpringBoot 工程项目</li>
</ol>
<p>基于 Spring 官方骨架，创建 SpringBoot
工程。这一步需要联网，如果创建较慢也可以使用阿里的骨架，将 Server URL
改为 <code>http://start.aliyun.com</code>。</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-2.1.png" srcset="/img/loading.gif" lazyload /></p>
<p>基本信息描述完毕之后，勾选所需的依赖，需要什么添加什么，这里添加 Web
开发相关依赖。</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-2.2.png" srcset="/img/loading.gif" lazyload /></p>
<p>点击 Create 之后，就会联网创建这个 SpringBoot 工程。
注意：在联网创建过程中，会下载相关资源(请耐心等待)</p>
<ol start="2" type="1">
<li>定义请求处理类</li>
</ol>
<p>在 com.baoduo 这个包下创建一个子包 controller，在 controller
包下新建一个类 HelloController，添加如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>运行测试</li>
</ol>
<p>运行 SpringBoot 自动生成的启动类
SpringBootQuickStartApplication，打开浏览器，输入
<code>http://localhost:8080/hello</code> 即可访问。</p>
<blockquote>
<p>在 SpringBoot 项目中，静态资源(html，css，js
等前端资源)默认可以存放的目录： - classpath:/static/ -
classpath:/public/ - classpath:/resources/ -
classpath:/META-INF/resources/</p>
<p>classpath：代表的是类路径，在 Maven 的项目中，其实指的就是
src/main/resources 或者 src/main/java，但是 Java 目录是存放 Java
代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources
下。</p>
</blockquote>
<h2 id="web分析">2.2 Web分析</h2>
<p>浏览器：</p>
<ul>
<li>输入网址：<code>http://192.168.100.11:8080/hello</code>，通过 IP
地址192.168.100.11定位到网络上的一台计算机</li>
</ul>
<blockquote>
<p>之前在浏览器中输入的 localhost，就是127.0.0.1（本机）</p>
</blockquote>
<ul>
<li>通过端口号8080找到计算机上运行的程序</li>
</ul>
<blockquote>
<p><code>localhost:8080</code> ,
意思是在本地计算机中找到正在运行的8080端口的程序</p>
</blockquote>
<ul>
<li>/hello 是请求资源位置
<ul>
<li>资源：对计算机而言资源就是数据</li>
<li>web
资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li>
</ul>
<blockquote>
<p><code>localhost:8080/hello</code>
，意思是向本地计算机中的8080端口程序，获取资源位置是 /hello 的数据
8080端口程序，在服务器找 /hello 位置的资源数据，发给浏览器</p>
</blockquote></li>
</ul>
<p>服务器：（可以理解为 ServerSocket）</p>
<ul>
<li>接收到浏览器发送的信息（如：/hello）</li>
<li>在服务器上找到 /hello 的资源</li>
<li>把资源发送给浏览器</li>
</ul>
<blockquote>
<p>网络三要素： - IP ：网络中计算机的唯一标识 - 端口
：计算机中运行程序的唯一标识 - 协议 ：网络中计算机之间交互的规则</p>
</blockquote>
<blockquote>
<p><strong>问题：浏览器和服务器两端进行数据交互，使用什么协议？</strong>
<strong>答案： HTTP 协议</strong></p>
</blockquote>
<h2 id="起步依赖">2.3 起步依赖</h2>
<p>在 SpringBoot
的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在刚刚的入门程序中引用的
<code>spring-boot-starter-web</code> 和
<code>spring-boot-starter-test</code>，就是起步依赖。</p>
<p>以入门程序中引入的起步依赖为例：</p>
<ul>
<li><code>spring-boot-starter-web</code>：包含了 Web
应用开发所需要的常见依赖</li>
<li><code>spring-boot-starter-test</code>：包含了单元测试所需要的常见依赖</li>
</ul>
<p><code>spring-boot-starter-web</code> 内部把关于 Web
开发所有的依赖都已经导入并且指定了版本，只需引入
<code>spring-boot-starter-web</code> 依赖就可以通过依赖传递自动导入 Web
开发需要依赖</p>
<blockquote>
<p>刚刚的 SpringBoot 入门程序中，并没有把程序部署到 Tomcat 的 webapps
目录下也可以运行，是因为 SpringBoot 中引入了 Web 运行环境(也就是引入
spring-boot-starter-web 起步依赖)，其内部已经集成了内置的 Tomcat
服务器。 我们可以通过 IDEA 开发工具右侧的 Maven
面板中，看到当前工程引入的依赖。其中已经将 Tomcat
的相关依赖传递下来了，也就是说在 SpringBoot 中可以直接使用 Tomcat
服务器。</p>
</blockquote>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-2.3.png" srcset="/img/loading.gif" lazyload /></p>
<p>Spring 的官方提供了很多现成的
starter(起步依赖)，我们在开发相关应用时，只需要引入对应的 starter
即可。官方地址：<a
target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters">Spring
Boot Reference Documentation</a></p>
<p>每一个起步依赖，都用于开发一个特定的功能。</p>
<blockquote>
<p>举例：当我们开发中需要使用 Redis 数据库时，只需要在 SpringBoot
项目中，引入：spring-boot-starter-redis ，即可导入 Redis
开发所需要的依赖。</p>
</blockquote>
<h2 id="springboot-父工程">2.4 SpringBoot 父工程</h2>
<p>前面的 SpringBoot 入门程序中，通过 Maven
引入的依赖，是没有指定具体的依赖版本号的。因为每一个 SpringBoot
工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-2.4.png" srcset="/img/loading.gif" lazyload /></p>
<h1 id="请求响应">3. 请求响应</h1>
<h2 id="前言">3.1 前言</h2>
<p>在入门程序中，我们在浏览器发起请求，请求了后端 Web
服务器(也就是内置的 Tomcat)。请求会被部署在 Tomcat 中的 Controller
接收，然后 Controller 给浏览器响应了一个字符串 “Hello
World”，而在请求响应的过程中是遵循 HTTP 协议的。</p>
<p>其实在 Tomcat 这类 Web 服务器中，是不识别我们自己定义的 Controller
的。但前面提到 Tomcat 是一个 Servlet 容器，是支持 Serlvet 规范的，所以在
Tomcat 中可以识别 Servlet 程序。 那我们所编写的 XxxController
是如何处理请求的，又与 Servlet 之间有什么联系呢？</p>
<p>在 SpringBoot 进行 Web 程序开发时，它内置了一个核心的 Servlet 程序
DispatcherServlet，称之为核心控制器。 DispatcherServlet
负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器
Controller，请求处理器处理完请求之后，最终再由 DispatcherServlet
给浏览器响应数据。</p>
<p>浏览器发送请求，会携带请求数据，包括：请求行、请求头。请求到达 Tomcat
之后，Tomcat 会负责解析这些请求数据，然后将解析后的请求数据封装到
HttpServletRequest 对象中，我们可以通过 HttpServletRequest
对象获取到请求数据；对请求进行处理之后，通过 HttpServletResponse
对象可以设置响应数据， 然后 Tomcat 将响应数据响应给浏览器。</p>
<p>•请求（HttpServletRequest）：获取请求数据
•响应（HttpServletResponse）：设置响应数据</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-3.1.png" srcset="/img/loading.gif" lazyload /></p>
<p>上述的这种浏览器/服务器的架构模式，我们称之为：BS架构。</p>
<ul>
<li>BS
架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。在浏览器网页直接访问的都是
BS 架构（维护方便  体验一般）</li>
<li>CS 架构：Client/Server，客户端/服务器架构模式。需要下载安装的都是 CS
架构（开发、维护麻烦   体验不错）</li>
</ul>
<h2 id="请求">3.2 请求</h2>
<h3 id="postman">3.2.1 Postman</h3>
<p>在前后端分离开发模式下，后端技术人员在开发过程中，没有前端页面怎么测试自己所开发的程序？</p>
<p>方式1：直接使用浏览器，在浏览器中输入地址测试后端程序。</p>
<ul>
<li>在浏览器地址栏中输入地址这种方式都是 GET 请求，不能使用 POST
请求</li>
<li>要使用 POST 请求，需要自己编写前端代码（比较麻烦）</li>
</ul>
<p>方式2：使用专业的接口测试工具，比如 Postman，还有一些基于 Postman
衍生的 Apipost 和 Apifox。</p>
<p><strong>Postman</strong> 是一款功能强大的网页调试与发送网页 HTTP
请求的应用，常用于进行接口测试。</p>
<blockquote>
<p>Postman 原是 Chrome
浏览器的插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的
HTTP 请求 使用 Postman
还可以在发起请求时，携带一些请求参数、请求头等信息</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.postman.com/downloads/">Download Postman | Get
Started for Free</a>直接安装</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-3.2.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="简单参数">3.2.2 简单参数</h3>
<p>在原始的 Web 程序中，需要通过 Servlet 中提供的
API：<code>HttpServletRequest</code>（请求对象），获取请求的相关信息。</p>
<blockquote>
<p>Tomcat 接收到 HTTP 请求时：把请求的相关信息封装到
<code>HttpServletRequest</code> 对象中</p>
</blockquote>
<p>在 Controller 中，要想获取 <code>HttpServletRequest</code>
对象，可以直接在方法的形参中声明 <code>HttpServletRequest</code>
对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br><span class="hljs-comment">//http://localhost:8080/simpleParam?name=Tom&amp;age=10</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//name就是请求参数名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//age就是请求参数名</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(ageStr);<span class="hljs-comment">//需要手动进行类型转换</span><br>        System.out.println(name+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Springboot 的环境中，对原始的 API
进行了封装，接收参数的形式更加简单。
如果是简单参数，参数名与形参变量名相同，定义<strong>同名的形参即可接收参数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name , Integer age )</span>&#123;<br>    <span class="hljs-comment">//形参名和请求参数名保持一致即可，SpringBoot自动完成类型转换</span><br>        System.out.println(name+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>不论是 GET 请求还是 POST 请求，对于简单参数来讲，只要保证请求参数名和
Controller 方法中的形参名保持一致，就可以获取到请求参数中的数据值。</p>
</blockquote>
<p>如果方法形参名称与请求参数名称不一致，Controller
方法中的形参就无法接收到请求数据，如果我们开发中，需要请求参数名和
Controller 方法中的形参名不相同时，可以使用 Spring 提供的
<code>@RequestParam</code> 注解完成映射。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;<br>        System.out.println(username+<span class="hljs-string">&quot;  :  &quot;</span>+age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><span class="citation" data-cites="RequestParam">@RequestParam</span>
中的 required 属性默认为
true，代表该请求参数必须传递，如果不传递将报错，如果该参数是可选的，可以将
required 属性设置为
false，<code>@RequestParam(name = "name", required = false)</code></p>
</blockquote>
<h3 id="实体参数">3.2.3 实体参数</h3>
<p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端
Controller
方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。</p>
<p>此时，我们可以将请求参数封装到一个实体类对象中。
要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong>，注意是<strong>属性名</strong>。</p>
<p>定义 entity 实体类（POJO）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    getter setter toString...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">// http://localhost:8080/simpleEntity?name=Tom&amp;age=10</span><br>    <span class="hljs-comment">//请求参数与实体的属性名相同</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/simpleEntity&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplePojo</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果实体中有属性也是实体，属于复杂实体类。要遵循：
<strong>请求参数名与形参对象属性名相同，请求参数按照对象层次结构关系中间用
<code>.</code> 连接</strong>。</p>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">//地址对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/complexPojo?name=Tom&amp;age=10&amp;address.province=henan&amp;address.city=zhengzhou</span><br>    <span class="hljs-comment">//请求参数使用 xxx.xxx 表示嵌套属性</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/complexEntity&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">complexPojo</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数组集合参数">3.2.4 数组集合参数</h3>
<p>在 HTML
的表单中，复选框是支持多选的，可以提交选择的多个值。其实多个值也是一个一个的提交，后端程序接收多个值可以使用数组或集合。</p>
<p><strong>数组</strong>：
<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//方式一：http://localhost:8080/arrayParam?hobby=game&amp;hobby=java</span><br>    <span class="hljs-comment">//方式二：http://localhost:8080/arrayParam?hobby=game,java</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[] hobby)</span>&#123;<br>    <span class="hljs-comment">//1. 形参定义为数组类型</span><br>    <span class="hljs-comment">//2. 请求参数与数组名相同</span><br>        System.out.println(Arrays.toString(hobby));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>集合</strong>：
<strong>请求参数名与形参集合对象名相同且请求参数为多个，<code>@RequestParam</code>
绑定参数关系</strong></p>
<blockquote>
<p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用<code>@RequestParam</code>
绑定参数关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//方式一：http://localhost:8080/arrayParam?hobby=game&amp;hobby=java</span><br>    <span class="hljs-comment">//方式二：http://localhost:8080/arrayParam?hobby=game,java</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/listParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; hobby)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@RequestParam注解</span><br>    <span class="hljs-comment">//2. 请求参数与集合对象名相同</span><br>        System.out.println(hobby);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="日期参数">3.2.5 日期参数</h3>
<p>日期的格式多种多样（如：2024-08-08 10:05:45 、2024/08/08
10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过
<code>@DateTimeFormat</code> 注解，以及其 pattern
属性来设置日期的格式。</p>
<ul>
<li><code>@DateTimeFormat</code> 注解的 <code>pattern</code>
属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。</li>
<li>后端 Controller 方法中，需要使用 <code>Date</code> 类型或
<code>LocalDateTime</code> 类型，来封装传递的参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/dateParam?updateTime=2024-08-08 10:05:45</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@DateTimeFormat注解，并指定pattern</span><br>    <span class="hljs-comment">//2. 形参使用Date或LocalDateTime类型，请求参数名与形参名相同</span><br>        System.out.println(updateTime);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="json-参数">3.2.6 JSON 参数</h3>
<p>在前后端进行交互时，如果是比较复杂的参数，通常会使用 JSON
格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）</p>
<p>学习 JSON 格式参数，主要从以下两个方面着手：</p>
<ol type="1">
<li>Postman 在发送请求时，如何传递 JSON 格式的请求参数</li>
</ol>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-3.3.png" srcset="/img/loading.gif" lazyload /></p>
<ol start="2" type="1">
<li>在服务端的 Controller 方法中，如何接收 JSON 格式的请求参数</li>
</ol>
<ul>
<li>传递 JSON 格式的参数，在 Controller 中会使用实体类进行封装。</li>
<li>封装规则：<strong>JSON 数据键名与形参对象属性名相同，定义 entity
实体类型形参即可接收参数。需要使用 <code>@RequestBody</code>
标识。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">//地址对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/jsonParam 参数在请求体中</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/jsonParam&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@RequestBody注解</span><br>    <span class="hljs-comment">//2. 使用实体接收参数，实体属性名与JSON键名相同</span><br>        System.out.println(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="路径参数">3.2.7 路径参数</h3>
<p>在开发中，经常还会直接在请求的URL中传递参数。例如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/user/<span class="hljs-number">1</span>          <br><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">880</span>/user/<span class="hljs-number">1</span>/<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>上面这种传递请求参数的形式我们称之为：路径参数。</p>
<ul>
<li>前端：通过请求 URL 直接传递参数</li>
<li>后端：使用 <code>&#123;…&#125;</code> 来标识该路径参数，需要使用
<code>@PathVariable</code> 注解获取路径参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestController</span> &#123;<br>    <span class="hljs-comment">//http://localhost:8080/1/ogonez   </span><br>    <span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id, <span class="hljs-meta">@PathVariable</span> String name)</span>&#123;<br>    <span class="hljs-comment">//1. 使用@PathVariable注解获取路径参数</span><br>    <span class="hljs-comment">//2. 请求路径中用&#123;&#125;标识路径参数</span><br>        System.out.println(id+ <span class="hljs-string">&quot; : &quot;</span> +name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="小结">3.2.8 小结</h3>
<ol type="1">
<li>简单参数
<ul>
<li>定义方法形参，请求参数名与形参变量名一致</li>
<li>如果不一致，通过 <code>@RequestParam</code> 手动映射</li>
</ul></li>
<li>实体参数
<ul>
<li>请求参数名与实体对象的属性名一致</li>
</ul></li>
<li>数组集合参数
<ul>
<li>数组：请求参数名与数组名一致</li>
<li>集合：请求参数名与集合名一致，<code>@RequestParam</code>
绑定关系</li>
</ul></li>
<li>日期参数
<ul>
<li><code>@DateTimeFormat</code></li>
<li><code>pattern</code> 属性指定日期格式</li>
</ul></li>
<li>JSON参数
<ul>
<li><code>@RequestBody</code>，键名和对象属性名一致</li>
</ul></li>
<li>路径参数
<ul>
<li><code>@PathVariable</code>，使用<code>&#123;...&#125;</code>表示路径</li>
</ul></li>
</ol>
<h2 id="响应">3.3 响应</h2>
<h3 id="responsebody">3.3.1 <span class="citation"
data-cites="ResponseBody">@ResponseBody</span></h3>
<p>前面提到 HTTP 协议的交互方式：请求响应模式（有请求就有响应）
Controller 程序除了接收请求外，还可以进行响应。</p>
<p>在前面所编写的 Controller 方法中，都已经设置了响应数据。Controller
方法中的 return 的结果，怎么响应给浏览器呢？使用
<code>@ResponseBody</code> 注解：</p>
<ul>
<li>类型：方法注解、类注解</li>
<li>位置：书写在 Controller 方法上或类上</li>
<li>作用：将<strong>方法返回值直接响应给浏览器</strong>
<ul>
<li>如果返回值类型是实体对象/集合，将会转换为 JSON
格式后再响应给浏览器</li>
</ul></li>
</ul>
<p>但是刚刚写的的 Controller 中，只是在类上添加了
<code>@RestController</code> 注解、方法添加了
<code>@RequestMapping</code> 注解，这是因为 <code>@RestController</code>
注解是一个组合注解，在类上添加 <code>@RestController</code>
就相当于添加了 <code>@ResponseBody</code>
注解，表示当前类下所有的方法返回值做为响应数据。</p>
<p><code>@RestController</code> = <code>@Controller</code> +
<code>@ResponseBody</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@RestController源码：</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span>   <span class="hljs-comment">//元注解（修饰注解的注解）</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="hljs-comment">//元注解</span><br><span class="hljs-meta">@Documented</span>    <span class="hljs-comment">//元注解</span><br><span class="hljs-meta">@Controller</span>   <br><span class="hljs-meta">@ResponseBody</span> <br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RestController &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = Controller.class</span><br><span class="hljs-meta">    )</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="统一响应结果">3.3.2 统一响应结果</h3>
<p>如果我们开发一个大型项目，项目中 Controller
方法将成千上万，返回值各种各样，没有任何的规范，将造成整个项目难以维护。所以我们会定义一个统一的返回结果。方案如下：</p>
<p>前端：只需要按照统一格式的返回结果进行解析，就可以拿到数据。</p>
<p>统一的返回结果使用类来描述，在这个结果中包含：</p>
<ul>
<li>响应状态码 <code>code</code>：当前请求是成功，还是失败</li>
<li>状态码信息 <code>msg</code>：给页面的提示信息</li>
<li>返回的数据
<code>data</code>：给前端响应的数据（字符串、对象、集合）</li>
</ul>
<p>定义在一个实体类 Result 来包含以上信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应码 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(Integer code, String msg, Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    getter setter...<br><br>    <span class="hljs-comment">//增删改 成功响应(不需要给前端返回数据)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应(把查询结果做为返回数据响应给前端)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;success&quot;</span>, data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>( <span class="hljs-number">0</span>, msg, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="分层解耦">4. 分层解耦</h1>
<h2 id="前言-1">4.1 前言</h2>
<p>如果将获取数据的代码，处理数据的逻辑代码，给页面响应的代码全部都堆积在一起，写在
Controller 方法中。业务逻辑稍微复杂一点，Controller
方法的代码量就会很大。</p>
<ul>
<li>当我们要修改操作数据部分的代码，需要改动 Controller</li>
<li>当我们要完善逻辑处理部分的代码，需要改动 Controller</li>
<li>当我们需要修改数据响应的代码，还是需要改动 Controller</li>
</ul>
<p>这样就会造成我们整个工程代码的复用性比较差，而且代码难以维护。
在现在的开发中，有非常成熟的解决思路，那就是分层开发。</p>
<h2 id="三层架构">4.2 三层架构</h2>
<p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一。</p>
<blockquote>
<p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。
这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p>
</blockquote>
<p>我们的程序大致上有这样三部分：</p>
<ul>
<li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li>
<li>逻辑处理：负责业务逻辑处理的代码。</li>
<li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li>
</ul>
<p>按照上述的三个部分，在项目开发中，我们可以将代码分为三层：</p>
<ul>
<li>Controller：控制层。接收前端发送的请求，与浏览器直接交互，对请求进行处理，并响应数据。</li>
<li>Service：业务逻辑层。处理具体的业务逻辑。</li>
<li>Dao：数据访问层(Data Access
Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li>
</ul>
<blockquote>
<p>在传统的 Java 应用中，通常会使用 DAO（Data Access
Object）模式来处理数据的访问和持久化。而在 MyBatis
等持久层框架中，通常会使用 Mapper 来实现类似的功能。DAO 和 Mapper
在目标上是相似的，都是用来处理数据的访问，但它们在具体的实现和用法上有一些区别。
1. 命名和用法： DAO
是一种设计模式，通常使用接口和实现类来定义和实现对数据的访问。在传统的
Java 应用中，DAO 接口中定义了访问数据库的方法，而 DAO
的实现类则包含了具体的数据库操作。 Mapper 是 MyBatis 中的概念，用于执行
SQL 语句并映射结果。在 MyBatis 中，Mapper 通常是一个 Java
接口，其中定义了与数据库交互的 SQL 映射语句。 2. SQL 映射： DAO 通常将
SQL 语句嵌入到 DAO 实现类中，可能是直接写在代码里，也可能通过 XML
等方式配置在实现类中。 Mapper 中的 SQL 语句通常是通过 XML
文件进行配置，这样可以将 SQL 语句与 Java 代码分离，使代码更易于维护。 3.
框架依赖： DAO 模式是一种通用的设计模式，可以在任何 Java
应用中使用，不依赖于特定的持久层框架。 Mapper 是 MyBatis
框架的概念，特定于 MyBatis 的用法和配置。 4. 数据映射： DAO
通常返回原始的数据对象，需要手动将结果集映射到 Java 对象。 Mapper 使用
MyBatis 提供的 ResultMap 等机制，自动将结果集映射为 Java 对象。</p>
</blockquote>
<p>基于三层架构的程序执行流程：</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.1.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li>Controller 层<strong>接收</strong>前端发起的请求，调用 Service
层来进行处理（接收 Service
返回的结果之后将数据<strong>响应</strong>给前端）</li>
<li>Serivce 层从 Dao
层获取数据进行<strong>逻辑处理</strong>（处理完成之后，把处理结果返回给
Controller 层）</li>
<li>Dao 层<strong>操作数据库中的数据</strong>（Dao 拿到的数据返回给
Service 层）</li>
</ul>
<p>结构如下：</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.2.png" srcset="/img/loading.gif" lazyload /></p>
<p>Controller 层中调用 Service 层的方法，先创建 Service 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EmpService</span> <span class="hljs-variable">empService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpServiceImpleA</span>();<br></code></pre></td></tr></table></figure>
<p>Service 层中调用 Dao 层的方法，先创建 Dao 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EmpDao</span> <span class="hljs-variable">empDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpDao</span>();<br></code></pre></td></tr></table></figure>
<p>三层架构的好处：</p>
<ol type="1">
<li>复用性强</li>
<li>便于维护</li>
<li>利用扩展</li>
</ol>
<h2 id="分层解耦-1">4.3 分层解耦</h2>
<p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p>
<ul>
<li>内聚：软件中各个功能模块内部的功能联系。</li>
<li>耦合：衡量软件中各个层/模块之间的依赖、关联的程度。</li>
</ul>
<p><strong>软件设计原则：高内聚低耦合。</strong></p>
<blockquote>
<p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即
“高内聚”。
低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p>
</blockquote>
<p>在刚刚的程序中，把业务类变为 EmpServiceB 时，需要修改 Controller
层中的代码，Service 的命名发生改变时，Controller 里创建的 Service
对象也要改名。Service 代码和 Controller 产生耦合。</p>
<p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.3.png" srcset="/img/loading.gif" lazyload /></p>
<p>之前的程序中，需要什么对象，就直接 new
一个，这种做法会使层与层之间代码耦合，所以不能 new，但是不 new
就没有对象，程序就会报错。</p>
<p>我们可以找一个中间人来联系它们，我们采用以下思路：</p>
<ul>
<li>提供一个容器，容器中存储一些对象(例：EmpService对象)</li>
<li>Controller 程序从容器中获取 EmpService 类型的对象</li>
</ul>
<p>我们想要实现上述解耦操作，就涉及到 Spring 中的两个核心概念：</p>
<ul>
<li><p><strong>控制反转：</strong> Inversion Of Control，简称
<strong>IOC</strong>。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p>
<blockquote>
<p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC
容器或 Spring 容器</p>
</blockquote></li>
<li><p><strong>依赖注入：</strong> Dependency Injection，简称
<strong>DI</strong>。容器为应用程序提供运行时所依赖的资源，称之为依赖注入。</p>
<blockquote>
<p>程序运行时需要某个资源，此时容器就为其提供这个资源。
例：EmpController 程序运行时需要 EmpService 对象，Spring
容器就为其提供并注入 EmpService 对象</p>
</blockquote></li>
</ul>
<p>IOC 容器中创建、管理的对象，称之为：bean 对象</p>
<p>要想实现解耦，可以将 Service 层及 Dao 层的实现类，交给 IOC 容器管理
<code>@Component</code> 表示当前类由 IOC 容器管理 为 Controller
程序中注入依赖的 Service 层对象，为 Service 程序中注入依赖的 Dao
层对象时依赖的对象 <code>@Autowired</code> ，就可以实现程序运行时 IOC
容器自动注入需要的依赖对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpServiceA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmpService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span><br>    <span class="hljs-keyword">private</span> EmpDao empDao ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="ioc">4.4 IOC</h2>
<p>IOC 控制反转，就是将对象的控制权交给 Spring 的 IOC 容器，由 IOC
容器创建及管理对象。IOC 容器创建的对象称为 Bean 对象。</p>
<p>要把对象交给 IOC
容器管理，需要在类上添加一个注解：<code>@Component</code></p>
<p>Spring 框架为了更好的标识 Web 应用程序开发中 bean
对象到底归属于哪一层，又提供了 <code>@Component</code> 的衍生注解：</p>
<table>

<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="citation"
data-cites="Controller">@Controller</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在控制器类上（RestController包含了）</td>
</tr>
<tr>
<td><span class="citation" data-cites="Service">@Service</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在业务类上</td>
</tr>
<tr>
<td><span class="citation"
data-cites="Repository">@Repository</span></td>
<td><span class="citation"
data-cites="Component的衍生注解">@Component的衍生注解</span></td>
<td>标注在数据访问类上（由于与mybatis整合，用的少）</td>
</tr>
<tr>
<td><span class="citation" data-cites="Component">@Component</span></td>
<td>声明bean的基础注解</td>
<td>不属于以上三类时，用此注解</td>
</tr>
</tbody>
</table>
<p><code>@Service</code> 和 <code>@Repository</code> 源码：</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.4.png" srcset="/img/loading.gif" lazyload /></p>
<p>在 IOC 容器中，每一个 Bean 都有一个属于自己的名字，可以通过注解的
value 属性指定 bean 的名字。如果没有指定，默认为类名首字母小写。</p>
<p>在 IDEA 中运行项目之后可以在 Actuator 中查看所有 Bean：</p>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.5.png" srcset="/img/loading.gif" lazyload /></p>
<blockquote>
<p>使用以上四个注解都可以声明 Bean，但是在 SpringBoot 集成 Web
开发中，声明控制器 Bean 只能用 <code>@Controller</code>。</p>
</blockquote>
<p>使用四大注解声明的 Bean，要想生效，还需要被组件扫描注解
<code>@ComponentScan</code> 扫描，<code>@ComponentScan</code>
注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解
<code>@SpringBootApplication</code> 中，<strong>默认扫描的范围是
SpringBoot 启动类所在包及其子包</strong>。</p>
<h2 id="di">4.5 DI</h2>
<p>DI 依赖注入，是指 IOC
容器要为应用程序提供运行时所依赖的资源，而资源指的就是对象。</p>
<p><code>@Autowired</code> 完成依赖注入的操作，而这个 Autowired
翻译过来叫：自动装配。</p>
<p><code>@Autowired</code>
注解，默认是按照<strong>类型</strong>进行自动装配的（去 IOC
容器中找某个类型的对象，然后完成注入操作）</p>
<blockquote>
<p>举例：在 EmpController 运行的时候，要到 IOC 容器当中去查找 EmpService
这个类型的对象，而我们通过 <code>@Service</code> 将 EmpService
这个类型的对象交给了 IOC
容器，所以就找到了这个类型的对象完成注入操作。</p>
</blockquote>
<p>如果在 IOC 容器中，存在多个相同类型的 Bean 对象，比如上面的
EmpServiceA 和 EmpServiceB，可以使用以下方案：</p>
<ul>
<li><code>@Primary</code> 注解：设定当前类为默认的实现。</li>
</ul>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.6.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li><code>@Qualifier</code> 注解：指定要注入的 Bean 对象，通过 value
属性指定要注入的 Bean 的名称。不能单独使用，必须配合
<code>@Autowired</code> 使用</li>
</ul>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.7.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li><code>@Resource</code> 注解：指定要注入的 Bean 对象，通过 name
属性指定要注入的 Bean 的名称。</li>
</ul>
<p><img src="https://img.zhubaoduo.com/SpringBoot入门-4.8.png" srcset="/img/loading.gif" lazyload /></p>
<p><code>@Autowird</code> 与 <code>@Resource</code> 的区别</p>
<ul>
<li><code>@Autowired</code> 是 <strong>Spring</strong>
框架提供的注解，而 <code>@Resource</code> 是 <strong>JDK</strong>
提供的注解</li>
<li><code>@Autowired</code> 默认是按照<strong>类型</strong>注入，而
<code>@Resource</code> 是按照<strong>名称</strong>注入</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Web%E5%BC%80%E5%8F%91/" class="category-chain-item">Web开发</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SpingBoot/" class="print-no-link">#SpingBoot</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>SpringBoot入门</div>
      <div>http://example.com/2023/08/19/Java开发/应用框架/后端/SpringBoot入门/SpringBoot入门/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>baoduozhu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/22/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E9%98%BF%E9%87%8C%E4%BA%91OSS/" title="文件上传和阿里云OSS">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">文件上传和阿里云OSS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/16/Java%E5%BC%80%E5%8F%91/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%90%8E%E7%AB%AF/MyBatis%E6%95%99%E7%A8%8B/MyBatis%E6%95%99%E7%A8%8B/" title="MyBatis教程">
                        <span class="hidden-mobile">MyBatis教程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <p>© 2025 朱宝铎个人技术专栏</p>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
